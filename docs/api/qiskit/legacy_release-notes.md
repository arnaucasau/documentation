---
title: Qiskit 0.45 release notes
description: Changes made to Qiskit
in_page_toc_max_heading_level: 2
---

<span id="legacy-release-notes" />

<span id="id1" />

# Qiskit 0.45 release notes

This page contains the full history of the release notes from when `qiskit` was a “meta-package”, which contained several different “elements”. It is maintained here for historical interest. The main release notes can be found at [Release Notes](release_notes#release-notes).

What is called “Qiskit Terra” within this document is principally what is now just called “Qiskit”.

## Version History

This table tracks the meta-package versions and the version of each legacy Qiskit element installed:

| Qiskit Metapackage Version | qiskit-terra | qiskit-aer  | qiskit-ignis | qiskit-ibmq-provider | qiskit-aqua | Release Date |
| -------------------------- | ------------ | ----------- | ------------ | -------------------- | ----------- | ------------ |
| 0.44.1                     | 0.25.1       |             |              |                      |             | 2023-08-17   |
| 0.44.0                     | 0.25.0       |             |              |                      |             | 2023-07-27   |
| 0.43.3                     | 0.24.2       | 0.12.2      |              | 0.20.2               |             | 2023-07-19   |
| 0.43.2                     | 0.24.1       | 0.12.1      |              | 0.20.2               |             | 2023-06-28   |
| 0.43.1                     | 0.24.1       | 0.12.0      |              | 0.20.2               |             | 2023-06-02   |
| 0.43.0                     | 0.24.0       | 0.12.0      |              | 0.20.2               |             | 2023-05-04   |
| 0.42.1                     | 0.23.3       | 0.12.0      |              | 0.20.2               |             | 2023-03-21   |
| 0.42.0                     | 0.23.2       | 0.12.0      |              | 0.20.2               |             | 2023-03-10   |
| 0.41.1                     | 0.23.2       | 0.11.2      |              | 0.20.1               |             | 2023-02-23   |
| 0.41.0                     | 0.23.1       | 0.11.2      |              | 0.20.0               |             | 2023-01-31   |
| 0.40.0                     | 0.23.0       | 0.11.2      |              | 0.19.2               |             | 2023-01-26   |
| 0.39.5                     | 0.22.4       | 0.11.2      |              | 0.19.2               |             | 2023-01-17   |
| 0.39.4                     | 0.22.3       | 0.11.2      |              | 0.19.2               |             | 2022-12-08   |
| 0.39.3                     | 0.22.3       | 0.11.1      |              | 0.19.2               |             | 2022-11-25   |
| 0.39.2                     | 0.22.2       | 0.11.1      |              | 0.19.2               |             | 2022-11-03   |
| 0.39.1                     | 0.22.1       | 0.11.1      |              | 0.19.2               |             | 2022-11-02   |
| 0.39.0                     | 0.22.0       | 0.11.0      |              | 0.19.2               |             | 2022-10-13   |
| 0.38.0                     | 0.21.2       | 0.11.0      |              | 0.19.2               |             | 2022-09-14   |
| 0.37.2                     | 0.21.2       | 0.10.4      |              | 0.19.2               |             | 2022-08-23   |
| 0.37.1                     | 0.21.1       | 0.10.4      |              | 0.19.2               |             | 2022-07-28   |
| 0.37.0                     | 0.21.0       | 0.10.4      |              | 0.19.2               |             | 2022-06-30   |
| 0.36.2                     | 0.20.2       | 0.10.4      | 0.7.1        | 0.19.1               |             | 2022-05-18   |
| 0.36.1                     | 0.20.1       | 0.10.4      | 0.7.0        | 0.19.1               |             | 2022-04-21   |
| 0.36.0                     | 0.20.0       | 0.10.4      | 0.7.0        | 0.19.0               |             | 2022-04-06   |
| 0.35.0                     | 0.20.0       | 0.10.3      | 0.7.0        | 0.18.3               |             | 2022-03-31   |
| 0.34.2                     | 0.19.2       | 0.10.3      | 0.7.0        | 0.18.3               |             | 2022-02-09   |
| 0.34.1                     | 0.19.1       | 0.10.2      | 0.7.0        | 0.18.3               |             | 2022-01-05   |
| 0.34.0                     | 0.19.1       | 0.10.1      | 0.7.0        | 0.18.3               |             | 2021-12-20   |
| 0.33.1                     | 0.19.1       | 0.9.1       | 0.7.0        | 0.18.2               |             | 2021-12-10   |
| 0.33.0                     | 0.19.0       | 0.9.1       | 0.7.0        | 0.18.1               |             | 2021-12-06   |
| 0.32.1                     | 0.18.3       | 0.9.1       | 0.6.0        | 0.18.1               | 0.9.5       | 2021-11-22   |
| 0.32.0                     | 0.18.3       | 0.9.1       | 0.6.0        | 0.18.0               | 0.9.5       | 2021-11-10   |
| 0.31.0                     | 0.18.3       | 0.9.1       | 0.6.0        | 0.17.0               | 0.9.5       | 2021-10-12   |
| 0.30.1                     | 0.18.3       | 0.9.0       | 0.6.0        | 0.16.0               | 0.9.5       | 2021-09-29   |
| 0.30.0                     | 0.18.2       | 0.9.0       | 0.6.0        | 0.16.0               | 0.9.5       | 2021-09-16   |
| 0.29.1                     | 0.18.2       | 0.8.2       | 0.6.0        | 0.16.0               | 0.9.5       | 2021-09-10   |
| 0.29.0                     | 0.18.1       | 0.8.2       | 0.6.0        | 0.16.0               | 0.9.4       | 2021-08-02   |
| 0.28.0                     | 0.18.0       | 0.8.2       | 0.6.0        | 0.15.0               | 0.9.4       | 2021-07-13   |
| 0.27.0                     | 0.17.4       | 0.8.2       | 0.6.0        | 0.14.0               | 0.9.2       | 2021-06-15   |
| 0.26.2                     | 0.17.4       | 0.8.2       | 0.6.0        | 0.13.1               | 0.9.1       | 2021-05-19   |
| 0.26.1                     | 0.17.4       | 0.8.2       | 0.6.0        | 0.13.1               | 0.9.1       | 2021-05-18   |
| 0.26.0                     | 0.17.3       | 0.8.2       | 0.6.0        | 0.13.1               | 0.9.1       | 2021-05-11   |
| 0.25.4                     | 0.17.2       | 0.8.2       | 0.6.0        | 0.12.3               | 0.9.1       | 2021-05-05   |
| 0.25.3                     | 0.17.1       | 0.8.2       | 0.6.0        | 0.12.3               | 0.9.1       | 2021-04-29   |
| 0.25.2                     | 0.17.1       | 0.8.1       | 0.6.0        | 0.12.3               | 0.9.1       | 2021-04-21   |
| 0.25.1                     | 0.17.1       | 0.8.1       | 0.6.0        | 0.12.2               | 0.9.1       | 2021-04-15   |
| 0.25.0                     | 0.17.0       | 0.8.0       | 0.6.0        | 0.12.2               | 0.9.0       | 2021-04-02   |
| 0.24.1                     | 0.16.4       | 0.7.6       | 0.5.2        | 0.12.2               | 0.8.2       | 2021-03-24   |
| 0.24.0                     | 0.16.4       | 0.7.6       | 0.5.2        | 0.12.1               | 0.8.2       | 2021-03-04   |
| 0.23.6                     | 0.16.4       | 0.7.5       | 0.5.2        | 0.11.1               | 0.8.2       | 2021-02-18   |
| 0.23.5                     | 0.16.4       | 0.7.4       | 0.5.2        | 0.11.1               | 0.8.2       | 2021-02-08   |
| 0.23.4                     | 0.16.3       | 0.7.3       | 0.5.1        | 0.11.1               | 0.8.1       | 2021-01-28   |
| 0.23.3                     | 0.16.2       | 0.7.3       | 0.5.1        | 0.11.1               | 0.8.1       | 2021-01-26   |
| 0.23.2                     | 0.16.1       | 0.7.2       | 0.5.1        | 0.11.1               | 0.8.1       | 2020-12-15   |
| 0.23.1                     | 0.16.1       | 0.7.1       | 0.5.1        | 0.11.1               | 0.8.1       | 2020-11-12   |
| 0.23.0                     | 0.16.0       | 0.7.0       | 0.5.0        | 0.11.0               | 0.8.0       | 2020-10-16   |
| 0.22.0                     | 0.15.2       | 0.6.1       | 0.4.0        | 0.10.0               | 0.7.5       | 2020-10-05   |
| 0.21.0                     | 0.15.2       | 0.6.1       | 0.4.0        | 0.9.0                | 0.7.5       | 2020-09-16   |
| 0.20.1                     | 0.15.2       | 0.6.1       | 0.4.0        | 0.8.0                | 0.7.5       | 2020-09-08   |
| 0.20.0                     | 0.15.1       | 0.6.1       | 0.4.0        | 0.8.0                | 0.7.5       | 2020-08-10   |
| 0.19.6                     | 0.14.2       | 0.5.2       | 0.3.3        | 0.7.2                | 0.7.3       | 2020-06-25   |
| 0.19.5                     | 0.14.2       | 0.5.2       | 0.3.2        | 0.7.2                | 0.7.3       | 2020-06-19   |
| 0.19.4                     | 0.14.2       | 0.5.2       | 0.3.0        | 0.7.2                | 0.7.2       | 2020-06-16   |
| 0.19.3                     | 0.14.1       | 0.5.2       | 0.3.0        | 0.7.2                | 0.7.1       | 2020-06-02   |
| 0.19.2                     | 0.14.1       | 0.5.1       | 0.3.0        | 0.7.1                | 0.7.1       | 2020-05-14   |
| 0.19.1                     | 0.14.1       | 0.5.1       | 0.3.0        | 0.7.0                | 0.7.0       | 2020-05-01   |
| 0.19.0                     | 0.14.0       | 0.5.1       | 0.3.0        | 0.7.0                | 0.7.0       | 2020-04-30   |
| 0.18.3                     | 0.13.0       | 0.5.1       | 0.3.0        | 0.6.1                | 0.6.6       | 2020-04-24   |
| 0.18.2                     | 0.13.0       | 0.5.0       | 0.3.0        | 0.6.1                | 0.6.6       | 2020-04-23   |
| 0.18.1                     | 0.13.0       | 0.5.0       | 0.3.0        | 0.6.0                | 0.6.6       | 2020-04-20   |
| 0.18.0                     | 0.13.0       | 0.5.0       | 0.3.0        | 0.6.0                | 0.6.5       | 2020-04-09   |
| 0.17.0                     | 0.12.0       | 0.4.1       | 0.2.0        | 0.6.0                | 0.6.5       | 2020-04-01   |
| 0.16.2                     | 0.12.0       | 0.4.1       | 0.2.0        | 0.5.0                | 0.6.5       | 2020-03-20   |
| 0.16.1                     | 0.12.0       | 0.4.1       | 0.2.0        | 0.5.0                | 0.6.4       | 2020-03-05   |
| 0.16.0                     | 0.12.0       | 0.4.0       | 0.2.0        | 0.5.0                | 0.6.4       | 2020-02-27   |
| 0.15.0                     | 0.12.0       | 0.4.0       | 0.2.0        | 0.4.6                | 0.6.4       | 2020-02-06   |
| 0.14.1                     | 0.11.1       | 0.3.4       | 0.2.0        | 0.4.5                | 0.6.2       | 2020-01-07   |
| 0.14.0                     | 0.11.0       | 0.3.4       | 0.2.0        | 0.4.4                | 0.6.1       | 2019-12-10   |
| 0.13.0                     | 0.10.0       | 0.3.2       | 0.2.0        | 0.3.3                | 0.6.1       | 2019-10-17   |
| 0.12.2                     | 0.9.1        | 0.3.0       | 0.2.0        | 0.3.3                | 0.6.0       | 2019-10-11   |
| 0.12.1                     | 0.9.0        | 0.3.0       | 0.2.0        | 0.3.3                | 0.6.0       | 2019-09-30   |
| 0.12.0                     | 0.9.0        | 0.3.0       | 0.2.0        | 0.3.2                | 0.6.0       | 2019-08-22   |
| 0.11.2                     | 0.8.2        | 0.2.3       | 0.1.1        | 0.3.2                | 0.5.5       | 2019-08-20   |
| 0.11.1                     | 0.8.2        | 0.2.3       | 0.1.1        | 0.3.1                | 0.5.3       | 2019-07-24   |
| 0.11.0                     | 0.8.2        | 0.2.3       | 0.1.1        | 0.3.0                | 0.5.2       | 2019-07-15   |
| 0.10.5                     | 0.8.2        | 0.2.1       | 0.1.1        | 0.2.2                | 0.5.2       | 2019-06-27   |
| 0.10.4                     | 0.8.2        | 0.2.1       | 0.1.1        | 0.2.2                | 0.5.1       | 2019-06-17   |
| 0.10.3                     | 0.8.1        | 0.2.1       | 0.1.1        | 0.2.2                | 0.5.1       | 2019-05-29   |
| 0.10.2                     | 0.8.0        | 0.2.1       | 0.1.1        | 0.2.2                | 0.5.1       | 2019-05-24   |
| 0.10.1                     | 0.8.0        | 0.2.0       | 0.1.1        | 0.2.2                | 0.5.0       | 2019-05-07   |
| 0.10.0                     | 0.8.0        | 0.2.0       | 0.1.1        | 0.2.1                | 0.5.0       | 2019-05-06   |
| 0.9.0                      | 0.8.0        | 0.2.0       | 0.1.1        | 0.1.1                | 0.5.0       | 2019-05-02   |
| 0.8.1                      | 0.7.2        | 0.1.1       | 0.1.0        |                      |             | 2019-05-01   |
| 0.8.0                      | 0.7.1        | 0.1.1       | 0.1.0        |                      |             | 2019-03-05   |
| 0.7.3                      | >=0.7,\<0.8  | >=0.1,\<0.2 |              |                      |             | 2019-02-19   |
| 0.7.2                      | >=0.7,\<0.8  | >=0.1,\<0.2 |              |                      |             | 2019-01-22   |
| 0.7.1                      | >=0.7,\<0.8  | >=0.1,\<0.2 |              |                      |             | 2019-01-17   |
| 0.7.0                      | >=0.7,\<0.8  | >=0.1,\<0.2 |              |                      |             | 2018-12-14   |

<Admonition title="Note" type="note">
  For the `0.7.0`, `0.7.1`, and `0.7.2` meta-package releases the meta-package versioning strategy was not formalized yet.
</Admonition>

<span id="qiskit-0-44-1" />

## Qiskit 0.44.1

<span id="terra-0-25-1" />

<span id="release-notes-0-25-1" />

### Terra 0.25.1

<span id="release-notes-0-25-1-prelude" />

#### Prelude

Qiskit Terra 0.25.1 is a bugfix release, addressing some issues identified since the 0.25.1 release.

<span id="release-notes-0-25-1-bug-fixes" />

#### Bug Fixes

*   Fixed a bug in QPY serialization ([`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy")) where multiple controlled custom gates in a circuit could result in an invalid QPY file that could not be parsed. Fixed [#9746](https://github.com/Qiskit/qiskit-terra/issues/9746).

*   Fixed [#9363](https://github.com/Qiskit/qiskit-terra/issues/9363). by labeling the non-registerless synthesis in the order that Tweedledum returns. For example, compare this example before and after the fix:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.classicalfunction import BooleanExpression

    boolean_exp = BooleanExpression.from_dimacs_file("simple_v3_c2.cnf")
    circuit = QuantumCircuit(boolean_exp.num_qubits)
    circuit.append(boolean_exp, range(boolean_exp.num_qubits))
    circuit.draw("text")

    from qiskit.circuit.classicalfunction import classical_function
    from qiskit.circuit.classicalfunction.types import Int1

    @classical_function
    def grover_oracle(a: Int1, b: Int1, c: Int1) -> Int1:
        return (a and b and not c)

    quantum_circuit = grover_oracle.synth(registerless=False)
    print(quantum_circuit.draw())
    ```

    Which would print

    ```python
         Before             After

         c: ──■──           a: ──■──
              │                  │
         b: ──■──           b: ──■──
              │                  │
         a: ──o──           c: ──o──
            ┌─┴─┐              ┌─┴─┐
    return: ┤ X ├      return: ┤ X ├
            └───┘              └───┘
    ```

*   Fixed `plot_state_paulivec()`, which previously damped the state coefficients by a factor of $2^n$, where $n$ is the number of qubits. Now the bar graph correctly displays the coefficients as $\mathrm{Tr}(\sigma\rho)$, where $\rho$ is the state to be plotted and $\sigma$ iterates over all possible tensor products of single-qubit Paulis.

*   Angles in the OpenQASM 2 exporter (`QuantumCircuit.qasm()`) will now always include a decimal point, for example in the case of `1.e-5`. This is required by a strict interpretation of the floating-point-literal specification in OpenQASM 2. Qiskit’s OpenQASM 2 parser ([`qasm2.load()`](qasm2#qiskit.qasm2.load "qiskit.qasm2.load") and [`loads()`](qasm2#qiskit.qasm2.loads "qiskit.qasm2.loads")) is more permissive by default, and will allow `1e-5` without the decimal point unless in `strict` mode.

*   The setter for [`SparsePauliOp.paulis`](qiskit.quantum_info.SparsePauliOp#paulis "qiskit.quantum_info.SparsePauliOp.paulis") will now correctly reject attempts to set the attribute with incorrectly shaped data, rather than silently allowing an invalid object to be created. See [#10384](https://github.com/Qiskit/qiskit-terra/issues/10384).

*   Fixed a performance regression in the [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") transpiler passes. Fixed [#10650](https://github.com/Qiskit/qiskit-terra/issues/10650)

<span id="qiskit-0-44-0" />

## Qiskit 0.44.0

This release officially marks the end of support for the Qiskit IBMQ Provider package and the removal of Qiskit Aer from the Qiskit metapackage. After this release the metapackage only contains Qiskit Terra, so this is the final release we will refer to the Qiskit metapackage and Qiskit Terra as separate things. Starting in the next release Qiskit 0.45.0 the Qiskit package will just be what was previously Qiskit Terra and there will no longer be a separation between them.

If you’re still using the `qiskit-ibmq-provider` package it has now been retired and is no longer supported. You should follow the links to the migration guides in the README for the package on how to switch over to the new replacement packages `qiskit-ibm-provider`, `qiskit-ibm-runtime`, and `qiskit-ibm-experiment`:

[https://github.com/Qiskit/qiskit-ibmq-provider#migration-guides](https://github.com/Qiskit/qiskit-ibmq-provider#migration-guides)

The Qiskit Aer project is still active and maintained moving forward it is just no longer included as part of the `qiskit` package. To continue using `qiskit-aer` you will need to explicitly install `qiskit-aer` and import the package from `qiskit_aer`.

As this is the final release of the Qiskit metapackage the following setuptools extras used to install optional dependencies will no longer work in the next release Qiskit 0.45.0:

> *   `nature`
> *   `machine-learning`
> *   `finance`
> *   `optimization`
> *   `experiments`

If you’re using the extras to install any packages you should migrate to using the packages directly instead of the extra. For example if you were using `pip install qiskit[experiments]` previously you should switch to `pip install qiskit qiskit-experiments` to install both packages. Similarly the `all` extra (what gets installed via `pip install "qiskit[all]"`) will no longer include these packages in Qiskit 0.45.0.

<span id="terra-0-25-0" />

<span id="release-notes-0-25-0" />

### Terra 0.25.0

<span id="release-notes-0-25-0-prelude" />

<span id="id2" />

#### Prelude

The Qiskit Terra 0.25.0 release highlights are:

*   Control-flow operations are now supported through the transpiler at all optimization levels, including levels 2 and 3 (e.g. calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") with keyword argument `optimization_level` specified as 2 or 3 is now supported).

*   The fields [`IfElseOp.condition`](qiskit.circuit.IfElseOp#condition "qiskit.circuit.IfElseOp.condition"), [`WhileLoopOp.condition`](qiskit.circuit.WhileLoopOp#condition "qiskit.circuit.WhileLoopOp.condition") and `SwitchCaseOp.target` can now be instances of the new runtime classical-expression type [`expr.Expr`](circuit_classical#qiskit.circuit.classical.expr.Expr "qiskit.circuit.classical.expr.Expr"). This is distinct from [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") because it is evaluated *at runtime* for backends that support such operations.

    These new expressions have significantly more power than the old two-tuple form of supplying classical conditions. For example, one can now represent equality constraints between two different classical registers, or the logic “or” of two classical bits. These two examples would look like:

    ```python
    from qiskit.circuit import QuantumCircuit, ClassicalRegister, QuantumRegister
    from qiskit.circuit.classical import expr

    qr = QuantumRegister(4)
    cr1 = ClassicalRegister(2)
    cr2 = ClassicalRegister(2)
    qc = QuantumCircuit(qr, cr1, cr2)
    qc.h(0)
    qc.cx(0, 1)
    qc.h(2)
    qc.cx(2, 3)
    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])

    # If the two registers are equal to each other.
    with qc.if_test(expr.equal(cr1, cr2)):
      qc.x(0)

    # While either of two bits are set.
    with qc.while_loop(expr.logic_or(cr1[0], cr1[1])):
      qc.reset(0)
      qc.reset(1)
      qc.measure([0, 1], cr1)
    ```

    For more examples, see the documentation for [`qiskit.circuit.classical`](circuit_classical#module-qiskit.circuit.classical "qiskit.circuit.classical").

    This feature is new for both Qiskit and the available quantum hardware that Qiskit works with. As the features are still being developed there are likely to be places where there are unexpected edge cases that will need some time to be worked out. If you encounter any issue around classical expression support or usage please open an issue with Qiskit or your hardware vendor.

    In this initial release, Qiskit has added the operations:

    *   [`bit_not()`](circuit_classical#qiskit.circuit.classical.expr.bit_not "qiskit.circuit.classical.expr.bit_not")
    *   [`logic_not()`](circuit_classical#qiskit.circuit.classical.expr.logic_not "qiskit.circuit.classical.expr.logic_not")
    *   [`bit_and()`](circuit_classical#qiskit.circuit.classical.expr.bit_and "qiskit.circuit.classical.expr.bit_and")
    *   [`bit_or()`](circuit_classical#qiskit.circuit.classical.expr.bit_or "qiskit.circuit.classical.expr.bit_or")
    *   [`bit_xor()`](circuit_classical#qiskit.circuit.classical.expr.bit_xor "qiskit.circuit.classical.expr.bit_xor")
    *   [`logic_and()`](circuit_classical#qiskit.circuit.classical.expr.logic_and "qiskit.circuit.classical.expr.logic_and")
    *   [`logic_or()`](circuit_classical#qiskit.circuit.classical.expr.logic_or "qiskit.circuit.classical.expr.logic_or")
    *   [`equal()`](circuit_classical#qiskit.circuit.classical.expr.equal "qiskit.circuit.classical.expr.equal")
    *   [`not_equal()`](circuit_classical#qiskit.circuit.classical.expr.not_equal "qiskit.circuit.classical.expr.not_equal")
    *   [`less()`](circuit_classical#qiskit.circuit.classical.expr.less "qiskit.circuit.classical.expr.less")
    *   [`less_equal()`](circuit_classical#qiskit.circuit.classical.expr.less_equal "qiskit.circuit.classical.expr.less_equal")
    *   [`greater()`](circuit_classical#qiskit.circuit.classical.expr.greater "qiskit.circuit.classical.expr.greater")
    *   [`greater_equal()`](circuit_classical#qiskit.circuit.classical.expr.greater_equal "qiskit.circuit.classical.expr.greater_equal")

    These can act on Python integer and Boolean literals, or on [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") and [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") instances.

    All these classical expressions are fully supported through the Qiskit transpiler stack, through QPY serialisation ([`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy")) and for export to OpenQASM 3 ([`qiskit.qasm3`](qasm3#module-qiskit.qasm3 "qiskit.qasm3")). Import from OpenQASM 3 is currently managed by [a separate package](https://github.com/Qiskit/qiskit-qasm3-import) (which is re-exposed via [`qiskit.qasm3`](qasm3#module-qiskit.qasm3 "qiskit.qasm3")), which we hope will be extended to match the new features in Qiskit.

*   The [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") module has been deprecated and will be removed in a future release. It has been superseded by a new standalone library `qiskit-algorithms` which can be found on PyPi or on Github here:

    [https://github.com/qiskit-community/qiskit-algorithms](https://github.com/qiskit-community/qiskit-algorithms)

    The [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") module will continue to work as before and bug fixes will be made to it until its future removal, but active development of new features has moved to the new package. If you’re relying on [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") you should update your Python requirements to also include `qiskit-algorithms` and update the imports from `qiskit.algorithms` to `qiskit_algorithms`. Please note that this new package does not include already deprecated algorithms code, including `opflow` and `QuantumInstance`-based algorithms. If you have not yet migrated from `QuantumInstance`-based to primitives-based algorithms, you should follow the migration guidelines in [https://qisk.it/algo\_migration](https://qisk.it/algo_migration). The decision to migrate the [`algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") module to a separate package was made to clarify the purpose Qiskit and make a distinction between the tools and libraries built on top of it.

Qiskit Terra 0.25 has dropped support for Python 3.7 following deprecation warnings started in Qiskit Terra 0.23. This is consistent with Python 3.7’s end-of-life on the 27th of June, 2023. To continue using Qiskit, you must upgrade to a more recent version of Python.

<span id="release-notes-0-25-0-new-features" />

#### New Features

*   The following features have been added in this release.

<span id="release-notes-0-25-0-transpiler-features" />

##### Transpiler Features

*   Added two new options to `BlockCollector`.

    The first new option `split_layers` allows collected blocks to be split into sub-blocks over disjoint qubit subsets, i.e. into depth-1 sub-blocks.

    The second new option `collect_from_back` allows blocks to be greedily collected starting from the outputs of the circuit. This is important in combination with ALAP-scheduling passes where we may prefer to put gates in the later rather than earlier blocks.

*   Added new options `split_layers` and `collect_from_back` to [`CollectLinearFunctions`](qiskit.transpiler.passes.CollectLinearFunctions "qiskit.transpiler.passes.CollectLinearFunctions") and [`CollectCliffords`](qiskit.transpiler.passes.CollectCliffords "qiskit.transpiler.passes.CollectCliffords") transpiler passes.

    When `split_layers` is True, the collected blocks are split into into sub-blocks over disjoint qubit subsets, i.e. into depth-1 sub-blocks. Consider the following example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler.passes import CollectLinearFunctions

    circuit = QuantumCircuit(5)
    circuit.cx(0, 2)
    circuit.cx(1, 4)
    circuit.cx(2, 0)
    circuit.cx(0, 3)
    circuit.swap(3, 2)
    circuit.swap(4, 1)

    # Collect all linear gates, without splitting into layers
    qct = CollectLinearFunctions(split_blocks=False, min_block_size=1, split_layers=False)(circuit)
    assert qct.count_ops()["linear_function"] == 1

    # Collect all linear gates, with splitting into layers
    qct = CollectLinearFunctions(split_blocks=False, min_block_size=1, split_layers=True)(circuit)
    assert qct.count_ops()["linear_function"] == 4
    ```

    The original circuit is linear. When collecting linear gates without splitting into layers, we should end up with a single linear function. However, when collecting linear gates and splitting into layers, we should end up with 4 linear functions.

    When `collect_from_back` is True, the blocks are greedily collected from the outputs towards the inputs of the circuit. Consider the following example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler.passes import CollectLinearFunctions

    circuit = QuantumCircuit(3)
    circuit.cx(1, 2)
    circuit.cx(1, 0)
    circuit.h(2)
    circuit.swap(1, 2)

    # This combines the CX(1, 2) and CX(1, 0) gates into a single linear function
    qct = CollectLinearFunctions(collect_from_back=False)(circuit)

    # This combines the CX(1, 0) and SWAP(1, 2) gates into a single linear function
    qct = CollectLinearFunctions(collect_from_back=True)(circuit)
    ```

    The original circuit contains a Hadamard gate, so that the CX(1, 0) gate can be combined either with CX(1, 2) or with SWAP(1, 2), but not with both. When `collect_from_back` is False, the linear blocks are greedily collected from the start of the circuit, and thus CX(1, 0) is combined with CX(1, 2). When `collect_from_back` is True, the linear blocks are greedily collected from the end of the circuit, and thus CX(1, 0) is combined with SWAP(1, 2).

*   Added [`DAGCircuit.classical_predecessors()`](qiskit.dagcircuit.DAGCircuit#classical_predecessors "qiskit.dagcircuit.DAGCircuit.classical_predecessors") and [`DAGCircuit.classical_successors()`](qiskit.dagcircuit.DAGCircuit#classical_successors "qiskit.dagcircuit.DAGCircuit.classical_successors"), an alternative to selecting classical wires that doesn’t require accessing the inner graph of a DAG node directly. The following example illustrates the new functionality:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit.converters import circuit_to_dag
    from qiskit.circuit.library import RZGate

    q = QuantumRegister(3, 'q')
    c = ClassicalRegister(3, 'c')
    circ = QuantumCircuit(q, c)
    circ.h(q[0])
    circ.cx(q[0], q[1])
    circ.measure(q[0], c[0])
    circ.rz(0.5, q[1]).c_if(c, 2)
    circ.measure(q[1], c[0])
    dag = circuit_to_dag(circ)

    rz_node = dag.op_nodes(RZGate)[0]
    # Contains the "measure" on clbit 0, and the "wire start" nodes for clbits 1 and 2.
    classical_predecessors = list(dag.classical_predecessors(rz_node))
    # Contains the "measure" on clbit 0, and the "wire end" nodes for clbits 1 and 2.
    classical_successors = list(dag.classical_successors(rz_node))
    ```

*   Enabled support for [`ControlFlowOp`](qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp") operations in the [`CommutativeCancellation`](qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation") pass. Previously, the blocks in control flow operations were skipped by this pass.

*   Enabled support for [`ControlFlowOp`](qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp") operations in the [`ConsolidateBlocks`](qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") pass.

*   Added [`DAGCircuit.quantum_causal_cone()`](qiskit.dagcircuit.DAGCircuit#quantum_causal_cone "qiskit.dagcircuit.DAGCircuit.quantum_causal_cone") to obtain the causal cone of a qubit in a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit"). The following example shows its correct usage:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit.circuit.library import CXGate, CZGate
    from qiskit.dagcircuit import DAGCircuit

    # Build a DAGCircuit
    dag = DAGCircuit()
    qreg = QuantumRegister(5)
    creg = ClassicalRegister(5)
    dag.add_qreg(qreg)
    dag.add_creg(creg)
    dag.apply_operation_back(CXGate(), qreg[[1, 2]], [])
    dag.apply_operation_back(CXGate(), qreg[[0, 3]], [])
    dag.apply_operation_back(CZGate(), qreg[[1, 4]], [])
    dag.apply_operation_back(CZGate(), qreg[[2, 4]], [])
    dag.apply_operation_back(CXGate(), qreg[[3, 4]], [])

    # Get the causal cone of qubit at index 0
    result = dag.quantum_causal_cone(qreg[0])
    ```

*   A new method [`find_bit()`](qiskit.dagcircuit.DAGCircuit#find_bit "qiskit.dagcircuit.DAGCircuit.find_bit") has been added to the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class, which returns the bit locations of the given [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") or [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") as a tuple of the positional index of the bit within the circuit and a list of tuples which locate the bit in the circuit’s registers.

*   The transpiler’s built-in [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") (`qiskit.circuit.equivalence_library.SessionEquivalenceLibrary`) has been taught the circular Pauli relations $X = iYZ$, $Y = iZX$ and $Z = iXY$. This should make transpiling to constrained, and potentially incomplete, basis sets more reliable. See [#10293](https://github.com/Qiskit/qiskit-terra/issues/10293) for more detail.

*   Control-flow operations are now supported through the transpiler at all optimization levels, including levels 2 and 3 (e.g. calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") with keyword argument `optimization_level=3`).

*   [`DAGCircuit.substitute_node()`](qiskit.dagcircuit.DAGCircuit#substitute_node "qiskit.dagcircuit.DAGCircuit.substitute_node") gained a `propagate_condition` keyword argument that is analogous to the same argument in [`substitute_node_with_dag()`](qiskit.dagcircuit.DAGCircuit#substitute_node_with_dag "qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag"). Setting this to `False` opts out of the legacy behaviour of copying a condition on the `node` onto the new `op` that is replacing it.

    This option is ignored for general control-flow operations, which will never propagate their condition, nor accept a condition from another node.

*   Introduced a new method, [`DAGCircuit.separable_circuits()`](qiskit.dagcircuit.DAGCircuit#separable_circuits "qiskit.dagcircuit.DAGCircuit.separable_circuits"), which returns a list of [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") objects, one for each set of connected qubits which have no gates connecting them to another set.

    Each [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") instance returned by this method will contain the same number of clbits as `self`. This method will not return [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") instances consisting solely of clbits.

*   Added the attribute [`Target.concurrent_measurements`](qiskit.transpiler.Target#concurrent_measurements "qiskit.transpiler.Target.concurrent_measurements") which represents a hardware constraint of qubits measured concurrently. This constraint is provided in a nested list form, in which each element represents a qubit group to be measured together. In an example below:

    ```python
    [[0, 1], [2, 3, 4]]
    ```

    qubits 0 and 1, and 2, 3 and 4 are measured together on the device. This constraint doesn’t block measuring an individual qubit, but you may need to consider the alignment of measure operations for these qubits when working with the [Qiskit Pulse scheduler](https://qiskit.org/documentation/tutorials/circuits_advanced/07_pulse_scheduler.html) and when authoring new transpiler passes that are timing-aware (i.e. passes that perform scheduling).

*   The transpiler pass [`SetLayout`](qiskit.transpiler.passes.SetLayout "qiskit.transpiler.passes.SetLayout") can now be constructed with a list of integers that represent the physical qubits on which the quantum circuit will be mapped on. That is, the first qubit in the circuit will be allocated to the physical qubit in position zero of the list, and so on.

*   The transpiler’s built-in [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") has been taught more Pauli-rotation equivalences between the one-qubit $R_X$, $R_Y$ and $R_Z$ gates, and between the two-qubit $R_{XX}$, $R_{YY}$ and $R_{ZZ}$ gates. This should make simple basis translations more reliable, especially circuits that use $Y$ rotations. See [#7332](https://github.com/Qiskit/qiskit-terra/issues/7332).

*   Control-flow operations are now supported by the Sabre family of transpiler passes, namely layout pass [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and routing pass [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap"). Function [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") keyword arguments `layout_method` and `routing_method` now accept the option `"sabre"` for circuits with control flow, which was previously unsupported.

<span id="release-notes-0-25-0-circuits-features" />

##### Circuits Features

*   The fields [`IfElseOp.condition`](qiskit.circuit.IfElseOp#condition "qiskit.circuit.IfElseOp.condition"), [`WhileLoopOp.condition`](qiskit.circuit.WhileLoopOp#condition "qiskit.circuit.WhileLoopOp.condition") and `SwitchCaseOp.target` can now be instances of the new runtime classical-expression type [`expr.Expr`](circuit_classical#qiskit.circuit.classical.expr.Expr "qiskit.circuit.classical.expr.Expr"). This is distinct from [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") because it is evaluated *at runtime* for backends that support such operations.

    These new expressions have significantly more power than the old two-tuple form of supplying classical conditions. For example, one can now represent equality constraints between two different classical registers, or the logic “or” of two classical bits. These two examples would look like:

    ```python
    from qiskit.circuit import QuantumCircuit, ClassicalRegister, QuantumRegister
    from qiskit.circuit.classical import expr

    qr = QuantumRegister(4)
    cr1 = ClassicalRegister(2)
    cr2 = ClassicalRegister(2)
    qc = QuantumCircuit(qr, cr1, cr2)
    qc.h(0)
    qc.cx(0, 1)
    qc.h(2)
    qc.cx(2, 3)
    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])

    # If the two registers are equal to each other.
    with qc.if_test(expr.equal(cr1, cr2)):
      qc.x(0)

    # While either of two bits are set.
    with qc.while_loop(expr.logic_or(cr1[0], cr1[1])):
      qc.reset(0)
      qc.reset(1)
      qc.measure([0, 1], cr1)
    ```

    For more examples, see the documentation for [`qiskit.circuit.classical`](circuit_classical#module-qiskit.circuit.classical "qiskit.circuit.classical").

    This feature is new for both Qiskit and the available quantum hardware that Qiskit works with. As the features are still being developed there are likely to be places where there are unexpected edge cases that will need some time to be worked out. If you encounter any issue around classical expression support or usage please open an issue with Qiskit or your hardware vendor.

    In this initial release, Qiskit has added the operations:

    *   [`bit_not()`](circuit_classical#qiskit.circuit.classical.expr.bit_not "qiskit.circuit.classical.expr.bit_not")
    *   [`logic_not()`](circuit_classical#qiskit.circuit.classical.expr.logic_not "qiskit.circuit.classical.expr.logic_not")
    *   [`bit_and()`](circuit_classical#qiskit.circuit.classical.expr.bit_and "qiskit.circuit.classical.expr.bit_and")
    *   [`bit_or()`](circuit_classical#qiskit.circuit.classical.expr.bit_or "qiskit.circuit.classical.expr.bit_or")
    *   [`bit_xor()`](circuit_classical#qiskit.circuit.classical.expr.bit_xor "qiskit.circuit.classical.expr.bit_xor")
    *   [`logic_and()`](circuit_classical#qiskit.circuit.classical.expr.logic_and "qiskit.circuit.classical.expr.logic_and")
    *   [`logic_or()`](circuit_classical#qiskit.circuit.classical.expr.logic_or "qiskit.circuit.classical.expr.logic_or")
    *   [`equal()`](circuit_classical#qiskit.circuit.classical.expr.equal "qiskit.circuit.classical.expr.equal")
    *   [`not_equal()`](circuit_classical#qiskit.circuit.classical.expr.not_equal "qiskit.circuit.classical.expr.not_equal")
    *   [`less()`](circuit_classical#qiskit.circuit.classical.expr.less "qiskit.circuit.classical.expr.less")
    *   [`less_equal()`](circuit_classical#qiskit.circuit.classical.expr.less_equal "qiskit.circuit.classical.expr.less_equal")
    *   [`greater()`](circuit_classical#qiskit.circuit.classical.expr.greater "qiskit.circuit.classical.expr.greater")
    *   [`greater_equal()`](circuit_classical#qiskit.circuit.classical.expr.greater_equal "qiskit.circuit.classical.expr.greater_equal")

    These can act on Python integer and Boolean literals, or on [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") and [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") instances.

    All these classical expressions are fully supported through the Qiskit transpiler stack, through QPY serialisation ([`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy")) and for export to OpenQASM 3 ([`qiskit.qasm3`](qasm3#module-qiskit.qasm3 "qiskit.qasm3")). Import from OpenQASM 3 is currently managed by [a separate package](https://github.com/Qiskit/qiskit-qasm3-import) (which is re-exposed via [`qiskit.qasm3`](qasm3#module-qiskit.qasm3 "qiskit.qasm3")), which we hope will be extended to match the new features in Qiskit.

*   Tooling for working with the new representations of classical runtime expressions has been added. A general [`ExprVisitor`](circuit_classical#qiskit.circuit.classical.expr.ExprVisitor "qiskit.circuit.classical.expr.ExprVisitor") is provided for consumers of these expressions to subclass. Two utilities based on this structure, [`iter_vars()`](circuit_classical#qiskit.circuit.classical.expr.iter_vars "qiskit.circuit.classical.expr.iter_vars") and [`structurally_equivalent()`](circuit_classical#qiskit.circuit.classical.expr.structurally_equivalent "qiskit.circuit.classical.expr.structurally_equivalent"), are also provided, which respectively produce an iterator through the [`Var`](circuit_classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") nodes and check whether two [`Expr`](circuit_classical#qiskit.circuit.classical.expr.Expr "qiskit.circuit.classical.expr.Expr") instances are structurally the same, up to some mapping of the [`Var`](circuit_classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") nodes contained.

*   Added function [`lift_legacy_condition()`](circuit_classical#qiskit.circuit.classical.expr.lift_legacy_condition "qiskit.circuit.classical.expr.lift_legacy_condition") which can be used to convert old-style conditions into new-style [`Expr`](circuit_classical#qiskit.circuit.classical.expr.Expr "qiskit.circuit.classical.expr.Expr") nodes. Note that these expression nodes are not permitted in old-style [`Instruction.condition`](qiskit.circuit.Instruction#condition "qiskit.circuit.Instruction.condition") fields, which are due to be replaced by more advanced classical handling such as [`IfElseOp`](qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp").

*   Added support for taking absolute values of [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")s. For example, the following is now possible:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter

    x = Parameter("x")
    circuit = QuantumCircuit(1)
    circuit.rx(abs(x), 0)

    bound = circuit.bind_parameters({x: -1})
    ```

*   The performance of [`QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") and [`bind_parameters()`](qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") has significantly increased for large circuits with structures typical of applications uses. This includes most circuits based on the [`NLocal`](qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") structure, such as [`EfficientSU2`](qiskit.circuit.library.EfficientSU2 "qiskit.circuit.library.EfficientSU2"). See [#10282](https://github.com/Qiskit/qiskit-terra/issues/10282) for more detail.

*   The method [`QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") has gained two new keywords arguments: `flat_input` and `strict`. These are advanced options that can be used to speed up the method when passing the parameter bindings as a dictionary; `flat_input=True` is a guarantee that the dictionary keys contain only [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") instances (not [`ParameterVector`](qiskit.circuit.ParameterVector "qiskit.circuit.ParameterVector")s), and `strict=False` allows the dictionary to contain parameters that are not present in the circuit. Using these two options can reduce the overhead of input normalisation in this function.

*   Added a new keyword argument `flatten` to the constructor for the following classes:

    > *   [`EfficientSU2`](qiskit.circuit.library.EfficientSU2 "qiskit.circuit.library.EfficientSU2")
    > *   [`ExcitationPreserving`](qiskit.circuit.library.ExcitationPreserving "qiskit.circuit.library.ExcitationPreserving")
    > *   [`NLocal`](qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal")
    > *   [`RealAmplitudes`](qiskit.circuit.library.RealAmplitudes "qiskit.circuit.library.RealAmplitudes")
    > *   [`TwoLocal`](qiskit.circuit.library.TwoLocal "qiskit.circuit.library.TwoLocal")
    > *   [`EvolvedOperatorAnsatz`](qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz")
    > *   [`QAOAAnsatz`](qiskit.circuit.library.QAOAAnsatz "qiskit.circuit.library.QAOAAnsatz")

    If this argument is set to `True` the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") subclass generated will not wrap the implementation into [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") or [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") objects. While this isn’t optimal for visualization it typically results in much better runtime performance, especially with [`QuantumCircuit.bind_parameters()`](qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") and [`QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") which can see a substatial runtime improvement with a flattened output compared to the nested wrapped default output.

*   Added support for constructing [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction")s from more general quantum circuits, that may contain:

    > *   Barriers (of type [`Barrier`](qiskit.circuit.library.Barrier "qiskit.circuit.library.Barrier")) and delays ([`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay")), which are simply ignored
    > *   Permutations (of type [`PermutationGate`](qiskit.circuit.library.PermutationGate "qiskit.circuit.library.PermutationGate"))
    > *   Other linear functions
    > *   Cliffords (of type [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford")), when the Clifford represents a linear function (and a `CircuitError` exception is raised if not)
    > *   Nested quantum circuits of this form

*   Added `LinearFunction.__eq__()` method. Two objects of type [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") are considered equal when their representations as binary invertible matrices are equal.

*   Added [`LinearFunction.extend_with_identity()`](qiskit.circuit.library.LinearFunction#extend_with_identity "qiskit.circuit.library.LinearFunction.extend_with_identity") method, which allows to extend a linear function over `k` qubits to a linear function over `n >= k` qubits, specifying the new positions of the original qubits and padding with identities on the remaining qubits.

*   Added two methods for pretty-printing [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") objects: [`LinearFunction.mat_str()`](qiskit.circuit.library.LinearFunction#mat_str "qiskit.circuit.library.LinearFunction.mat_str"), which returns the string representation of the linear function viewed as a matrix with 0/1 entries, and [`LinearFunction.function_str()`](qiskit.circuit.library.LinearFunction#function_str "qiskit.circuit.library.LinearFunction.function_str"), which returns the string representation of the linear function viewed as a linear transformation.

*   The instructions [`StatePreparation`](qiskit.circuit.library.StatePreparation "qiskit.circuit.library.StatePreparation") and `Initialize`, and their associated circuit methods [`QuantumCircuit.prepare_state()`](qiskit.circuit.QuantumCircuit#prepare_state "qiskit.circuit.QuantumCircuit.prepare_state") and [`initialize()`](qiskit.circuit.QuantumCircuit#initialize "qiskit.circuit.QuantumCircuit.initialize"), gained a keyword argument `normalize`, which can be set to `True` to automatically normalize an array target. By default this is `False`, which retains the current behaviour of raising an exception when given non-normalized input.

<span id="release-notes-0-25-0-algorithms-features" />

##### Algorithms Features

*   Added the option to pass a callback to the [`UMDA`](qiskit.algorithms.optimizers.UMDA "qiskit.algorithms.optimizers.UMDA") optimizer, which allows keeping track of the number of function evaluations, the current parameters, and the best achieved function value.

<span id="release-notes-0-25-0-openqasm-features" />

##### OpenQASM Features

*   The OpenQASM 3 exporters ([`qasm3.dump()`](qasm3#qiskit.qasm3.dump "qiskit.qasm3.dump"), [`dumps()`](qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps") and [`Exporter`](qasm3#qiskit.qasm3.Exporter "qiskit.qasm3.Exporter")) have a new `allow_aliasing` argument, which will eventually replace the `alias_classical_registers` argument. This controls whether aliasing is permitted for either classical bits or qubits, rather than the option only being available for classical bits.

<span id="release-notes-0-25-0-quantum-information-features" />

##### Quantum Information Features

*   Added a new function `negativity()` that calculates the entanglement measure of negativity of a quantum state. Example usage of the above function is given below:

    ```python
    from qiskit.quantum_info.states.densitymatrix import DensityMatrix
    from qiskit.quantum_info.states.statevector import Statevector
    from qiskit.quantum_info import negativity
    import numpy as np

    # Constructing a two-qubit bell state vector
    state = np.array([0, 1/np.sqrt(2), -1/np.sqrt(2), 0])
    # Calculating negativity of statevector
    negv = negativity(Statevector(state), [1])

    # Creating the Density Matrix (DM)
    rho = DensityMatrix.from_label("10+")
    # Calculating negativity of DM
    negv2 = negativity(rho, [0, 1])
    ```

*   Added the function [`schmidt_decomposition()`](quantum_info#qiskit.quantum_info.schmidt_decomposition "qiskit.quantum_info.schmidt_decomposition"). This function works with the [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes for bipartite pure states.

*   Adds support for multiplication of [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") objects with [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects by using the \* operator, for example:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.quantum_info import SparsePauliOp

    param = Parameter("a")
    op = SparsePauliOp("X")
    param * op
    ```

<span id="release-notes-0-25-0-pulse-features" />

##### Pulse Features

*   The [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") library was extended. The new pulse functions in the library are:

    > *   [`GaussianDeriv()`](qiskit.pulse.library.GaussianDeriv "qiskit.pulse.library.GaussianDeriv")
    > *   [`Sech()`](qiskit.pulse.library.Sech_fun.rst#qiskit.pulse.library.Sech "qiskit.pulse.library.Sech")
    > *   [`SechDeriv()`](qiskit.pulse.library.SechDeriv "qiskit.pulse.library.SechDeriv")
    > *   [`Square()`](qiskit.pulse.library.Square_fun.rst#qiskit.pulse.library.Square "qiskit.pulse.library.Square")

    The new functions return a `ScalableSymbolicPulse` instance, and match the functionality of the corresponding functions in the discrete pulse library, with the exception of [`Square()`](qiskit.pulse.library.Square_fun.rst#qiskit.pulse.library.Square "qiskit.pulse.library.Square") for which a phase of $2\pi$ shifts by a full cycle (contrary to the discrete [`square()`](pulse#qiskit.pulse.library.square "qiskit.pulse.library.square") where such a shift was induced by a $\pi$ phase).

*   The method `filter()` is activated in the [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.schedule.ScheduleBlock") class. This method enables users to retain only [`Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") objects which pass through all the provided filters. As builtin filter conditions, pulse [`Channel`](pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel") subclass instance and [`Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") subclass type can be specified. User-defined callbacks taking [`Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") instance can be added to the filters, too.

*   The method `exclude()` is activated in the [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.schedule.ScheduleBlock") class. This method enables users to retain only [`Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") objects which do not pass at least one of all the provided filters. As builtin filter conditions, pulse [`Channel`](pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel") subclass instance and [`Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") subclass type can be specified. User-defined callbacks taking [`Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") instance can be added to the filters, too. This method is the complement of `filter()`, so the following condition is always satisfied: `block.filter(*filters) + block.exclude(*filters) == block` in terms of instructions included, where `block` is a [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.schedule.ScheduleBlock") instance.

*   Added a new function [`gaussian_square_echo()`](qiskit.pulse.library.gaussian_square_echo "qiskit.pulse.library.gaussian_square_echo") to the pulse library. The returned pulse is composed of three [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare") pulses. The first two are echo pulses with duration half of the total duration and implement rotary tones. The third pulse is a cancellation tone that lasts the full duration of the pulse and implements correcting single qubit rotations.

*   QPY supports the `Discriminator` and `Kernel` objects. This feature enables users to serialize and deserialize the [`Acquire`](qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire") instructions with these objects using QPY.

<span id="release-notes-0-25-0-synthesis-features" />

##### Synthesis Features

*   Added a new synthesis function [`synth_cx_cz_depth_line_my()`](synthesis#qiskit.synthesis.synth_cx_cz_depth_line_my "qiskit.synthesis.synth_cx_cz_depth_line_my") which produces the circuit form of a CX circuit followed by a CZ circuit for linear nearest neighbor (LNN) connectivity in 2-qubit depth of at most 5n, using CX and phase gates (S, Sdg or Z). The synthesis algorithm is based on the paper of Maslov and Yang, [arXiv:2210.16195](https://arxiv.org/abs/2210.16195).

    The algorithm accepts a binary invertible matrix `mat_x` representing the CX-circuit, a binary symmetric matrix `mat_z` representing the CZ-circuit, and returns a quantum circuit with 2-qubit depth of at most 5n computing the composition of the CX and CZ circuits. The following example illustrates the new functionality:

    ```python
    import numpy as np
    from qiskit.synthesis.linear_phase import synth_cx_cz_depth_line_my
    mat_x = np.array([[0, 1], [1, 1]])
    mat_z = np.array([[0, 1], [1, 0]])
    qc = synth_cx_cz_depth_line_my(mat_x, mat_z)
    ```

    This function is now used by default in the Clifford synthesis algorithm [`synth_clifford_depth_lnn()`](synthesis#qiskit.synthesis.synth_clifford_depth_lnn "qiskit.synthesis.synth_clifford_depth_lnn") that optimizes 2-qubit depth for LNN connectivity, improving the 2-qubit depth from 9n+4 to 7n+2. The clifford synthesis algorithm can be used as follows:

    ```python
    from qiskit.quantum_info import random_clifford
    from qiskit.synthesis import synth_clifford_depth_lnn

    cliff = random_clifford(3)
    qc = synth_clifford_depth_lnn(cliff)
    ```

    The above synthesis can be further improved as described in the paper by Maslov and Yang, using local optimization between 2-qubit layers. This improvement is left for follow-up work.

<span id="release-notes-0-25-0-visualization-features" />

##### Visualization Features

*   [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") and function [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") when using option `output='mpl'` now support drawing the nested circuit blocks of [`ControlFlowOp`](qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp") operations, including `if`, `else`, `while`, `for`, and `switch/case`. Circuit blocks are wrapped with boxes to delineate the circuits.

*   Some restrictions when using `wire_order` in the circuit drawers have been relaxed. Now, `wire_order` can list just qubits and, in that case, it can be used with `cregbundle=True`, since it will not affect the classical bits.

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister

    qr = QuantumRegister(4, "q")
    cr = ClassicalRegister(4, "c")
    cr2 = ClassicalRegister(2, "ca")
    circuit = QuantumCircuit(qr, cr, cr2)
    circuit.h(0)
    circuit.h(3)
    circuit.x(1)
    circuit.x(3).c_if(cr, 10)
    circuit.draw('text', wire_order=[2, 3, 0, 1], cregbundle=True)
    ```

    ```python
     q_2: ────────────
          ┌───┐ ┌───┐
     q_3: ┤ H ├─┤ X ├─
          ├───┤ └─╥─┘
     q_0: ┤ H ├───╫───
          ├───┤   ║
     q_1: ┤ X ├───╫───
          └───┘┌──╨──┐
     c: 4/═════╡ 0xa ╞
               └─────┘
    ca: 2/════════════
    ```

<span id="release-notes-0-25-0-misc-features" />

##### Misc. Features

*   A new lazy import tester, [`HAS_PYGMENTS`](utils#qiskit.utils.optionals.HAS_PYGMENTS "qiskit.utils.optionals.HAS_PYGMENTS"), is available for testing for the presence of [the Pygments syntax highlighting library](https://pygments.org/).

*   The magic `%qiskit_version_table` from `qiskit.tools.jupyter` now includes all imported modules with `qiskit` in their name.

<span id="release-notes-0-25-0-upgrade-notes" />

#### Upgrade Notes

*   Qiskit Terra 0.25 has dropped support for Python 3.7 following deprecation warnings started in Qiskit Terra 0.23. This is consistent with Python 3.7’s end-of-life on the 27th of June, 2023. To continue using Qiskit, you must upgrade to a more recent version of Python.

*   Qiskit Terra 0.25 now requires versison 0.13.0 of `rustworkx`.

*   By default Qiskit builds its compiled extensions using the [Python Stable ABI](https://docs.python.org/3/c-api/stable.html) with support back to the oldest version of Python supported by Qiskit (currently 3.8). This means that moving forward there will be a single precompiled wheel that is shipped on release that works with all of Qiskit’s supported Python versions. There isn’t any expected runtime performance difference using the limited API so it is enabled by default for all builds now. Previously, the compiled extensions were built using the version specific API and would only work with a single Python version. This change was made to reduce the number of package files we need to build and publish in each release. When building Qiskit from source, there should be no changes necessary to the build process except that the default tags in the output filenames will be different to reflect the use of the limited API.

<span id="release-notes-0-25-0-transpiler-upgrade-notes" />

##### Transpiler Upgrade Notes

*   Support for passing in lists of argument values to the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function is removed. This functionality was deprecated as part of the 0.23.0 release. You are still able to pass in a list of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects for the first positional argument. What has been removed is list broadcasting of the other arguments to each circuit in that input list. Removing this functionality was necessary to greatly reduce the overhead for parallel execution for transpiling multiple circuits at once. If you’re using this functionality currently you can call [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") multiple times instead. For example if you were previously doing something like:

    ```python
    from qiskit.transpiler import CouplingMap
    from qiskit import QuantumCircuit
    from qiskit import transpile

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    cmaps = [CouplingMap.from_heavy_hex(d) for d in range(3, 15, 2)]
    results = transpile([qc] * 6, coupling_map=cmaps)
    ```

    instead you should now run something like:

    ```python
    from qiskit.transpiler import CouplingMap
    from qiskit import QuantumCircuit
    from qiskit import transpile

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    cmaps = [CouplingMap.from_heavy_hex(d) for d in range(3, 15, 2)]
    results = [transpile(qc, coupling_map=cm) for cm in cmap]
    ```

    You can also leverage [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") or `multiprocessing` from the Python standard library if you want to run this in parallel.

*   The Sabre family of transpiler passes (namely [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap")) are now used by default for all circuits when invoking the transpiler at optimization level 1 (e.g. calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") with keyword argument `optimization_level=1`). Previously, circuits with control flow operations used [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") and [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") with this profile.

<span id="release-notes-0-25-0-circuits-upgrade-notes" />

##### Circuits Upgrade Notes

*   The OpenQASM 2 constructor methods on [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") ([`from_qasm_str()`](qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") and [`from_qasm_file()`](qiskit.circuit.QuantumCircuit#from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file")) have been switched to use the Rust-based parser added in Qiskit Terra 0.24. This should result in significantly faster parsing times (10 times or more is not uncommon) and massively reduced intermediate memory usage.

    The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods are kept with the same interface for continuity; the preferred way to access the OpenQASM 2 importer is to use [`qasm2.load()`](qasm2#qiskit.qasm2.load "qiskit.qasm2.load") and [`qasm2.loads()`](qasm2#qiskit.qasm2.loads "qiskit.qasm2.loads"), which offer an expanded interface to control the parsing and construction.

*   The deprecated `circuit_cregs` argument to the constructor for the [`InstructionSet`](qiskit.circuit.InstructionSet "qiskit.circuit.InstructionSet") class has been removed. It was deprecated in the 0.19.0 release. If you were using this argument and manually constructing an [`InstructionSet`](qiskit.circuit.InstructionSet "qiskit.circuit.InstructionSet") object (which should be quite uncommon as it’s mostly used internally) you should pass a callable to the `resource_requester` keyword argument instead. For example:

    ```python
    from qiskit.circuit import Clbit, ClassicalRegister, InstructionSet
    from qiskit.circuit.exceptions import CircuitError

    def my_requester(bits, registers):
        bits_set = set(bits)
        bits_flat = tuple(bits)
        registers_set = set(registers)

        def requester(specifier):
            if isinstance(specifer, Clbit) and specifier in bits_set:
                return specifier
            if isinstance(specifer, ClassicalRegster) and specifier in register_set:
                return specifier
            if isinstance(specifier, int) and 0 <= specifier < len(bits_flat):
                return bits_flat[specifier]
            raise CircuitError(f"Unknown resource: {specifier}")

        return requester

    my_bits = [Clbit() for _ in [None]*5]
    my_registers = [ClassicalRegister(n) for n in range(3)]

    InstructionSet(resource_requester=my_requester(my_bits, my_registers))
    ```

<span id="release-notes-0-25-0-openqasm-upgrade-notes" />

##### OpenQASM Upgrade Notes

*   The OpenQASM 2 constructor methods on [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") ([`from_qasm_str()`](qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") and [`from_qasm_file()`](qiskit.circuit.QuantumCircuit#from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file")) have been switched to use the Rust-based parser added in Qiskit Terra 0.24. This should result in significantly faster parsing times (10 times or more is not uncommon) and massively reduced intermediate memory usage.

    The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods are kept with the same interface for continuity; the preferred way to access the OpenQASM 2 importer is to use [`qasm2.load()`](qasm2#qiskit.qasm2.load "qiskit.qasm2.load") and [`qasm2.loads()`](qasm2#qiskit.qasm2.loads "qiskit.qasm2.loads"), which offer an expanded interface to control the parsing and construction.

*   The OpenQASM 3 exporters ([`qasm3.dump()`](qasm3#qiskit.qasm3.dump "qiskit.qasm3.dump"), [`dumps()`](qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps") and [`Exporter`](qasm3#qiskit.qasm3.Exporter "qiskit.qasm3.Exporter")) will now use fewer “register alias” definitions in its output. The circuit described will not change, but it will now preferentially export in terms of direct `bit`, `qubit` and `qubit[n]` types rather than producing a `_loose_bits` register and aliasing more registers off this. This is done to minimise the number of advanced OpenQASM 3 features in use, and to avoid introducing unnecessary array structure into programmes that do not require it.

<span id="release-notes-0-25-0-quantum-information-upgrade-notes" />

##### Quantum Information Upgrade Notes

*   [`Clifford.from_circuit()`](qiskit.quantum_info.Clifford#from_circuit "qiskit.quantum_info.Clifford.from_circuit") will no longer attempt to resolve instructions whose [`definition`](qiskit.circuit.Instruction#definition "qiskit.circuit.Instruction.definition") fields are mutually recursive with some other object. Such recursive definitions are already a violation of the strictly hierarchical ordering that the [`definition`](qiskit.circuit.Instruction#definition "qiskit.circuit.Instruction.definition") field requires, and code should not rely on this being possible at all. If you want to define equivalences that are permitted to have (mutual) cycles, use an [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary").

<span id="release-notes-0-25-0-visualization-upgrade-notes" />

##### Visualization Upgrade Notes

*   In the internal `~qiskit.visualization.circuit.matplotlib.MatplotlibDrawer` object, the arguments `layout`, `global_phase`, `qregs` and `cregs` have been removed. They were originally deprecated in Qiskit Terra 0.20. These objects are simply inferred from the given `circuit` now.

    This is an internal worker class of the visualization routines. It is unlikely you will need to change any of your code.

<span id="release-notes-0-25-0-misc-upgrade-notes" />

##### Misc. Upgrade Notes

*   The `qiskit.util` import location has been removed, as it had been deprecated since Qiskit Terra 0.17. Users should use the new import location, `qiskit.utils`.

<span id="release-notes-0-25-0-deprecation-notes" />

#### Deprecation Notes

*   Extensions of the `qiskit` and `qiskit.providers` namespaces by external packages are now deprecated and the hook points enabling this will be removed in a future release. In the past, the Qiskit project was composed of elements that extended a shared namespace and these hook points enabled doing that. However, it was not intended for these interfaces to ever be used by other packages. Now that the overall Qiskit package is no longer using that packaging model, leaving the possibility for these extensions carry more risk than benefits and is therefore being deprecated for future removal. If you’re maintaining a package that extends the Qiskit namespace (i.e. your users import from `qiskit.x` or `qiskit.providers.y`) you should transition to using a standalone Python namespace for your package. No warning will be raised as part of this because there is no method to inject a warning at the packaging level that would be required to warn external packages of this change.

*   The dictionary `qiskit.__qiskit_version__` is deprecated, as Qiskit is defined with a single package (`qiskit-terra`). In the future, `qiskit.__version__` will be the single point to query the Qiskit version, as a standard string.

<span id="release-notes-0-25-0-transpiler-deprecations" />

##### Transpiler Deprecations

*   The function `get_vf2_call_limit` available via the module `qiskit.transpiler.preset_passmanagers.common` has been deprecated. This will likely affect very few users since this function was neither explicitly exported nor documented. Its functionality has been replaced and extended by a function in the same module.

<span id="release-notes-0-25-0-circuits-deprecations" />

##### Circuits Deprecations

*   The method [`qasm()`](qiskit.circuit.Instruction#qasm "qiskit.circuit.Instruction.qasm") and all overriding methods of subclasses of :class:\~qiskit.circuit.Instruction are deprecated. There is no replacement for generating an OpenQASM2 string for an isolated instruction as typically a single instruction object has insufficient context to completely generate a valid OpenQASM2 string. If you’re relying on this method currently you’ll have to instead rely on the OpenQASM2 exporter: [`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") to generate the OpenQASM2 for an entire circuit object.

<span id="release-notes-0-25-0-algorithms-deprecations" />

##### Algorithms Deprecations

*   The [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") module has been deprecated and will be removed in a future release. It has been superseded by a new standalone library `qiskit-algorithms` which can be found on PyPi or on Github here:

    [https://github.com/qiskit-community/qiskit-algorithms](https://github.com/qiskit-community/qiskit-algorithms)

    The [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") module will continue to work as before and bug fixes will be made to it until its future removal, but active development of new features has moved to the new package. If you’re relying on [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") you should update your Python requirements to also include `qiskit-algorithms` and update the imports from `qiskit.algorithms` to `qiskit_algorithms`. Please note that this new package does not include already deprecated algorithms code, including `opflow` and `QuantumInstance`-based algorithms. If you have not yet migrated from `QuantumInstance`-based to primitives-based algorithms, you should follow the migration guidelines in [https://qisk.it/algo\_migration](https://qisk.it/algo_migration). The decision to migrate the [`algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") module to a separate package was made to clarify the purpose Qiskit and make a distinction between the tools and libraries built on top of it.

<span id="release-notes-0-25-0-pulse-deprecations" />

##### Pulse Deprecations

*   Initializing a `ScalableSymbolicPulse` with complex value for `amp`. This change also affects the following library pulses:

    > *   [`Gaussian`](qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian")
    > *   [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare")
    > *   [`Drag`](qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag")
    > *   [`Constant`](qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant")

    Initializing `amp` for these with a complex value is now deprecated as well.

    Instead, use two floats when specifying the `amp` and `angle` parameters, where `amp` represents the magnitude of the complex amplitude, and angle represents the angle of the complex amplitude. i.e. the complex amplitude is given by $\texttt{amp} \times \exp(i \times \texttt{angle})$.

*   The [`Call`](qiskit.pulse.instructions.Call "qiskit.pulse.instructions.Call") instruction has been deprecated and will be removed in a future release. Instead, use function [`call()`](pulse#qiskit.pulse.builder.call "qiskit.pulse.builder.call") from module [`qiskit.pulse.builder`](pulse#module-qiskit.pulse.builder "qiskit.pulse.builder") within an active building context.

<span id="release-notes-0-25-0-misc-deprecations" />

##### Misc. Deprecations

*   The Jupyter magic `%circuit_library_info` and the objects in `qiskit.tools.jupyter.library` it calls in turn:

    *   `circuit_data_table`
    *   `properties_widget`
    *   `qasm_widget`
    *   `circuit_digram_widget`
    *   `circuit_library_widget`

    are deprecated and will be removed in a future release. These objects were only intended for use in the documentation build. They are no longer used there, so are no longer supported or maintained.

<span id="release-notes-0-25-0-known-issues" />

#### Known Issues

*   Circuits containing classical expressions made with the [`expr`](circuit_classical#module-qiskit.circuit.classical.expr "qiskit.circuit.classical.expr") module are not yet supported by the circuit visualizers.

<span id="release-notes-0-25-0-bug-fixes" />

<span id="id3" />

#### Bug Fixes

*   Fixed a bug in [`Channel`](pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel") where index validation was done incorrectly and only raised an error when the index was both non-integer and negative, instead of either.

*   Fixed an issue with the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function and all the preset pass managers generated via [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") where the output [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object’s [`layout`](qiskit.circuit.QuantumCircuit#layout "qiskit.circuit.QuantumCircuit.layout") attribute would have an invalid [`TranspileLayout.final_layout`](qiskit.transpiler.TranspileLayout#final_layout "qiskit.transpiler.TranspileLayout.final_layout") attribute. This would occur in scenarios when the [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") pass would run and find an alternative initial layout that has lower reported error rates. When altering the initial layout the [`final_layout`](qiskit.transpiler.TranspileLayout#final_layout "qiskit.transpiler.TranspileLayout.final_layout") attribute was never updated to reflect this change. This has been corrected so that the `final_layout` is always correctly reflecting the output permutation caused by the routing stage. Fixed [#10457](https://github.com/Qiskit/qiskit-terra/issues/10457)

*   The OpenQASM 2 parser ([`qasm2.load()`](qasm2#qiskit.qasm2.load "qiskit.qasm2.load") and [`loads()`](qasm2#qiskit.qasm2.loads "qiskit.qasm2.loads")) running in `strict` mode will now correctly emit an error if a `barrier` statement has no arguments. When running in the (default) more permissive mode, an argument-less `barrier` statement will continue to cause a barrier on all qubits currently in scope (the qubits a gate definition affects, or all the qubits defined by a program, if the statement is in a gate body or in the global scope, respectively).

*   The OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) will now no longer attempt to output `barrier` statements that act on no qubits. Such a barrier statement has no effect in Qiskit either, but is invalid OpenQASM 2.

*   Qiskit can represent custom instructions that act on zero qubits, or on a non-zero number of classical bits. These cannot be exported to OpenQASM 2, but previously [`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") would try, and output invalid OpenQASM 2. Instead, a [`QASM2ExportError`](qasm2#qiskit.qasm2.QASM2ExportError "qiskit.qasm2.QASM2ExportError") will now correctly be raised. See [#7351](https://github.com/Qiskit/qiskit-terra/issues/7351) and [#10435](https://github.com/Qiskit/qiskit-terra/issues/10435).

*   Fixed an issue with using [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target")s without coupling maps with the [`FullAncillaAllocation`](qiskit.transpiler.passes.FullAncillaAllocation "qiskit.transpiler.passes.FullAncillaAllocation") transpiler pass. In this case, [`FullAncillaAllocation`](qiskit.transpiler.passes.FullAncillaAllocation "qiskit.transpiler.passes.FullAncillaAllocation") will now add ancilla qubits so that the number of qubits in the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") matches that of `Target.num_qubits`.

*   [`DAGCircuit.substitute_node()`](qiskit.dagcircuit.DAGCircuit#substitute_node "qiskit.dagcircuit.DAGCircuit.substitute_node") will no longer silently overwrite an existing condition on the given replacement `op`. If `propagate_condition` is set to `True` (the default), a [`DAGCircuitError`](dagcircuit#qiskit.dagcircuit.DAGCircuitError "qiskit.dagcircuit.DAGCircuitError") will be raised instead.

*   A parametrised circuit that contains a custom gate whose definition has a parametrised global phase can now successfully bind the parameter in the inner global phase. See [#10283](https://github.com/Qiskit/qiskit-terra/issues/10283) for more detail.

*   Construction of a [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") containing zero-qubit operations will no longer raise an error. These operations impart a global phase on the resulting statevector.

*   The control-flow builder interface will now correctly include [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") resources from nested switch statements in their containing circuit scopes. See [#10398](https://github.com/Qiskit/qiskit-terra/issues/10398).

*   Fixed an issue in [`QuantumCircuit.decompose()`](qiskit.circuit.QuantumCircuit#decompose "qiskit.circuit.QuantumCircuit.decompose") where passing a circuit name to the function that matched a composite gate name would not decompose the gate if it had a label assigned to it as well. Fixed [#9136](https://github.com/Qiskit/qiskit-terra/issues/9136)

*   Fixed an issue with [`qiskit.visualization.plot_histogram()`](qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram") where the relative legend did not show up when the given dataset had a zero value in the first position. See [#10158](https://github.com/Qiskit/qiskit-terra/issues/10158) for more details.

*   Fixed a failure with method [`Target.update_from_instruction_schedule_map()`](qiskit.transpiler.Target#update_from_instruction_schedule_map "qiskit.transpiler.Target.update_from_instruction_schedule_map") triggered by the given `inst_map` containing a [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") with unassigned durations.

*   When the parameter `conditional=True` is specified in [`random_circuit()`](circuit#qiskit.circuit.random.random_circuit "qiskit.circuit.random.random_circuit"), conditional operations in the resulting circuit will now be preceded by a full mid-circuit measurment. Fixes [#9016](https://github.com/Qiskit/qiskit-terra/issues/9016)

*   Improved the type annotations on the [`QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") method to reflect the change in return type depending on the `inplace` argument.

*   The OpenQASM 2 circuit-constructor methods ([`QuantumCircuit.from_qasm_str()`](qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") and [`from_qasm_file()`](qiskit.circuit.QuantumCircuit#from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file")) will no longer error when encountering a `gate` definition that contains `U` or `CX` instructions. See [#5536](https://github.com/Qiskit/qiskit-terra/issues/5536).

*   Reduced overhead of the [`ConsolidateBlocks`](qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") pass by performing matrix operations on all two-qubit blocks instead of creating an instance of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and passing it to an [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator"). The speedup will only be applicable when consolidating two-qubit blocks. Anything higher than that will still be handled by the [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") class. Check [#8779](https://github.com/Qiskit/qiskit-terra/issues/8779) for details.

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](qasm3#module-qiskit.qasm3 "qiskit.qasm3")) will no longer output invalid OpenQASM 3 for non-unitary [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") instances, but will instead raise a [`QASM3ExporterError`](qasm3#qiskit.qasm3.QASM3ExporterError "qiskit.qasm3.QASM3ExporterError") explaining that these are not yet supported. This feature is slated for a later release of Qiskit, when there are more classical-processing facilities throughout the library.

*   Fixes issue [#10185](https://github.com/Qiskit/qiskit-terra/issues/10185).

*   Fixed an issue with function `state_to_latex()`. Previously, it produced invalid LaTeX with unintended coefficient rounding, which resulted in errors when calling `state_drawer()`. Fixed [#9297](https://github.com/Qiskit/qiskit-terra/issues/9297).

<span id="qiskit-0-43-3" />

## Qiskit 0.43.3

<span id="terra-0-24-2" />

### Terra 0.24.2

<span id="release-notes-0-24-2-prelude" />

<span id="id4" />

#### Prelude

Qiskit Terra 0.24.2 is a bugfix release, addressing some minor issues identified since the 0.24.1 release.

<span id="release-notes-0-24-2-upgrade-notes" />

<span id="id5" />

#### Upgrade Notes

*   The QPY format version emitted by `dump` has increased to 8. This new format version adds support for serializing the [`QuantumCircuit.layout`](qiskit.circuit.QuantumCircuit#layout "qiskit.circuit.QuantumCircuit.layout") attribute.

<span id="release-notes-0-24-2-bug-fixes" />

<span id="id6" />

#### Bug Fixes

*   Fixed the deserialization of [`DiagonalGate`](qiskit.circuit.library.DiagonalGate "qiskit.circuit.library.DiagonalGate") instances through QPY. Fixed [#10364](https://github.com/Qiskit/qiskit-terra/issues/10364)

*   Fixed an issue with the `qs_decomposition()` function, which does quantum Shannon decomposition, when it was called on trivial numeric unitaries that do not benefit from this decomposition, an unexpected error was raised. This error has been fixed so that such unitaries are detected and the equivalent circuit is returned. Fixed [#10036](https://github.com/Qiskit/qiskit-terra/issues/10036)

*   Fixed an issue in the the [`BasicSwap`](qiskit.transpiler.passes.BasicSwap "qiskit.transpiler.passes.BasicSwap") class that prevented the [`BasicSwap.run()`](qiskit.transpiler.passes.BasicSwap#run "qiskit.transpiler.passes.BasicSwap.run") method from functioning if the `fake_run` keyword argument was set to `True` when the class was instantiated. Fixed [#10147](https://github.com/Qiskit/qiskit-terra/issues/10147)

*   Fixed an issue with copying circuits with new-style [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit")s and [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit")s (bits without registers) where references to these bits from the containing circuit could be broken, causing issues with serialization and circuit visualization. Fixed [#10409](https://github.com/Qiskit/qiskit-terra/issues/10409)

*   The [`CheckMap`](qiskit.transpiler.passes.CheckMap "qiskit.transpiler.passes.CheckMap") transpiler pass will no longer spuriously error when dealing with nested conditional structures created by the control-flow builder interface. See [#10394](https://github.com/Qiskit/qiskit-terra/issues/10394).

*   Fixed an failure of the [Pulse Builder](pulse#pulse-builder) when the context is initialized with [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2").

*   Fixed the output of pulse [`measure()`](pulse#qiskit.pulse.builder.measure "qiskit.pulse.builder.measure") and [`measure_all()`](pulse#qiskit.pulse.builder.measure_all "qiskit.pulse.builder.measure_all") when functions are called with the [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend.

*   Fixed the dimensions of the output density matrix from [`DensityMatrix.partial_transpose()`](qiskit.quantum_info.DensityMatrix#partial_transpose "qiskit.quantum_info.DensityMatrix.partial_transpose") so they match the dimensions of the corresponding input density matrix.

*   Importing [`qiskit.primitives`](primitives#module-qiskit.primitives "qiskit.primitives") will no longer cause deprecation warnings stemming from the deprecated [`qiskit.opflow`](opflow#module-qiskit.opflow "qiskit.opflow") module. These warnings would have been hidden to users by the default Python filters, but triggered the eager import of [`opflow`](opflow#module-qiskit.opflow "qiskit.opflow"), which meant that a subsequent import by a user would not trigger the warnings. Fixed [#10245](https://github.com/Qiskit/qiskit-terra/issues/10245)

*   Fixed the OpenQASM 2 output of [`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") when a custom gate object contained a gate with the same name. Ideally this shouldn’t happen for most gates, but complex algorithmic operations like the [`GroverOperator`](qiskit.circuit.library.GroverOperator "qiskit.circuit.library.GroverOperator") class could produce such structures accidentally. See [#10162](https://github.com/Qiskit/qiskit-terra/issues/10162).

*   Fixed a regression in the LaTeX drawer of [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") when temporary files are placed on a separate filesystem to the working directory. See [#10211](https://github.com/Qiskit/qiskit-terra/issues/10211).

*   Fixed an issue with [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") when using the `target` parameter where circuits with control flow were not properly mapped to the target.

*   Fixed bug in [`VQD`](qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD") where `result.optimal_values` was a copy of `result.optimal_points`. It now returns the corresponding values. Fixed [#10263](https://github.com/Qiskit/qiskit-terra/issues/10263)

*   Improved the error messages returned when an attempt to convert a fully bound [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") into a concrete `float` or `int` failed, for example because the expression was naturally a complex number. Fixed [#9187](https://github.com/Qiskit/qiskit-terra/issues/9187)

*   Fixed `float` conversions for [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") values which had, at some point in their construction history, an imaginary component that had subsequently been cancelled. When using Sympy as a backend, these conversions would usually already have worked. When using Symengine as the backend, these conversions would often fail with type errors, despite the result having been symbolically evaluated to be real, and [`ParameterExpression.is_real()`](qiskit.circuit.ParameterExpression#is_real "qiskit.circuit.ParameterExpression.is_real") being true. Fixed [#10191](https://github.com/Qiskit/qiskit-terra/issues/10191)

*   Fixed the [`qpy`](qpy#module-qiskit.qpy "qiskit.qpy") serialization of [`QuantumCircuit.layout`](qiskit.circuit.QuantumCircuit#layout "qiskit.circuit.QuantumCircuit.layout") attribue. Previously, the [`layout`](qiskit.circuit.QuantumCircuit#layout "qiskit.circuit.QuantumCircuit.layout") attribute would have been dropped when serializing a circuit to QPY. Fixed [#10112](https://github.com/Qiskit/qiskit-terra/issues/10112)

<span id="aer-0-12-2" />

<span id="release-notes-aer-0-12-2" />

### Aer 0.12.2

<span id="release-notes-aer-0-12-2-prelude" />

<span id="id7" />

#### Prelude

Qiskit Aer 0.12.2 is the second patch release to 0.12.0. This fixes some bugs that have been discovered since the release of 0.12.1.

<span id="release-notes-aer-0-12-2-upgrade-notes" />

<span id="id8" />

#### Upgrade Notes

*   Qiskit Aer now requires CUDA version for GPU simulator to 11.2 or higher. Previously, CUDA 10.1 was the minimum supported version. This change was necessary because of changes in the upstream CUDA ecosystem, including cuQuantum support. To support users running with different versions of CUDA there is now a separate package available for running with CUDA 11: `qiskit-aer-gpu-cu11` and using the `qiskit-aer-gpu` package now requires CUDA 12. If you’re an existing user of the `qiskit-aer-gpu` package and want to use CUDA 11 you will need to run:

    ```python
    pip uninstall qiskit-aer-gpu && pip install -U qiskit-aer-gpu-cu11
    ```

    to go from the previously CUDA 10.x compatible `qiskit-aer-gpu` package’s releases to upgrade to the new CUDA 11 compatible package. If you’re running CUDA 12 locally already you can upgrade the `qiskit-aer-gpu` package as normal.

<span id="release-notes-aer-0-12-2-bug-fixes" />

<span id="id9" />

#### Bug Fixes

*   If a circuit has conditional and parameters, the circuit was not be correctly simulated because parameter bindings of Aer used wrong positions to apply parameters. This is from a lack of consideration of bfunc operations injected by conditional. With this commit, parameters are set to correct positions with consideration of injected bfun operations.

*   Parameters for global phases were not correctly set in #1814. [https://github.com/Qiskit/qiskit-aer/pull/1814](https://github.com/Qiskit/qiskit-aer/pull/1814) Parameter values for global phases were copied to a template circuit and not to actual circuits to be simulated. This commit correctly copies parameter values to circuits to be simulated.

*   Results of `backend.run()` were not serializable because they include `AerCircuit`s. This commit makes the results serializable by removing `AerCircuit`s from metadata.

*   :meth:`QuantumCircuit.save_statevector()` does not work if the circuit is generated from OpenQASM3 text because its quantum registers have duplicated qubit instances. With this commit, :meth:`QuantumCircuit.save_statevector()` uses :data:`QuantumCircuit.qubits` to get qubits to be saved.

<span id="ibm-q-provider-0-20-2" />

### IBM Q Provider 0.20.2

No change.

<span id="qiskit-0-43-2" />

## Qiskit 0.43.2

As a reminder, [Qiskit Aer](https://qiskit.org/ecosystem/aer/)’s inclusion in the `qiskit` package is deprecated. The next minor version of Qiskit Aer (0.13) will not be included in any release of the `qiskit` package, and you should immediately begin installing Aer separately by:

```python
pip install qiskit-aer
```

and importing it as:

```python
import qiskit_aer
```

Starting from Qiskit 0.44, the command `pip install qiskit` will no longer install Qiskit Aer, or the obsolete IBM Q Provider that has already been replaced by the new IBM Provider \<[https://qiskit.org/ecosystem/ibm-provider/>\_\_](https://qiskit.org/ecosystem/ibm-provider/>__).

<span id="terra-0-24-1" />

<span id="release-notes-0-24-2" />

### Terra 0.24.1

No change

<span id="aer-0-12-1" />

### Aer 0.12.1

<span id="release-notes-aer-0-12-1-prelude" />

<span id="id10" />

#### Prelude

Qiskit Aer 0.12.1 is the first patch release to 0.12.0. This fixes some bugs that have been discovered since the release of 0.12.0.

<span id="release-notes-aer-0-12-1-known-issues" />

<span id="id11" />

#### Known Issues

*   Fix a bug that returns wrong expectation values in `Estimator` when `abelian_grouping=True`.

<span id="release-notes-aer-0-12-1-upgrade-notes" />

<span id="id12" />

#### Upgrade Notes

*   Improved performance when the same circuits and multiple parameters are passed to [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator") with `approximation=True`.

<span id="release-notes-aer-0-12-1-deprecation-notes" />

<span id="id13" />

#### Deprecation Notes

*   Options of meth:\~.AerSimulator.run need to use correct types.

<span id="release-notes-aer-0-12-1-bug-fixes" />

<span id="id14" />

#### Bug Fixes

*   Performance regression due to introduction of `AER::Config` is fixed. This class has many fields but is frequently copied in `AER::Transpile::CircuitOptimization`. Originally `json_t` (former class for configuration) was also frequently copied but it does have entries in most cases and then this copy overhead is not a problem. With this fix, `AER::Transpile::CircuitOptimization` does not copy `AER::Config`.

*   When BLAS calls are failed, because omp threads do not handle exceptions, Aer crashes without any error messages. This fix is for omp threads to catch exceptions correctly and then rethrow them outside of omp loops.

*   Previously, parameters for gates are not validate in C++. If parameters are shorter than expected (due to custom gate), segmentaion faults are thrown. This commit adds checks whether parameter lenght is expceted. This commit will fix issues reported in #1612. [https://github.com/Qiskit/qiskit-aer/issues/1612](https://github.com/Qiskit/qiskit-aer/issues/1612)

*   Since 0.12.0, parameter values in circuits are temporarily replaced with constant values and parameter values are assigned in C++ library. Therefore, if parameter\_binds is specified, simulator returns results with the constnat values as paramter values. With this commit, Aer raises an error if parameter\_binds is not specified though circuits have parameters.

*   Available devices and methods are no longer queried when importing Aer.

*   Previously `AerSimulator` modifies circuit metadata to maintain consistency between input and output of simulation with side effect of unexpected view of metadata from applicatiln in simiulation. This fix avoids using circuit metadata to maintain consistency internaly and then always provides consistent view of metadata to application.

*   Fixed a bug where the variance in metadata in EstimatorResult was complex and now returns float.

*   Fixed a build break to compile Qiskit Aer with cuQuautum support (AER\_ENABLE\_CUQUANTUM=true). This change does not affect build for CPU and normal GPU binaries.

*   Fixed a bug in `from_backend()` that raised an error when the backend has no T1 and T2 values (i.e. None) for a qubit in its qubit properties. This commit updates `NoiseModel.from_backend()` and `basic_device_gate_errors()` so that they add an identity `QuantumError` (i.e. effectively no thermal relaxation error) to a qubit with no T1 and T2 values for all gates acting on qubits including the qubit. Fixed [#1779](https://github.com/Qiskit/qiskit-aer/issues/1779) and [#1815](https://github.com/Qiskit/qiskit-aer/issues/1815).

*   Fix an issue even if the number of qubits is set by a coupling map or device’s configuration, when the simulation method is configured, the number of qubits is overwritten in accordance with the method. Fixed [#1769](https://github.com/Qiskit/qiskit-aer/issues/1769)

*   This is fix for library path setting in CMakeLists.txt for cuQuantum SDK. Because the latest cuQuantum includes libraries for CUDA 11.x and 12.x, this fix uses CUDA version returned from FindCUDA to the path of libraries of cuQuantum and cuTENSOR.

*   This is fix for static link libraries of cuQuantum when building with CUQUANTUM\_STATIC=true.

*   MPI parallelization was not enabled since we have not used qobj. This fix sets the number of processes and MPI rank correctly.

*   `AerCircuit` is created from a circuit by iterating its operations while skipping barrier instructions. However, skipping barrier instructions make wrong positionings of parameter bindings. This fix adds `barrier()` and keeps parametr bindings correct.

*   Aer still supports Qobj as an argument of `run()` though it was deprecated. However, since 0.12.0, it always fails if no `run_options` is specified. This fix enables simulation of Qobj without `run_options`.

*   Since 0.12.0, `AerConfig` is used for simulation configuration while performing strict type checking for arguments of meth:\~.AerSimulator.run. This commit adds casting if argument types are not expected.

*   :meth:`QuantumCircuit.initialize()` with int value was not processed correctly as reported in #1821 \<[https://github.com/Qiskit/qiskit-aer/issues/1821](https://github.com/Qiskit/qiskit-aer/issues/1821)>. This commit enables such initialization by decomposing initialize instructions.

*   [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") supports parameterization for its global\_phase. However, Aer has not allowed such parameterization and failed when transpiler generates parameterized global phases. This commit supports parameterization of global\_phase and resolve issues related to [https://github.com/Qiskit/qiskit-aer/issues/1795](https://github.com/Qiskit/qiskit-aer/issues/1795), [https://github.com/Qiskit/qiskit-aer/issues/1781](https://github.com/Qiskit/qiskit-aer/issues/1781), and [https://github.com/Qiskit/qiskit-aer/issues/1798](https://github.com/Qiskit/qiskit-aer/issues/1798).

*   Aer will now use `omp_set_max_active_levels()` instead of the deprecated `omp_set_nested()` when compiled against recent versions of OpenMP.

<span id="id15" />

### IBM Q Provider 0.20.2

No change.

<span id="qiskit-0-43-1" />

## Qiskit 0.43.1

<span id="release-notes-terra-0-24-1" />

<span id="id16" />

### Terra 0.24.1

<span id="release-notes-terra-0-24-1-prelude" />

<span id="id17" />

#### Prelude

Qiskit Terra 0.24.1 is the first patch release to 0.24.0. This fixes some bugs that have been discovered since the release of 0.24.0.

<span id="release-notes-terra-0-24-1-upgrade-notes" />

<span id="id18" />

#### Upgrade Notes

*   Changed [`QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") to bind assigned integer and float values directly into the parameters of [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") instances in the circuit rather than binding the values wrapped within a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"). This change should have little user impact as `float(QuantumCircuit.data[i].operation.params[j])` still produces a `float` (and is the only way to access the value of a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")). Also, [`Instruction()`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") parameters could already be `float` as well as a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"), so code dealing with instruction parameters should already handle both cases. The most likely chance for user impact is in code that uses `isinstance` to check for [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") and behaves differently depending on the result. Additionally, qpy serializes the numeric value in a bound [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") at a different precision than a `float` (see also the related bug fix note about [`QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters")).

<span id="release-notes-terra-0-24-1-bug-fixes" />

<span id="id19" />

#### Bug Fixes

*   Updated [`plot_gate_map()`](qiskit.visualization.plot_gate_map "qiskit.visualization.plot_gate_map"), [`plot_error_map()`](qiskit.visualization.plot_error_map "qiskit.visualization.plot_error_map"), and [`plot_circuit_layout()`](qiskit.visualization.plot_circuit_layout "qiskit.visualization.plot_circuit_layout") to support 433 qubit heavy-hex coupling maps. This allows coupling map visualizations for IBM Quantum’s `ibm_seattle` backend.

*   Changed the binding of numeric values with [`QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") to avoid a mismatch between the values of circuit instruction parameters and corresponding parameter keys in the circuit’s calibration dictionary. Fixed [#9764](https://github.com/Qiskit/qiskit-terra/issues/9764) and [#10166](https://github.com/Qiskit/qiskit-terra/issues/10166). See also the related upgrade note regarding [`QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters").

*   Fixed a bug in `BlockCollapser` where classical bits were ignored when collapsing a block of nodes.

*   Fixed a bug in [`replace_block_with_op()`](qiskit.dagcircuit.DAGCircuit#replace_block_with_op "qiskit.dagcircuit.DAGCircuit.replace_block_with_op") and [`replace_block_with_op()`](qiskit.dagcircuit.DAGDependency#replace_block_with_op "qiskit.dagcircuit.DAGDependency.replace_block_with_op") that led to ignoring classical bits.

*   Fixed a bug in [`QuantumCircuit.compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") where the `SwitchCaseOp.target` attribute in the subcircuit was not correctly mapped to a register in the base circuit.

*   Fix a bug in [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") where calling calibration with wrong parameters would crash instead of raising an exception.

*   Fixed an issue with the [`BooleanExpression.from_dimacs_file()`](qiskit.circuit.classicalfunction.BooleanExpression#from_dimacs_file "qiskit.circuit.classicalfunction.BooleanExpression.from_dimacs_file") constructor method where the exception type raised when tweedledum wasn’t installed was not the expected `MissingOptionalLibrary`. Fixed [#10079](https://github.com/Qiskit/qiskit-terra/issues/10079)

*   Using `initial_layout` in calls to [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") will no longer error if the circuit contains qubits not in any registers, or qubits that exist in more than one register. See [#10125](https://github.com/Qiskit/qiskit-terra/issues/10125).

*   Fixed the gate decomposition of multi-controlled Z rotation gates added via [`QuantumCircuit.mcrz()`](qiskit.circuit.QuantumCircuit#mcrz "qiskit.circuit.QuantumCircuit.mcrz"). Previously, this method implemented a multi-controlled phase gate, which has a relative phase difference to the Z rotation. To obtain the previous [`QuantumCircuit.mcrz()`](qiskit.circuit.QuantumCircuit#mcrz "qiskit.circuit.QuantumCircuit.mcrz") behaviour, use [`QuantumCircuit.mcp()`](qiskit.circuit.QuantumCircuit#mcp "qiskit.circuit.QuantumCircuit.mcp").

*   Fixed an issue with the [`PassManagerConfig.from_backend()`](qiskit.transpiler.PassManagerConfig#from_backend "qiskit.transpiler.PassManagerConfig.from_backend") constructor when building a [`PassManagerConfig`](qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig") object from a [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") instance that didn’t have a coupling map attribute defined. Previously, the constructor would incorrectly create a [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") object with 0 qubits instead of using `None`. Fixed [#10171](https://github.com/Qiskit/qiskit-terra/issues/10171)

*   Fixes a bug introduced in Qiskit 0.24.0 where numeric rotation angles were no longer substituted for symbolic ones before preparing for two-qubit synthesis. This caused an exception to be raised because the synthesis routines require numberic matrices.

*   Fix a bug in which running [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") in parallel would raise an error due to OneQubitGateErrorMap not being picklable.

*   Fix a bug in the [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") passes where the passes were failing to account for the 1 qubit error component when evaluating a potential layout.

<span id="aer-0-12-0" />

### Aer 0.12.0

No change

<span id="id22" />

### IBM Q Provider 0.20.2

No change

<span id="qiskit-0-43-0" />

## Qiskit 0.43.0

<span id="terra-0-24-0" />

<span id="release-notes-terra-0-24-0" />

### Terra 0.24.0

<span id="release-notes-0-24-0-prelude" />

<span id="id23" />

#### Prelude

This is a major feature release that includes numerous new features and bugfixes.

This release is the final release with support for running Qiskit with Python 3.7. Starting in the next minor version release Python >=3.8 will be required to run Qiskit.

The highlights of this release:

##### QuantumInstance, OpFlow, and algorithms usage deprecation

This release officially deprecates the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class (and its associated helper methods and classes), the [`qiskit.opflow`](opflow#module-qiskit.opflow "qiskit.opflow") module, and any usage of those in [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms"). This deprecation comes from a long thread of work that started in Qiskit Terra 0.21.0 to refactor the [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") module to be based on the computational [`primitives`](primitives#module-qiskit.primitives "qiskit.primitives"). There are associated migration guides for any existing users to migrate to the new workflow:

> *   `QuantumInstance` migration guide: [https://qisk.it/qi\_migration](https://qisk.it/qi_migration)
> *   `Opflow` migration guide: [https://qisk.it/opflow\_migration](https://qisk.it/opflow_migration)
> *   Algorithms migration guide: [https://qisk.it/algo\_migration](https://qisk.it/algo_migration)

##### OpenQASM2 improvements

This release includes a major refactoring for the OpenQASM 2.0 support in Qiskit. The first change is the introduction of a new parser for OpenQASM 2.0 in the [`qiskit.qasm2`](qasm2#module-qiskit.qasm2 "qiskit.qasm2") module. This new module replaces the existing [`qiskit.qasm`](qasm#module-qiskit.qasm "qiskit.qasm") module. The new parser is more explicit and correct with respect to the language specification. It is also implemented in Rust and is significantly faster than the previous parser. Paired with the new parser the OpenQASM 2.0 exporter underwent a large refactor that improved the correctness of the output when using the [`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") method to generate QASM output from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object.

##### Transpiler support for devices with disjoint connectivity

The transpiler now supports targeting backends with disjoint connectivity. Previously, the transpiler only supported backends which were fully connected (where there is a path to run operations between all pairs of qubits in the backend). Now, if a backend has disconnected connectivity the transpiler is able to reason about how to apply layout ([Layout Stage](transpiler#layout-stage)) and routing ([Routing Stage](transpiler#routing-stage)) for the backend. If the input circuit is not able to be executed on the hardware given the lack of connectivity between connected components, a descriptive error will be returned.

For example, the Heron device outlined in IBM Quantum’s [hardware roadmap](https://research.ibm.com/blog/ibm-quantum-roadmap-2025) describes a future backend which will have shared control hardware and real-time classical communication between separate quantum processors. This support enables the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") to accurately model these types of future devices or other hardware with similar constraints.

##### Switch Operation

This release adds a new control flow operation, the switch statement. This is implemented using a new operation class [`SwitchCaseOp`](qiskit.circuit.SwitchCaseOp "qiskit.circuit.SwitchCaseOp") and the [`QuantumCircuit.switch()`](qiskit.circuit.QuantumCircuit#switch "qiskit.circuit.QuantumCircuit.switch") method. This allows switching on a numeric input (such as a classical register or bit) and executing the circuit that corresponds to the matching value.

<span id="release-notes-0-24-0-new-features" />

<span id="id24" />

#### New Features

*   Added the functions [`add_deprecation_to_docstring()`](utils#qiskit.utils.add_deprecation_to_docstring "qiskit.utils.add_deprecation_to_docstring"), [`deprecate_arg()`](utils#qiskit.utils.deprecate_arg "qiskit.utils.deprecate_arg"), and [`deprecate_func()`](utils#qiskit.utils.deprecate_func "qiskit.utils.deprecate_func") to the [`qiskit.utils`](utils#module-qiskit.utils "qiskit.utils") module.

    [`add_deprecation_to_docstring()`](utils#qiskit.utils.add_deprecation_to_docstring "qiskit.utils.add_deprecation_to_docstring") will rewrite the function’s docstring to include a Sphinx `.. deprecated::` directive so that the deprecation shows up in docs and with `help()`. The deprecation decorators from [`qiskit.utils`](utils#module-qiskit.utils "qiskit.utils") call [`add_deprecation_to_docstring()`](utils#qiskit.utils.add_deprecation_to_docstring "qiskit.utils.add_deprecation_to_docstring") already for you; but you can call it directly if you are using different mechanisms for deprecations.

    `@deprecate_func` replaces `@deprecate_function` and is used to deprecate an entire function. It will auto-generate most of the deprecation message for you.

    `@deprecate_arg` replaces `@deprecate_arguments` and is used to deprecate an argument on a function. It will generate a more useful message than the previous function. It is also more flexible, for example it allows setting a `predicate` so that you only deprecate certain situations, such as using a deprecated value or data type.

<span id="release-notes-0-24-0-transpiler-features" />

<span id="id25" />

##### Transpiler Features

*   Added an alternative way to specify in `HLSConfig` the list of synthesis methods used for a given high-level object. As before, a synthesis method can be specified as a tuple consisting of the name of the method and additional arguments. Additionally, a synthesis method can be specified as a tuple consisting of an instance of [`HighLevelSynthesisPlugin`](qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin") and additional arguments. Moreover, when there are no additional arguments, a synthesis method can be specified simply by name or by an instance of [`HighLevelSynthesisPlugin`](qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin"). The following example illustrates the new functionality:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.circuit.library.generalized_gates import PermutationGate
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig, HighLevelSynthesis
    from qiskit.transpiler.passes.synthesis.high_level_synthesis import ACGSynthesisPermutation

    qc = QuantumCircuit(6)
    qc.append(PermutationGate([1, 2, 3, 0]), [1, 2, 3, 4])

    # All of the ways to specify hls_config are equivalent
    hls_config = HLSConfig(permutation=[("acg", {})])
    hls_config = HLSConfig(permutation=["acg"])
    hls_config = HLSConfig(permutation=[(ACGSynthesisPermutation(), {})])
    hls_config = HLSConfig(permutation=[ACGSynthesisPermutation()])

    # The hls_config can then be passed as an argument to HighLevelSynthesis
    pm = PassManager(HighLevelSynthesis(hls_config=hls_config))
    qc_synthesized = pm.run(qc)
    ```

*   Added support to the [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") object to have a disjoint connectivity. Previously, a [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") could only be constructed if the graph was connected. This will enable using [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") to represent hardware with disjoint qubits, such as hardware with qubits on multiple separate chips.

*   Added a new method [`CouplingMap.connected_components()`](qiskit.transpiler.CouplingMap#connected_components "qiskit.transpiler.CouplingMap.connected_components") which is used to get a list of [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") component subgraphs for a disjoint [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap"). If the [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") object is connected this will just return a single [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") equivalent to the original.

*   Added new rules to the built-in [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") instance: `qiskit.circuit.equivalence_library.SessionEquivalenceLibrary`. The new rules added are:

    > *   [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") into [`ECRGate`](qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate") and 1-qubit Clifford gates (up to a global phase).
    > *   [`HGate`](qiskit.circuit.library.HGate "qiskit.circuit.library.HGate") into [`SXGate`](qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate") and [`SGate`](qiskit.circuit.library.SGate "qiskit.circuit.library.SGate") (up to a global phase).
    > *   [`HGate`](qiskit.circuit.library.HGate "qiskit.circuit.library.HGate") into [`SXdgGate`](qiskit.circuit.library.SXdgGate "qiskit.circuit.library.SXdgGate") and [`SdgGate`](qiskit.circuit.library.SdgGate "qiskit.circuit.library.SdgGate") (up to a global phase).

*   Added high-level-synthesis plugins for [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") and for [`qiskit.quantum_info.Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford"), extending the set of synthesis methods that can be called from [`HighLevelSynthesis`](qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass.

    For [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") the available plugins are listed below:

    | Plugin name | High-level synthesis plugin      |
    | ----------- | -------------------------------- |
    | `default`   | `DefaultSynthesisLinearFunction` |
    | `kms`       | `KMSSynthesisLinearFunction`     |
    | `pmh`       | `PMHSynthesisLinearFunction`     |

    For [`qiskit.quantum_info.Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") the available plugins are listed below:

    | Plugin name | High-level synthesis plugin |
    | ----------- | --------------------------- |
    | `default`   | `DefaultSynthesisClifford`  |
    | `ag`        | `AGSynthesisClifford`       |
    | `bm`        | `BMSynthesisClifford`       |
    | `greedy`    | `GreedySynthesisClifford`   |
    | `layers`    | `LayerSynthesisClifford`    |
    | `lnn`       | `LayerLnnSynthesisClifford` |

    Please refer to [`qiskit.synthesis`](synthesis#module-qiskit.synthesis "qiskit.synthesis") documentation for more information about each individual method.

    The following example illustrates some of the new plugins:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import LinearFunction
    from qiskit.quantum_info import Clifford
    from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig, HighLevelSynthesis

    # Create a quantum circuit with one linear function and one clifford
    qc1 = QuantumCircuit(3)
    qc1.cx(0, 1)
    qc1.swap(0, 2)
    lin_fun = LinearFunction(qc1)

    qc2 = QuantumCircuit(3)
    qc2.h(0)
    qc2.cx(0, 2)
    cliff = Clifford(qc2)

    qc = QuantumCircuit(4)
    qc.append(lin_fun, [0, 1, 2])
    qc.append(cliff, [1, 2, 3])

    # Choose synthesis methods that adhere to linear-nearest-neighbour connectivity
    hls_config = HLSConfig(linear_function=["kms"], clifford=["lnn"])

    # Synthesize
    qct = HighLevelSynthesis(hls_config)(qc)
    print(qct.decompose())
    ```

*   Added a new transpiler pass, [`MinimumPoint`](qiskit.transpiler.passes.MinimumPoint "qiskit.transpiler.passes.MinimumPoint") which is used primarily as a pass to check a loop condition in a [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager"). This pass will track the state of fields in the property set over its past executions and set a boolean field when either a fixed point is reached over the backtracking depth or selecting the minimum value found if the backtracking depth is reached. This is an alternative to the [`FixedPoint`](qiskit.transpiler.passes.FixedPoint "qiskit.transpiler.passes.FixedPoint") which simply checks for a fixed value in a property set field between subsequent executions.

*   Added a new method, [`swap_nodes()`](qiskit.dagcircuit.DAGCircuit#swap_nodes "qiskit.dagcircuit.DAGCircuit.swap_nodes"), to the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") to allow swapping nodes which are partially connected. Partially connected here means that the two nodes share at least one edge (which represents a qubit or clbit). If the nodes do not share any edges a [`DAGCircuitError`](dagcircuit#qiskit.dagcircuit.DAGCircuitError "qiskit.dagcircuit.DAGCircuitError") is raised.

*   Add a new synthesis algorithm [`synth_cz_depth_line_mr()`](synthesis#qiskit.synthesis.synth_cz_depth_line_mr "qiskit.synthesis.synth_cz_depth_line_mr") of a CZ circuit for linear nearest neighbor (LNN) connectivity in 2-qubit depth of 2n+2 using CX and phase gates (S, Sdg or Z). The synthesized circuit reverts the order of the qubits. The synthesis algorithm is based on the paper of Maslov and Roetteler ([https://arxiv.org/abs/1705.09176](https://arxiv.org/abs/1705.09176)).

*   Add a new synthesis algorithm [`synth_clifford_depth_lnn()`](synthesis#qiskit.synthesis.synth_clifford_depth_lnn "qiskit.synthesis.synth_clifford_depth_lnn") of a Clifford circuit for LNN connectivity in 2-qubit depth of 9n+4 (which is still not optimal), using the layered Clifford synthesis ([`synth_clifford_layers()`](synthesis#qiskit.synthesis.synth_clifford_layers "qiskit.synthesis.synth_clifford_layers")), [`synth_cnot_depth_line_kms()`](synthesis#qiskit.synthesis.synth_cnot_depth_line_kms "qiskit.synthesis.synth_cnot_depth_line_kms") to synthesize the CX layer in depth 5n, and [`synth_cz_depth_line_mr()`](synthesis#qiskit.synthesis.synth_cz_depth_line_mr "qiskit.synthesis.synth_cz_depth_line_mr") to synthesize each of the CZ layers in depth 2n+2. This PR will be followed by another PR based on the recent paper of Maslov and Yang ([https://arxiv.org/abs/2210.16195](https://arxiv.org/abs/2210.16195)), that synthesizes the CX-CZ layers in depth 5n for LNN connectivity and performs further optimization, and hence reduces the depth of a Clifford circuit to 7n-4 for LNN connectivity.

*   Equivalences between the controlled Pauli rotations and translations to two-Pauli rotations are now available in the equivalence library for Qiskit standard gates. This allows, for example, to translate a [`CRZGate`](qiskit.circuit.library.CRZGate "qiskit.circuit.library.CRZGate") to a [`RZZGate`](qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate") plus [`RZGate`](qiskit.circuit.library.RZGate "qiskit.circuit.library.RZGate") or a [`CRYGate`](qiskit.circuit.library.CRYGate "qiskit.circuit.library.CRYGate") to a single [`RZXGate`](qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate") plus single qubit gates:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.compiler import transpile

    angle = 0.123
    circuit = QuantumCircuit(2)
    circuit.cry(angle, 0, 1)

    basis = ["id", "sx", "x", "rz", "rzx"]
    transpiled = transpile(circuit, basis_gates=basis)
    print(transpiled.draw())
    ```

*   Added a new option, `copy_operations`, to [`circuit_to_dag()`](converters#qiskit.converters.circuit_to_dag "qiskit.converters.circuit_to_dag") to enable optionally disabling deep copying the operations from the input [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") to the output [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). In cases where the input :class\`\~.QuantumCircuit\` is not used anymore after conversion this deep copying is unnecessary overhead as any shared references wouldn’t have any potential unwanted side effects if the input [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") is discarded.

*   Added a new option, `copy_operations`, to [`dag_to_circuit()`](converters#qiskit.converters.dag_to_circuit "qiskit.converters.dag_to_circuit") to enable optionally disabling deep copying the operations from the input [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") to the output [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). In cases where the input [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") is not used anymore after conversion this deep copying is unnecessary overhead as any shared references wouldn’t have any potential unwanted side effects if the input [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") is discarded.

*   Added a new function [`passmanager_stage_plugins()`](transpiler_plugins#qiskit.transpiler.preset_passmanagers.plugin.passmanager_stage_plugins "qiskit.transpiler.preset_passmanagers.plugin.passmanager_stage_plugins") to the [`qiskit.transpiler.preset_passmanagers.plugin`](transpiler_plugins#module-qiskit.transpiler.preset_passmanagers.plugin "qiskit.transpiler.preset_passmanagers.plugin") module. This function is used to obtain a mapping from plugin names to their their class type. This enables identifying and querying any defined pass manager stage plugin’s documentation. For example:

    ```python
    >>> from qiskit.transpiler.preset_passmanagers.plugin import passmanager_stage_plugins
    >>> passmanager_stage_plugins('routing')['lookahead'].__class__

    qiskit.transpiler.preset_passmanagers.builtin_plugins.LookaheadSwapPassManager

    >>> help(passmanager_stage_plugins('routing')['lookahead'])
    Help on BasicSwapPassManager in module qiskit.transpiler.preset_passmanagers.builtin_plugins object:

    class BasicSwapPassManager(qiskit.transpiler.preset_passmanagers.plugin.PassManagerStagePlugin)
    |  Plugin class for routing stage with :class:`~.BasicSwap`
    ...
    ```

*   The transpiler pass `Error` now also accepts callable inputs for its `msg` parameter. If used these input callables will be passed the `property_set` attribute of the pass and are expected to return a string which will be used for the error message when the pass is run. For example:

    ```python
    from qiskit.transpiler.passes import Error

    def error_message(property_set):

        size = property_set["size']
        return f"The circuit size is: {size}"

    error_pass = Error(error_message)
    ```

    When `error_pass` is included in a pass manager it will error using the message `"The circuit size is: n"` where `n` is the circuit size set in the property set (typically from the previous execution of the [`Size`](qiskit.transpiler.passes.Size "qiskit.transpiler.passes.Size") pass).

*   The [`build_coupling_map()`](qiskit.transpiler.Target#build_coupling_map "qiskit.transpiler.Target.build_coupling_map") method has a new keyword argument, `filter_idle_qubits` which when set to `True` will remove any qubits from the output [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") that don’t support any operations.

*   The [`GateDirection`](qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection") transpiler pass can now correctly handle [`SwapGate`](qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") instances that may be present in the circuit when executing on a circuit. In these cases if the swap gate’s qubit arguments are on the non-native direction of an edge, the pass will flip the argument order.

*   The [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") and [`RZXCalibrationBuilderNoEcho`](qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho") transpiler passes now will correctly use an [`ECRGate`](qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate") for the entangling gate if the backend’s native entangling gate is [`ECRGate`](qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate"). Previously, the passes would only function correctly if the entangling gate was [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate").

*   Added a new constructor for the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class, [`Target.from_configuration()`](qiskit.transpiler.Target#from_configuration "qiskit.transpiler.Target.from_configuration"), which lets you construct a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object from the separate object types for describing the constraints of a backend (e.g. basis gates, [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap"), [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties"), etc). For example:

    ```python
    target = Target.from_configuration(
        basis_gates=["u", "cx", "measure"],
        coupling_map=CouplingMap.from_line(25),
    )
    ```

    This will construct a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object that has [`UGate`](qiskit.circuit.library.UGate "qiskit.circuit.library.UGate"), [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate"), and [`Measure`](qiskit.circuit.library.Measure "qiskit.circuit.library.Measure") globally available on 25 qubits which are connected in a line.

*   Added a new function `synth_cnot_phase_aam()` which is used to synthesize cnot phase circuits for all-to-all architectures using the Amy, Azimzadeh, and Mosca method. This function is identical to the available `qiskit.transpiler.synthesis.graysynth()` function but has a more descriptive name and is more logically placed in the package tree. This new function supersedes the legacy function which will likely be deprecated in a future release.

*   Internal tweaks to the routing algorithm in [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap"), used in transpilation of non-dynamic circuits at all non-zero optimization levels, have sped up routing for very large circuits. For example, the time to route a depth-5 [`QuantumVolume`](qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") circuit for a 1081-qubit heavy-hex coupling map is approximately halved.

*   The runtime performance of the [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") transpiler pass has been significantly improved. This was done by both rewriting all the computation for the pass in Rust and also decreasing the amount of intermediate objects created as part of the pass’s execution. This should also correspond to a similar improvement in the runtime performance of [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") with the `optimization_level` keyword argument set to `1`, `2`, or `3`.

*   Add a new synthesis method [`synth_stabilizer_layers()`](synthesis#qiskit.synthesis.synth_stabilizer_layers "qiskit.synthesis.synth_stabilizer_layers") of a stabilizer state into layers. It provides a similar decomposition to the synthesis described in Lemma 8 of Bravyi and Maslov, (arxiv:2003.09412) without the initial Hadamard-free sub-circuit which does not affect the stabilizer state.

*   Add a new synthesis method `synth_stabilizer_lnn()` of a stabilizer state for linear nearest neighbor connectivity in 2-qubit depth of 2n+2 and two distinct CX layers, using CX and phase gates (S, Sdg or Z). The synthesis algorithm is based on the paper of Maslov and Roetteler ([https://arxiv.org/abs/1705.09176](https://arxiv.org/abs/1705.09176)).

*   The [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") pass now supports running against a target with a disjoint [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap"). When targeting a disjoint coupling the input [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") is split into its connected components of virtual qubits, each component is mapped to the connected components of the [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap"), layout is run on each connected component in isolation, and then all layouts are combined and returned. Note when the `routing_pass` argument is set the pass doesn’t support running with disjoint connectivity.

*   The following layout and routing transpiler passes from the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") modules now will support accepting a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object which is used to model the constraints of a target backend via the first positional argument (currently named either `coupling_map` or `backend_properties`).

    The list of passes with the new support for [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") input are:

    > *   [`CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout")
    > *   [`FullAncillaAllocation`](qiskit.transpiler.passes.FullAncillaAllocation "qiskit.transpiler.passes.FullAncillaAllocation")
    > *   [`Layout2qDistance`](qiskit.transpiler.passes.Layout2qDistance "qiskit.transpiler.passes.Layout2qDistance")
    > *   [`NoiseAdaptiveLayout`](qiskit.transpiler.passes.NoiseAdaptiveLayout "qiskit.transpiler.passes.NoiseAdaptiveLayout")
    > *   [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout")
    > *   [`TrivialLayout`](qiskit.transpiler.passes.TrivialLayout "qiskit.transpiler.passes.TrivialLayout")
    > *   [`BasicSwap`](qiskit.transpiler.passes.BasicSwap "qiskit.transpiler.passes.BasicSwap")
    > *   `BIPMapping`
    > *   `LayoutTransformation`
    > *   [`LookaheadSwap`](qiskit.transpiler.passes.LookaheadSwap "qiskit.transpiler.passes.LookaheadSwap")
    > *   [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap")
    > *   [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap")
    > *   [`CheckMap`](qiskit.transpiler.passes.CheckMap "qiskit.transpiler.passes.CheckMap")

*   The pass manager construction helper function [`generate_embed_passmanager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.common.generate_embed_passmanager "qiskit.transpiler.preset_passmanagers.common.generate_embed_passmanager") will now also accept a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") for it’s sole positional argument (currently named `coupling_map`). This can be used to construct a layout embedding [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") from a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object instead of from a [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap").

*   The following layout and routing transpiler passes from the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") modules have a new keyword argument, `target` which takes in a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object which is used to model the constraints of a target backend. If the `target` keyword argument is specified it will be used as the source of truth for any hardware constraints used in the operation of the transpiler pass. It will supersede any other arguments for specifying hardware constraints, typically those arguments which take a [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap"), [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") or a basis gate list. The list of these passes with the new `target` argument are:

    > *   [`Unroller`](qiskit.transpiler.passes.Unroller "qiskit.transpiler.passes.Unroller")
    > *   `PulseGate`
    > *   [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder")
    > *   [`CommutativeCancellation`](qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation")
    > *   [`EchoRZXWeylDecomposition`](qiskit.transpiler.passes.EchoRZXWeylDecomposition "qiskit.transpiler.passes.EchoRZXWeylDecomposition")
    > *   [`Optimize1qGatesSimpleCommutation`](qiskit.transpiler.passes.Optimize1qGatesSimpleCommutation "qiskit.transpiler.passes.Optimize1qGatesSimpleCommutation")
    > *   [`Optimize1qGates`](qiskit.transpiler.passes.Optimize1qGates "qiskit.transpiler.passes.Optimize1qGates")
    > *   `CheckCXDirection`
    > *   [`ALAPSchedule`](qiskit.transpiler.passes.ALAPSchedule "qiskit.transpiler.passes.ALAPSchedule")
    > *   [`ASAPSchedule`](qiskit.transpiler.passes.ASAPSchedule "qiskit.transpiler.passes.ASAPSchedule")
    > *   [`ALAPScheduleAnalysis`](qiskit.transpiler.passes.ALAPScheduleAnalysis "qiskit.transpiler.passes.ALAPScheduleAnalysis")
    > *   [`ASAPScheduleAnalysis`](qiskit.transpiler.passes.ASAPScheduleAnalysis "qiskit.transpiler.passes.ASAPScheduleAnalysis")
    > *   [`DynamicalDecoupling`](qiskit.transpiler.passes.DynamicalDecoupling "qiskit.transpiler.passes.DynamicalDecoupling")
    > *   [`PadDynamicalDecoupling`](qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling")
    > *   [`TimeUnitConversion`](qiskit.transpiler.passes.TimeUnitConversion "qiskit.transpiler.passes.TimeUnitConversion")

*   The pass manager construction helper function [`generate_scheduling()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.common.generate_scheduling "qiskit.transpiler.preset_passmanagers.common.generate_scheduling") has a new keyword argument `target` which is used to specify a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object to model the constraints of the target backend being compiled for when generating a new [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager"). If specified this new argument will supersede the other argument `inst_map`.

*   The `default` plugin used by the [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass now chooses one and two-qubit unitary synthesis based on the error rates reported in the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target"). In particular, it runs all possible synthesis methods supported by the plugin and chooses the option which will result in the lowest error. For a one-qubit decomposition, it can target Pauli basis (e.g. RZ-RX-RZ or RZ-RY-RZ), generic unitary basis (e.g. U), and a few others. For a two-qubit decomposition, it can target any supercontrolled basis (e.g. CNOT, iSWAP, B) or multiple controlled basis (e.g. CZ, CH, ZZ^.5, ZX^.2, etc.).

*   The interface for [`UnitarySynthesisPlugin`](qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin") has two new optional properties `supports_gate_lengths_by_qubit` and `supports_gate_errors_by_qubit` which when set will add the fields `gate_lengths_by_qubit` and `gate_errors_by_qubit` respectively to the input options to the plugin’s `run()` method. These new fields are an alternative view of the data provided by `gate_lengths` and `gate_errors` but instead have the form: `{(qubits,): [Gate, length]}` (where `Gate` is the instance of [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") for that definition). This allows plugins to reason about working with gates of the same type but but that have different parameters set.

*   Added a new transpiler pass, [`UnrollForLoops`](qiskit.transpiler.passes.UnrollForLoops "qiskit.transpiler.passes.UnrollForLoops"), which is used to unroll any [`ForLoopOp`](qiskit.circuit.ForLoopOp "qiskit.circuit.ForLoopOp") operations in a circuit. This pass unrolls for-loops when possible, if there are no [`ContinueLoopOp`](qiskit.circuit.ContinueLoopOp "qiskit.circuit.ContinueLoopOp") or [`BreakLoopOp`](qiskit.circuit.BreakLoopOp "qiskit.circuit.BreakLoopOp") inside the body block of the loop. For example:

    ```python
    from qiskit.transpiler.passes import UnrollForLoops
    from qiskit import QuantumCircuit

    unroll_pass = UnrollForLoops()

    qc = QuantumCircuit(1)
    # For loop over range 5
    with qc.for_loop(range(5)) as i:
        qc.rx(i, 0)
    # Unroll loop into 5 rx gates
    unroll_pass(qc).draw("mpl")
    ```

    ![\_images/legacy\_release\_notes-1.png](/images/api/qiskit/legacy_release_notes-1.png)

*   Added a new parameter `max_trials` to pass [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") which, when specified, limits the number of layouts discovered and compared when searching for the best layout. This differs from existing parameters `call_limit` and `time_limit` (which are used to limit the number of state visits performed by the VF2 algorithm and the total time spent by pass [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout"), respectively) in that it is used to place an upper bound on the time spent scoring potential layouts, which may be useful for larger devices.

*   The [`CheckMap`](qiskit.transpiler.passes.CheckMap "qiskit.transpiler.passes.CheckMap") transpiler pass has a new keyword argument on its constructor, `property_set_field`. This argument can be used to specify a field in the property set to store the results of the analysis. Previously, it was only possible to store the result in the field `"is_swap_mapped"` (which is the default). This enables you to store the result of multiple instances of the pass in a [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") in different fields.

<span id="release-notes-0-24-0-circuits-features" />

<span id="id26" />

##### Circuits Features

*   Added a new gate class, [`GlobalPhaseGate`](qiskit.circuit.library.GlobalPhaseGate "qiskit.circuit.library.GlobalPhaseGate"), which can be used to add a global phase on the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instance.

*   Added a new attribute, [`layout`](qiskit.circuit.QuantumCircuit#layout "qiskit.circuit.QuantumCircuit.layout"), to the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This attribute is typically populated by [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`PassManager.run()`](qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") (when the [Layout Stage](transpiler#layout-stage) and [Routing Stage](transpiler#routing-stage) are run in the [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager")) and contains a [`TranspileLayout`](qiskit.transpiler.TranspileLayout "qiskit.transpiler.TranspileLayout") which contains the information about the permutation of the input circuit during [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile").

*   Added a new argument, `var_order`, to the [`PhaseOracle`](qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") class’s constructor to enable setting the order in which the variables in the logical expression are being considered. For example:

    ```python
    from qiskit.tools.visualization import plot_histogram
    from qiskit.primitives import Sampler
    from qiskit.circuit.library import PhaseOracle
    from qiskit.algorithms import Grover, AmplificationProblem

    oracle = PhaseOracle('((A & C) | (B & D)) & ~(C & D)', var_order=['A', 'B', 'C', 'D'])
    problem = AmplificationProblem(oracle=oracle, is_good_state=oracle.evaluate_bitstring)
    grover = Grover(sampler=Sampler())
    result = grover.amplify(problem)
    print(result.circuit_results[0])
    ```

*   A new OpenQASM 2 parser is available in [`qiskit.qasm2`](qasm2#module-qiskit.qasm2 "qiskit.qasm2"). This has two entry points: [`qasm2.load()`](qasm2#qiskit.qasm2.load "qiskit.qasm2.load") and [`qasm2.loads()`](qasm2#qiskit.qasm2.loads "qiskit.qasm2.loads"), for reading the source code from a file and from a string, respectively:

    ```python
    import qiskit.qasm2
    program = """
      OPENQASM 2.0;
      include "qelib1.inc";
      qreg q[2];
      h q[0];
      cx q[0], q[1];
    """
    bell = qiskit.qasm2.loads(program)
    ```

    This new parser is approximately 10x faster than the existing ones at [`QuantumCircuit.from_qasm_file()`](qiskit.circuit.QuantumCircuit#from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file") and [`QuantumCircuit.from_qasm_str()`](qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") for large files, and has less overhead on each call as well. The new parser is more extensible, customisable and generally also more type-safe; it will not attempt to output custom Qiskit objects when the definition in the OpenQASM 2 file clashes with the Qiskit object, unlike the current exporter. See the [`qiskit.qasm2`](qasm2#module-qiskit.qasm2 "qiskit.qasm2") module documentation for full details and more examples.

*   Improve the decomposition of multi-controlled Pauli-X and Pauli-Y rotations with [`QuantumCircuit.mcrx()`](qiskit.circuit.QuantumCircuit#mcrx "qiskit.circuit.QuantumCircuit.mcrx") and ``QuantumCircuit.mcry on :math:`n()`` controls to $16n - 40$ CX gates, for $n \geq 4$. This improvement is based on [arXiv:2302.06377](https://arxiv.org/abs/2302.06377).

*   Qiskit now supports the representation of `switch` statements, using the new [`SwitchCaseOp`](qiskit.circuit.SwitchCaseOp "qiskit.circuit.SwitchCaseOp") instruction and the [`QuantumCircuit.switch()`](qiskit.circuit.QuantumCircuit#switch "qiskit.circuit.QuantumCircuit.switch") method. This allows switching on a numeric input (such as a classical register or bit) and executing the circuit that corresponds to the matching value. Multiple values can point to the same circuit, and [`CASE_DEFAULT`](circuit#qiskit.circuit.CASE_DEFAULT "qiskit.circuit.CASE_DEFAULT") can be used as an always-matching label.

    You can also use a builder interface, similar to the other control-flow constructs to build up these switch statements:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister

    qreg = QuantumRegister(2)
    creg = ClassicalRegister(2)
    qc = QuantumCircuit(qreg, creg)

    qc.h([0, 1])
    qc.measure([0, 1], [0, 1])
    with qc.switch(creg) as case:
      with case(0):  # if the register is '00'
        qc.z(0)
      with case(1, 2):  # if the register is '01' or '10'
        qc.cx(0, 1)
      with case(case.DEFAULT):  # the default case
        qc.h(0)
    ```

    The `switch` statement has support throughout the Qiskit compiler stack; you can [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") circuits containing it (if the backend advertises its support for the construct), and it will serialize to QPY.

    The `switch` statement is not currently a feature of OpenQASM 3, but [it is under active design and consideration](https://github.com/openqasm/openqasm/pull/463), which is expected to be adopted in the near future. Qiskit Terra has experimental support for exporting this statement to the OpenQASM 3 syntax proposed in the linked pull request, using an experimental feature flag. To export a `switch` statement circuit (such as the one created above) to OpenQASM 3 using this speculative support, do:

    ```python
    from qiskit import qasm3

    qasm3.dumps(qc, experimental=qasm3.ExperimentalFeatures.SWITCH_CASE_V1)
    ```

<span id="release-notes-0-24-0-algorithms-features" />

<span id="id27" />

##### Algorithms Features

*   Added a new attribute [`eigenvalue_threshold`](qiskit.algorithms.minimum_eigensolvers.AdaptVQE#eigenvalue_threshold "qiskit.algorithms.minimum_eigensolvers.AdaptVQE.eigenvalue_threshold") to the [`AdaptVQE`](qiskit.algorithms.minimum_eigensolvers.AdaptVQE "qiskit.algorithms.minimum_eigensolvers.AdaptVQE") class for configuring a new kind of threshold to terminate the algorithm once the eigenvalue changes less than a set value.

*   Added a new attribute [`gradient_threshold`](qiskit.algorithms.minimum_eigensolvers.AdaptVQE#gradient_threshold "qiskit.algorithms.minimum_eigensolvers.AdaptVQE.gradient_threshold") to the [`AdaptVQE`](qiskit.algorithms.minimum_eigensolvers.AdaptVQE "qiskit.algorithms.minimum_eigensolvers.AdaptVQE") class which will replace the [`threshold`](qiskit.algorithms.minimum_eigensolvers.AdaptVQE#threshold "qiskit.algorithms.minimum_eigensolvers.AdaptVQE.threshold") in the future. This new attribute behaves the same as the existing `threshold` attribute but has a more accurate name, given the introduction of additional threshold options in the class.

*   Added the [`EstimationProblem.has_good_state`](qiskit.algorithms.EstimationProblem#has_good_state "qiskit.algorithms.EstimationProblem.has_good_state") attribute, which allows to check whether an [`EstimationProblem`](qiskit.algorithms.EstimationProblem "qiskit.algorithms.EstimationProblem") has a custom [`EstimationProblem.is_good_state`](qiskit.algorithms.EstimationProblem#is_good_state "qiskit.algorithms.EstimationProblem.is_good_state") or if it is the default. This is useful for checks in amplitude estimators, such as [`AmplitudeEstimation`](qiskit.algorithms.AmplitudeEstimation "qiskit.algorithms.AmplitudeEstimation"), which only support the default implementation.

*   Adds a flag `local` to the [`ComputeUncompute`](qiskit.algorithms.state_fidelities.ComputeUncompute "qiskit.algorithms.state_fidelities.ComputeUncompute") state fidelity class that allows to compute the local fidelity, which is defined by averaging over single-qubit projectors.

*   Gradient classes rearrange the gradient result according to the order of the input parameters now.

    Example:

    ```python
    from qiskit.algorithms.gradients import ParamShiftEstimatorGradient
    from qiskit.circuit import QuantumCircuit, Parameter
    from qiskit.primitives import Estimator
    from qiskit.quantum_info import SparsePauliOp

    # Create a circuit with a parameter
    p = {i: Parameter(f'p{i}') for i in range(3)}
    qc = QuantumCircuit(1)
    qc.rx(p[0], 0)
    qc.ry(p[1], 0)
    qc.rz(p[2], 0)
    op = SparsePauliOp.from_list([("Z", 1)])
    param_values = [0.1, 0.2, 0.3]

    # Create a gradient object
    estimator = Estimator()
    grad = ParamShiftEstimatorGradient(estimator)
    result = grad.run(qc, op, [param_values]).result()
    # would produce a gradient of the form [df/dp0, df/dp1, df/dp2]
    result = grad.run(qc, op, [param_values], parameters=[[p[2], p[0]]]).result()
    # would produce a gradient of the form [df/dp2, df/dp0]
    ```

*   Added support for handling time-dependent Hamiltonians (i.e. singly parametrized operators) to the [`TrotterQRTE`](qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE") class. To facilitate working with this, added the [`num_timesteps`](qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE#num_timesteps "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE.num_timesteps") attribute and a matching keyword argument to the [`TrotterQRTE`](qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE") constructor to control the number of time steps to divide the full evolution.

*   Added support for observable evaluations at every time-step during the execution of the [`TrotterQRTE`](qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE") class. The [`TimeEvolutionProblem.aux_operators`](qiskit.algorithms.TimeEvolutionProblem#aux_operators "qiskit.algorithms.TimeEvolutionProblem.aux_operators") is evaluated at every time step if the `ProductFormula.reps` attribute of the input `product_formula` argument in the constructor is set to 1.

*   Added extensions to the [`VQD`](qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD") algorithm, which allow to pass a list of optimizers and initial points for the different minimization runs. For example, the `k`-th initial point and `k`-th optimizer will be used for the optimization of the `k-1`-th exicted state.

<span id="release-notes-0-24-0-quantum-information-features" />

<span id="id28" />

##### Quantum Information Features

*   Added two new constructor methods, [`Clifford.from_matrix()`](qiskit.quantum_info.Clifford#from_matrix "qiskit.quantum_info.Clifford.from_matrix") and [`Clifford.from_operator()`](qiskit.quantum_info.Clifford#from_operator "qiskit.quantum_info.Clifford.from_operator"), that create a [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") object from its unitary matrix and operator representation respectively.

*   The constructor of [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") now can take any Clifford gate object up to 3 qubits as long it implements a `to_matrix` method, including parameterized gates such as `Rz(pi/2)`, which were not convertible before.

*   Added new utility functions: [`commutator()`](quantum_info#qiskit.quantum_info.commutator "qiskit.quantum_info.commutator"), [`anti_commutator()`](quantum_info#qiskit.quantum_info.anti_commutator "qiskit.quantum_info.anti_commutator"), and [`double_commutator()`](quantum_info#qiskit.quantum_info.double_commutator "qiskit.quantum_info.double_commutator") which are used to compute commutators for any object implementing the `LinearOp` abstract base class such as `QuantumChannel`, [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp"), or [`ScalarOp`](qiskit.quantum_info.ScalarOp "qiskit.quantum_info.ScalarOp").

*   Added the method `StabilizerState.equiv`, that checks if the generating sets of two stabilizer states generate the same stabilizer group. For example, the stabilizer group of the two-qubit Bell state contains the four elements $\{II, XX, -YY, ZZ\}$ and hence can be generated by either $[XX, ZZ]$, $[XX, -YY]$ or $[-YY, ZZ]$.

*   Added a new method, [`partial_transpose()`](qiskit.quantum_info.DensityMatrix#partial_transpose "qiskit.quantum_info.DensityMatrix.partial_transpose"), to the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module’s [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") class. This method is used to compute the partial transposition of a density matrix, which is necessary for detecting entanglement between bipartite quantum systems.

*   Added a method [`qiskit.quantum_info.Operator.apply_permutation()`](qiskit.quantum_info.Operator#apply_permutation "qiskit.quantum_info.Operator.apply_permutation") that pre-composes or post-composes an Operator with a Permutation. This method works for general qudits.

    Here is an example to calculate $P^\dagger.O.P$ which reorders Operator’s bits:

    ```python
    import numpy as np
    from qiskit.quantum_info.operators import Operator

    op = Operator(np.array(range(576)).reshape((24, 24)), input_dims=(2, 3, 4), output_dims=(2, 3, 4))
    perm = [1, 2, 0]
    inv_perm = [2, 0, 1]
    conjugate_op = op.apply_permutation(inv_perm, front=True).apply_permutation(perm, front=False)
    ```

    The conjugate operator has dimensions (4, 2, 3) x (4, 2, 3), which is consistent with permutation moving qutrit to position 0, qubit to position 1, and the 4-qudit to position 2.

*   Natively support the construction of [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") objects with [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") coefficients, without requiring the explicit construction of an object-array. Now the following is supported:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.quantum_info import SparsePauliOp

    x = Parameter("x")
    op = SparsePauliOp(["Z", "X"], coeffs=[1, x])
    ```

*   Added the [`SparsePauliOp.assign_parameters()`](qiskit.quantum_info.SparsePauliOp#assign_parameters "qiskit.quantum_info.SparsePauliOp.assign_parameters") method and [`SparsePauliOp.parameters`](qiskit.quantum_info.SparsePauliOp#parameters "qiskit.quantum_info.SparsePauliOp.parameters") attribute to assign and query unbound parameters inside a [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp"). This function can for example be used as:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.quantum_info import SparsePauliOp

    x = Parameter("x")
    op = SparsePauliOp(["Z", "X"], coeffs=[1, x])

    # free_params will be: ParameterView([x])
    free_params = op.parameters

    # assign the value 2 to the parameter x
    bound = op.assign_parameters([2])
    ```

<span id="release-notes-0-24-0-pulse-features" />

<span id="id29" />

##### Pulse Features

*   Added new [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") classes to the pulse library ([`qiskit.pulse.library`](pulse#module-qiskit.pulse.library "qiskit.pulse.library")) The new pulses in the library are:

    > *   [`Sin`](qiskit.pulse.library.Sin_class.rst#qiskit.pulse.library.Sin "qiskit.pulse.library.Sin")
    > *   [`Cos`](qiskit.pulse.library.Cos_class.rst#qiskit.pulse.library.Cos "qiskit.pulse.library.Cos")
    > *   [`Sawtooth`](qiskit.pulse.library.Sawtooth_class.rst#qiskit.pulse.library.Sawtooth "qiskit.pulse.library.Sawtooth")
    > *   [`Triangle`](qiskit.pulse.library.Triangle_class.rst#qiskit.pulse.library.Triangle "qiskit.pulse.library.Triangle")

    These new classes are instances of `ScalableSymbolicPulse`. With the exception of the `Sawtooth` phase, behavior is identical to that of the corresponding waveform generator function (e.g. [`sin()`](pulse#qiskit.pulse.library.sin "qiskit.pulse.library.sin")). The phase for the `Sawtooth` class is defined such that a phase of $2\pi$ shifts by a full cycle.

*   Added support to QPY ([`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy")) for working with pulse [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") instances with unassigned references, and preserving the data structure for the reference to subroutines. This feature allows users to serialize and deserialize a template pulse program for tasks such as pulse calibration. For example:

    ```python
    from qiskit import pulse
    from qiskit import qpy

    with pulse.build() as schedule:
        pulse.reference("cr45p", "q0", "q1")
        pulse.reference("x", "q0")
        pulse.reference("cr45p", "q0", "q1")

    with open('template_ecr.qpy', 'wb') as fd:
        qpy.dump(schedule, fd)
    ```

*   A new method `CalibrationEntry.user_provided()` has been added to calibration entries. This method can be called to check whether the entry is defined by an end user or backend.

*   Added a new method [`Target.get_calibration()`](qiskit.transpiler.Target#get_calibration "qiskit.transpiler.Target.get_calibration") which provides convenient access to the calibration of an instruction in a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object This method can be called with parameter args and kwargs, and it returns a pulse schedule built with parameters when the calibration is templated with parameters.

<span id="release-notes-0-24-0-providers-features" />

##### Providers Features

*   The [`BackendV2Converter`](qiskit.providers.BackendV2Converter "qiskit.providers.BackendV2Converter") class has a new keyword argument, `filter_faulty`, on its constructor. When this argument is set to `True` the converter class will filter out any qubits or operations listed as non-operational in the [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") payload for the input [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1"). While not extensively used a [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") object supports annotating both qubits and gates as being non-operational. Previously, if a backend had set that flag on any qubits or gates the output `BackendV2` instance and its [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") would include all operations whether they were listed as operational or not. By leveraging the new flag you can filter out these non-operational qubits and gates from the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target"). When the flag is set the output backend will still be listed as the full width (e.g. a 24 qubit backend with 4 qubits listed as not operational will still show it has 24 qubits) but the faulty qubits will not have any operations listed as being supported in the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target").

*   The [`Options`](qiskit.providers.Options "qiskit.providers.options.Options") class now implements the the `Mapping` protocol and `__setitem__` method. This means that [`Options`](qiskit.providers.Options "qiskit.providers.Options") instances now offer the same interface as standard dictionaries, except for the deletion methods (\_\_delitem\_\_, pop, clear). Key assignments are validated by the validators, if any are registered.

<span id="release-notes-0-24-0-visualization-features" />

<span id="id30" />

##### Visualization Features

*   Added a new function, `staged_pass_manager_drawer()`, which is used for visualizing a [`StagedPassManager`](qiskit.transpiler.StagedPassManager "qiskit.transpiler.StagedPassManager") instance. It draws the full pass manager with each stage represented as an outer box.

    For example:

    ```python
    from qiskit.visualization import staged_pass_manager_drawer
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    from qiskit.providers.fake_provider import FakeSherbrooke

    backend = FakeSherbrooke()
    pm = generate_preset_pass_manager(3, backend)
    staged_pass_manager_drawer(pm)
    ```

*   The [`StagedPassManager.draw()`](qiskit.transpiler.StagedPassManager#draw "qiskit.transpiler.StagedPassManager.draw") method has been updated to include visualization of the stages in addition to the overall pass manager. The stages are represented by outer boxes in the visualization. In previous releases the stages were not included in the visualization. For example:

    ```python
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    from qiskit.providers.fake_provider import FakeSherbrooke

    backend = FakeSherbrooke()
    pm = generate_preset_pass_manager(3, backend)
    pm.draw(pm)
    ```

*   Added a new keyword argument, `figsize`, to the [`plot_bloch_multivector()`](qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector") function. This argument can be used to set a size for individual Bloch sphere sub-plots. For example, if there are $n$ qubits and `figsize` is set to `(w, h)`, then the overall figure width is set to $n \cdot w$, while the overall height is set to $h$.

*   Added a new keyword argument, `font_size`, to the [`plot_bloch_multivector()`](qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector") function. This argument can be used to control the font size in the output visualization.

*   Added two new keyword arguments, `title_font_size` and `title_pad`, to the [`plot_bloch_multivector()`](qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector") function. These arguments can be used to control the font size of the overall title and its padding respectively.

<span id="release-notes-0-24-0-upgrade-notes" />

<span id="id31" />

#### Upgrade Notes

*   The minimum supported Rust version (MSRV) has been increased from 1.56.1 to 1.61.0. If you’re are building Qiskit from source you will now need to ensure that you have at least Rust 1.61.0 installed to be able to build Qiskit. This change was made because several upstream dependencies have increased their MSRVs.

*   Removed the usage of primitives with the context manager and the initialization with circuits, (observables only for Estimator), and parameters which was deprecated in the Qiskit Terra 0.22.0 release in October 2022.

*   `PrimitiveJob.submit()` no longer blocks on execution finishing. As a result, [`Sampler.run()`](qiskit.primitives.Sampler#run "qiskit.primitives.Sampler.run"), [`BackendSampler.run()`](qiskit.primitives.BackendSampler#run "qiskit.primitives.BackendSampler.run"), [`Estimator.run()`](qiskit.primitives.Estimator#run "qiskit.primitives.Estimator.run") and [`BaseEstimator.run()`](qiskit.primitives.BaseEstimator#run "qiskit.primitives.BaseEstimator.run") do not block until `PrimitiveJob.result()` method is called.

<span id="release-notes-0-24-0-transpiler-upgrade-notes" />

<span id="id32" />

##### Transpiler Upgrade Notes

*   The maximum number of trials evaluated when searching for the best layout using [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") is now limited in [`level_1_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`level_2_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`level_3_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") to `2 500`, `25 000`, and `250 000`, respectively. Previously, all found possible layouts were evaluated. This change was made to prevent transpilation from hanging during layout scoring for circuits with many connected components on larger devices, which scales combinatorially since each connected component would be evaluated in all possible positions on the device. To perform a full search as before, manually run [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") over the transpiled circuit in strict mode, specifying `0` for `max_trials`.

*   The previously deprecated `condition` attribute of the [`DAGDepNode`](qiskit.dagcircuit.DAGDepNode "qiskit.dagcircuit.DAGDepNode") class has been removed. It was marked as deprecated in the 0.18 release (07-2021). Instead you should use the [`condition`](qiskit.circuit.Instruction#condition "qiskit.circuit.Instruction.condition") attribute of the `op` attribute to access the condition of an operation node. For other node types there is no condition to access.

*   The default value of `metadata` in both [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") has been changed from `None` to `{}` for compatibility with the matching `metadata` attribute of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").

*   The ``CouplingMap.__eq__`()`` method has been updated to check that the edge lists of the underlying graphs contain the same elements. Under the assumption that the underlying graphs are connected, this check additionally ensures that the graphs have the same number of nodes with the same labels. Any code using `CouplingMap() == CouplingMap()` to check object equality should be updated to `CouplingMap() is CouplingMap()`.

*   When running the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function with a [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") based backend or a [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") via the `backend_properties` keyword argument that has any qubits or gates flagged as faulty the function will no longer try to automatically remap the qubits based on this information. The method by which [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") attempted to do this remapping was fundamentally flawed and in most cases of such a backend it would result an internal error being raised. In practice very few backends ever set the fields in [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") to flag a qubit or gate as faulty. If you were relying on [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") to do this re-mapping for you, you will now need to manually do that and pass a mapped input to the `coupling_map` and `backend_properties` arguments which has filtered out the faulty qubits and gates and then manually re-map the output.

*   The result of transpilations for fixed seeds may have changed compared to previous versions of Qiskit Terra. This is because of internal tweaks to the routing algorithm used by [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") and [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout"), which are the default routing and layout passes respectively, to make them significantly faster for large circuits.

<span id="release-notes-0-24-0-circuits-upgrade-notes" />

<span id="id33" />

##### Circuits Upgrade Notes

*   The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") [`metadata`](qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") attribute now always returns a dictionary, and can only be set to a dictionary. Previously, its default value was `None`, and could be manually set to `None` or a dictionary.

<span id="release-notes-0-24-0-algorithms-upgrade-notes" />

##### Algorithms Upgrade Notes

*   The deprecated modules `factorizers` and `linear_solvers`, containing `HHL` and `Shor` have been removed from [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms"). These functionalities were originally deprecated as part of the 0.22.0 release (released on October 13, 2022). You can access the code through the Qiskit Textbook instead: [Linear Solvers (HHL)](https://learn.qiskit.org/course/ch-applications/solving-linear-systems-of-equations-using-hhl-and-its-qiskit-implementation) , [Factorizers (Shor)](https://learn.qiskit.org/course/ch-algorithms/shors-algorithm)

<span id="release-notes-0-24-0-pulse-upgrade-notes" />

##### Pulse Upgrade Notes

*   [`Target.update_from_instruction_schedule_map()`](qiskit.transpiler.Target#update_from_instruction_schedule_map "qiskit.transpiler.Target.update_from_instruction_schedule_map") no longer raises `KeyError` nor `ValueError` when qubits are missing in the target instruction or `inst_name_map` is not provided for the undefined instruction. In the former case, it just ignores the input [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap")'s definition for undefined qubits. In the latter case, a gate mapping is pulled from the standard Qiskit gates and finally, a custom opaque [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") object is defined from the schedule name if no mapping is found.

<span id="release-notes-0-24-0-providers-upgrade-notes" />

##### Providers Upgrade Notes

*   The deprecated `max_credits` argument to [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute"), [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") and all of the `Qobj` configurations (e.g. [`QasmQobjConfig`](qiskit.qobj.QasmQobjConfig "qiskit.qobj.QasmQobjConfig") and [`PulseQobjConfig`](qiskit.qobj.PulseQobjConfig "qiskit.qobj.PulseQobjConfig")) has been removed. This argument dates back to early versions of Qiskit which was tied more closely to the IBM Quantum service offering. At that time the `max_credits` field was part of the “credit system” used by IBM Quantum’s service offering. However, that credit system has not been in use on IBM Quantum backends for nearly three years and also Qiskit is not tied to IBM Quantum’s service offerings anymore (and hasn’t been for a long time). If you were relying on this option in some way for a backend you will need to ensure that your [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") implementation exposes a `max_credits` field in its [`Options`](qiskit.providers.Options "qiskit.providers.Options") object.

*   The [`name`](qiskit.providers.BackendV2#name "qiskit.providers.BackendV2.name") attribute on the [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") based fake backend classes in [`qiskit.providers.fake_provider`](providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") have changed from earlier releases. Previously, the names had a suffix `"_v2"` to differentiate the class from the [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") version. This suffix has been removed as having the suffix could lead to inconsistencies with other snapshotted data used to construct the backend object.

<span id="release-notes-0-24-0-deprecation-notes" />

<span id="id34" />

#### Deprecation Notes

*   The modules [`qiskit.opflow`](opflow#module-qiskit.opflow "qiskit.opflow"), `qiskit.utils.backend_utils`, [`qiskit.utils.mitigation`](utils_mitigation#module-qiskit.utils.mitigation "qiskit.utils.mitigation"), `qiskit.utils.measurement_error_mitigation`, class [`qiskit.utils.QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") and methods `find_regs_by_name()`, `run_circuits()` have been deprecated and will be removed in a future release. Using [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") is superseded by [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler"). See [Opflow Migration](https://qisk.it/opflow_migration). See [QuantumInstance Migration](https://qisk.it/qi_migration).

<span id="release-notes-0-24-0-transpiler-deprecations" />

<span id="id35" />

##### Transpiler Deprecations

*   The transpiler routing pass, `BIPMapping` has been deprecated and will be removed in a future release. It has been replaced by an external plugin package: `qiskit-bip-mapper`. Details for this new package can be found at the package’s github repository:

    [https://github.com/qiskit-community/qiskit-bip-mapper](https://github.com/qiskit-community/qiskit-bip-mapper)

    The pass was made into a separate plugin package for two reasons, first the dependency on CPLEX makes it harder to use and secondly the plugin packge more cleanly integrates with [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile").

*   Misspelled `aquire_alignment` in the class [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") has been replaced by correct spelling `acquire_alignment`. The old constructor argument aquire\_alignment and [`Target.aquire_alignment`](qiskit.transpiler.Target#aquire_alignment "qiskit.transpiler.Target.aquire_alignment") are deprecated and will be removed in a future release. Use [`Target.acquire_alignment`](qiskit.transpiler.Target#acquire_alignment "qiskit.transpiler.Target.acquire_alignment") instead to get and set the alignment constraint value.

<span id="release-notes-0-24-0-circuits-deprecations" />

<span id="id36" />

##### Circuits Deprecations

*   Setting the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") [`metadata`](qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") attribute to `None` has been deprecated and will no longer be supported in a future release. Instead, users should set it to an empty dictionary if they want it to contain no data.

<span id="release-notes-0-24-0-algorithms-deprecations" />

<span id="id37" />

##### Algorithms Deprecations

*   All of the following features are now deprecated, after having been made pending deprecation since 0.22.0. More information is available at [https://qisk.it/algo\_migration](https://qisk.it/algo_migration).

    *   Module `qiskit.algorithms.minimum_eigen_solvers` is deprecated and superseded by [`qiskit.algorithms.minimum_eigensolvers`](qiskit.algorithms.minimum_eigensolvers#module-qiskit.algorithms.minimum_eigensolvers "qiskit.algorithms.minimum_eigensolvers").

    *   Module `qiskit.algorithms.eigen_solvers` is deprecated and superseded by [`qiskit.algorithms.eigensolvers`](qiskit.algorithms.eigensolvers#module-qiskit.algorithms.eigensolvers "qiskit.algorithms.eigensolvers").

    *   Module `qiskit.algorithms.evolvers` is deprecated and superseded by `qiskit.algorithms.time_evolvers`.

    *   Class [`qiskit.algorithms.TrotterQRTE`](qiskit.algorithms.TrotterQRTE "qiskit.algorithms.TrotterQRTE") is deprecated and superseded by [`qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE`](qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE").

    *   Using [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") or [`Backend`](qiskit.providers.Backend "qiskit.providers.Backend") is deprecated and superseded by [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") in the following classes:

        > *   [`Grover`](qiskit.algorithms.Grover "qiskit.algorithms.Grover")
        > *   [`AmplitudeEstimation`](qiskit.algorithms.AmplitudeEstimation "qiskit.algorithms.AmplitudeEstimation")
        > *   [`FasterAmplitudeEstimation`](qiskit.algorithms.FasterAmplitudeEstimation "qiskit.algorithms.FasterAmplitudeEstimation")
        > *   [`IterativePhaseEstimation`](qiskit.algorithms.IterativePhaseEstimation "qiskit.algorithms.IterativePhaseEstimation")
        > *   [`MaximumLikelihoodAmplitudeEstimation`](qiskit.algorithms.MaximumLikelihoodAmplitudeEstimation "qiskit.algorithms.MaximumLikelihoodAmplitudeEstimation")
        > *   [`HamiltonianPhaseEstimation`](qiskit.algorithms.HamiltonianPhaseEstimation "qiskit.algorithms.HamiltonianPhaseEstimation")
        > *   [`IterativePhaseEstimation`](qiskit.algorithms.IterativePhaseEstimation "qiskit.algorithms.IterativePhaseEstimation")
        > *   [`PhaseEstimation`](qiskit.algorithms.PhaseEstimation "qiskit.algorithms.PhaseEstimation")

    *   Using [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") or [`Backend`](qiskit.providers.Backend "qiskit.providers.Backend") or `ExpectationBase` is deprecated and superseded by [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") in the following static method: [`get_fidelity()`](qiskit.algorithms.optimizers.QNSPSA#get_fidelity "qiskit.algorithms.optimizers.QNSPSA.get_fidelity")

    *   Function `eval_observables()` is deprecated and superseded by `estimate_observables()` function.

<span id="release-notes-0-24-0-quantum-information-deprecations" />

##### Quantum Information Deprecations

*   The `PauliTable` and `StabilizerTable` are deprecated and will be removed in a future release. Instead, the [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") should be used. With this change, `table()` has been deprecated so that you should operate directly from `tableau()` without it.

<span id="release-notes-0-24-0-pulse-deprecations" />

<span id="id38" />

##### Pulse Deprecations

*   Assignment of complex values to `ParameterExpression` in any Qiskit Pulse object now raises a `PendingDeprecationWarning`. This will align the Pulse module with other modules where such assignment wasn’t possible to begin with. The typical use case for complex parameters in the module was the SymbolicPulse library. As of Qiskit-Terra 0.23.0 all library pulses were converted from complex amplitude representation to real representation using two floats (amp,angle), as used in the `ScalableSymbolicPulse` class. This eliminated the need for complex parameters. Any use of complex parameters (and particularly custom-built pulses) should be converted in a similar fashion to avoid the use of complex parameters.

<span id="release-notes-0-24-0-bug-fixes" />

<span id="id39" />

#### Bug Fixes

*   The [`AmplitudeEstimation`](qiskit.algorithms.AmplitudeEstimation "qiskit.algorithms.AmplitudeEstimation") class now correctly warns if an [`EstimationProblem`](qiskit.algorithms.EstimationProblem "qiskit.algorithms.EstimationProblem") with a set `is_good_state` property is passed as input, as it is not supported and ignored. Previously, the algorithm would silently ignore this option leading to unexpected results.

*   [`QuantumCircuit.append()`](qiskit.circuit.QuantumCircuit#append "qiskit.circuit.QuantumCircuit.append") will now correctly raise an error if given an incorrect number of classical bits to apply to an operation. Fix [#9385](https://github.com/Qiskit/qiskit-terra/issues/9385).

*   The [`BarrierBeforeFinalMeasurements`](qiskit.transpiler.passes.BarrierBeforeFinalMeasurements "qiskit.transpiler.passes.BarrierBeforeFinalMeasurements") and [`MergeAdjacentBarriers`](qiskit.transpiler.passes.MergeAdjacentBarriers "qiskit.transpiler.passes.MergeAdjacentBarriers") transpiler passes previously had a non-deterministic order of their emitted [`Barrier`](qiskit.circuit.library.Barrier "qiskit.circuit.library.Barrier") instructions. This did not change the semantics of circuits but could, in limited cases where there were non-full-width barriers, cause later stochastic transpiler passes to see a different topological ordering of the circuit and consequently have different outputs for fixed seeds. The passes have been made deterministic to avoid this.

*   The return type of [`run()`](qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") will now always be the same as that of its first argument. Passing a single circuit returns a single circuit, passing a list of circuits, even of length 1, returns a list of circuits. See [#9798](https://github.com/Qiskit/qiskit-terra/issues/9798).

*   Fixed a bug where [`PauliOp.adjoint()`](qiskit.opflow.primitive_ops.PauliOp#adjoint "qiskit.opflow.primitive_ops.PauliOp.adjoint") did not return a correct value for Paulis with complex coefficients, like `PauliOp(Pauli("iX"))`. Fixed [#9433](https://github.com/Qiskit/qiskit-terra/issues/9433).

*   Fixed an issue with the circuit drawer function [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method when displaying instruction parameters that type [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") which would result in an illegible drawing. Fixed [#9908](https://github.com/Qiskit/qiskit-terra/issues/9908)

*   Fixed an issue with the circuit drawer function [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method when using the `text` method and the argument `vertical_compression="low"` where it would use an incorrect character for the top-right corner of boxes used to represent gates in the circuit.

*   Fixed an issue with the [`Gate.control()`](qiskit.circuit.Gate#control "qiskit.circuit.Gate.control") method where it previously would incorrectly handle `str` or `None` input types for the `ctrl_state` argument.

*   Fixed an edge case in the construction of [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") instances; a string with an optional phase and no qubits is now a valid label, making an operator with no qubits (such as `Pauli("-i")`). This was already possible when using the array forms, or empty slices. Fixed [#9720](https://github.com/Qiskit/qiskit-terra/issues/9720).

*   Fixed an issue when using the [`pulse`](pulse#module-qiskit.pulse "qiskit.pulse") macro `measure()` when working with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") based backend. Previously, trying to use `qiskit.pulse.macros.measure()` with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") based backend would have resulted in an error. Fixed [#9488](https://github.com/Qiskit/qiskit-terra/issues/9488)

*   Fixed an issue with the [`marginal_distribution()`](result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution") function where it would incorrectly raise an error when an input counts dictionary was using a numpy integer type instead of the Python int type. The underlying function always would handle the different types correctly, but the input type checking was previously incorrectly raising a `TypeError` in this case.

*   Fixed a bug where [`Parameter.is_real()`](qiskit.circuit.Parameter#is_real "qiskit.circuit.Parameter.is_real") did not return `None` when the parameter is not bound. Fixed [#8619](https://github.com/Qiskit/qiskit-terra/issues/8619).

*   Circuits containing [`C3SXGate`](qiskit.circuit.library.C3SXGate "qiskit.circuit.library.C3SXGate") can now be output and read in again safely from the OpenQASM 2.0 exporter ([`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) and parser ([`QuantumCircuit.from_qasm_str()`](qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str")).

*   Fixed a bug in QPY ([`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy")) where circuits containing gates of class [`MCXGate`](qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate"), [`MCXGrayCode`](qiskit.circuit.library.MCXGrayCode "qiskit.circuit.library.MCXGrayCode"), and `MCXRecursive`, and [`MCXVChain`](qiskit.circuit.library.MCXVChain "qiskit.circuit.library.MCXVChain") would fail to serialize. See [#9390](https://github.com/Qiskit/qiskit-terra/issues/9390).

*   Fixed the transpiler routing passes [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap"), [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap"), [`LookaheadSwap`](qiskit.transpiler.passes.LookaheadSwap "qiskit.transpiler.passes.LookaheadSwap"), and [`BasicSwap`](qiskit.transpiler.passes.BasicSwap "qiskit.transpiler.passes.BasicSwap") so that they consistently raise a [`TranspilerError`](transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.TranspilerError") when their respective `.run()` method is called if the passes were initialized with `coupling_map=None`. Previously, these passes would raise errors in this case but they were all caused by side effects and the specific exception was not predictable. Fixed [#7127](https://github.com/Qiskit/qiskit-terra/issues/7127)

*   Manually setting an item in [`QuantumCircuit.data`](qiskit.circuit.QuantumCircuit#data "qiskit.circuit.QuantumCircuit.data") will now correctly allow the operation to be any object that implements [`Operation`](qiskit.circuit.Operation "qiskit.circuit.Operation"), not just a [`circuit.Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction"). Note that any manual mutation of [`QuantumCircuit.data`](qiskit.circuit.QuantumCircuit#data "qiskit.circuit.QuantumCircuit.data") is discouraged; it is not *usually* any more efficient than building a new circuit object, as checking the invariants surrounding parametrised objects can be surprisingly expensive.

*   Fixed a bug when constructing [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") from within the [`TemplateOptimization`](qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") transpiler pass, which could lead to incorrect optimizations.

*   Fixed a bug in [`TensoredOp.to_matrix()`](qiskit.opflow.list_ops.TensoredOp#to_matrix "qiskit.opflow.list_ops.TensoredOp.to_matrix") where the global coefficient of the operator was multiplied to the final matrix more than once. Now, the global coefficient is correclty applied, independent of the number of tensored operators or states. Fixed [#9398](https://github.com/Qiskit/qiskit-terra/issues/9398).

*   Fixed global-phase handling in the [`UnrollCustomDefinitions`](qiskit.transpiler.passes.UnrollCustomDefinitions "qiskit.transpiler.passes.UnrollCustomDefinitions") transpiler pass if the instruction in question had a global phase, but no instructions in its definition field.

*   Fixed the the type annotations for the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function. The return type is now narrowed correctly depending on whether a single circuit or a list of circuits was passed.

*   Fixed a bug where [`IterativePhaseEstimation`](qiskit.algorithms.IterativePhaseEstimation "qiskit.algorithms.IterativePhaseEstimation") was generating the wrong circuit, causing the algorithm to fail for simple cases. Fixed [#9280](https://github.com/Qiskit/qiskit-terra/issues/9280).

*   A bug has been fixed which had allowed broadcasting when a [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") is initialized from [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli")s or labels. For instance, the code `PauliList(["XXX", "Z"])` now raises a `ValueError` rather than constructing the equivalent of `PauliList(["XXX", "ZZZ"])`.

*   The OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) will no longer emit duplicate definitions for gates that appear in other gates’ definitions. See [#7771](https://github.com/Qiskit/qiskit-terra/issues/7771), [#8086](https://github.com/Qiskit/qiskit-terra/issues/8086), [#8402](https://github.com/Qiskit/qiskit-terra/issues/8402), [#8558](https://github.com/Qiskit/qiskit-terra/issues/8558), and [#9805](https://github.com/Qiskit/qiskit-terra/issues/9805).

*   The OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) will now handle multiple and nested definitions of [`UnitaryGate`](qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate"). See [#4623](https://github.com/Qiskit/qiskit-terra/issues/4623), [#6712](https://github.com/Qiskit/qiskit-terra/issues/6712), [#7772](https://github.com/Qiskit/qiskit-terra/issues/7772), and [#8222](https://github.com/Qiskit/qiskit-terra/issues/8222).

*   The OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) will now output definitions for gates used only in other gates’ definitions in a correct order. See [#7769](https://github.com/Qiskit/qiskit-terra/issues/7769) and [#7773](https://github.com/Qiskit/qiskit-terra/issues/7773).

*   Standard gates defined by Qiskit, such as [`RZXGate`](qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate"), will now have properly parametrised definitions when exported using the OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")). See [#7172](https://github.com/Qiskit/qiskit-terra/issues/7172).

*   Quantum volume circuits ([`QuantumVolume`](qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume")) are now supported by the OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")). See [#6466](https://github.com/Qiskit/qiskit-terra/issues/6466) and [#7051](https://github.com/Qiskit/qiskit-terra/issues/7051).

*   The OpenQASM 2 exporter will now output gates with no known definition with `opaque` statements, rather than failing. See [#5036](https://github.com/Qiskit/qiskit-terra/issues/5036).

*   An issue that prevented `transpile()` from working when passed a list of [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") objects was fixed. Note that passing such a list of coupling maps is deprecated and will not be possible starting with Qiskit Terra 0.25. Fixes [#9885](https://github.com/Qiskit/qiskit-terra/issues/9885).

*   Previous to this release, the `figsize` argument of [`plot_bloch_multivector()`](qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector") was not used by the visualization, making it impossible to change its size (e.g. to shrink it for single-qubit states). This release fixes it by introducing a use for the `figsize` argument.

*   Fixed an issue in [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") with `optimization_level=1` (as well as in the preset pass managers returned by [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") and [`level_1_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager")) where previously if the `routing_method` and `layout_method` arguments were not set and no control flow operations were present in the circuit then in cases where routing was required the [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") transpiler pass would not be run. This was the opposite of the expected behavior because [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") is intended to find a potentially better performing layout after a heuristic layout pass and routing are run. Fixed [#9936](https://github.com/Qiskit/qiskit-terra/issues/9936)

*   Construction of a [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") containing zero-qubit operations will no longer raise an error. These operations impart a global phase on the resulting statevector.

*   Fixed an issue in tranpiler passes for padding delays, which did not respect target’s constraints and inserted delays even for qubits not supporting [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") instruction. [`PadDelay`](qiskit.transpiler.passes.PadDelay "qiskit.transpiler.passes.PadDelay") and [`PadDynamicalDecoupling`](qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling") are fixed so that they do not pad any idle time of qubits such that the target does not support `Delay` instructions for the qubits. Also legacy scheduling passes `ASAPSchedule` and `ALAPSchedule`, which pad delays internally, are fixed in the same way. In addition, `transpile()` is fixed to call `PadDelay` with a `target` object so that it works correctly when called with `scheduling_method` option. Fixed [#9993](https://github.com/Qiskit/qiskit-terra/issues/9993)

*   Fixed the type annotations on the [`QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") method to correctly reflect the change in return type depending on the value of the `inplace` argument.

*   Fixed a performance scaling issue with the [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") passes in the preset pass managers and [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), which would occur when transpiling circuits with many connected components on large devices. Now the transpiler passes set upper bounds on the number of potential layouts that will be evaluated.

*   Fixed an issue in the `state_to_latex()` function where it would potentially produce invalid LaTeX due to unintended coefficient rounding. This could also result in errors when the `state_drawer()` was called. Fixed [#9297](https://github.com/Qiskit/qiskit-terra/issues/9297).

<span id="id41" />

### Aer 0.12.0

No change

<span id="id42" />

### IBM Q Provider 0.20.2

No change

<span id="qiskit-0-42-1" />

## Qiskit 0.42.1

<span id="terra-0-23-3" />

<span id="release-notes-terra-0-23-3" />

### Terra 0.23.3

<span id="release-notes-terra-0-23-3-prelude" />

<span id="id43" />

#### Prelude

Qiskit Terra 0.23.3 is a minor bugfix release.

<span id="release-notes-terra-0-23-3-bug-fixes" />

<span id="id44" />

#### Bug Fixes

*   Fixes a bug in the [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") transformation pass where the score for substitutions was wrongly calculated when the gate errors are zero.

*   The method [`ECRGate.inverse()`](qiskit.circuit.library.ECRGate#inverse "qiskit.circuit.library.ECRGate.inverse") now returns another [`ECRGate`](qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate") instance rather than a custom gate, since it is self inverse.

*   Clip probabilities in the `QuantumState.probabilities()` and `QuantumState.probabilities_dict()` methods to the interval `[0, 1]`. This fixes roundoff errors where probabilities could e.g. be larger than 1, leading to errors in the shot emulation of the sampler. Fixed [#9761](https://github.com/Qiskit/qiskit-terra/issues/9761).

*   Fixed a bug in the [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") where the binary probability bitstrings were truncated to the minimal number of bits required to represent the largest outcome as integer. That means that if e.g. `{"0001": 1.0}` was measured, the result was truncated to `{"1": 1.0}`.

*   Fixed an issue with the [`PassManagerConfig.from_backend()`](qiskit.transpiler.PassManagerConfig#from_backend "qiskit.transpiler.PassManagerConfig.from_backend") constructor method when it was used with a [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") based simulator backend. For some simulator backends which did not populate some optional fields the constructor would error. Fixed [#9265](https://github.com/Qiskit/qiskit-terra/issues/9265) and [#8546](https://github.com/Qiskit/qiskit-terra/issues/8546)

*   Fixed the [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") and [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator") to run successfully with a custom `bound_pass_manager`. Previously, the execution for single circuits with a `bound_pass_manager` would raise a `ValueError` because a list was not returned in one of the steps.

*   The [`GateDirection`](qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection") transpiler pass will no longer reject gates that have been given explicit calibrations, but do not exist in the generic coupling map or target.

*   Fixed an issue with the [`CommutationChecker`](qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") class where it would attempt to internally allocate an array for $2^{n}$ qubits when it only needed an array to represent $n$ qubits. This could cause an excessive amount of memory for wide gates, for example a 4 qubit gate would require 32 gigabytes instead of 2 kilobytes. Fixed [#9197](https://github.com/Qiskit/qiskit-terra/issues/9197)

*   Getting empty calibration from [`InstructionProperties`](qiskit.transpiler.InstructionProperties "qiskit.transpiler.InstructionProperties") raises AttributeError has been fixed. Now it returns `None`.

*   Fixed [`qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") so that it appends `;` after `reset` instruction.

*   Register and parameter names will now be escaped during the OpenQASM 3 export ([`qasm3.dumps()`](qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps")) if they are not already valid identifiers. Fixed [#9658](https://github.com/Qiskit/qiskit-terra/issues/9658).

*   QPY (using [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load")) will now correctly deserialize [`StatePreparation`](qiskit.circuit.library.StatePreparation "qiskit.circuit.library.StatePreparation") instructions. Previously, QPY would error when attempting to load a file containing one. Fixed [#8297](https://github.com/Qiskit/qiskit-terra/issues/8297).

*   Fixed a bug in [`random_circuit()`](circuit#qiskit.circuit.random.random_circuit "qiskit.circuit.random.random_circuit") with 64 or more qubits and `conditional=True`, where the resulting circuit could have an incorrectly typed value in its condition, causing a variety of failures during transpilation or other circuit operations. Fixed [#9649](https://github.com/Qiskit/qiskit-terra/issues/9649).

*   Fixed an issue with the [`OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") class’s methods [`angles()`](qiskit.quantum_info.OneQubitEulerDecomposer#angles "qiskit.quantum_info.OneQubitEulerDecomposer.angles") and [`angles_and_phase()`](qiskit.quantum_info.OneQubitEulerDecomposer#angles_and_phase "qiskit.quantum_info.OneQubitEulerDecomposer.angles_and_phase") would error if the input matrix was of a dtype other than `complex`/`np.cdouble`. In earlier releases this worked fine but this stopped working in Qiskit Terra 0.23.0 when the internals of [`OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") were re-written in Rust. Fixed [#9827](https://github.com/Qiskit/qiskit-terra/issues/9827)

*   The Qiskit gates [`CCZGate`](qiskit.circuit.library.CCZGate "qiskit.circuit.library.CCZGate"), [`CSGate`](qiskit.circuit.library.CSGate "qiskit.circuit.library.CSGate"), [`CSdgGate`](qiskit.circuit.library.CSdgGate "qiskit.circuit.library.CSdgGate") are not defined in `qelib1.inc` and, therefore, when dump as OpenQASM 2.0, their definition should be inserted in the file. Fixes [#9559](https://github.com/Qiskit/qiskit-terra/issues/9559), [#9721](https://github.com/Qiskit/qiskit-terra/issues/9721), and [#9722](https://github.com/Qiskit/qiskit-terra/issues/9722).

<span id="id45" />

### Aer 0.12.0

No change

<span id="id46" />

### IBM Q Provider 0.20.2

No change

<span id="qiskit-0-42-0" />

## Qiskit 0.42.0

<span id="terra-0-23-2" />

### Terra 0.23.2

No change

<span id="id47" />

### Aer 0.12.0

<span id="release-notes-0-12-0-aer-prelude" />

<span id="id48" />

#### Prelude

The Qiskit Aer 0.12.0 release highlights are:

> *   Added a new GPU tensor network simulator based on [cuTensorNet](https://docs.nvidia.com/cuda/cuquantum/cutensornet/index.html)
> *   Added a new `AerDensityMatrix` class to the [`qiskit_aer.quantum_info`](https://qiskit.org/ecosystem/aer/apidocs/aer_quantum_info.html#module-qiskit_aer.quantum_info "(in Qiskit Aer v0.13.0)") module
> *   Greatly improving the runtime performance of the `AerSimulator` and the legacy `QasmSimulator`, `StatevectorSimulator`, and `UnitarySimulator` classes by directly converting the input [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects to an internal C++ representation instead of first serializing the circuit to a [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj"). This improvement will be most noticeable for circuits with a small number of qubits or parameterized circuits using the `parameter_binds` keyword argument.

<span id="release-notes-0-12-0-aer-new-features" />

<span id="id49" />

#### New Features

*   Added a new class method `from_backend_properties()` to the `NoiseModel`. This enables constructing a new `NoiseModel` from a `BackendProperties` object. Similar functionality used to be present in the `NoiseModel.from_backend()` constructor, however it was removed since a `BackendProperties` object alone doesn’t contain sufficient information to create a `NoiseModel` object.

*   Added a new class, `AerDensityMatrix`, to the [`qiskit_aer.quantum_info`](https://qiskit.org/ecosystem/aer/apidocs/aer_quantum_info.html#module-qiskit_aer.quantum_info "(in Qiskit Aer v0.13.0)") module. This class is used to provide the same interface to the upstream [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") class in Qiskit but backed by Qiskit Aer’s simulation.

*   Added a new keyword argument, `abelian_grouping`, to the [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator"). This argument is used to control whether the [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator") will group the input observables into qubit-wise commutable observables which reduces the number of circuit executions required to compute the expectation value and improves the runtime performance of the [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator"). By default this is set to `True`.

*   `AerState` has a new method `initialize_density_matrix()` that sets a density matrix to `AER::QV::DensityMatrix`. This method will be called in `q.i.states.DensityMatrix` to initialize its data with `ndarray`. `initialize_density_matrix()` has a boolean argument that specifies copy or share of `ndarray` data. If the data is shared with C++ and python, the data must not be collected in python while C++ accesses it.

*   The overhead for running simulations with `run()` (for all simulator backend classess) has been greatly reduced. This was accomplished by no longer internally serializing [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects into [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") and instead the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object directly to an internal C++ circuit structure used for simulation. This improvement is most noticeable for simulations of circuts with a small number of qubits or parameterized circuits using the `parameter_binds` keyword argument of `run()`. Note that pulse simualation (via the now deprecated `PulseSimulator`) and DASK-based simulation still use the internal serialization and will not see this performance improvement.

*   Added a new method to the `AerJob`, `circuits()`, which returns a list of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects. This method returns `None` if Qobj is used for simulation.

*   `AerState` and `AerStatevector` now support applying [`Kraus`](qiskit.quantum_info.Kraus "qiskit.quantum_info.Kraus") operators. In `AerStatevector`, one of the Kraus operators is applied randomly to the quantum state based on the error probabilities.

*   Added a new simulation method based on NVIDIA’s [cuTensorNet](https://docs.nvidia.com/cuda/cuquantum/cutensornet/index.html) APIs of cuQuantum SDK. This provides a GPU accelerated general tensor network simulator that can simulate any quantum circuit, by internally translating the circuit into a tensor network to perform the simulation. To use this simulation method, set `method="tensor_network"` and `device="GPU"` when initializing an `AerSimulator` object. For example:

    ```python
    from qiskit_aer import AerSimulator

    tensor_net_sim = AerSimulator(method="tensor_network", device="GPU")
    ```

    This method supports both statevector and density matrix simulations. Noise simulation can also be done with a density matrix single shot simulation if there are not any `SaveStatevector` operations in the circuit.

    This new simulation method also supports parallelization with multiple GPUs and MPI processes by using tensor network slicing technique. However, this type of simulation will likely take a very long time if the input circuits are complicated.

*   The `BLA_VENDOR` environment variable can now be specified to use a different BLAS library when building Qiskit Aer from source. By default if this is not specified OpenBLAS will be used by default. If the BLAS library specified in BLA\_VENDOR\` can not be found then the Cmake build process will stop.

<span id="release-notes-0-12-0-aer-known-issues" />

<span id="id50" />

#### Known Issues

*   This release of Qiskit Aer is not compatible with the Conan 2.X release series. If you are building Qiskit Aer from source manually ensure that you are using a Conan 1.x release. Compatibility with newer versions of Conan will be fixed in a future release. You can refer to issue [#1730](https://github.com/Qiskit/qiskit-aer/issues/1730) for more details.

<span id="release-notes-0-12-0-aer-upgrade-notes" />

<span id="id51" />

#### Upgrade Notes

*   The default behavior of the [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator") primitive will now group the input observable into qubit-wise commutable observables. The grouping reduces the number of circuits to be executed and improves the performance. If you desire the previous behavior you can initialize your [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator") instance with the keyword argument `abelian_grouping=False`.

*   Removed the usage of primitives with the context manager and the initialization with circuits, (observables only for Estimator), and parameters which has been deprecated in the Qiskit Terra 0.22.0 release in October 2022.

*   The behavior of `run()` method has changed when invalid or otherwise unsimulatable [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects are passed as an input. Previously, in these cases the `run()` method would return an `AerJob` whose `result()` method would return a [`Result`](qiskit.result.Result "qiskit.result.Result") with the `ERROR` or `PARTIAL COMPLETED` (depending on whether all the circuit inputs or only some were invalid or not). Starting in this release instead of returning a result object with these statuses an exception will be raised instead. This change was necessary because of the performance improvements by no longer internally serializing the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects to a Qobj before passing it to C++, instead the direct conversion from [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") now errors directly when trying to simulate a circuit Qiskit Aer is unable to execute. If you desire the previous behavior you can build Qiskit Aer in standalone mode and manually serialize your [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects to a JSON representation of the [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") which you then pass to the standalone Aer binary which will retain the previous behavior.

*   A deprecated method `add_nonlocal_quantum_error()` in `NoiseModel` has been removed. No alternative method is available. If you want to add non-local quantum errors, you should write a transpiler pass that inserts your own quantum error into a circuit, and run the pass just before running the circuit on Aer simulator.

*   The `NoiseModel.from_backend()` now has changed not to accept `BackendProperties` object as a `backend` argument. Use newly added `NoiseModel.from_backend_properties()` method instead.

*   A deprecated `standard_gates` argument broadly used in several methods and functions (listed below) across `noise` module has been removed.

    *   `NoiseModel.from_backend()` and `noise.device.basic_device_gate_errors()`
    *   `kraus_error()`, `mixed_unitary_error()`, `pauli_error()` and `depolarizing_error()` in `noise.errors.standard_errors`
    *   `QuantumError.__init__()`

    No alternative means are available because the user should be agnostic about how the simulator represents noises (quantum errors) internally.

*   The constructor of `QuantumError` has now dropped the support of deprecated json-like input for `noise_ops` argument. Use the new styple input for `noise_ops` argument instead, for example,

    ```python
    from qiskit.circuit.library import IGate, XGate
    from qiskit_aer.noise import QuantumError

    error = QuantumError([
        ((IGate(), [1]), 0.9),
        ((XGate(), [1]), 0.1),
    ])

    # json-like input is no longer accepted (the following code fails)
    #  error = QuantumError([
    #      ([{"name": "I", "qubits": [1]}], 0.9),
    #      ([{"name": "X", "qubits": [1]}], 0.1),
    #  ])
    ```

    Also it has dropped deprecated arguments:

    *   `number_of_qubits`: Use `QuantumCircuit` to define `noise_ops` instead.
    *   `atol`: Use `QuantumError.atol` attribute instead.
    *   `standard_gates`: No alternative is available (users should not too much care about internal representation of quantum errors).

*   The deprecated `noise.errors.errorutils` module has been entirely removed and no alternatives are available. All functions in the module were helper functions meant to be used only for implementing functions in `standard_errors` (i.e. they should have been provided as private functions) and no longer used in it.

*   The deprecated `utils.noise_remapper` have been entirely removed and no alternatives are available since the C++ code now automatically truncates and remaps noise models if it truncates circuits.

*   All deprecated functions (`pauli_operators()` and `reset_operators()`) and class (`NoiseTransformer`) in `utils.noise_transformation` module have been removed, and no alternatives are available. They were in fact private functions/class used only for implementing `approximate_quantum_error()` and should not have been public.

*   The previously deprecated `qobj` argument name of the `AerSimulator` and `PulseSimulator` classes’ `run()` method has now been removed. This argument name was deprecated as part of the Qiskit Aer 0.8.0 release and has been by the `circuits` and `schedules` argument name respectively.

*   Aer’s `setup.py` has been updated to no longer attempt to make calls to `pip` to install build requirements, both manually and via the `setup_requires` option in `setuptools.setup`. The preferred way to build Aer is to use a [PEP 517](https://peps.python.org/pep-0517/)-compatible builder such as:

    ```python
    pip install .
    ```

    This change means that a direct call to `setup.py` will no longer work if the build requirements are not installed. This is inline with modern Python packaging guidelines.

<span id="release-notes-0-12-0-aer-deprecation-notes" />

<span id="id52" />

#### Deprecation Notes

*   Support for running Qiskit Aer with Python 3.7 support has been deprecated and will be removed in a future release. This means starting in a future release you will need to upgrade the Python version you’re using to Python 3.8 or above.

*   The `PulseSimulator` backend has been deprecated and will be removed in a future release. If you’re using the `PulseSimulator` backend to perform pulse level simulation, instead you should use the [Qiskit Dynamics](https://qiskit.org/documentation/dynamics/) library instead to perform the simulation. Qiskit Dynamics provides a more flexible and robust pulse level simulation framework than the `PulseSimulator` backend.

*   The `qobj()` method of the `AerJob` class is now deprecated and will be removed in a future release. The use of the qobj format as input to `run()` has been deprecated since qiskit-aer 0.9.0 and in most cases this method would return `None` now anyway. If you’d like to get the input to the `run()` method now you can use the `circuits()` method instead, which will return the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects that were simulated in the job.

*   A `warnings` argument broadly used in several methods and functions across `noise` module has been deprecated in favor of the use of filtering functions in Python’s standard `warnings` library.

<span id="release-notes-0-12-0-aer-bug-fixes" />

<span id="id53" />

#### Bug Fixes

*   Fixed an issue when creating a new `AerStatevector` instance from a `numpy.ndarray` that had non-contiguous memory. Previously, this would result in unexpected behavior (and a potential error) as the `AerStatevector` assumed the input array was contiguous. This has been fixed so that memory layout is checked and the `numpy.ndarray` will be copied internally as a contiguous array before using it.

*   Fixed an issue with the [`Sampler`](qiskit.primitives.Sampler "qiskit.primitives.Sampler") class where it would previously fail if the input [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") contained multiple multiple classical registers. Fixed [#1679](https://github.com/Qiskit/qiskit-aer/issues/1679)

*   The bits count of classical register used on the GPU was not set before calculating free available memory for chunks that causes infinite loop. So this fix set bits count before allocating chunks if batch shots execution is enabled.

*   Fix build errors and test errors when enabling GPU but disabling cuQuantum.

*   Fixed an issue in the matrix product state simulation method (i.e. setting the keyword argument `method="matrix_product_state"` when initializing an `AerSimulator` object) where the simulator would incorrectly sort the qubits prior to performing measurment potentially resulting in an infinite loop. This has been fixed so the measurement of the qubits occurs in the order of the current MPS structure and then sorting afterwards as a post-processing step. This also will likely improve the performance of the simulation method and enable more accurate representation of entangled states. Fixed [#1694](https://github.com/Qiskit/qiskit-aer/issues/1694)

*   The `AerSimulator` backend with methods:

    *   `statevector`
    *   `density_matrix`
    *   `matrix_product_state`
    *   `stabilizer`

    now report that they support `break_loop` and `continue_loop` instructions when used as backends for the Terra [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function. The simulators already did support these, but had just not been reporting it.

<span id="release-notes-ibmq-0-20-2" />

<span id="id54" />

### IBM Q Provider 0.20.2

This release removes the overly restrictive version constraints set in the requirements for the package added in 0.20.1. For the 0.20.1 the only dependency that was intended to have a version cap was the `requests-ntlm` package as its new release was the only dependency which currently has an incompatibility with `qiskit-ibmq-provider`. The other version caps which were added as part of 0.20.1 were causing installation issues in several environments because it made the `qiskit-ibmq-provider` package incompatible with the dependency versions used in other packages.

<span id="qiskit-0-41-1" />

## Qiskit 0.41.1

<span id="release-notes-terra-0-23-2" />

<span id="id55" />

### Terra 0.23.2

<span id="release-notes-terra-0-23-2-prelude" />

<span id="id56" />

#### Prelude

The Qiskit Terra 0.23.2 patch release fixes further bugs identified in the 0.23 series.

<span id="release-notes-terra-0-23-2-bug-fixes" />

<span id="id57" />

#### Bug Fixes

*   Add the following Clifford gates, that already exist in the circuit library, to the [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") class: [`SXGate`](qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate"), [`SXdgGate`](qiskit.circuit.library.SXdgGate "qiskit.circuit.library.SXdgGate"), [`CYGate`](qiskit.circuit.library.CYGate "qiskit.circuit.library.CYGate"), [`DCXGate`](qiskit.circuit.library.DCXGate "qiskit.circuit.library.DCXGate"), [`iSwapGate`](qiskit.circuit.library.iSwapGate "qiskit.circuit.library.iSwapGate") and [`ECRGate`](qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate").

*   Add a decomposition of an [`ECRGate`](qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate") into Clifford gates (up to a global phase) to the standard equivalence library.

*   Fixed an issue with the [`BackendV2Converter`](qiskit.providers.BackendV2Converter "qiskit.providers.BackendV2Converter") class when wrapping a [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1")-based simulator. It would error if either the `online_date` field in the [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") for the simulator was not present or if the simulator backend supported ideal implementations of gates that involve more than 1 qubit. Fixed [#9562](https://github.com/Qiskit/qiskit-terra/issues/9562).

*   Fixed an incorrect return value of the method `BackendV2Converter.meas_map()` that had returned the backend `dt` instead.

*   Fixed missing return values from the methods [`BackendV2Converter.drive_channel()`](qiskit.providers.BackendV2Converter#drive_channel "qiskit.providers.BackendV2Converter.drive_channel"), [`measure_channel()`](qiskit.providers.BackendV2Converter#measure_channel "qiskit.providers.BackendV2Converter.measure_channel"), [`acquire_channel()`](qiskit.providers.BackendV2Converter#acquire_channel "qiskit.providers.BackendV2Converter.acquire_channel") and [`control_channel()`](qiskit.providers.BackendV2Converter#control_channel "qiskit.providers.BackendV2Converter.control_channel").

*   The deprecated [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") and [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") properties [`register`](qiskit.circuit.Qubit#register "qiskit.circuit.Qubit.register") and [`index`](qiskit.circuit.Qubit#index "qiskit.circuit.Qubit.index") will now be correctly round-tripped by QPY ([`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy")) in all valid usages of [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister"). In earlier releases in the Terra 0.23 series, this information would be lost. In versions before 0.23.0, this information was partially reconstructed but could be incorrect or produce invalid circuits for certain register configurations.

    The correct way to retrieve the index of a bit within a circuit, and any registers in that circuit the bit is contained within is to call [`QuantumCircuit.find_bit()`](qiskit.circuit.QuantumCircuit#find_bit "qiskit.circuit.QuantumCircuit.find_bit"). This method will return the correct information in all versions of Terra since its addition in version 0.19.

*   Fixed an issue with the [`InstructionScheduleMap.has_custom_gate()`](qiskit.pulse.InstructionScheduleMap#has_custom_gate "qiskit.pulse.InstructionScheduleMap.has_custom_gate") method, where it would always return `True` when the [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") object was created by [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target"). Fixed [#9595](https://github.com/Qiskit/qiskit-terra/issues/9595).

*   Fixed a bug in the NumPy-based eigensolvers ([`NumPyMinimumEigensolver`](qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolver "qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolver") / [`NumPyEigensolver`](qiskit.algorithms.eigensolvers.NumPyEigensolver "qiskit.algorithms.eigensolvers.NumPyEigensolver")) and in the SciPy-based time evolvers ([`SciPyRealEvolver`](qiskit.algorithms.SciPyRealEvolver "qiskit.algorithms.SciPyRealEvolver") / [`SciPyImaginaryEvolver`](qiskit.algorithms.SciPyImaginaryEvolver "qiskit.algorithms.SciPyImaginaryEvolver")), where operators that support conversion to sparse matrices, such as [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp"), were converted to dense matrices anyways.

*   Fixed a bug in [`generate_basic_approximations()`](synthesis#qiskit.synthesis.generate_basic_approximations "qiskit.synthesis.generate_basic_approximations") where the inverse of the [`SdgGate`](qiskit.circuit.library.SdgGate "qiskit.circuit.library.SdgGate") was not correctly recognized as [`SGate`](qiskit.circuit.library.SGate "qiskit.circuit.library.SGate"). Fixed [#9585](https://github.com/Qiskit/qiskit-terra/issues/9585).

*   Fixed a bug in the [`VQD`](qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD") algorithm where the energy evaluation function could not process batches of parameters, making it incompatible with optimizers with `max_evals_grouped>1`. Fixed [#9500](https://github.com/Qiskit/qiskit-terra/issues/9500).

*   Fixed bug in [`QNSPSA`](qiskit.algorithms.optimizers.QNSPSA "qiskit.algorithms.optimizers.QNSPSA") which raised a type error when the computed fidelities happened to be of type `int` but the perturbation was of type `float`.

<span id="aer-0-11-2" />

### Aer 0.11.2

No change

<span id="ibm-q-provider-0-20-1" />

<span id="release-notes-ibmq-0-20-1" />

### IBM Q Provider 0.20.1

Since `qiskit-ibmq-provider` is now deprecated, the dependencies have been bumped and fixed to the latest working versions. There was an issue with the latest version of the `requests-ntlm` package which caused some end to end tests to fail.

<span id="qiskit-0-41-0" />

## Qiskit 0.41.0

<span id="terra-0-23-1" />

### Terra 0.23.1

<span id="release-notes-0-23-1-prelude" />

<span id="id58" />

#### Prelude

Qiskit Terra 0.23.1 is a small patch release to fix bugs identified in Qiskit Terra 0.23.0

<span id="release-notes-0-23-1-bug-fixes" />

<span id="id59" />

#### Bug Fixes

*   An edge case of pickle [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") with non-picklable iterable `arguments` is now fixed. Previously, using an unpickleable iterable as the `arguments` parameter to [`InstructionScheduleMap.add()`](qiskit.pulse.InstructionScheduleMap#add "qiskit.pulse.InstructionScheduleMap.add") (such as `dict_keys`) could cause parallel calls to [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") to fail. These arguments will now correctly be normalized internally to `list`.

*   Fixed a performance bug in [`ReverseEstimatorGradient`](qiskit.algorithms.gradients.ReverseEstimatorGradient "qiskit.algorithms.gradients.ReverseEstimatorGradient") where the calculation did a large amount of unnecessary copies if the gradient was only calculated for a subset of parameters, or in a circuit with many unparameterized gates.

*   Fixed a bad deprecation of [`Register.name_format`](qiskit.circuit.Register#name_format "qiskit.circuit.Register.name_format") which had made the class attribute available only from instances and not the class. When trying to send dynamic-circuits jobs to hardware backends, this would frequently cause the error:

    ```python
    AttributeError: 'property' object has no attribute 'match'
    ```

    Fixed [#9493](https://github.com/Qiskit/qiskit-terra/issues/9493).

<span id="id60" />

### Aer 0.11.2

No change

<span id="ibm-q-provider-0-20-0" />

<span id="release-notes-ibmq-0-20-0" />

### IBM Q Provider 0.20.0

<span id="id61" />

#### Prelude

This release of the `qiskit-ibmq-provider` package marks the package as deprecated and will be retired and archived in the future. The functionality in `qiskit-ibmq-provider` has been supersceded by 3 packages `qiskit-ibm-provider`, `qiskit-ibm-runtime`, and `qiskit-ibm-experiment` which offer different subsets of functionality that `qiskit-ibmq-provider` contained. You can refer to the table here:

[https://github.com/Qiskit/qiskit-ibmq-provider#migration-guides](https://github.com/Qiskit/qiskit-ibmq-provider#migration-guides)

for links to the migration guides for moving from `qiskit-ibmq-provider` to its replacmeent packages.

<span id="release-notes-ibmq-0-20-0-deprecation-notes" />

<span id="id62" />

#### Deprecation Notes

*   As of version 0.20.0, `qiskit-ibmq-provider` has been deprecated with its support ending and eventual archival being no sooner than 3 months from that date. The function provided by qiskit-ibmq-provider is not going away rather it has being split out to separate repositories. Please see [https://github.com/Qiskit/qiskit-ibmq-provider#migration-guides](https://github.com/Qiskit/qiskit-ibmq-provider#migration-guides).

<span id="release-notes-ibmq-0-20-0-bug-fixes" />

<span id="id63" />

#### Bug Fixes

*   In the upcoming terra release there will be a release candidate tagged prior to the final release. However changing the version string for the package is blocked on the qiskit-ibmq-provider right now because it is trying to parse the version and is assuming there will be no prelease suffix on the version string (see [#8200](https://github.com/Qiskit/qiskit-terra/pull/8200) for the details). PR [#1135](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1135) fixes this version parsing to use the regex from the pypa/packaging project which handles all the PEP440 package versioning include pre-release suffixes. This will enable terra to release an 0.21.0rc1 tag without breaking the qiskit-ibmq-provider.

*   PR [#1129](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1129) updates `least_busy()` method to no longer support BaseBackend as a valid input or output type since it has been long deprecated in qiskit-terra and has recently been removed.

*   `threading.currentThread` and `notifyAll` were deprecated in Python 3.10 (October 2021) and will be removed in Python 3.12 (October 2023). PR [#1133](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1133) replaces them with `threading.current_thread`, `notify_all` added in Python 2.6 (October 2008).

*   Calls to run a quantum circuit with `dynamic=True` now raise an error that asks the user to install the new `qiskit-ibm-provider`.

<span id="qiskit-0-40-0" />

## Qiskit 0.40.0

This release officially deprecates the Qiskit IBMQ provider project as part of the Qiskit metapackage. This means that in a future release, `pip install qiskit` will no longer automatically include `qiskit-ibmq-provider`. If you’re currently installing or listing `qiskit` as a dependency to get `qiskit-ibmq-provider`, you should update to explicitly include `qiskit-ibmq-provider` as well. This is being done as the Qiskit project moves towards a model where the `qiskit` package only contains the common core functionality for building and compiling quantum circuits, programs, and applications. Packages that build on that core or link Qiskit to hardware or simulators will be installable as separate packages.

<span id="terra-0-23-0" />

### Terra 0.23.0

<span id="release-notes-0-23-0-prelude" />

<span id="id64" />

#### Prelude

Qiskit Terra 0.23.0 is a major feature release that includes a multitude of new features and bugfixes. The highlights for this release are:

> *   Support for importing OpenQASM 3 programs and creating [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects from the input program via two new functions [`qiskit.qasm3.load()`](qasm3#qiskit.qasm3.load "qiskit.qasm3.load") and [`qiskit.qasm3.loads()`](qasm3#qiskit.qasm3.loads "qiskit.qasm3.loads").
>
> *   Improvements to the library of synthesis algorithms included in Qiskit. This includes the following new synthesis functions:
>
>     > *   Clifford Synthesis
>     >
>     >     *   [`synth_clifford_layers()`](synthesis#qiskit.synthesis.synth_clifford_layers "qiskit.synthesis.synth_clifford_layers")
>     >     *   [`synth_clifford_greedy()`](synthesis#qiskit.synthesis.synth_clifford_greedy "qiskit.synthesis.synth_clifford_greedy")
>     >
>     > *   Linear Function Synthesis:
>     >
>     >     *   [`synth_cnot_depth_line_kms()`](synthesis#qiskit.synthesis.synth_cnot_depth_line_kms "qiskit.synthesis.synth_cnot_depth_line_kms")
>     >     *   [`synth_cnot_count_full_pmh()`](synthesis#qiskit.synthesis.synth_cnot_count_full_pmh "qiskit.synthesis.synth_cnot_count_full_pmh")
>     >
>     > *   Permutation Synthesis:
>     >
>     >     *   [`synth_permutation_basic()`](synthesis#qiskit.synthesis.synth_permutation_basic "qiskit.synthesis.synth_permutation_basic")
>     >     *   [`synth_permutation_acg()`](synthesis#qiskit.synthesis.synth_permutation_acg "qiskit.synthesis.synth_permutation_acg")
>     >     *   [`synth_permutation_depth_lnn_kms()`](synthesis#qiskit.synthesis.synth_permutation_depth_lnn_kms "qiskit.synthesis.synth_permutation_depth_lnn_kms")
>     >
>     > *   [`SolovayKitaevDecomposition`](qiskit.synthesis.SolovayKitaevDecomposition "qiskit.synthesis.SolovayKitaevDecomposition") detailed in: [https://arxiv.org/abs/quant-ph/0505030](https://arxiv.org/abs/quant-ph/0505030)
>     >
>     > *   New plugins for [`HighLevelSynthesis`](qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis"):
>     >
>     >     *   `ACGSynthesisPermutation`
>     >     *   `KMSSynthesisPermutation`
>     >     *   `BasicSynthesisPermutation`
>     >
>     > *   New plugin for [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis")
>     >
>     >     *   [`SolovayKitaevSynthesis`](qiskit.transpiler.passes.SolovayKitaevSynthesis "qiskit.transpiler.passes.SolovayKitaevSynthesis")
>
> *   Performance improvements to [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout"). The pass is now primarily written in Rust which can lead to a runtime improvement, however the bigger improvement is in the quality of the output (on average, fewer [`SwapGate`](qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") gates introduced by [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap")). For example, running [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") on Bernstein Vazirani circuits targeting the [`FakeSherbrooke`](qiskit.providers.fake_provider.FakeSherbrooke "qiskit.providers.fake_provider.FakeSherbrooke") backend yields the following results:
>
>     ![\_images/legacy\_release\_notes-2.png](/images/api/qiskit/legacy_release_notes-2.png)

This release also deprecates support for running with Python 3.7. A `DeprecationWarning` will now be emitted if you run Qiskit with Python 3.7. Support for Python 3.7 will be removed as part of the 0.25.0 release (currently planned for release in July 2023), at which point you will need Python 3.8 or newer to use Qiskit.

<span id="id65" />

#### New Features

*   The pulses in [`qiskit.pulse.library`](pulse#module-qiskit.pulse.library "qiskit.pulse.library")

    > *   [`Gaussian`](qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian")
    > *   [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare")
    > *   [`Drag`](qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag")
    > *   [`Constant`](qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant")

    can be initialized with new parameter `angle`, such that two float parameters could be provided: `amp` and `angle`. Initialization with complex `amp` is still supported.

*   The [`AdaptVQE`](qiskit.algorithms.minimum_eigensolvers.AdaptVQE "qiskit.algorithms.minimum_eigensolvers.AdaptVQE") class has a new attribute, [`eigenvalue_history`](qiskit.algorithms.minimum_eigensolvers.AdaptVQEResult#eigenvalue_history "qiskit.algorithms.minimum_eigensolvers.AdaptVQEResult.eigenvalue_history"), which is used to track the lowest achieved energy per iteration of the AdaptVQE. For example:

    ```python
    from qiskit.algorithms.minimum_eigensolvers import VQE
    from qiskit.algorithms.minimum_eigensolvers.adapt_vqe import AdaptVQE
    from qiskit.algorithms.optimizers import SLSQP
    from qiskit.circuit.library import EvolvedOperatorAnsatz
    from qiskit.opflow import PauliSumOp
    from qiskit.primitives import Estimator
    from qiskit.quantum_info import SparsePauliOp
    from qiskit.utils import algorithm_globals

    excitation_pool = [
        PauliSumOp(
            SparsePauliOp(["IIIY", "IIZY"], coeffs=[0.5 + 0.0j, -0.5 + 0.0j]), coeff=1.0
        ),
        PauliSumOp(
            SparsePauliOp(["ZYII", "IYZI"], coeffs=[-0.5 + 0.0j, 0.5 + 0.0j]), coeff=1.0
        ),
        PauliSumOp(
            SparsePauliOp(
                ["ZXZY", "IXIY", "IYIX", "ZYZX", "IYZX", "ZYIX", "ZXIY", "IXZY"],
                coeffs=[
                    -0.125 + 0.0j,
                    0.125 + 0.0j,
                    -0.125 + 0.0j,
                    0.125 + 0.0j,
                    0.125 + 0.0j,
                    -0.125 + 0.0j,
                    0.125 + 0.0j,
                    -0.125 + 0.0j,
                ],
            ),
            coeff=1.0,
        ),
    ]
    ansatz = EvolvedOperatorAnsatz(excitation_pool, initial_state=self.initial_state)
    optimizer = SLSQP()
    h2_op = PauliSumOp.from_list(
        [
            ("IIII", -0.8105479805373266),
            ("ZZII", -0.2257534922240251),
            ("IIZI", +0.12091263261776641),
            ("ZIZI", +0.12091263261776641),
            ("IZZI", +0.17218393261915543),
            ("IIIZ", +0.17218393261915546),
            ("IZIZ", +0.1661454325638243),
            ("ZZIZ", +0.1661454325638243),
            ("IIZZ", -0.2257534922240251),
            ("IZZZ", +0.16892753870087926),
            ("ZZZZ", +0.17464343068300464),
            ("IXIX", +0.04523279994605788),
            ("ZXIX", +0.04523279994605788),
            ("IXZX", -0.04523279994605788),
            ("ZXZX", -0.04523279994605788),
        ]
    )

    algorithm_globals.random_seed = 42
    calc = AdaptVQE(VQE(Estimator(), ansatz, self.optimizer))
    res = calc.compute_minimum_eigenvalue(operator=h2_op)

    print(calc.eigenvalue_history)
    ```

    the returned value of `calc.history` should be roughly `[-1.85727503]` as there is a single iteration.

*   The runtime logging when running the [`AdaptVQE`](qiskit.algorithms.minimum_eigensolvers.AdaptVQE "qiskit.algorithms.minimum_eigensolvers.AdaptVQE") has been improved. When running the class now, `DEBUG` and `INFO` level log messages will be emitted as the class runs.

*   Added a new transpiler pass, `CollectAndCollapse`, to collect and to consolidate blocks of nodes in a circuit. This pass is designed to be a general base class for combined block collection and consolidation. To be completely general, the work of collecting and collapsing the blocks is done via functions provided during instantiating the pass. For example, the [`CollectLinearFunctions`](qiskit.transpiler.passes.CollectLinearFunctions "qiskit.transpiler.passes.CollectLinearFunctions") has been updated to inherit from `CollectAndCollapse` and collects blocks of [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") and [`SwapGate`](qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") gates, and replaces each block with a [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction"). The [`CollectCliffords`](qiskit.transpiler.passes.CollectCliffords "qiskit.transpiler.passes.CollectCliffords") which is also now based on `CollectAndCollapse`, collects blocks of “Clifford” gates and replaces each block with a [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford").

    The interface also supports the option `do_commutative_analysis`, which allows to exploit commutativity between gates in order to collect larger blocks of nodes. For example, collecting blocks of CX gates in the following circuit:

    ```python
    qc = QuantumCircuit(2)
    qc.cx(0, 1)
    qc.z(0)
    qc.cx(1, 0)
    ```

    using `do_commutative_analysis` enables consolidating the two CX gates, as the first CX gate and the Z gate commute.

*   Added a new class `BlockCollector` that implements various collection strategies, and a new class `BlockCollapser` that implements various collapsing strategies. Currently `BlockCollector` includes the strategy to greedily collect all gates adhering to a given filter function (for example, collecting all Clifford gates), and `BlockCollapser` includes the strategy to consolidate all gates in a block to a single object (or example, a block of Clifford gates can be consolidated to a single [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford")).

*   Added a new [`CollectCliffords`](qiskit.transpiler.passes.CollectCliffords "qiskit.transpiler.passes.CollectCliffords") transpiler pass that collects blocks of Clifford gates and consolidates these blocks into [`qiskit.quantum_info.Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") objects. This pass inherits from `CollectAndCollapse` and in particular supports the option `do_commutative_analysis`. It also supports two additional options `split_blocks` and `min_block_size`. See the release notes for `CollectAndCollapse` and [`CollectLinearFunctions`](qiskit.transpiler.passes.CollectLinearFunctions "qiskit.transpiler.passes.CollectLinearFunctions") for additional details.

*   The [`CollectLinearFunctions`](qiskit.transpiler.passes.CollectLinearFunctions "qiskit.transpiler.passes.CollectLinearFunctions") transpiler pass has several new arguments on its constructor:

    > *   `do_commutative_analysis`: enables exploiting commutativity between gates in order to collect larger blocks of nodes.
    >
    > *   `split_blocks`: enables spliting collected blocks into sub-blocks over disjoint subsets of qubits. For example, in the following circuit:
    >
    >     ```python
    >     qc = QuantumCircuit(4)
    >     qc.cx(0, 2)
    >     qc.cx(1, 3)
    >     qc.cx(2, 0)
    >     qc.cx(3, 1)
    >     qc.cx(1, 3)
    >     ```
    >
    >     the single block of CX gates over qubits `{0, 1, 2, 3}` can be split into two disjoint sub-blocks, one over qubits `{0, 2}` and the other over qubits `{1, 3}`.
    >
    > *   `min_block_size`: allows to specify the minimum size of the block to be consolidated, blocks with fewer gates will not be modified. For example, in the following circuit:
    >
    >     ```python
    >     qc = QuantumCircuit(4)
    >     qc.cx(1, 2)
    >     qc.cx(2, 1)
    >     ```
    >
    >     the two CX gates will be consolidated when `min_block_size` is 1 or 2, and will remain unchanged when `min_block_size` is 3 or larger.

*   Added a depth-efficient synthesis algorithm [`synth_cnot_depth_line_kms()`](synthesis#qiskit.synthesis.synth_cnot_depth_line_kms "qiskit.synthesis.synth_cnot_depth_line_kms") for linear reversible circuits [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") over the linear nearest-neighbor architecture, following the paper: [https://arxiv.org/abs/quant-ph/0701194](https://arxiv.org/abs/quant-ph/0701194).

*   The [`DAGCircuit.replace_block_with_op()`](qiskit.dagcircuit.DAGCircuit#replace_block_with_op "qiskit.dagcircuit.DAGCircuit.replace_block_with_op") method will now return the new [`DAGOpNode`](qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode") that is created when the block is replaced. Previously, calling this method would not return anything.

*   Added a depth-efficient synthesis algorithm [`synth_permutation_depth_lnn_kms()`](synthesis#qiskit.synthesis.synth_permutation_depth_lnn_kms "qiskit.synthesis.synth_permutation_depth_lnn_kms") for [`Permutation`](qiskit.circuit.library.Permutation "qiskit.circuit.library.Permutation") over the linear nearest-neighbor architecture, following the paper: [https://arxiv.org/abs/quant-ph/0701194](https://arxiv.org/abs/quant-ph/0701194)

*   Added a new class [`PermutationGate`](qiskit.circuit.library.PermutationGate "qiskit.circuit.library.PermutationGate") for representing permutation logic as a circuit element. Unlike the existing [`Permutation`](qiskit.circuit.library.Permutation "qiskit.circuit.library.Permutation") circuit library element which had a static definition this new class avoids synthesizing a permutation circuit when it is declared. This delays the actual synthesis to the transpiler. It also allows enables using several different algorithms for synthesizing permutations, which are available as high-level-synthesis permutation plugins.

    Another key feature of the [`PermutationGate`](qiskit.circuit.library.PermutationGate "qiskit.circuit.library.PermutationGate") is that implements the `__array__` interface for efficiently returning a unitary matrix for a permutation.

*   Added several high-level-synthesis plugins for synthesizing permutations:

    > *   `BasicSynthesisPermutation`: applies to fully-connected architectures and is based on sorting. This is the previously used algorithm for constructing quantum circuits for permutations.
    > *   `ACGSynthesisPermutation`: applies to fully-connected architectures but is based on the Alon, Chung, Graham method. It synthesizes any permutation in depth 2 (measured in terms of SWAPs).
    > *   `KMSSynthesisPermutation`: applies to linear nearest-neighbor architectures and corresponds to the recently added Kutin, Moulton, Smithline method.

    For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import PermutationGate
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig, HighLevelSynthesis
    from qiskit.transpiler.passes.synthesis.plugin import HighLevelSynthesisPluginManager

    # Create a permutation and add it to a quantum circuit
    perm = PermutationGate([4, 6, 3, 7, 1, 2, 0, 5])
    qc = QuantumCircuit(8)
    qc.append(perm, range(8))

    # Print available plugin names for synthesizing permutations
    # Returns ['acg', 'basic', 'default', 'kms']
    print(HighLevelSynthesisPluginManager().method_names("permutation"))

    # Default plugin for permutations
    # Returns a quantum circuit with size 6 and depth 3
    qct = PassManager(HighLevelSynthesis()).run(qc)
    print(f"Default: {qct.size() = }, {qct.depth() = }")

    # KMSSynthesisPermutation plugin for permutations
    # Returns a quantum circuit with size 18 and depth 6
    # but adhering to the linear nearest-neighbor architecture.
    qct = PassManager(HighLevelSynthesis(HLSConfig(permutation=[("kms", {})]))).run(qc)
    print(f"kms: {qct.size() = }, {qct.depth() = }")

    # BasicSynthesisPermutation plugin for permutations
    # Returns a quantum circuit with size 6 and depth 3
    qct = PassManager(HighLevelSynthesis(HLSConfig(permutation=[("basic", {})]))).run(qc)
    print(f"basic: {qct.size() = }, {qct.depth() = }")

    # ACGSynthesisPermutation plugin for permutations
    # Returns a quantum circuit with size 6 and depth 2
    qct = PassManager(HighLevelSynthesis(HLSConfig(permutation=[("acg", {})]))).run(qc)
    print(f"acg: {qct.size() = }, {qct.depth() = }")
    ```

*   Added new classes for Quantum Fisher Information (QFI) and Quantum Geometric Tensor (QGT) algorithms using [`primitives`](primitives#module-qiskit.primitives "qiskit.primitives"), [`qiskit.algorithms.gradients.QFI`](qiskit.algorithms.gradients.QFI "qiskit.algorithms.gradients.QFI") and [`qiskit.algorithms.gradients.LinCombQGT`](qiskit.algorithms.gradients.LinCombQGT "qiskit.algorithms.gradients.LinCombQGT"), to the gradients module: [`qiskit.algorithms.gradients`](qiskit.algorithms.gradients#module-qiskit.algorithms.gradients "qiskit.algorithms.gradients"). For example:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter
    from qiskit.algorithms.gradients import LinCombQGT, QFI

    estimator = Estimator()
    a, b = Parameter("a"), Parameter("b")
    qc = QuantumCircuit(1)
    qc.h(0)
    qc.rz(a, 0)
    qc.rx(b, 0)

    parameter_value = [[np.pi / 4, 0]]

    qgt = LinCombQGT(estimator)
    qgt_result = qgt.run([qc], parameter_value).result()

    qfi = QFI(qgt)
    qfi_result = qfi.run([qc], parameter_value).result()
    ```

*   Added a new keyword argument, `derivative_type`, to the constructor for the [`LinCombEstimatorGradient`](qiskit.algorithms.gradients.LinCombEstimatorGradient "qiskit.algorithms.gradients.LinCombEstimatorGradient"). This argument takes a `DerivativeType` enum that enables specifying to compute only the real or imaginary parts of the gradient.

*   Added a new option `circuit_reverse_bits` to the user config file. This allows users to set a boolean for their preferred default behavior of the `reverse_bits` argument of the circuit drawers [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") and [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer"). For example, adding a section to the user config file in the default location `~/.qiskit/settings.conf` with:

    ```python
    [default]
    circuit_reverse_bits = True
    ```

    will change the default to display the bits in reverse order.

*   Added a new class [`Z2Symmetries`](qiskit.quantum_info.Z2Symmetries "qiskit.quantum_info.Z2Symmetries") to [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") which is used to identify any $Z_2$ symmetries from an input [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp").

*   Added a new pulse directive [`TimeBlockade`](qiskit.pulse.instructions.TimeBlockade "qiskit.pulse.instructions.TimeBlockade"). This directive behaves almost identically to the delay instruction, but will be removed before execution. This directive is intended to be used internally within the pulse builder and helps [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") represent instructions with absolute time intervals. This allows the pulse builder to convert `Schedule` into `ScheduleBlock`, rather than wrapping with [`Call`](qiskit.pulse.instructions.Call "qiskit.pulse.instructions.Call") instructions.

*   Added primitive-enabled algorithms for Variational Quantum Time Evolution that implement the interface for Quantum Time Evolution. The [`qiskit.algorithms.VarQRTE`](qiskit.algorithms.VarQRTE "qiskit.algorithms.VarQRTE") class is used for real and the [`qiskit.algorithms.VarQITE`](qiskit.algorithms.VarQITE "qiskit.algorithms.VarQITE") class is used for imaginary quantum time evolution according to a variational principle passed.

    Each algorithm accepts a variational principle which implements the [`ImaginaryVariationalPrinciple`](qiskit.algorithms.time_evolvers.variational.ImaginaryVariationalPrinciple "qiskit.algorithms.time_evolvers.variational.ImaginaryVariationalPrinciple") abstract interface. The following implementations are included:

    > *   [`ImaginaryMcLachlanPrinciple`](qiskit.algorithms.time_evolvers.variational.ImaginaryMcLachlanPrinciple "qiskit.algorithms.time_evolvers.variational.ImaginaryMcLachlanPrinciple")
    > *   [`RealMcLachlanPrinciple`](qiskit.algorithms.time_evolvers.variational.RealMcLachlanPrinciple "qiskit.algorithms.time_evolvers.variational.RealMcLachlanPrinciple")

    For example:

    ```python
    from qiskit.algorithms import TimeEvolutionProblem, VarQITE
    from qiskit.algorithms.time_evolvers.variational import ImaginaryMcLachlanPrinciple
    from qiskit.circuit.library import EfficientSU2
    from qiskit.quantum_info import SparsePauliOp
    import numpy as np

    observable = SparsePauliOp.from_list(
        [
            ("II", 0.2252),
            ("ZZ", 0.5716),
            ("IZ", 0.3435),
            ("ZI", -0.4347),
            ("YY", 0.091),
            ("XX", 0.091),
        ]
    )

    ansatz = EfficientSU2(observable.num_qubits, reps=1)
    init_param_values = np.zeros(len(ansatz.parameters))
    for i in range(len(ansatz.parameters)):
        init_param_values[i] = np.pi / 2
    var_principle = ImaginaryMcLachlanPrinciple()
    time = 1
    evolution_problem = TimeEvolutionProblem(observable, time)
    var_qite = VarQITE(ansatz, var_principle, init_param_values)
    evolution_result = var_qite.evolve(evolution_problem)
    ```

*   Added rules for converting [`XXPlusYYGate`](qiskit.circuit.library.XXPlusYYGate "qiskit.circuit.library.XXPlusYYGate") and [`XXMinusYYGate`](qiskit.circuit.library.XXMinusYYGate "qiskit.circuit.library.XXMinusYYGate") to other gates to the `SessionEquivalenceLibrary`. This enables running [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") targeting a backend or [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") that uses these gates.

*   Added two new fake backends, [`FakePrague`](qiskit.providers.fake_provider.FakePrague "qiskit.providers.fake_provider.FakePrague") and [`FakeSherbrooke`](qiskit.providers.fake_provider.FakeSherbrooke "qiskit.providers.fake_provider.FakeSherbrooke") to the [`qiskit.providers.fake_provider`](providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") module. [`FakePrague`](qiskit.providers.fake_provider.FakePrague "qiskit.providers.fake_provider.FakePrague") provides a backend with a snapshot of the properties from the IBM Prague Egret R1 backend and [`FakeSherbrooke`](qiskit.providers.fake_provider.FakeSherbrooke "qiskit.providers.fake_provider.FakeSherbrooke") provides a backend with a snapshot of the properties from the IBM Sherbrooke Eagle R3 backend.

*   Added a new keyword argument, `allow_unknown_parameters`, to the [`ParameterExpression.bind()`](qiskit.circuit.ParameterExpression#bind "qiskit.circuit.ParameterExpression.bind") and [`ParameterExpression.subs()`](qiskit.circuit.ParameterExpression#subs "qiskit.circuit.ParameterExpression.subs") methods. When set this new argument enables passing a dictionary containing unknown parameters to these methods without causing an error to be raised. Previously, this would always raise an error without any way to disable that behavior.

*   The [`BaseEstimator.run()`](qiskit.primitives.BaseEstimator#run "qiskit.primitives.BaseEstimator.run") method’s `observables` argument now accepts a `str` or sequence of `str` input type in addition to the other types already accepted. When used the input string format should match the Pauli string representation accepted by the constructor for [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") objects.

*   Added a new constructor method [`QuantumCircuit.from_instructions()`](qiskit.circuit.QuantumCircuit#from_instructions "qiskit.circuit.QuantumCircuit.from_instructions") that enables creating a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object from an iterable of instructions. For example:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit.circuit.quantumcircuitdata import CircuitInstruction
    from qiskit.circuit import Measure
    from qiskit.circuit.library import HGate, CXGate


    qr = QuantumRegister(2)
    cr = ClassicalRegister(2)
    instructions = [
        CircuitInstruction(HGate(), [qr[0]], []),
        CircuitInstruction(CXGate(), [qr[0], qr[1]], []),
        CircuitInstruction(Measure(), [qr[0]], [cr[0]]),
        CircuitInstruction(Measure(), [qr[1]], [cr[1]]),
    ]
    circuit = QuantumCircuit.from_instructions(instructions)
    circuit.draw("mpl")
    ```

    ![\_images/legacy\_release\_notes-3.png](/images/api/qiskit/legacy_release_notes-3.png)

*   The [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") class now takes an optional `copy` keyword argument in its constructor. If set to `False`, then a `StabilizerTable` provided as input will not be copied, but will be used directly. This can have performance benefits, if the data in the table will never be mutated by any other means.

*   The performance of [`Clifford.compose()`](qiskit.quantum_info.Clifford#compose "qiskit.quantum_info.Clifford.compose") has been greatly improved for all numbers of qubits. For operators of 20 qubits, the speedup is on the order of 100 times.

*   Added a new synthesis function [`synth_clifford_layers()`](synthesis#qiskit.synthesis.synth_clifford_layers "qiskit.synthesis.synth_clifford_layers"), for synthesizing a [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") into layers. The algorithm is based on S. Bravyi, D. Maslov, Hadamard-free circuits expose the structure of the Clifford group, [arxiv:2003.09412](https://arxiv.org/abs/2003.09412). This decomposes the Clifford into 8 layers of gates including two layers of CZ gates, and one layer of CX gates. For example, a 5-qubit Clifford circuit is decomposed into the following layers:

    ```python
         ┌─────┐┌─────┐┌────────┐┌─────┐┌─────┐┌─────┐┌─────┐┌────────┐
    q_0: ┤0    ├┤0    ├┤0       ├┤0    ├┤0    ├┤0    ├┤0    ├┤0       ├
         │     ││     ││        ││     ││     ││     ││     ││        │
    q_1: ┤1    ├┤1    ├┤1       ├┤1    ├┤1    ├┤1    ├┤1    ├┤1       ├
         │     ││     ││        ││     ││     ││     ││     ││        │
    q_2: ┤2 S2 ├┤2 CZ ├┤2 CX_dg ├┤2 H2 ├┤2 S1 ├┤2 CZ ├┤2 H1 ├┤2 Pauli ├
         │     ││     ││        ││     ││     ││     ││     ││        │
    q_3: ┤3    ├┤3    ├┤3       ├┤3    ├┤3    ├┤3    ├┤3    ├┤3       ├
         │     ││     ││        ││     ││     ││     ││     ││        │
    q_4: ┤4    ├┤4    ├┤4       ├┤4    ├┤4    ├┤4    ├┤4    ├┤4       ├
         └─────┘└─────┘└────────┘└─────┘└─────┘└─────┘└─────┘└────────┘
    ```

    This method will allow to decompose a [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") in 2-qubit depth $7n+2$ for linear nearest neighbor (LNN) connectivity.

*   The return types for the [`power()`](qiskit.circuit.Gate#power "qiskit.circuit.Gate.power") methods on several standard library gate classes have been updated to return more specific gate objects that result in a less lossy and more efficient output. For example, running [`power()`](qiskit.circuit.library.IGate#power "qiskit.circuit.library.IGate.power") now returns an [`IGate`](qiskit.circuit.library.IGate "qiskit.circuit.library.IGate") instance instead of [`UnitaryGate`](qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") as was done previously.

    The full list of output types that have been improved are:

    | Gate Class                                                                                     | Output Class from [`power()`](qiskit.circuit.Gate#power "qiskit.circuit.Gate.power")           |
    | ---------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
    | [`CPhaseGate`](qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate")          | [`CPhaseGate`](qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate")          |
    | [`CSGate`](qiskit.circuit.library.CSGate "qiskit.circuit.library.CSGate")                      | [`CPhaseGate`](qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate")          |
    | [`CSdgGate`](qiskit.circuit.library.CSdgGate "qiskit.circuit.library.CSdgGate")                | [`CPhaseGate`](qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate")          |
    | [`IGate`](qiskit.circuit.library.IGate "qiskit.circuit.library.IGate")                         | [`IGate`](qiskit.circuit.library.IGate "qiskit.circuit.library.IGate").                        |
    | [`PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate")             | [`PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate")             |
    | [`RGate`](qiskit.circuit.library.RGate "qiskit.circuit.library.RGate")                         | [`RGate`](qiskit.circuit.library.RGate "qiskit.circuit.library.RGate")                         |
    | [`RXGate`](qiskit.circuit.library.RXGate "qiskit.circuit.library.RXGate")                      | [`RXGate`](qiskit.circuit.library.RXGate "qiskit.circuit.library.RXGate")                      |
    | [`RXXGate`](qiskit.circuit.library.RXXGate "qiskit.circuit.library.RXXGate")                   | [`RXXGate`](qiskit.circuit.library.RXXGate "qiskit.circuit.library.RXXGate")                   |
    | [`RYGate`](qiskit.circuit.library.RYGate "qiskit.circuit.library.RYGate")                      | [`RYGate`](qiskit.circuit.library.RYGate "qiskit.circuit.library.RYGate")                      |
    | [`RYYGate`](qiskit.circuit.library.RYYGate "qiskit.circuit.library.RYYGate")                   | [`RYYGate`](qiskit.circuit.library.RYYGate "qiskit.circuit.library.RYYGate")                   |
    | [`RZGate`](qiskit.circuit.library.RZGate "qiskit.circuit.library.RZGate")                      | [`RZGate`](qiskit.circuit.library.RZGate "qiskit.circuit.library.RZGate")                      |
    | [`RZXGate`](qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate")                   | [`RZXGate`](qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate")                   |
    | [`RZZGate`](qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate")                   | [`RZZGate`](qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate")                   |
    | [`SdgGate`](qiskit.circuit.library.SdgGate "qiskit.circuit.library.SdgGate")                   | [`PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate")             |
    | [`SGate`](qiskit.circuit.library.SGate "qiskit.circuit.library.SGate")                         | [`PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate")             |
    | [`TdgGate`](qiskit.circuit.library.TdgGate "qiskit.circuit.library.TdgGate")                   | [`PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate")             |
    | [`TGate`](qiskit.circuit.library.TGate "qiskit.circuit.library.TGate")                         | [`PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate")             |
    | [`XXMinusYYGate`](qiskit.circuit.library.XXMinusYYGate "qiskit.circuit.library.XXMinusYYGate") | [`XXMinusYYGate`](qiskit.circuit.library.XXMinusYYGate "qiskit.circuit.library.XXMinusYYGate") |
    | [`XXPlusYYGate`](qiskit.circuit.library.XXPlusYYGate "qiskit.circuit.library.XXPlusYYGate")    | [`XXPlusYYGate`](qiskit.circuit.library.XXPlusYYGate "qiskit.circuit.library.XXPlusYYGate")    |
    | [`ZGate`](qiskit.circuit.library.ZGate "qiskit.circuit.library.ZGate")                         | [`PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate")             |
    | [`iSwapGate`](qiskit.circuit.library.iSwapGate "qiskit.circuit.library.iSwapGate")             | [`XXPlusYYGate`](qiskit.circuit.library.XXPlusYYGate "qiskit.circuit.library.XXPlusYYGate")    |

*   The [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") is now represented internally as a `PyDiGraph`, this underlying graph object can be accesed from the new [`graph`](qiskit.circuit.EquivalenceLibrary#graph "qiskit.circuit.EquivalenceLibrary.graph") attribute. This attribute is intended for use internally in Qiskit and therefore should always be copied before being modified by the user to prevent possible corruption of the internal equivalence graph.

*   The [`Operator.from_circuit()`](qiskit.quantum_info.Operator#from_circuit "qiskit.quantum_info.Operator.from_circuit") constructor method now will reverse the output permutation caused by the routing/swap mapping stage of the transpiler. By default if a transpiled circuit had Swap gates inserted the output matrix will have that permutation reversed so the returned matrix will be equivalent to the original un-transpiled circuit. If you’d like to disable this default behavior the `ignore_set_layout` keyword argument can be set to `True` to do this (in addition to previous behavior of ignoring the initial layout from transpilation). If you’d like to manually set a final layout you can use the new `final_layout` keyword argument to pass in a [`Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout") object to use for the output permutation.

*   Added support to the [`GateDirection`](qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection") transpiler pass to handle the the symmetric [`RXXGate`](qiskit.circuit.library.RXXGate "qiskit.circuit.library.RXXGate"), [`RYYGate`](qiskit.circuit.library.RYYGate "qiskit.circuit.library.RYYGate"), and [`RZZGate`](qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate") gates. The pass will now correctly handle these gates and simply reverse the qargs order in place without any other modifications.

*   Added support for using the Python exponentiation operator, `**`, with [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") objects is now supported. It is equivalent to running the [`Gate.power()`](qiskit.circuit.Gate#power "qiskit.circuit.Gate.power") method on the object.

    For example:

    ```python
    from qiskit.circuit.library import XGate

    sx = XGate() ** 0.5
    ```

*   Added new `GaussianSquareDrag` pulse shape to the [`qiskit.pulse.library`](pulse#module-qiskit.pulse.library "qiskit.pulse.library") module. This pulse shape is similar to [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare") but uses the [`Drag`](qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag") shape during its rise and fall. The correction from the DRAG pulse shape can suppress part of the frequency spectrum of the rise and fall of the pulse which can help avoid exciting spectator qubits when they are close in frequency to the drive frequency of the pulse.

*   Added a new keyword argument, `method`, to the constructors for the [`FiniteDiffEstimatorGradient`](qiskit.algorithms.gradients.FiniteDiffEstimatorGradient "qiskit.algorithms.gradients.FiniteDiffEstimatorGradient") and [`FiniteDiffSamplerGradient`](qiskit.algorithms.gradients.FiniteDiffSamplerGradient "qiskit.algorithms.gradients.FiniteDiffSamplerGradient") classes. The `method` argument accepts a string to indicate the computation method to use for the gradient. There are three methods, available `"central"`, `"forward"`, and `"backward"`. The definition of the methods are:

    | Method       | Computation                |
    | ------------ | -------------------------- |
    | `"central"`  | $\frac{f(x+e)-f(x-e)}{2e}$ |
    | `"forward"`  | $\frac{f(x+e) - f(x)}{e}$  |
    | `"backward"` | $\frac{f(x)-f(x-e)}{e}$    |

    where $e$ is the offset epsilon.

*   All gradient classes in [`qiskit.algorithms.gradients`](qiskit.algorithms.gradients#module-qiskit.algorithms.gradients "qiskit.algorithms.gradients") now preserve unparameterized operations instead of attempting to unroll them. This allows to evaluate gradients on custom, opaque gates that individual primitives can handle and keeps a higher level of abstraction for optimized synthesis and compilation after the gradient circuits have been constructed.

*   Added a [`TranslateParameterizedGates`](qiskit.transpiler.passes.TranslateParameterizedGates "qiskit.transpiler.passes.TranslateParameterizedGates") pass to map only parameterized gates in a circuit to a specified basis, but leave unparameterized gates untouched. The pass first attempts unrolling and finally translates if a parameterized gate cannot be further unrolled.

*   The [`CollectCliffords`](qiskit.transpiler.passes.CollectCliffords "qiskit.transpiler.passes.CollectCliffords") transpiler pass has been expanded to collect and combine blocks of “clifford gates” into [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") objects, where “clifford gates” may now also include objects of type [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction"), [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford"), and [`PauliGate`](qiskit.circuit.library.PauliGate "qiskit.circuit.library.PauliGate"). For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import LinearFunction, PauliGate
    from qiskit.quantum_info.operators import Clifford
    from qiskit.transpiler.passes import CollectCliffords
    from qiskit.transpiler import PassManager

    # Create a Clifford
    cliff_circuit = QuantumCircuit(2)
    cliff_circuit.cx(0, 1)
    cliff_circuit.h(0)
    cliff = Clifford(cliff_circuit)

    # Create a linear function
    lf = LinearFunction([[0, 1], [1, 0]])

    # Create a pauli gate
    pauli_gate = PauliGate("XYZ")

    # Create a quantum circuit with the above and also simple clifford gates.
    qc = QuantumCircuit(4)
    qc.cz(0, 1)
    qc.append(cliff, [0, 1])
    qc.h(0)
    qc.append(lf, [0, 2])
    qc.append(pauli_gate, [0, 2, 1])
    qc.x(2)

    # Run CollectCliffords transpiler pass
    qct = PassManager(CollectCliffords()).run(qc)
    ```

    All the gates will be collected and combined into a single [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford"). Thus the final circuit consists of a single [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") object.

*   [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") is now implicitly iterable, with the iteration being identical to iterating through the output of [`CouplingMap.get_edges()`](qiskit.transpiler.CouplingMap#get_edges "qiskit.transpiler.CouplingMap.get_edges"). In other words,

    ```python
    from qiskit.transpiler import CouplingMap
    coupling = CouplingMap.from_line(3)
    list(coupling) == list(coupling.get_edges())
    ```

    will now function as expected, as will other iterations. This is purely a syntactic convenience.

*   Added a new function [`synth_cnot_count_full_pmh()`](synthesis#qiskit.synthesis.synth_cnot_count_full_pmh "qiskit.synthesis.synth_cnot_count_full_pmh") which is used to synthesize linear reversible circuits for all-to-all architectures using the Patel, Markov and Hayes method. This function is identical to the available `qiskit.transpiler.synthesis.cnot_synth()` function but has a more descriptive name and is more logically placed in the package tree. This new function supersedes the legacy function which will likely be deprecated in a future release.

*   [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") has been updated to store backend calibration data in the format of PulseQobj JSON and invokes conversion when the data is accessed for the first time, i.e. lazy conversion. This internal logic update drastically improves the performance of loading backend especially with many calibration entries.

*   New module `qiskit.pulse.calibration_entries` has been added. This contains several wrapper classes for different pulse schedule representations.

    *   `ScheduleDef`
    *   `CallableDef`
    *   `PulseQobjDef`

    These classes implement the `get_schedule()` and `get_signature()` methods that returns pulse schedule and parameter names to assign, respectively. These classes are internally managed by the [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") or backend [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target"), and thus they will not appear in a typical user programs.

*   Introduced a new subclass `ScalableSymbolicPulse`, as a subclass of [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse"). The new subclass behaves the same as [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse"), except that it assumes that the envelope of the pulse includes a complex amplitude pre-factor of the form $\text{amp} * e^{i \times \text{angle}}$. This envelope shape matches many common pulses, including all of the pulses in the Qiskit Pulse library (which were also converted to `amp`, `angle` representation in this release).

    The new subclass removes the non-unique nature of the `amp`, `angle` representation, and correctly compares pulses according to their complex amplitude.

*   Added a new keyword argument, `dtype`, to the [`PauliSumOp.from_list()`](qiskit.opflow.primitive_ops.PauliSumOp#from_list "qiskit.opflow.primitive_ops.PauliSumOp.from_list") method. When specified this argument can be used to specify the `dtype` of the numpy array allocated for the [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") used internally by the constructed [`PauliSumOp`](qiskit.opflow.primitive_ops.PauliSumOp "qiskit.opflow.primitive_ops.PauliSumOp").

*   Support for importing OpenQASM 3 programs into Qiskit has been added. This can most easily be accessed using the functions [`qasm3.loads()`](qasm3#qiskit.qasm3.loads "qiskit.qasm3.loads") and [`qasm3.load()`](qasm3#qiskit.qasm3.load "qiskit.qasm3.load"), to load a program directly from a string and indirectly from a filename, respectively. For example, one can now do:

    ```python
    from qiskit import qasm3

    circuit = qasm3.loads("""
      OPENQASM 3.0;
      include "stdgates.inc";

      qubit q;
      qubit[5] qr;
      bit c;
      bit[5] cr;

      h q;
      c = measure q;

      if (c) {
        h qr[0];
        cx qr[0], qr[1];
        cx qr[0], qr[2];
        cx qr[0], qr[3];
        cx qr[0], qr[4];
      } else {
        h qr[4];
        cx qr[4], qr[3];
        cx qr[4], qr[2];
        cx qr[4], qr[1];
        cx qr[4], qr[0];
      }
      cr = measure qr;
    """)
    ```

    This will load the program into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instance in the variable `circuit`.

    Not all OpenQASM 3 features are supported at first, because Qiskit does not yet have a way to represent advanced classical data processing. The capabilities of the importer will increase along with the capabilities of the rest of Qiskit. The initial feature set of the importer is approximately the same set of features that would be output by the exporter ([`qasm3.dump()`](qasm3#qiskit.qasm3.dump "qiskit.qasm3.dump") and [`qasm3.dumps()`](qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps")).

    Note that Qiskit’s support of OpenQASM 3 is not meant to provide a totally lossless representation of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")s. For that, consider using [`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy").

*   The [`primitives`](primitives#module-qiskit.primitives "qiskit.primitives")-based gradient classes defined by the [`BaseEstimatorGradient`](qiskit.algorithms.gradients.BaseEstimatorGradient "qiskit.algorithms.gradients.BaseEstimatorGradient") and [`BaseSamplerGradient`](qiskit.algorithms.gradients.BaseSamplerGradient "qiskit.algorithms.gradients.BaseSamplerGradient") abstract classes have been updated to simplify extending the base interface. There are three new internal overridable methods, `_preprocess()`, `_postprocess()`, and `_run_unique()`. `_preprocess()` enables a subclass to customize the input gradient circuits and parameters, `_postprocess` enables to customize the output result, and `_run_unique` enables calculating the gradient of a circuit with unique parameters.

*   The [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") transpiler pass has greatly improved performance as it has been re-written in Rust. As part of this rewrite the pass has been transformed from an analysis pass to a transformation pass that will run both layout and routing. This was done to not only improve the runtime performance but also improve the quality of the results. The previous functionality of the pass as an analysis pass can be retained by manually setting the `routing_pass` argument or using the new `skip_routing` argument.

*   The [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") transpiler pass has a new constructor argument `layout_trials`. This argument is used to control how many random number generator seeds will be attempted to run [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") with. When set the SABRE layout algorithm is run `layout_trials` number of times and the best quality output (measured in the lowest number of swap gates added) is selected. These seed trials are executed in parallel using multithreading to minimize the potential performance overhead of running layout multiple times. By default if this is not specified the [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") pass will default to using the number of physical CPUs are available on the local system.

*   Added two new classes [`SciPyRealEvolver`](qiskit.algorithms.SciPyRealEvolver "qiskit.algorithms.SciPyRealEvolver") and [`SciPyImaginaryEvolver`](qiskit.algorithms.SciPyImaginaryEvolver "qiskit.algorithms.SciPyImaginaryEvolver") that implement integration methods for time evolution of a quantum state. The value and standard deviation of observables as well as the times they are evaluated at can be queried as [`TimeEvolutionResult.observables`](qiskit.algorithms.TimeEvolutionResult#observables "qiskit.algorithms.TimeEvolutionResult.observables") and [`TimeEvolutionResult.times`](qiskit.algorithms.TimeEvolutionResult#times "qiskit.algorithms.TimeEvolutionResult.times"). For example:

    ```python
    from qiskit.algorithms.time_evolvers.time_evolution_problem import TimeEvolutionProblem
    from qiskit.quantum_info import SparsePauliOp
    from qiskit.quantum_info.states.statevector import Statevector
    from qiskit.algorithms import SciPyImaginaryEvolver

    initial_state = Statevector.from_label("+++++")
    hamiltonian = SparsePauliOp("ZZZZZ")
    evolution_problem = TimeEvolutionProblem(hamiltonian, 100, initial_state, {"Energy":hamiltonian})
    classic_evolver = SciPyImaginaryEvolver(num_timesteps=300)
    result = classic_evolver.evolve(evolution_problem)
    print(result.observables)
    ```

*   Added the [`SolovayKitaev`](qiskit.transpiler.passes.SolovayKitaev "qiskit.transpiler.passes.SolovayKitaev") transpiler pass to run the Solovay-Kitaev algorithm for approximating single-qubit unitaries using a discrete gate set. In combination with the basis translator, this allows to convert any unitary circuit to a universal discrete gate set, which could be implemented fault-tolerantly.

    This pass can e.g. be used after compiling to U and CX gates:

    ```python
    from qiskit import transpile
    from qiskit.circuit.library import QFT
    from qiskit.transpiler.passes.synthesis import SolovayKitaev

    qft = QFT(3)

    # optimize to general 1-qubit unitaries and CX
    transpiled = transpile(qft, basis_gates=["u", "cx"], optimization_level=1)

    skd = SolovayKitaev()  # uses T Tdg and H as default basis
    discretized = skd(transpiled)

    print(discretized.count_ops())
    ```

    The decomposition can also be used with the unitary synthesis plugin, as the “sk” method on the [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import Operator
    from qiskit.transpiler.passes import UnitarySynthesis

    circuit = QuantumCircuit(1)
    circuit.rx(0.8, 0)
    unitary = Operator(circuit).data

    unitary_circ = QuantumCircuit(1)
    unitary_circ.unitary(unitary, [0])

    synth = UnitarySynthesis(basis_gates=["h", "s"], method="sk")
    out = synth(unitary_circ)

    out.draw('mpl')
    ```

    ![\_images/legacy\_release\_notes-4.png](/images/api/qiskit/legacy_release_notes-4.png)

*   Random-circuit generation with [`qiskit.circuit.random.random_circuit()`](circuit#qiskit.circuit.random.random_circuit "qiskit.circuit.random.random_circuit") is now significantly faster for large circuits.

*   Random-circuit generation with [`qiskit.circuit.random.random_circuit()`](circuit#qiskit.circuit.random.random_circuit "qiskit.circuit.random.random_circuit") will now output all “standard” gates in Qiskit’s circuit library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library")). This includes two 4-qubit gates [`C3SXGate`](qiskit.circuit.library.C3SXGate "qiskit.circuit.library.C3SXGate") and [`RC3XGate`](qiskit.circuit.library.RC3XGate "qiskit.circuit.library.RC3XGate"), and the allowed values of `max_operands` have been expanded accordingly.

*   The [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") transpiler pass has a new keyword argument, `target`, on its constructor. This argument can be used to specify a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object that represnts the compilation target. If used it superscedes the `basis` argument to determine if an instruction in the circuit is present on the target backend.

*   The [`UnrollCustomDefinitions`](qiskit.transpiler.passes.UnrollCustomDefinitions "qiskit.transpiler.passes.UnrollCustomDefinitions") transpiler pass has a new keyword argument, `target`, on its constructor. This argument can be used to specify a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object that represnts the compilation target. If used it superscedes the `basis_gates` argument to determine if an instruction in the circuit is present on the target backend.

*   Added the [`ReverseEstimatorGradient`](qiskit.algorithms.gradients.ReverseEstimatorGradient "qiskit.algorithms.gradients.ReverseEstimatorGradient") class for a classical, fast evaluation of expectation value gradients based on backpropagation or reverse-mode gradients. This class uses statevectors and thus provides exact gradients but scales exponentially in system size. It is designed for fast reference calculation of smaller system sizes. It can for example be used as:

    ```python
    from qiskit.circuit.library import EfficientSU2
    from qiskit.quantum_info import SparsePauliOp
    from qiskit.algorithms.gradients import ReverseEstimatorGradient

    observable = SparsePauliOp.from_sparse_list([("ZZ", [0, 1], 1)], num_qubits=10)
    circuit = EfficientSU2(num_qubits=10)
    values = [i / 100 for i in range(circuit.num_parameters)]
    gradient = ReverseEstimatorGradient()

    result = gradient.run([circuit], [observable], [values]).result()
    ```

*   Added a new keyword argument, `use_dag` to the constructor for the [`OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") class. When `use_dag` is set to `True` the output from the decomposer will be a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") object instead of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object. This is useful for transpiler passes that use [`OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") (such as [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition")) as working directly with a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") avoids the overhead of converting between [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit").

*   Added the ability for analysis passes to set custom heuristic weights for the [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") transpiler passes. If an analysis pass sets the `vf2_avg_error_map` key in the property set, its value is used for the error weights instead of the error rates from the backend’s [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") (or [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") for [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1")). The value should be an `ErrorMap` instance, where each value represents the avg error rate for all 1 or 2 qubit operation on those qubits. If a value is `NaN`, the corresponding edge is treated as an ideal edge (or qubit for 1q operations). For example, an error map created as:

    ```python
    from qiskit.transpiler.passes.layout.vf2_utils import ErrorMap

    error_map = ErrorMap(3)
    error_map.add_error((0, 0), 0.0024)
    error_map.add_error((0, 1), 0.01)
    error_map.add_error((1, 1), 0.0032)
    ```

    describes a 2 qubit target, where the avg 1q error rate is `0.0024` on qubit 0 and `0.0032` on qubit 1, the avg 2q error rate for gates that operate on (0, 1) is 0.01, and (1, 0) is not supported by the target. This will be used for scoring if it’s set for the `vf2_avg_error_map` key in the property set when [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") are run. For example:

    ```python
    from qiskit.transpiler import AnalysisPass, PassManager, Target
    from qiskit.transpiler.passes import VF2Layout
    from qiskit.transpiler.passes.layout.vf2_utils import ErrorMap
    from qiskit.circuit.library import CZGate, UGate
    from qiskit.circuit import Parameter

    class CustomVF2Scoring(AnalysisPass):
      """Set custom score for vf2."""

      def run(self, dag):
        error_map = ErrorMap(3)
        error_map.add_error((0, 0), 0.0024)
        error_map.add_error((0, 1), 0.01)
        error_map.add_error((1, 1), 0.0032)
        self.property_set["vf2_avg_error_map"] = error_map


    target = Target(num_qubits=2)
    target.add_instruction(
        UGate(Parameter('theta'), Parameter('phi'), Parameter('lam')),
        {(0,): None, (1,): None}
    )
    target.add_instruction(
        CZGate(), {(0, 1): None}
    )

    vf2_pass = VF2Layout(target=target, seed=1234568942)
    pm = PassManager([CustomVF2Scoring(), vf2_pass])
    ```

    That will run [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") with the custom scoring from `error_map` for a 2 qubit [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") that doesn’t contain any error rates.

<span id="release-notes-0-23-0-upgrade-notes" />

<span id="id66" />

#### Upgrade Notes

*   When initializing any of the pulse classes in [`qiskit.pulse.library`](pulse#module-qiskit.pulse.library "qiskit.pulse.library"):

    > *   [`Gaussian`](qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian")
    > *   [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare")
    > *   [`Drag`](qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag")
    > *   [`Constant`](qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant")

    providing a complex `amp` argument with a finite `angle` will result in [`PulseError`](pulse#qiskit.pulse.PulseError "qiskit.pulse.PulseError") now. For example, instead of calling `Gaussian(duration=100,sigma=20,amp=0.5j)` one should use `Gaussian(duration=100,sigma=20,amp=0.5,angle=np.pi/2)` instead now. The pulse envelope which used to be defined as `amp * ...` is in turn defined as `amp * exp(1j * angle) * ...`. This change was made to better support [Qiskit Experiments](https://qiskit.org/documentation/experiments/) where the amplitude and angle of pulses are calibrated in separate experiments.

*   For Python 3.7 [singledispatchmethod](https://pypi.org/project/singledispatchmethod/) is now a dependency. This was added to enable leveraging the method dispatch mechanism in the standard library of newer versions of Python. If you’re on Python >= 3.8 there is no extra dependency required.

*   The previously deprecated `MSBasisDecomposer` transpiler pass available via the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module has been removed. It was originally deprecated as part of the Qiskit Terra 0.16.0 release (10-16-2020). Instead the [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") transpiler pass should be used instead to translate a circuit into an appropriate basis with a [`RXXGate`](qiskit.circuit.library.RXXGate "qiskit.circuit.library.RXXGate")

*   [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") objects that are initialized with the `base` attribute will no long have a shared reference with the [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") passed in. In earlier releases if you mutated `base` after it was used to create a new [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") instance both instances would reflect that change. This no longer is the case and updates to `base` will no longer be reflected in the new [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary"). For example, if you created an equivalence library with:

    ```python
    import math

    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import XGate
    from qiskit.circuit.equivalence import EquivalenceLibrary

    original_lib = EquivalenceLibrary()
    qc = QuantumCircuit(1)
    qc.rx(math.pi, 0)
    original_lib.add_equivalence(XGate(), qc)
    new_lib = EquivalenceLibrary(base=original_lib)
    ```

    if you modified `original_lib` with:

    ```python
    import from qiskit.circuit.library import SXGate

    qc = QuantumCircuit(1)
    qc.rx(math.pi / 2, 0)
    original_lib.add_equivalence(SXGate(), qc)
    ```

    in previous releases `new_lib` would also include the definition of `SXGate` after it was added to `original_lib`, but in this release this no longer will be the case. This change was made because of the change in internal data structure to be a graph, which improved performance of the [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") class, especially when there are multiple runs of the [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") transpiler pass.

*   The `initial_state` argument for the constructor of the [`NLocal`](qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") class along with assigning directly to the `NLocal.initial_state` atrribute must be a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") now. Support for using other types for this argument and attribute is no longer supported. Support for other types was deprecated as part of the Qiskit Terra 0.18.0 release (July 2021).

*   The LaTeX array drawers (e.g. `array_to_latex`, `Statevector.draw('latex')`) now use the same sympy function as the ket-convention drawer. This means it may render some numbers differently to previous releases, but will provide a more consistent experience. For example, it may identify new factors, or rationalize denominators where it did not previously. The default `precision` has been changed from 5 to 10.

*   The QPY version format version emitted by [`dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") has been increased to version 6. This new format version is incompatible with the previous versions and will result in an error when trying to load it with a deserializer that isn’t able to handle QPY version 6. This change was necessary to support the introduction of `ScalableSymbolicPulse` which was handled by adding a `class_name_size` attribute to the header of the dumped [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") objects.

*   The `__hash__` method for the [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") was removed. This was done to reflect the mutable nature (via parameter assignment) of this class which could result in errors when using [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") in situtations where a hashable object was required. This means the builtin `hash()` method and using [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") as keys in dictionaries or set members will no longer work.

*   The names of [`Register`](qiskit.circuit.Register "qiskit.circuit.Register") instances (which includes instances of [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and `ClassicalRegigster`) are no longer constrained to be valid OpenQASM 2 identifiers. This is being done as the restriction is overly strict as Qiskit becomes more decoupled from OpenQASM 2, and even the OpenQASM 3 specification is not so restrictive. If you were relying on registers having valid OpenQASM 2 identifier names, you will need to begin escaping the names. A simplistic version of this could be done, for example, by:

    ```python
    import re
    import string

    def escape(name: str) -> str:
      out = re.sub(r"\W", "_", name, flags=re.ASCII)
      if not out or out[0] not in string.ascii_lowercase:
        return "reg_" + out
      return out
    ```

*   The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods `u1`, `u2`, `u3`, and their controlled variants `cu1`, `cu3` and `mcu1` have been removed following their deprecation in Qiskit Terra 0.16.0. This was to remove gate names that were usually IBM-specific, in favour of the more general methods [`p()`](qiskit.circuit.QuantumCircuit#p "qiskit.circuit.QuantumCircuit.p"), [`u()`](qiskit.circuit.QuantumCircuit#u "qiskit.circuit.QuantumCircuit.u"), [`cp()`](qiskit.circuit.QuantumCircuit#cp "qiskit.circuit.QuantumCircuit.cp") and [`cu()`](qiskit.circuit.QuantumCircuit#cu "qiskit.circuit.QuantumCircuit.cu"). The gate classes [`U1Gate`](qiskit.circuit.library.U1Gate "qiskit.circuit.library.U1Gate"), [`U2Gate`](qiskit.circuit.library.U2Gate "qiskit.circuit.library.U2Gate") and [`U3Gate`](qiskit.circuit.library.U3Gate "qiskit.circuit.library.U3Gate") are still available for use with [`QuantumCircuit.append()`](qiskit.circuit.QuantumCircuit#append "qiskit.circuit.QuantumCircuit.append"), so backends can still support bases with these gates explicitly given.

*   The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods `combine` and `extend` have been removed following their deprecation in Qiskit Terra 0.17.0. This was done because these functions were simply less powerful versions of [`QuantumCircuit.compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose"), which should be used instead.

    The removal of `extend` also means that the `+` and `+=` operators are no longer defined for [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). Instead, you can use the `&` and `&=` operators respectively, which use [`QuantumCircuit.compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose").

*   The previously deprecated functions: `qiskit.circuit.measure.measure()` and `qiskit.circuit.reset.reset()` have been removed. These functions were deprecated in the Qiskit Terra 0.19.0 release (December, 2021). Instead you should use the [`QuantumCircuit.measure()`](qiskit.circuit.QuantumCircuit#measure "qiskit.circuit.QuantumCircuit.measure") and [`QuantumCircuit.reset()`](qiskit.circuit.QuantumCircuit#reset "qiskit.circuit.QuantumCircuit.reset") methods of the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object you wish to append a [`Measure`](qiskit.circuit.library.Measure "qiskit.circuit.library.Measure") or [`Reset`](qiskit.circuit.library.Reset "qiskit.circuit.library.Reset") operation to.

*   The previously deprecated `ParameterView` methods which were inherited from `set` have been removed from `ParameterView`, the type returned by [`QuantumCircuit.parameters`](qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters"). The specific methods which have been removed are:

    > *   `add()`
    > *   `difference()`
    > *   `difference_update()`
    > *   `discard()`
    > *   `intersection()`
    > *   `intersection_update()`
    > *   `issubset()`
    > *   `issuperset()`
    > *   `symmetric_difference()`
    > *   `symmetric_difference_update()`
    > *   `union()`
    > *   `update()`

    along with support for the Python operators:

    > *   `ixor`: `^=`
    > *   `isub`: `-=`
    > *   `ior`: `|=`

    These were deprecated in the Qiskit Terra 0.17.0 release (April, 2021). The `ParameterView` type is now a general sequence view type and doesn’t support these `set` operations any longer.

*   The previously deprecated [NetworkX](https://networkx.org/) converter methods for the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") classes: `DAGCircuit.to_networkx()`, `DAGCircuit.from_networkx()`, and `DAGDependency.to_networkx()` have been removed. These methods were originally deprecated as part of the Qiskit Terra 0.21.0 release (June, 2022). Qiskit has been using [rustworkx](https://qiskit.org/documentation/rustworkx/) as its graph library since the qiskit-terra 0.12.0 release and since then the NetworkX converter function have been a lossy process. They were originally added so that users could leverage NetworkX’s algorithms library to leverage functionality not present in [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and/or rustworkx. However, since that time both [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and rustworkx has matured and offers more functionality and the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") is tightly coupled to rustworkx for its operation and having these converter methods provided limited functionality and therefore have been removed.

*   `tweedledum` has been removed as a core requirement of Qiskit Terra. The functionality provided ([`qiskit.circuit.classicalfunction`](classicalfunction#module-qiskit.circuit.classicalfunction "qiskit.circuit.classicalfunction")) is still available, if `tweedledum` is installed manually, such as by:

    ```python
    pip install tweedledum
    ```

    This change was made because `tweedledum` development has slowed to the point of not keeping up with new Python and OS releases, and was blocking some Qiskit users from installing Qiskit.

*   The lazy optional checkers [`HAS_MATPLOTLIB`](utils#qiskit.utils.optionals.HAS_MATPLOTLIB "qiskit.utils.optionals.HAS_MATPLOTLIB"), [`HAS_PIL`](utils#qiskit.utils.optionals.HAS_PIL "qiskit.utils.optionals.HAS_PIL"), [`HAS_PYLATEX`](utils#qiskit.utils.optionals.HAS_PYLATEX "qiskit.utils.optionals.HAS_PYLATEX") and [`HAS_PDFTOCAIRO`](utils#qiskit.utils.optionals.HAS_PDFTOCAIRO "qiskit.utils.optionals.HAS_PDFTOCAIRO") are no longer exposed from [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization"), having been deprecated in Qiskit Terra 0.21. The canonical location for these (and many other lazy checkers) is [`qiskit.utils.optionals`](utils#module-qiskit.utils.optionals "qiskit.utils.optionals"), and all four objects can be found there.

*   The previously deprecated `gate` argument to the constructor of the [`Decompose`](qiskit.transpiler.passes.Decompose "qiskit.transpiler.passes.Decompose") transpiler pass, along with its matching attribute `Decompose.gate` have been removed. The argument and attribute were deprecated as part of the Qiskit Terra 0.19.0 release (December, 2021). Instead the `gates_to_decompose` argument for the constructor along with the `Decompose.gates_to_decompose` attribute should be used instead. The `gates_to_decompose` argument and attribute should function the same, but has a more explicit name and also enables specifying lists of gates instead of only supporting a single gate.

*   The previously deprecated `label` argument for the constructor of the [`MCMT`](qiskit.circuit.library.MCMT "qiskit.circuit.library.MCMT") and [`MCMTVChain`](qiskit.circuit.library.MCMTVChain "qiskit.circuit.library.MCMTVChain") classes has been removed. It was deprecated as of the Qiskit Terra 0.19.0 release (Decemeber, 2021). Using the `label` argument on these classes was undefined behavior as they are subclasses of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instead of [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction"). This would result in the assigned label generally being ignored. If you need to assign a `label` to an instance of [`MCMT`](qiskit.circuit.library.MCMT "qiskit.circuit.library.MCMT") or [`MCMTVChain`](qiskit.circuit.library.MCMTVChain "qiskit.circuit.library.MCMTVChain") you should convert them to an [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") instance with [`to_gate()`](qiskit.circuit.QuantumCircuit#to_gate "qiskit.circuit.QuantumCircuit.to_gate") and then assign the desired label to [`label`](qiskit.circuit.Gate#label "qiskit.circuit.Gate.label") attribute. For example:

    ```python
    from qiskit.circuit.library import MCMT, XGate

    mcmt_circuit = MCMT(XGate(), 3, 2)
    mcmt_gate = mcmt_circuit.to_gate()
    mcmt_gate.label = "Custom MCMT X"
    ```

*   The `retworkx` dependency for Qiskit has been removed and replaced by `rustworkx` library. These are the same packages, but `rustworkx` is the new name for `retworkx` which was renamed as part of their combined 0.12.0 release. If you were previously using retworkx 0.12.0 with Qiskit then you already installed rustworkx (retworkx 0.12.0 was just a redirect shim for backwards compatibility). This change was made to migrate to the new package name which will be the only supported package in the future.

*   The default behavior of the [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") compiler pass has changed. The pass is no longer an [`AnalysisPass`](qiskit.transpiler.AnalysisPass "qiskit.transpiler.AnalysisPass") and by default will compute the initital layout, apply it to the circuit, and will also run [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") internally and apply the swap mapping and set the `final_layout` property set with the permutation caused by swap insertions. This means for users running [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") as part of a custom [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") will need to adjust the pass manager to account for this (unless they were setting the `routing_pass` argument for [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout")). This change was made in the interest of improving the quality output, the layout and routing quality are highly coupled and [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") will now run multiple parallel seed trials and to calculate which seed provides the best results it needs to perform both the layout and routing together. There are three ways you can adjust the usage in your custom pass manager. The first is to avoid using embedding in your preset pass manager. If you were previously running something like:

    ```python
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.preset_passmanagers import common
    from qiskit.transpiler.passes.SabreLayout

    pm = PassManager()
    pm.append(SabreLayout(coupling_map)
    pm += common.generate_embed_passmanager(coupling_map)
    ```

    to compute the layout and then apply it (which was typically followed by routing) you can adjust the usage to just simply be:

    ```python
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.preset_passmanagers import common
    from qiskit.transpiler.passes.SabreLayout

    pm = PassManager()
    pm.append(SabreLayout(coupling_map)
    ```

    as [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") will apply the layout and you no longer need the embedding stage. Alternatively, you can specify the `routing_pass` argument which will revert [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") to its previous behavior. For example, if you want to run [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") as it was run in previous releases you can do something like:

    ```python
    from qiskit.transpiler.passes import SabreSwap, SabreLayout
    routing_pass = SabreSwap(
        coupling_map, "decay", seed=seed, fake_run=True
    )
    layout_pass = SabreLayout(coupling_map, routing_pass=routing_pass, seed=seed)
    ```

    which will have [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") run as an analysis pass and just set the `layout` property set. The final approach is to leverage the `skip_routing` argument on `SabreLayout`, when this argument is set to `True` it will skip applying the found layout and inserting the swap gates from routing. However, doing this has a runtime penalty as `SabreLayout` will still be computing the routing and just does not use this data. The first two approaches outlined do not have additional overhead associated with them.

*   The layouts computed by the [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") pass (when run without the `routing_pass` argument) with a fixed seed value may change from previous releases. This is caused by a new random number generator being used as part of the rewrite of the [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") pass in Rust which significantly improved the performance. If you rely on having consistent output you can run the pass in an earlier version of Qiskit and leverage [`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy") to save the circuit and then load it using the current version. Alternatively you can explicitly set the `routing_pass` argument to an instance of [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") to mirror the previous behavior of [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout"):

    ```python
    from qiskit.transpiler.passes import SabreSwap, SabreLayout


    routing_pass = SabreSwap(
        coupling_map, "decay", seed=seed, fake_run=True
    )
    layout_pass = SabreLayout(coupling_map, routing_pass=routing_pass, seed=seed)
    ```

    which will mirror the behavior of the pass in the previous release. Note, that if you were using the `swap_trials` argument on [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") in previous releases when adjusting the usage to this form that you will need to set `trials` argument on the [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") constructor if you want to retain the previous output with a fixed seed.

*   The exact circuit returned by `qiskit.circuit.random.random_circuit` for a given seed has changed. This is due to efficiency improvements in the internal random-number generation for the function.

*   The version requirement for the optional feature package `qiskit-toqm`, installable via `pip install qiskit-terra[toqm]`, has been upgraded from version `0.0.4` to `0.1.0`. To use the `toqm` routing method with [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") you must now use qiskit-toqm version `0.1.0` or newer. Older versions are no longer discoverable by the transpiler.

*   The output [`QuasiDistribution`](qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution") from the `Sampler.run` method has been updated to filter out any states with a probability of zero. Now if a valid state is missing from the dictionary output it can be assumed to have a 0 probability. Previously, all possible outcomes for a given number of bits (e.g. for a 3 bit result `000`, `001`, `010`, `011`, `100`, `101`, `110`, and `111`) even if the probability of a given state was 0. This change was made to reduce the size of the output as for larger number of bits the output size could be quite large. Also, filtering the zero probability results makes the output consistent with other implementations of [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler").

*   The behavior of the pulse builder when a [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") is called has been upgraded. Called schedules are internally converted into [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") representation and now reference mechanism is always applied rather than appending the schedules wrapped by the [`Call`](qiskit.pulse.instructions.Call "qiskit.pulse.instructions.Call") instruction. Note that the converted block doesn’t necessary recover the original alignment context. This is simply an ASAP aligned sequence of pulse instructions with absolute time intervals. This is an upgrade of internal representation of called pulse programs and thus no API changes. However the [`Call`](qiskit.pulse.instructions.Call "qiskit.pulse.instructions.Call") instruction and [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") no longer appear in the builder’s pulse program. This change guarantees the generated schedule blocks are always QPY compatible. If you are filtering the output schedule instructions by [`Call`](qiskit.pulse.instructions.Call "qiskit.pulse.instructions.Call"), you can access to the [`ScheduleBlock.references`](qiskit.pulse.ScheduleBlock#references "qiskit.pulse.ScheduleBlock.references") instead to retrieve the called program.

*   [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") and [`RZXCalibrationBuilderNoEcho`](qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho") transpiler pass have been upgraded to generate [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"). This change guarantees the transpiled circuits are always QPY compatible. If you are directly using [`rescale_cr_inst()`](qiskit.transpiler.passes.RZXCalibrationBuilder#rescale_cr_inst "qiskit.transpiler.passes.RZXCalibrationBuilder.rescale_cr_inst"), method from another program or a pass subclass to rescale cross resonance pulse of the device, now this method is turned into a pulse builder macro, and you need to use this method within the pulse builder context to adopts to new release. The method call injects a play instruction to the context pulse program, instead of returning a [`Play`](qiskit.pulse.instructions.Play "qiskit.pulse.instructions.Play") instruction with the stretched pulse.

<span id="release-notes-0-23-0-deprecation-notes" />

<span id="id67" />

#### Deprecation Notes

*   Support for running Qiskit with Python 3.7 support has been deprecated and will be removed in the qiskit-terra 0.25.0 release. This means starting in the 0.25.0 release you will need to upgrade the Python version you’re using to Python 3.8 or above.

*   The class [`LinearFunctionsSynthesis`](qiskit.transpiler.passes.LinearFunctionsSynthesis "qiskit.transpiler.passes.LinearFunctionsSynthesis") class is now deprecated and will be removed in a future release. It has been superseded by the more general [`HighLevelSynthesis`](qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") class which should be used instead. For example, you can instantiate an instance of [`HighLevelSynthesis`](qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") that will behave the same way as `LinearFunctionSynthesis` with:

    ```python
    from qiskit.transpiler.passes import HighLevelSynthesis
    from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig

    HighLevelSynthesis(
        HLSConfig(
            linear_function=[("default", {})],
            use_default_on_unspecified=False,
        )
    )
    ```

*   Support for passing in lists of argument values to the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function is deprecated and will be removed in the 0.25.0 release. This is being done to facilitate greatly reducing the overhead for parallel execution for transpiling multiple circuits at once. If you’re using this functionality currently you can call [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") multiple times instead. For example if you were previously doing something like:

    ```python
    from qiskit.transpiler import CouplingMap
    from qiskit import QuantumCircuit
    from qiskit import transpile

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()
    cmaps = [CouplingMap.from_heavy_hex(d) for d in range(3, 15, 2)]
    results = transpile([qc] * 6, coupling_map=cmaps)
    ```

    instead you should run something like:

    ```python
    from itertools import cycle
    from qiskit.transpiler import CouplingMap
    from qiskit import QuantumCircuit
    from qiskit import transpile

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()
    cmaps = [CouplingMap.from_heavy_hex(d) for d in range(3, 15, 2)]

    results = []
    for qc, cmap in zip(cycle([qc]), cmaps):
        results.append(transpile(qc, coupling_map=cmap))
    ```

    You can also leverage [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") or `multiprocessing` from the Python standard library if you want to run this in parallel.

*   The legacy version of the pulse drawer present in the `qiskit.visualization.pulse` has been deprecated and will be removed in a future release. This includes the `ScheduleDrawer` and :class\`WaveformDrawer\` classes. This module has been superseded by the `qiskit.visualization.pulse_v2` drawer and the typical user API [`pulse_drawer()`](qiskit.visualization.pulse_drawer "qiskit.visualization.pulse_drawer") and `PulseBlock.draw()` are already updated internally to use `qiskit.visualization.pulse_v2`.

*   The `pulse.Instruction.draw()` method has been deprecated and will removed in a future release. The need for this method has been superseded by the `qiskit.visualization.pulse_v2` drawer which doesn’t require `Instrucion` objects to have their own draw method. If you need to draw a pulse instruction you should leverage the [`pulse_drawer()`](qiskit.visualization.pulse_drawer "qiskit.visualization.pulse_drawer") instead.

*   The import `qiskit.circuit.qpy_serialization` is deprecated, as QPY has been promoted to the top level. You should import the same objects from [`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy") instead. The old path will be removed in a future of Qiskit Terra.

*   The `qiskit.IBMQ` object is deprecated. This alias object lazily redirects attribute access to `qiskit.providers.ibmq.IBMQ`. As the `qiskit-ibmq-provider` package has been supersceded by `qiskit-ibm-provider` package which maintains its own namespace maintaining this alias is no longer relevant with the new package. If you were relying on the `qiskit.IBMQ` alias you should update your usage to use `qiskit.providers.ibmq.IBMQ` directly instead (and also consider migrating to `qiskit-ibm-provider`, see the [migration guide](https://qiskit.org/documentation/partners/qiskit_ibm_provider/tutorials/Migration_Guide_from_qiskit-ibmq-provider.html) for more details).

*   Several public methods of pulse Qobj converters have been deprecated and in a future release they will no longer be directly callable. The list of methods is:

    In `InstructionToQobjConverter`,

    *   `convert_acquire()`
    *   `convert_bundled_acquires()`
    *   `convert_set_frequency()`
    *   `convert_shift_frequency()`
    *   `convert_set_phase()`
    *   `convert_shift_phase()`
    *   `convert_delay()`
    *   `convert_play()`
    *   `convert_snapshot()`

    In `QobjToInstructionConverter`,

    *   `convert_acquire()`
    *   `convert_set_phase()`
    *   `convert_shift_phase()`
    *   `convert_set_frequency()`
    *   `convert_shift_frequency()`
    *   `convert_delay()`
    *   `bind_pulse()`
    *   `convert_parametric()`
    *   `convert_snapshot()`

    Instead of calling any of these methods directly they will be implicitly selected when a converter instance is directly called. For example:

    ```python
    converter = QobjToInstructionConverter()
    converter(pulse_qobj)
    ```

*   The `qiskit.visualization.state_visualization.num_to_latex_ket()` and `qiskit.visualization.state_visualization.num_to_latex_terms()` functions have been deprecated and will be removed in a future release. These function were primarily used internally by the LaTeX output from [`Statevector.draw()`](qiskit.quantum_info.Statevector#draw "qiskit.quantum_info.Statevector.draw") and [`DensityMatrix.draw()`](qiskit.quantum_info.DensityMatrix#draw "qiskit.quantum_info.DensityMatrix.draw") which no longer are using these function and are leverging [sympy](https://pypi.org/project/sympy/) for this instead. If you were using these functions you should cosinder using Sympy’s [nsimplify()](https://docs.sympy.org/latest/modules/simplify/simplify.html) [latex()](https://docs.sympy.org/latest/modules/printing.html) functions.

*   The method `Register.qasm()` is deprecated and will be removed in a future release. This method is found on the subclasses [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister"). The deprecation is because the `qasm()` method promotes a false view of the responsible party for safe conversion to OpenQASM 2; a single object alone does not have the context to provide a safe conversion, such as whether its name clashes after escaping it to produce a valid identifier.

*   The class-variable regular expression [`Register.name_format`](qiskit.circuit.Register#name_format "qiskit.circuit.Register.name_format") is deprecated and wil be removed in a future release. The names of registers are now permitted to be any valid Python string, so the regular expression has no use any longer.

*   The functions `qiskit.quantum_info.synthesis.decompose_clifford()` and `qiskit.quantum_info.synthesis.decompose_cnot_dihedral()` are deprecated and will be removed in a future release. They are replaced by the two functions [`qiskit.synthesis.synth_clifford_full()`](synthesis#qiskit.synthesis.synth_clifford_full "qiskit.synthesis.synth_clifford_full") and [`qiskit.synthesis.synth_cnotdihedral_full()`](synthesis#qiskit.synthesis.synth_cnotdihedral_full "qiskit.synthesis.synth_cnotdihedral_full") respectively.

<span id="release-notes-0-23-0-bug-fixes" />

<span id="id68" />

#### Bug Fixes

*   Fixed an issue in the [`PauliOp.adjoint()`](qiskit.opflow.primitive_ops.PauliOp#adjoint "qiskit.opflow.primitive_ops.PauliOp.adjoint") method where it would return the correct value for Paulis with complex coefficients, for example: `PauliOp(Pauli("iX"))`. Fixed [#9433](https://github.com/Qiskit/qiskit-terra/issues/9433).

*   Fixed an issue with the amplitude estimation algorithms in the `qiskit.algorithms.amplitude_estimators` module (see `amplitude_estimators`) for the usage with primitives built from the abstract [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") primitive (such as [`Sampler`](qiskit.primitives.Sampler "qiskit.primitives.Sampler") and [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler")). Previously, the measurement results were expanded to more bits than actually measured which for oracles with more than one qubit led to potential errors in the detection of the “good” quantum states for oracles.

*   Fixed an issue where the `QuantumCircuit.add_calibrations()` and `DAGCircuit.add_calibrations()` methods had a mismatch in their behavior of parameter-formatting logic. Previously `DAGCircuit.add_calibrations()` tried to cast every parameter into `float`, `QuantumCircuit.add_calibrations()` used given parameters as-is. This would potentially cause an error when running [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") on a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with pulse gates as the parameters of the calibrations could be kept as `ParameterExpresion` objects.

*   Fixed a deserialization issue in QPY’s ([`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy")) [`load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") function where circuits containing gates of class [`MCXGate`](qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate"), [`MCXGrayCode`](qiskit.circuit.library.MCXGrayCode "qiskit.circuit.library.MCXGrayCode"), [`MCXRecursive`](qiskit.circuit.library.MCXRecursive "qiskit.circuit.library.MCXRecursive"), and [`MCXVChain`](qiskit.circuit.library.MCXVChain "qiskit.circuit.library.MCXVChain") would fail to deserialize. Fixed [#9390](https://github.com/Qiskit/qiskit-terra/issues/9390).

*   Fixed an issue in [`TensoredOp.to_matrix()`](qiskit.opflow.list_ops.TensoredOp#to_matrix "qiskit.opflow.list_ops.TensoredOp.to_matrix") where the global coefficient of the operator was multiplied to the final matrix more than once. Now, the global coefficient is correctly applied, independent of the number of tensored operators or states. Fixed [#9398](https://github.com/Qiskit/qiskit-terra/issues/9398).

*   The output from the [`run()`](qiskit.primitives.BackendSampler#run "qiskit.primitives.BackendSampler.run") method of the the [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") class now sets the `shots` and `stddev_upper_bound` attributes of the returned [`QuasiDistribution`](qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution"). Previously these attributes were missing which prevent some post-processing using the output. Fixed [#9311](https://github.com/Qiskit/qiskit-terra/issues/9311)

*   The OpenQASM 2 exporter method [`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") will now emit higher precision floating point numbers for gate parameters by default. In addition, a tighter bound ($1e-12$ instead of $1e-6$) is used for checking whether a given parameter is close to a fraction/power of $\pi$. Fixed [#7166](https://github.com/Qiskit/qiskit-terra/issues/7166).

*   Fixed support in the [`primitives`](primitives#module-qiskit.primitives "qiskit.primitives") module for running [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects with control flow instructions (e.g. [`IfElseOp`](qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp")). Previously, the `BaseSampler` and `BaseEstimator` base classes could not correctly normalize such circuits. However, executing these circuits is dependent on the particular implementation of the primitive supporting control flow instructions. This just fixed support to enable a particular implementation of `BaseSampler` or `BaseEstimator` to use control flow instructions.

*   Fixed an issue with the `PauliOp.matmul()` method where it would return incorrect results with `iI`. Fixed [#8680](https://github.com/Qiskit/qiskit-terra/issues/8680).

*   Fixed an issue with the Approximate Quantum Compiler ([`AQC`](qiskit.transpiler.synthesis.aqc.AQC "qiskit.transpiler.synthesis.aqc.AQC")) class which caused it to return an incorrect circuit when the input unitary had a determinant of -1. Fixed [#9327](https://github.com/Qiskit/qiskit-terra/issues/9327)

*   Fixed an issue with the [`QuantumCircuit.compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") method where it would incorrectly reject valid qubit or clbit specifiers. This has been fixed so that the method now accepts the same set of qubit and clbit specifiers as other [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods, such as [`append()`](qiskit.circuit.QuantumCircuit#append "qiskit.circuit.QuantumCircuit.append"). Fixed [#8691](https://github.com/Qiskit/qiskit-terra/issues/8691).

*   Fixed an issue with the [`QuantumCircuit.compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") method where it would incorrectly map registers in conditions on the given circuit to complete registers on the base. Previously, the mapping was very imprecise; the bits used within each condition were not subject to the mapping, and instead an inaccurate attempt was made to find a corresponding register. This could also result in a condition on a smaller register being expanded to be on a larger register, which is not a valid transformation. Now, a condition on a single bit or a register will be composed to be on precisely the bits as defined by the `clbits` argument. A new aliasing register will be added to the base circuit to facilitate this, if necessary. Fixed [#6583](https://github.com/Qiskit/qiskit-terra/issues/6583).

*   Fixed an issue with the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function when run with `optimization_level` set to `1`, `2`, or `3` and no `backend`, `basis_gates`, or `target` argument specified. If the input circuit had runs of single qubit gates which could be simplified the output circuit would not be as optimized as possible as those runs of single qubit gates would not have been removed. This could have been corrected previously by specifying either the `backend`, `basis_gates`, or `target` arguments on the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") call, but now the output will be as simplified as it can be without knowing the target gates allowed. Fixed [#9217](https://github.com/Qiskit/qiskit-terra/issues/9217)

*   Fixed an issue with the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function when run with `optimization_level=3` and no `backend`, `basis_gates`, or `target` argument specified. If the input circuit contained any 2 qubit blocks which were equivalent to an identity matrix the output circuit would not be as optimized as possible and and would still contain that identity block. This could have been corrected previously by specifying either the `backend`, `basis_gates`, or `target` arguments on the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") call, but now the output will be as simplified as it can be without knowing the target gates allowed. Fixed [#9217](https://github.com/Qiskit/qiskit-terra/issues/9217)

*   Fixed an issue with [`LinCombSamplerGradient`](qiskit.algorithms.gradients.LinCombSamplerGradient "qiskit.algorithms.gradients.LinCombSamplerGradient") where it would potentially raise an error when run with the [`Sampler`](https://qiskit.org/ecosystem/aer/stubs/qiskit_aer.primitives.Sampler.html#qiskit_aer.primitives.Sampler "(in Qiskit Aer v0.13.0)") class from `qiskit-aer`.

*   Fixed an issue with [`NumPyEigensolver`](qiskit.algorithms.eigensolvers.NumPyEigensolver "qiskit.algorithms.eigensolvers.NumPyEigensolver") and by extension [`NumPyMinimumEigensolver`](qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolver "qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolver") where solving for `BaseOperator` subclasses other than `Operator` would cause an error.

*   Fixed an issue in the metadata output from [`primitives`](primitives#module-qiskit.primitives "qiskit.primitives") where the list made copies by reference and all elements were updated with the same value at every iteration.

*   Fixed an issue with the `QobjToInstructionConverter` when multiple backends are called and they accidentally have the same pulse name in the pulse library. This was an edge case that could only be caused when a converter instance was reused across multiple backends (this was not a typical usage pattern).

*   Fixed an issue with the [`PVQD`](qiskit.algorithms.PVQD "qiskit.algorithms.PVQD") class where the loss function was incorrecly squaring the fidelity. This has been fixed so that the loss function matches the definition in the original algorithm definition.

*   Fixed a bug in QPY ([`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy")) where circuits containing registers whose bits occurred in the circuit after loose bits would fail to deserialize. See [#9094](https://github.com/Qiskit/qiskit-terra/issues/9094).

*   The class `TwoQubitWeylDecomposition` is now compatible with the `pickle` protocol. Previously, it would fail to deserialize and would raise a `TypeError`. See [#7312](https://github.com/Qiskit/qiskit-terra/issues/7312).

*   Fixed an issue with the [`LocalReadoutMitigator.quasi_probabilities()`](qiskit.result.LocalReadoutMitigator#quasi_probabilities "qiskit.result.LocalReadoutMitigator.quasi_probabilities") method where the `shots` argument was not used. It is now used to set the number of shots in the return object.

*   Fixed a regression in the construction of [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") objects from `QuantumCircuits` that contain other [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") objects.

*   Fixed an issue with the `TwoQubitWeylDecomposition` class (and its subclasses) to enable the Python standard library `pickle` to serialize these classes. This partially fixed [#7312](https://github.com/Qiskit/qiskit-terra/issues/7312)

*   [`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") will now correctly escape gate and register names that collide with reserved OpenQASM 2 keywords. Fixes [#5043](https://github.com/Qiskit/qiskit-terra/issues/5043).

*   Fixed an issue in the [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") where the ECR pulse sequence was misaligned. Fixed [#9013](https://github.com/Qiskit/qiskit-terra/issues/9013).

*   Fixed an issue with the [`pulse_drawer()`](qiskit.visualization.pulse_drawer "qiskit.visualization.pulse_drawer") where in some cases the output visualization would omit some of the channels in a schedule. Fixed [#8981](https://github.com/Qiskit/qiskit-terra/issues/8981).

<span id="id69" />

### Aer 0.11.2

No change

<span id="ibm-q-provider-0-19-2" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-39-5" />

## Qiskit 0.39.5

<span id="terra-0-22-4" />

<span id="release-notes-terra-0-22-4" />

### Terra 0.22.4

<span id="release-notes-terra-0-22-4-prelude" />

<span id="id70" />

#### Prelude

Qiskit Terra 0.22.4 is a minor bugfix release, fixing some bugs identified in the 0.22 series.

<span id="release-notes-terra-0-22-4-bug-fixes" />

<span id="id71" />

#### Bug Fixes

*   Fixed a bug in [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") that raised an error if its [`run()`](qiskit.primitives.BackendSampler#run "qiskit.primitives.BackendSampler.run") method was called two times sequentially.

*   Fixed two bugs in the [`ComposedOp`](qiskit.opflow.list_ops.ComposedOp "qiskit.opflow.list_ops.ComposedOp") where the [`ComposedOp.to_matrix()`](qiskit.opflow.list_ops.ComposedOp#to_matrix "qiskit.opflow.list_ops.ComposedOp.to_matrix") method did not provide the correct results for compositions with [`StateFn`](qiskit.opflow.state_fns.StateFn "qiskit.opflow.state_fns.StateFn") and for compositions with a global coefficient. Fixed [#9283](https://github.com/Qiskit/qiskit-terra/issues/9283).

*   Fixed the problem in which primitives, [`Sampler`](qiskit.primitives.Sampler "qiskit.primitives.Sampler") and [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator"), did not work when passed a circuit with `numpy.ndarray` as a parameter.

*   Fixed a bug in [`SamplingVQE`](qiskit.algorithms.minimum_eigensolvers.SamplingVQE "qiskit.algorithms.minimum_eigensolvers.SamplingVQE") where the `aggregation` argument did not have an effect. Now the aggregation function and, with it, the CVaR expectation value can correctly be specified.

*   Fixed a performance bug where [`SamplingVQE`](qiskit.algorithms.minimum_eigensolvers.SamplingVQE "qiskit.algorithms.minimum_eigensolvers.SamplingVQE") evaluated the energies of eigenstates in a slow manner.

*   Fixed the autoevaluation of the beta parameters in [`VQD`](qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD"), added support for [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") inputs, and fixed the energy evaluation function to leverage the asynchronous execution of primitives, by only retrieving the job results after both jobs have been submitted.

*   Fixed an issue with the [`Statevector.probabilities_dict()`](qiskit.quantum_info.Statevector#probabilities_dict "qiskit.quantum_info.Statevector.probabilities_dict") and [`DensityMatrix.probabilities_dict()`](qiskit.quantum_info.DensityMatrix#probabilities_dict "qiskit.quantum_info.DensityMatrix.probabilities_dict") methods where they would return incorrect results for non-qubit systems when the `qargs` argument was specified. Fixed [#9210](https://github.com/Qiskit/qiskit-terra/issues/9210)

*   Fixed handling of some `classmethod`s by [`wrap_method()`](utils#qiskit.utils.wrap_method "qiskit.utils.wrap_method") in Python 3.11. Previously, in Python 3.11, `wrap_method` would wrap the unbound function associated with the `classmethod` and then fail when invoked because the class object usually bound to the `classmethod` was not passed to the function. Starting in Python 3.11.1, this issue affected `QiskitTestCase`, preventing it from being imported by other test code. Fixed [#9291](https://github.com/Qiskit/qiskit-terra/issues/9291).

<span id="id72" />

### Aer 0.11.2

No change

<span id="id73" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-39-4" />

## Qiskit 0.39.4

<span id="terra-0-22-3" />

### Terra 0.22.3

No change

<span id="release-notes-aer-0-11-2" />

<span id="id74" />

### Aer 0.11.2

<span id="release-notes-aer-0-11-2-new-features" />

<span id="id75" />

#### New Features

*   Added support for running Qiskit Aer with Python 3.11 support.

<span id="release-notes-aer-0-11-2-known-issues" />

<span id="id76" />

#### Known Issues

*   Fix two bugs in AerStatevector. AerStatevector uses mc\* instructions, which are not enabled in matrix\_product\_state method. This commit changes AerStatevector not to use MC\* and use H, X, Y, Z, U and CX. AerStatevector also failed if an instruction is decomposed to empty QuantumCircuit. This commit allows such instruction.

<span id="release-notes-aer-0-11-2-bug-fixes" />

<span id="id77" />

#### Bug Fixes

*   Fixed support in the `AerSimulator.from_backend()` method for instantiating an `AerSimulator` instance from an a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") object. Previously, attempting to use `AerSimulator.from_backend()` with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") object would have raised an `AerError` saying this wasn’t supported.

*   Fixes a bug where `NoiseModel.from_backend()` with a `BackendV2` object may generate a noise model with excessive `QuantumError` s on non-Gate instructions while, for example, only `ReadoutError` s should be sufficient for measures. This commit updates `NoiseModel.from_backend()` with a `BackendV2` object so that it returns the same noise model as that called with the corresponding `BackendV1` object. That is, the resulting noise model does not contain any `QuantumError` s on measures and it may contain only thermal relaxation errors on other non-gate instructions such as resets. Note that it still contains `ReadoutError` s on measures.

*   Fixed a bug in `NoiseModel.from_backend()` where using the `temperature` kwarg with a non-default value would incorrectly compute the excited state population for the specified temperature. Previously, there was an additional factor of 2 in the Boltzman distribution calculation leading to an incorrect smaller value for the excited state population.

*   Fixed incorrect logic in the control-flow compiler that could allow unrelated instructions to appear “inside” control-flow bodies during execution, causing incorrect results. For example, previously:

    ```python
    from qiskit import QuantumCircuit
    from qiskit_aer import AerSimulator

    backend = AerSimulator(method="statevector")

    circuit = QuantumCircuit(3, 3)
    circuit.measure(0, 0)
    circuit.measure(1, 1)

    with circuit.if_test((0, True)):
        with circuit.if_test((1, False)):
            circuit.x(2)

    with circuit.if_test((0, False)):
        with circuit.if_test((1, True)):
            circuit.x(2)

    circuit.measure(range(3), range(3))
    print(backend.run(circuit, method=method, shots=100).result())
    ```

    would print `{'010': 100}` as the nested control-flow operations would accidentally jump over the first X gate on qubit 2, which should have been executed.

*   Fixes a bug where `NoiseModel.from_backend()` prints verbose warnings when supplying a backend that reports un-physical device parameters such as T2 > 2 \* T1 due to statistical errors in their estimation. This commit removes such warnings because they are not actionable for users in the sense that there are no means other than truncating them to the theoretical bounds as done within `noise.device` module. See [Issue 1631](https://github.com/Qiskit/qiskit-aer/issues/1631) for details of the fixed bug.

*   This is fix for GPU statevector simulator. Chunk distribution tried to allocate all free memory on GPU, but this causes memory allocation error. So this fix allocates 80 percent of free memory. Also this fixes size of matrix buffer when noise sampling is applied.

*   This is a fix of AerState running with cache blocking. AerState wrongly configured transpiler of Aer for cache blocking, and then its algorithm to swap qubits worked wrongly. This fix corrects AerState to use this transpiler. More specifically, After the transpilation, a swapped qubit map is recoverd to the original map when using AerState. This fix is necessary for AerStatevector to use multiple-GPUs.

*   This is fix for AerStatevector. It was not possible to create an AerStatevector instance directly from terra’s Statevector. This fix allows a Statevector as AerStatevector’s input.

*   [`SamplerResult.quasi_dists`](qiskit.primitives.SamplerResult#quasi_dists "qiskit.primitives.SamplerResult.quasi_dists") contain the data about the number of qubits. `QuasiDistribution.binary_probabilities()` returns bitstrings with correct length.

*   Previously seed is not initialized in AerStatevector and then sampled results are always same. With this commit, a seed is initialized for each sampling and sampled results can be vary.

<span id="id78" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-39-3" />

## Qiskit 0.39.3

<span id="release-notes-terra-0-22-3" />

<span id="id79" />

### Terra 0.22.3

<span id="release-notes-terra-0-22-3-prelude" />

<span id="id80" />

#### Prelude

Qiskit Terra 0.22.3 is a minor bugfix release, fixing some further bugs in the 0.22 series.

<span id="release-notes-terra-0-22-3-bug-fixes" />

<span id="id81" />

#### Bug Fixes

*   `AdaptVQE` now correctly indicates that it supports auxiliary operators.

*   The circuit drawers ([`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") and [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer")) will no longer emit a warning about the `cregbundle` parameter when using the default arguments, if the content of the circuit requires all bits to be drawn individually. This was most likely to appear when trying to draw circuits with new-style control-flow operations.

*   Fixed a bug causing [`QNSPSA`](qiskit.algorithms.optimizers.QNSPSA "qiskit.algorithms.optimizers.QNSPSA") to fail when `max_evals_grouped` was set to a value larger than 1.

*   Fixed an issue with the [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") pass which would cause the output of multiple runs of the pass without the `seed` argument specified to reuse the same random number generator seed between runs instead of using different seeds. This previously caused identical results to be returned between runs even when no `seed` was specified.

*   Fixed an issue with the primitive classes, [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") and [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator"), where instances were not able to be serialized with `pickle`. In general these classes are not guaranteed to be serializable as [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") and [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") instances are not required to be serializable (and often are not), but the class definitions of [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") and [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator") no longer prevent the use of `pickle`.

*   The `pulse.Instruction.draw()` method will now succeed, as before. This method is deprecated with no replacement planned, but it should still work for the period of deprecation.

<span id="aer-0-11-1" />

### Aer 0.11.1

No change

<span id="id82" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-39-2" />

## Qiskit 0.39.2

<span id="terra-0-22-2" />

<span id="release-notes-terra-0-22-2" />

### Terra 0.22.2

<span id="release-notes-terra-0-22-2-prelude" />

<span id="id83" />

#### Prelude

Qiskit Terra 0.22.2 is a minor bugfix release, and marks the first official support for Python 3.11.

<span id="release-notes-terra-0-22-2-bug-fixes" />

<span id="id84" />

#### Bug Fixes

*   Fixed an issue with the backend primitive classes [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") and [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator") which prevented running with a [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") instance that does not have a `max_experiments` field set in its [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration").

*   Fixed a bug in the [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") pass when transpiling for backends with a defined [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target"), where the interaction graph would be built incorrectly. This could result in excessive runtimes due to the graph being far more complex than necessary.

*   The Pulse expression parser should no longer periodically hang when called from Jupyter notebooks. This is achieved by avoiding an internal `deepycopy` of a recursive object that seemed to be particularly difficult for the memoization to evaluate.

<span id="id85" />

### Aer 0.11.1

No change

<span id="id86" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-39-1" />

## Qiskit 0.39.1

<span id="terra-0-22-1" />

<span id="release-notes-0-22-1" />

### Terra 0.22.1

<span id="release-notes-0-22-1-prelude" />

<span id="id87" />

#### Prelude

Qiskit Terra 0.22.1 is a bugfix release, addressing some minor issues identified since the 0.22.0 release.

<span id="release-notes-0-22-1-deprecation-notes" />

<span id="id88" />

#### Deprecation Notes

*   The `pauli_list` kwarg of [`pauli_basis()`](qiskit.quantum_info.pauli_basis "qiskit.quantum_info.pauli_basis") has been deprecated as [`pauli_basis()`](qiskit.quantum_info.pauli_basis "qiskit.quantum_info.pauli_basis") now always returns a [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList"). This argument was removed prematurely from Qiskit Terra 0.22.0 which broke compatibility for users that were leveraging the `pauli_list``argument. Now, the argument has been restored but will emit a ``DeprecationWarning` when used. If used it has no effect because since Qiskit Terra 0.22.0 a [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") is always returned.

<span id="release-notes-0-22-1-bug-fixes" />

<span id="id89" />

#### Bug Fixes

*   Fixed the [`BarrierBeforeFinalMeasurements`](qiskit.transpiler.passes.BarrierBeforeFinalMeasurements "qiskit.transpiler.passes.BarrierBeforeFinalMeasurements") transpiler pass when there are conditions on loose [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit")s immediately before the final measurement layer. Previously, this would fail claiming that the bit was not present in an internal temporary circuit. Fixed [#8923](https://github.com/Qiskit/qiskit-terra/issues/8923)

*   The equality checkers for [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") (with objects of the same type) will now correctly handle conditions on single bits. Previously, these would produce false negatives for equality, as the bits would use “exact” equality checks instead of the “semantic” checks the rest of the properties of circuit instructions get.

*   Fixed handling of classical bits in [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") with control flow. Previously, control-flow operations would be expanded to contain all the classical bits in the outer circuit and not contracted again, leading to a mismatch between the numbers of clbits the instruction reported needing and the actual number supplied to it. Fixed [#8903](https://github.com/Qiskit/qiskit-terra/issues/8903)

*   Fixed handling of globally defined instructions for the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class. Previously, two methods, [`operations_for_qargs()`](qiskit.transpiler.Target#operations_for_qargs "qiskit.transpiler.Target.operations_for_qargs") and [`operation_names_for_qargs()`](qiskit.transpiler.Target#operation_names_for_qargs "qiskit.transpiler.Target.operation_names_for_qargs") would ignore/incorrectly handle any globally defined ideal operations present in the target. For example:

    ```python
    from qiskit.transpiler import Target
    from qiskit.circuit.library import CXGate

    target = Target(num_qubits=5)
    target.add_instruction(CXGate())
    names = target.operation_names_for_qargs((1, 2))
    ops = target.operations_for_qargs((1, 2))
    ```

    will now return `{"cx"}` for `names` and `[CXGate()]` for `ops` instead of raising a `KeyError` or an empty return.

*   Fixed an issue in the [`Target.add_instruction()`](qiskit.transpiler.Target#add_instruction "qiskit.transpiler.Target.add_instruction") method where it would previously have accepted an argument with an invalid number of qubits as part of the `properties` argument. For example:

    ```python
    from qiskit.transpiler import Target
    from qiskit.circuit.library import CXGate

    target = Target()
    target.add_instruction(CXGate(), {(0, 1, 2): None})
    ```

    This will now correctly raise a `TranspilerError` instead of causing runtime issues when interacting with the target. Fixed [#8914](https://github.com/Qiskit/qiskit-terra/issues/8914)

*   Fixed an issue with the [`plot_state_hinton()`](qiskit.visualization.plot_state_hinton "qiskit.visualization.plot_state_hinton") visualization function which would result in a misplaced axis that was offset from the actual plot. Fixed #8446 \<[https://github.com/Qiskit/qiskit-terra/issues/8446](https://github.com/Qiskit/qiskit-terra/issues/8446)>

*   Fixed the output of the [`plot_state_hinton()`](qiskit.visualization.plot_state_hinton "qiskit.visualization.plot_state_hinton") function so that the state labels are ordered ordered correctly, and the image matches up with the natural matrix ordering. Fixed [#8324](https://github.com/Qiskit/qiskit-terra/issues/8324)

*   Fixed an issue with the primitive classes, [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") and [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator") when running on backends that have a limited number of circuits in each job. Not all backends support an unlimited batch size (most hardware backends do not) and previously the backend primitive classes would have potentially incorrectly sent more circuits than the backend supported. This has been corrected so that [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") and [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator") will chunk the circuits into multiple jobs if the backend has a limited number of circuits per job.

*   Fixed an issue with the [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator") class where previously setting a run option named `monitor` to a value that evaluated as `True` would have incorrectly triggered a job monitor that only worked on backends from the `qiskit-ibmq-provider` package. This has been removed so that you can use a `monitor` run option if needed without causing any issues.

*   Fixed an issue with the [`Target.build_coupling_map()`](qiskit.transpiler.Target#build_coupling_map "qiskit.transpiler.Target.build_coupling_map") method where it would incorrectly return `None` for a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object with a mix of ideal globally available instructions and instructions that have qubit constraints. Now in such cases the [`Target.build_coupling_map()`](qiskit.transpiler.Target#build_coupling_map "qiskit.transpiler.Target.build_coupling_map") will return a coupling map for the constrained instruction (unless it’s a 2 qubit operation which will return `None` because globally there is no connectivity constraint). Fixed [#8971](https://github.com/Qiskit/qiskit-terra/issues/8971)

*   Fixed an issue with the [`Target.qargs`](qiskit.transpiler.Target#qargs "qiskit.transpiler.Target.qargs") attribute where it would incorrectly return `None` for a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object that contained any globally available ideal instruction.

*   Fixed the premature removal of the `pauli_list` keyword argument of the [`pauli_basis()`](qiskit.quantum_info.pauli_basis "qiskit.quantum_info.pauli_basis") function which broke existing code using the `pauli_list=True` future compatibility path on upgrade to Qiskit Terra 0.22.0. This keyword argument has been added back to the function and is now deprecated and will be removed in a future release.

*   Fixed an issue in QPY serialization ([`dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump")) when a custom [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") subclass that overloaded the `_define()` method to provide a custom definition for the operation. Previously, this case of operation was not serialized correctly because it wasn’t accounting for using the potentially `_define()` method to provide a definition. Fixes [#8794](https://github.com/Qiskit/qiskit-terra/issues/8794)

*   QPY deserialisation will no longer add extra [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") instances to the circuit if there are both loose [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit")s in the circuit and more [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit")s than [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit")s.

*   QPY deserialisation will no longer add registers named q and c if the input circuit contained only loose bits.

*   Fixed the [`SparsePauliOp.dot()`](qiskit.quantum_info.SparsePauliOp#dot "qiskit.quantum_info.SparsePauliOp.dot") method when run on two operators with real coefficients. To fix this, the dtype that `SparsePauliOp` can take is restricted to `np.complex128` and `object`. Fixed [#8992](https://github.com/Qiskit/qiskit-terra/issues/8992)

*   Fixed an issue in the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and `QuantumCircuit.draw()` method where the only built-in style for the `mpl` output that was usable was `default`. If another built-in style, such as `iqx`, were used then a warning about the style not being found would be emitted and the drawer would fall back to use the `default` style. Fixed [#8991](https://github.com/Qiskit/qiskit-terra/issues/8991)

*   Fixed an issue with the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") where it would previously fail with a `TypeError` if a custom [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object was passed in via the `target` argument and a list of multiple circuits were specified for the `circuits` argument.

*   Fixed an issue with [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") when targeting a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") (either directly via the `target` argument or via a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") instance from the `backend` argument) that contained an ideal [`Measure`](qiskit.circuit.library.Measure "qiskit.circuit.library.Measure") instruction (one that does not have any properties defined). Previously this would raise an exception trying to parse the target. Fixed [#8969](https://github.com/Qiskit/qiskit-terra/issues/8969)

*   Fixed an issue with the [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") pass where it would error when running with a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") that had instructions that were missing error rates. This has been corrected so in such cases the lack of an error rate will be treated as an ideal implementation and if no error rates are present it will just select the first matching layout. Fixed [#8970](https://github.com/Qiskit/qiskit-terra/issues/8970)

*   Fixed an issue with the [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") pass where it would error when running with a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") that had instructions that were missing. In such cases the lack of an error rate will be treated as an ideal implementation of the operation.

*   Fixed an issue with the [`VQD`](qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD") class if more than `k=2` eigenvalues were computed. Previously this would fail due to an internal type mismatch, but now runs as expected. Fixed [#8982](https://github.com/Qiskit/qiskit-terra/issues/8982)

*   Fixed a performance bug where the new primitive-based variational algorithms [`minimum_eigensolvers.VQE`](qiskit.algorithms.minimum_eigensolvers.VQE "qiskit.algorithms.minimum_eigensolvers.VQE"), [`eigensolvers.VQD`](qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD") and [`SamplingVQE`](qiskit.algorithms.minimum_eigensolvers.SamplingVQE "qiskit.algorithms.minimum_eigensolvers.SamplingVQE") did not batch energy evaluations per default, which resulted in a significant slowdown if a hardware backend was used.

*   Zero-operand gates and instructions will now work with [`circuit_to_gate()`](converters#qiskit.converters.circuit_to_gate "qiskit.converters.circuit_to_gate"), [`QuantumCircuit.to_gate()`](qiskit.circuit.QuantumCircuit#to_gate "qiskit.circuit.QuantumCircuit.to_gate"), [`Gate.control()`](qiskit.circuit.Gate#control "qiskit.circuit.Gate.control"), and the construction of an [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") containing zero-operand instructions. This edge case is occasionally useful in creating global-phase gates as part of larger compound instructions, though for many uses, [`QuantumCircuit.global_phase`](qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") may be more appropriate.

*   Fixes issue where [`Statevector.evolve()`](qiskit.quantum_info.Statevector#evolve "qiskit.quantum_info.Statevector.evolve") and [`DensityMatrix.evolve()`](qiskit.quantum_info.DensityMatrix#evolve "qiskit.quantum_info.DensityMatrix.evolve") would raise an exeception for nested subsystem evolution for non-qubit subsystems. Fixes [issue #8897](https://github.com/Qiskit/qiskit-terra/issues/8897)

*   Fixes bug in [`Statevector.evolve()`](qiskit.quantum_info.Statevector#evolve "qiskit.quantum_info.Statevector.evolve") where subsystem evolution will return the incorrect value in certain cases where there are 2 or more than non-evolved subsystems with different subsystem dimensions. Fixes [issue #8899](https://github.com/Qiskit/qiskit-terra/issues/8899)

<span id="release-notes-aer-0-11-1" />

<span id="id90" />

### Aer 0.11.1

<span id="release-notes-aer-0-11-1-bug-fixes" />

<span id="id91" />

#### Bug Fixes

*   Fixed a potential build error when trying to use CMake 3.18 or newer and building qiskit-aer with GPU support enabled. Since CMake 3.18 or later when building with CUDA the `CMAKE_CUDA_ARCHITECTURES` was required to be set with the architecture value for the target GPU. This has been corrected so that setting `AER_CUDA_ARCH` will be used if this was not set.

*   Fixes a bug in the handling of instructions with clbits in `LocalNoisePass`. Previously, it was accidentally erasing clbits of instructions (e.g. measures) to which the noise is applied in the case of `method="append"`.

*   Fixed the performance overhead of the Sampler class when running with identical circuits on multiple executions. This was accomplished by skipping/caching the transpilation of these identical circuits on subsequent executions.

*   Fixed compatibility of the [`Sampler`](https://qiskit.org/ecosystem/aer/stubs/qiskit_aer.primitives.Sampler.html#qiskit_aer.primitives.Sampler "(in Qiskit Aer v0.13.0)") and `Estimator` primitive classes with qiskit-terra 0.22.0 release. In qiskit-terra 0.22.0 breaking API changes were made to the abstract interface which broke compatibility with these classes, this has been addressed so that [`Sampler`](https://qiskit.org/ecosystem/aer/stubs/qiskit_aer.primitives.Sampler.html#qiskit_aer.primitives.Sampler "(in Qiskit Aer v0.13.0)") and `Estimator` can now be used with qiskit-terra >= 0.22.0.

<span id="id92" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-39-0" />

## Qiskit 0.39.0

This release also officially deprecates the Qiskit Aer project as part of the Qiskit metapackage. This means that in a future release `pip install qiskit` will no longer include `qiskit-aer`. If you’re currently installing or listing `qiskit` as a dependency to get Aer you should upgrade this to explicitly list `qiskit-aer` as well.

The `qiskit-aer` project is still active and maintained moving forward but for the Qiskit metapackage (i.e. what gets installed via `pip install qiskit`) the project is moving towards a model where the Qiskit package only contains the common core functionality for building and compiling quantum circuits, programs, and applications and packages that build on it or link Qiskit to hardware or simulators are separate packages.

<span id="terra-0-22-0" />

### Terra 0.22.0

<span id="release-notes-0-22-0-prelude" />

<span id="id93" />

#### Prelude

The Qiskit Terra 0.22.0 release is a major feature release that includes a myriad of new feature and bugfixes. The highlights for this release are:

> *   Adding initial support to the transpiler for transpiling [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects that contain control flow instructions such as [`ForLoopOp`](qiskit.circuit.ForLoopOp "qiskit.circuit.ForLoopOp") and [`WhileLoopOp`](qiskit.circuit.WhileLoopOp "qiskit.circuit.WhileLoopOp").
> *   Greatly improved scaling and performance for the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function with large numbers of qubits, especially when `optimization_level=3` is used.
> *   External plugin interface for [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") that enables external packages to implement stages for the default pass managers. More details on this can be found at [`qiskit.transpiler.preset_passmanagers.plugin`](transpiler_plugins#module-qiskit.transpiler.preset_passmanagers.plugin "qiskit.transpiler.preset_passmanagers.plugin"). Additionally, [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backends can now optionally set custom default plugins to use for the scheduling and translation stages.
> *   Updated algorithm implementations in [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") that leverage the [`primitives`](primitives#module-qiskit.primitives "qiskit.primitives") classes that implement the [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") and [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator").

<span id="release-notes-0-22-0-new-features" />

<span id="id94" />

#### New Features

*   Add support for representing an operation that has a variable width to the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class. Previously, a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object needed to have an instance of `Operation` defined for each operation supported in the target. This was used for both validation of arguments and parameters of the operation. However, for operations that have a variable width this wasn’t possible because each instance of an `Operation` class can only have a fixed number of qubits. For cases where a backend supports variable width operations the instruction can be added with the class of the operation instead of an instance. In such cases the operation will be treated as globally supported on all qubits. For example, if building a target like:

    ```python
    from qiskit.circuit import Parameter, Measure, IfElseOp, ForLoopOp, WhileLoopOp
    from qiskit.circuit.library import IGate, RZGate, SXGate, XGate, CXGate
    from qiskit.transpiler import Target, InstructionProperties

    theta = Parameter("theta")

    ibm_target = Target()
    i_props = {
        (0,): InstructionProperties(duration=35.5e-9, error=0.000413),
        (1,): InstructionProperties(duration=35.5e-9, error=0.000502),
        (2,): InstructionProperties(duration=35.5e-9, error=0.0004003),
        (3,): InstructionProperties(duration=35.5e-9, error=0.000614),
        (4,): InstructionProperties(duration=35.5e-9, error=0.006149),
    }
    ibm_target.add_instruction(IGate(), i_props)
    rz_props = {
        (0,): InstructionProperties(duration=0, error=0),
        (1,): InstructionProperties(duration=0, error=0),
        (2,): InstructionProperties(duration=0, error=0),
        (3,): InstructionProperties(duration=0, error=0),
        (4,): InstructionProperties(duration=0, error=0),
    }
    ibm_target.add_instruction(RZGate(theta), rz_props)
    sx_props = {
        (0,): InstructionProperties(duration=35.5e-9, error=0.000413),
        (1,): InstructionProperties(duration=35.5e-9, error=0.000502),
        (2,): InstructionProperties(duration=35.5e-9, error=0.0004003),
        (3,): InstructionProperties(duration=35.5e-9, error=0.000614),
        (4,): InstructionProperties(duration=35.5e-9, error=0.006149),
    }
    ibm_target.add_instruction(SXGate(), sx_props)
    x_props = {
        (0,): InstructionProperties(duration=35.5e-9, error=0.000413),
        (1,): InstructionProperties(duration=35.5e-9, error=0.000502),
        (2,): InstructionProperties(duration=35.5e-9, error=0.0004003),
        (3,): InstructionProperties(duration=35.5e-9, error=0.000614),
        (4,): InstructionProperties(duration=35.5e-9, error=0.006149),
    }
    ibm_target.add_instruction(XGate(), x_props)
    cx_props = {
        (3, 4): InstructionProperties(duration=270.22e-9, error=0.00713),
        (4, 3): InstructionProperties(duration=305.77e-9, error=0.00713),
        (3, 1): InstructionProperties(duration=462.22e-9, error=0.00929),
        (1, 3): InstructionProperties(duration=497.77e-9, error=0.00929),
        (1, 2): InstructionProperties(duration=227.55e-9, error=0.00659),
        (2, 1): InstructionProperties(duration=263.11e-9, error=0.00659),
        (0, 1): InstructionProperties(duration=519.11e-9, error=0.01201),
        (1, 0): InstructionProperties(duration=554.66e-9, error=0.01201),
    }
    ibm_target.add_instruction(CXGate(), cx_props)
    measure_props = {
        (0,): InstructionProperties(duration=5.813e-6, error=0.0751),
        (1,): InstructionProperties(duration=5.813e-6, error=0.0225),
        (2,): InstructionProperties(duration=5.813e-6, error=0.0146),
        (3,): InstructionProperties(duration=5.813e-6, error=0.0215),
        (4,): InstructionProperties(duration=5.813e-6, error=0.0333),
    }
    ibm_target.add_instruction(Measure(), measure_props)
    ibm_target.add_instruction(IfElseOp, name="if_else")
    ibm_target.add_instruction(ForLoopOp, name="for_loop")
    ibm_target.add_instruction(WhileLoopOp, name="while_loop")
    ```

    The [`IfElseOp`](qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp"), [`ForLoopOp`](qiskit.circuit.ForLoopOp "qiskit.circuit.ForLoopOp"), and [`WhileLoopOp`](qiskit.circuit.WhileLoopOp "qiskit.circuit.WhileLoopOp") operations are globally supported for any number of qubits. This is then reflected by other calls in the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") API such as [`instruction_supported()`](qiskit.transpiler.Target#instruction_supported "qiskit.transpiler.Target.instruction_supported"):

    ```python
    ibm_target.instruction_supported(operation_class=WhileLoopOp, qargs=(0, 2, 3, 4))
    ibm_target.instruction_supported('if_else', qargs=(0, 1))
    ```

    both return `True`.

*   Added new primitive implementations, [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") and [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator"), to [`qiskit.primitives`](primitives#module-qiskit.primitives "qiskit.primitives"). Thes new primitive class implementation wrap a [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") or [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") instance as a [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") or [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator") respectively. The intended use case for these primitive implementations is to bridge the gap between providers that do not have native primitive implementations and use that provider’s backend with APIs that work with primitives. For example, the [`SamplingVQE`](qiskit.algorithms.minimum_eigensolvers.SamplingVQE "qiskit.algorithms.minimum_eigensolvers.SamplingVQE") class takes a [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") instance to function. If you’d like to run that class with a backend from a provider without a native primitive implementation you can construct a [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") to do this:

    ```python
    from qiskit.algorithms.minimum_eigensolvers import SamplingVQE
    from qiskit.algorithms.optimizers import SLSQP
    from qiskit.circuit.library import TwoLocal
    from qiskit.primitives import BackendSampler
    from qiskit.providers.fake_provider import FakeHanoi
    from qiskit.opflow import PauliSumOp
    from qiskit.quantum_info import SparsePauliOp

    backend = FakeHanoi()
    sampler = BackendSampler(backend=backend)

    operator = PauliSumOp(SparsePauliOp(["ZZ", "IZ", "II"], coeffs=[1, -0.5, 0.12]))
    ansatz = TwoLocal(rotation_blocks=["ry", "rz"], entanglement_blocks="cz")
    optimizer = SLSQP()
    sampling_vqe = SamplingVQE(sampler, ansatz, optimizer)
    result = sampling_vqe.compute_minimum_eigenvalue(operator)
    eigenvalue = result.eigenvalue
    ```

    If you’re using a provider that has native primitive implementations (such as `qiskit-ibm-runtime` or `qiskit-aer`) it is always a better choice to use that native primitive implementation instead of [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator") or [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") as the native implementations will be much more efficient and/or do additional pre and post processing. [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator") and [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") are designed to be generic that can work with any backend that returns [`Counts`](qiskit.result.Counts "qiskit.result.Counts") in their `Results` which precludes additional optimization.

*   Added a new algorithm class, [`AdaptVQE`](qiskit.algorithms.minimum_eigensolvers.AdaptVQE "qiskit.algorithms.minimum_eigensolvers.AdaptVQE") to [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") This algorithm uses a [`qiskit.algorithms.minimum_eigensolvers.VQE`](qiskit.algorithms.minimum_eigensolvers.VQE "qiskit.algorithms.minimum_eigensolvers.VQE") in combination with a pool of operators from which to build out an [`qiskit.circuit.library.EvolvedOperatorAnsatz`](qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz") adaptively. For example:

    ```python
    from qiskit.algorithms.minimum_eigensolvers import AdaptVQE, VQE
    from qiskit.algorithms.optimizers import SLSQP
    from qiskit.primitives import Estimator
    from qiskit.circuit.library import EvolvedOperatorAnsatz

    # get your Hamiltonian
    hamiltonian = ...

    # construct your ansatz
    ansatz = EvolvedOperatorAnsatz(...)

    vqe = VQE(Estimator(), ansatz, SLSQP())

    adapt_vqe = AdaptVQE(vqe)

    result = adapt_vqe.compute_minimum_eigenvalue(hamiltonian)
    ```

*   The [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") class now has support for two new optional hook points enabling backends to inject custom compilation steps as part of [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager"). If a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") implementation includes the methods `get_scheduling_stage_plugin()` or `get_translation_stage_plugin()` the transpiler will use the returned string as the default value for the `scheduling_method` and `translation_method` arguments. This enables backends to run additional custom transpiler passes when targetting that backend by leveraging the transpiler stage [`plugin`](transpiler_plugins#module-qiskit.transpiler.preset_passmanagers.plugin "qiskit.transpiler.preset_passmanagers.plugin") interface. For more details on how to use this see: [Custom Transpiler Passes](providers#custom-transpiler-backend).

*   Added a new keyword argument, `ignore_backend_supplied_default_methods`, to the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function which can be used to disable a backend’s custom selection of a default method if the target backend has `get_scheduling_stage_plugin()` or `get_translation_stage_plugin()` defined.

*   Added a `label` parameter to the [`Barrier`](qiskit.circuit.library.Barrier "qiskit.circuit.library.Barrier") class’s constructor and the [`barrier()`](qiskit.circuit.QuantumCircuit#barrier "qiskit.circuit.QuantumCircuit.barrier") method which allows a user to assign a label to an instance of the [`Barrier`](qiskit.circuit.library.Barrier "qiskit.circuit.library.Barrier") directive. For visualizations generated with [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") or [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") this label will be printed at the top of the `barrier`.

    ```python
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.h(1)
    circuit.barrier(label="After H")
    circuit.draw('mpl')
    ```

*   Add new gates [`CCZGate`](qiskit.circuit.library.CCZGate "qiskit.circuit.library.CCZGate"), [`CSGate`](qiskit.circuit.library.CSGate "qiskit.circuit.library.CSGate"), and [`CSdgGate`](qiskit.circuit.library.CSdgGate "qiskit.circuit.library.CSdgGate") to the standard gates in the Circuit Library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library")).

*   Added [`qiskit.algorithms.eigensolvers`](qiskit.algorithms.eigensolvers#module-qiskit.algorithms.eigensolvers "qiskit.algorithms.eigensolvers") package to include interfaces for primitive-enabled algorithms. This new module will eventually replace the previous `qiskit.algorithms.eigen_solvers`. This new module contains an alternative implementation of the [`VQD`](qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD") which instead of taking a backend or [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") instead takes an instance of [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator"), including [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator"), [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator"), or any provider implementations such as those as those present in `qiskit-ibm-runtime` and `qiskit-aer`.

    For example, to use the new implementation with an instance of [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator") class:

    ```python
    from qiskit.algorithms.eigensolvers import VQD
    from qiskit.algorithms.optimizers import SLSQP
    from qiskit.circuit.library import TwoLocal
    from qiskit.primitives import Sampler, Estimator
    from qiskit.algorithms.state_fidelities import ComputeUncompute
    from qiskit.opflow import PauliSumOp
    from qiskit.quantum_info import SparsePauliOp

    h2_op = PauliSumOp(SparsePauliOp(
        ["II", "IZ", "ZI", "ZZ", "XX"],
        coeffs=[
            -1.052373245772859,
            0.39793742484318045,
            -0.39793742484318045,
            -0.01128010425623538,
            0.18093119978423156,
        ],
    ))

    estimator = Estimator()
    ansatz = TwoLocal(rotation_blocks=["ry", "rz"], entanglement_blocks="cz")
    optimizer = SLSQP()
    fidelity = ComputeUncompute(Sampler())

    vqd = VQD(estimator, fidelity, ansatz, optimizer, k=2)
    result = vqd.compute_eigenvalues(h2_op)
    eigenvalues = result.eigenvalues
    ```

    Note that the evaluated auxillary operators are now obtained via the `aux_operators_evaluated` field on the results. This will consist of a list or dict of tuples containing the expectation values for these operators, as we well as the metadata from primitive run. `aux_operator_eigenvalues` is no longer a valid field.

*   Added new algorithms to calculate state fidelities/overlaps for pairs of quantum circuits (that can be parametrized). Apart from the base class ([`BaseStateFidelity`](qiskit.algorithms.state_fidelities.BaseStateFidelity "qiskit.algorithms.state_fidelities.BaseStateFidelity")) which defines the interface, there is an implementation of the compute-uncompute method that leverages instances of the [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") primitive: [`qiskit.algorithms.state_fidelities.ComputeUncompute`](qiskit.algorithms.state_fidelities.ComputeUncompute "qiskit.algorithms.state_fidelities.ComputeUncompute").

    For example:

    ```python
    import numpy as np
    from qiskit.primitives import Sampler
    from qiskit.algorithms.state_fidelities import ComputeUncompute
    from qiskit.circuit.library import RealAmplitudes

    sampler = Sampler(...)
    fidelity = ComputeUncompute(sampler)
    circuit = RealAmplitudes(2)
    values = np.random.random(circuit.num_parameters)
    shift = np.ones_like(values) * 0.01

    job = fidelity.run([circuit], [circuit], [values], [values+shift])
    fidelities = job.result().fidelities
    ```

*   Added a new module [`qiskit.algorithms.gradients`](qiskit.algorithms.gradients#module-qiskit.algorithms.gradients "qiskit.algorithms.gradients") that contains classes which are used to compute gradients using the primitive interfaces defined in [`qiskit.primitives`](primitives#module-qiskit.primitives "qiskit.primitives"). There are 4 types of gradient classes: Finite Difference, Parameter Shift, Linear Combination of Unitary, and SPSA with implementations that either use an instance of the [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator") interface:

    > *   [`ParamShiftEstimatorGradient`](qiskit.algorithms.gradients.ParamShiftEstimatorGradient "qiskit.algorithms.gradients.ParamShiftEstimatorGradient")
    > *   [`LinCombEstimatorGradient`](qiskit.algorithms.gradients.LinCombEstimatorGradient "qiskit.algorithms.gradients.LinCombEstimatorGradient")
    > *   [`FiniteDiffEstimatorGradient`](qiskit.algorithms.gradients.FiniteDiffEstimatorGradient "qiskit.algorithms.gradients.FiniteDiffEstimatorGradient")
    > *   [`SPSAEstimatorGradient`](qiskit.algorithms.gradients.SPSAEstimatorGradient "qiskit.algorithms.gradients.SPSAEstimatorGradient")

    or an instance of the [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") interface:

    > *   [`ParamShiftSamplerGradient`](qiskit.algorithms.gradients.ParamShiftSamplerGradient "qiskit.algorithms.gradients.ParamShiftSamplerGradient")
    > *   [`LinCombSamplerGradient`](qiskit.algorithms.gradients.LinCombSamplerGradient "qiskit.algorithms.gradients.LinCombSamplerGradient")
    > *   [`FiniteDiffSamplerGradient`](qiskit.algorithms.gradients.FiniteDiffSamplerGradient "qiskit.algorithms.gradients.FiniteDiffSamplerGradient")
    > *   [`SPSASamplerGradient`](qiskit.algorithms.gradients.SPSASamplerGradient "qiskit.algorithms.gradients.SPSASamplerGradient")

    The estimator-based gradients compute the gradient of expectation values, while the sampler-based gradients return gradients of the measurement outcomes (also referred to as “probability gradients”).

    For example:

    ```python
    estimator = Estimator(...)
    gradient = ParamShiftEstimatorGradient(estimator)
    job = gradient.run(circuits, observables, parameters)
    gradients = job.result().gradients
    ```

*   The [`Grover`](qiskit.algorithms.Grover "qiskit.algorithms.Grover") class has a new keyword argument, `sampler` which is used to run the algorithm using an instance of the [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") interface to calculate the results. This new argument supersedes the the `quantum_instance` argument and accordingly, `quantum_instance` is pending deprecation and will be deprecated and subsequently removed in future releases.

    Example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.primitives import Sampler
    from qiskit.algorithms import Grover, AmplificationProblem

    sampler = Sampler()
    oracle = QuantumCircuit(2)
    oracle.cz(0, 1)
    problem = AmplificationProblem(oracle, is_good_state=["11"])
    grover = Grover(sampler=sampler)
    result = grover.amplify(problem)
    ```

*   A new option, `"formatter.control.fill_waveform"` has been added to the pulse drawer (`pulse_v2.draw()` and [`Schedule.draw()`](qiskit.pulse.Schedule#draw "qiskit.pulse.Schedule.draw")) style sheets. This option can be used to remove the face color of pulses in the output visualization which allows for drawing pulses only with lines.

    For example:

    ```python
    from qiskit.visualization.pulse_v2 import IQXStandard

    my_style = IQXStandard(
        **{"formatter.control.fill_waveform": False, "formatter.line_width.fill_waveform": 2}
    )

    my_sched.draw(style=my_style)
    ```

*   Added a new transpiler pass, [`ResetAfterMeasureSimplification`](qiskit.transpiler.passes.ResetAfterMeasureSimplification "qiskit.transpiler.passes.ResetAfterMeasureSimplification"), which is used to replace a [`Reset`](qiskit.circuit.library.Reset "qiskit.circuit.library.Reset") operation after a [`Measure`](qiskit.circuit.library.Measure "qiskit.circuit.library.Measure") with a conditional [`XGate`](qiskit.circuit.library.XGate "qiskit.circuit.library.XGate"). This pass can be used on backends where a [`Reset`](qiskit.circuit.library.Reset "qiskit.circuit.library.Reset") operation is performed by doing a measurement and then a conditional X gate so that this will remove the duplicate implicit [`Measure`](qiskit.circuit.library.Measure "qiskit.circuit.library.Measure") from the [`Reset`](qiskit.circuit.library.Reset "qiskit.circuit.library.Reset") operation. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.transpiler.passes import ResetAfterMeasureSimplification

    qc = QuantumCircuit(1)
    qc.measure_all()
    qc.reset(0)
    qc.draw('mpl')
    ```

    ```python
    result = ResetAfterMeasureSimplification()(qc)
    result.draw('mpl')
    ```

*   Added a new supported value, `"reverse_linear"` for the `entanglement` keyword argument to the constructor for the [`NLocal`](qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") circuit class. For [`TwoLocal`](qiskit.circuit.library.TwoLocal "qiskit.circuit.library.TwoLocal") circuits (which are subclassess of [`NLocal`](qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal")), if `entanglement_blocks="cx"` then using `entanglement="reverse_linear"` provides an equivalent n-qubit circuit as `entanglement="full"` but with only $n-1$ [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") gates, instead of $\frac{n(n-1)}{2}$.

*   [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") has been updated so that it can manage unassigned subroutine, in other words, to allow lazy calling of other programs. For example, this enables the following workflow:

    ```python
    from qiskit import pulse

    with pulse.build() as prog:
      pulse.reference("x", "q0")

    with pulse.build() as xq0:
      pulse.play(Gaussian(160, 0.1, 40), pulse.DriveChannel(0))

    prog.assign_references({("x", "q0"): xq0})
    ```

    Now a user can create `prog` without knowing actual implementation of the reference `("x", "q0")`, and assign it at a later time for execution. This improves modularity of pulse programs, and thus one can easily write a template pulse program relying on other calibrations.

    To realize this feature, the new pulse instruction (compiler directive) [`Reference`](qiskit.pulse.instructions.Reference "qiskit.pulse.instructions.Reference") has been added. This instruction is injected into the current builder scope when the [`reference()`](pulse#qiskit.pulse.builder.reference "qiskit.pulse.builder.reference") command is used. All references defined in the current pulse program can be listed with the `references` property.

    In addition, every reference is managed with a scope to ease parameter management. [`scoped_parameters()`](qiskit.pulse.ScheduleBlock#scoped_parameters "qiskit.pulse.ScheduleBlock.scoped_parameters") and [`search_parameters()`](qiskit.pulse.ScheduleBlock#search_parameters "qiskit.pulse.ScheduleBlock.search_parameters") have been added to [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"). See API documentation for more details.

*   Added a new method [`SparsePauliOp.argsort()`](qiskit.quantum_info.SparsePauliOp#argsort "qiskit.quantum_info.SparsePauliOp.argsort"), which returns the composition of permutations in the order of sorting by coefficient and sorting by Pauli. By using the `weight` keyword argument for the method the output can additionally be sorted by the number of non-identity terms in the Pauli, where the set of all Paulis of a given weight are still ordered lexicographically.

*   Added a new method [`SparsePauliOp.sort()`](qiskit.quantum_info.SparsePauliOp#sort "qiskit.quantum_info.SparsePauliOp.sort"), which will first sort the coefficients using numpy’s `argsort()` and then sort by Pauli, where the Pauli sort takes precedence. If the Pauli sort is the same, it will then be sorted by coefficient. By using the `weight` keyword argument the output can additionally be sorted by the number of non-identity terms in the Pauli, where the set of all Paulis of a given weight are still ordered lexicographically.

*   Added a new keyword argument, `wire_order`, to the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method which allows arbitrarily reordering both the quantum and classical bits in the output visualization. For example:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister

    qr = QuantumRegister(4, "q")
    cr = ClassicalRegister(4, "c")
    cr2 = ClassicalRegister(2, "ca")
    circuit = QuantumCircuit(qr, cr, cr2)
    circuit.h(0)
    circuit.h(3)
    circuit.x(1)
    circuit.x(3).c_if(cr, 10)
    circuit.draw('mpl', cregbundle=False, wire_order=[2, 1, 3, 0, 6, 8, 9, 5, 4, 7])
    ```

*   Added support for the [`CSGate`](qiskit.circuit.library.CSGate "qiskit.circuit.library.CSGate"), [`CSdgGate`](qiskit.circuit.library.CSdgGate "qiskit.circuit.library.CSdgGate") and [`CCZGate`](qiskit.circuit.library.CCZGate "qiskit.circuit.library.CCZGate") classes to the constructor for the operator class [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral "qiskit.quantum_info.CNOTDihedral"). The input circuits when creating a [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral "qiskit.quantum_info.CNOTDihedral") operator will now support circuits using these gates. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import CNOTDihedral

    qc = QuantumCircuit(2)
    qc.t(0)
    qc.cs(0, 1)
    qc.tdg(0)
    operator = CNOTDihedral(qc)
    ```

*   The amplitude estimation algorithm classes:

    > *   [`AmplitudeEstimation`](qiskit.algorithms.AmplitudeEstimation "qiskit.algorithms.AmplitudeEstimation"),
    > *   [`FasterAmplitudeEstimation`](qiskit.algorithms.FasterAmplitudeEstimation "qiskit.algorithms.FasterAmplitudeEstimation"),
    > *   [`IterativeAmplitudeEstimation`](qiskit.algorithms.IterativeAmplitudeEstimation "qiskit.algorithms.IterativeAmplitudeEstimation"),
    > *   [`MaximumLikelihoodAmplitudeEstimation`](qiskit.algorithms.MaximumLikelihoodAmplitudeEstimation "qiskit.algorithms.MaximumLikelihoodAmplitudeEstimation")

    Now have a new keyword argument, `sampler` on their constructor that takes an instance of an object that implements the [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") interface including [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler"), `Sampler`, or any provider implementations such as those as those present in qiskit-ibm-runtime and qiskit-aer. This provides an alternative to using the `quantum_instance` argument to set the target [`Backend`](qiskit.providers.Backend "qiskit.providers.Backend") or [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") to run the algorithm on. Using a [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") is pending deprecation and will be deprecated in a future release.

*   Added a new class, [`BackendV2Converter`](qiskit.providers.BackendV2Converter "qiskit.providers.BackendV2Converter"), which is used to wrap a [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") instance in a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") interface. It enables you to have a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") instance from any [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1"). This enables standardizing access patterns on the newer [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") interface even if you still support [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1").

*   Added a new function [`convert_to_target()`](qiskit.providers.convert_to_target "qiskit.providers.convert_to_target") which is used to take a [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration"), and optionally a [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") and [`PulseDefaults`](qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") and create a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object equivalent to the contents of those objects.

*   `qiskit.quantum_info.BaseOperator` subclasses (such as [`ScalarOp`](qiskit.quantum_info.ScalarOp "qiskit.quantum_info.ScalarOp"), [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") and [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList")) can now be used with the built-in Python `sum()` function.

*   A new transpiler pass, [`ConvertConditionsToIfOps`](qiskit.transpiler.passes.ConvertConditionsToIfOps "qiskit.transpiler.passes.ConvertConditionsToIfOps") was added, which can be used to convert old-style [`Instruction.c_if()`](qiskit.circuit.Instruction#c_if "qiskit.circuit.Instruction.c_if")-conditioned instructions into [`IfElseOp`](qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp") objects. This is to help ease the transition from the old type to the new type for backends. For most users, there is no need to add this to your pass managers, and it is not included in any preset pass managers.

*   Refactored gate commutativity analysis into a class [`CommutationChecker`](qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker"). This class allows you to check (based on matrix multiplication) whether two gates commute or do not commute, and to cache the results (so that a similar check in the future will no longer require matrix multiplication).

    For example we can now do:

    ```python
    from qiskit.circuit import QuantumRegister, CommutationChecker

    comm_checker = CommutationChecker()
    qr = QuantumRegister(4)

    res = comm_checker.commute(CXGate(), [qr[1], qr[0]], [], CXGate(), [qr[1], qr[2]], [])
    ```

    As the two CX gates commute (the first CX gate is over qubits `qr[1]` and `qr[0]`, and the second CX gate is over qubits `qr[1]` and `qr[2]`), we will have that `res` is `True`.

    This commutativity checking is over-conservative for conditional and parameterized gates, and may return `False` even when such gates commute.

*   Added a new transpiler pass [`CommutativeInverseCancellation`](qiskit.transpiler.passes.CommutativeInverseCancellation "qiskit.transpiler.passes.CommutativeInverseCancellation") that cancels pairs of inverse gates exploiting commutation relations between gates. This pass is a generalization of the transpiler pass [`InverseCancellation`](qiskit.transpiler.passes.InverseCancellation "qiskit.transpiler.passes.InverseCancellation") as it detects a larger set of inverse gates, and as it takes commutativity into account. The pass also avoids some problems associated with the transpiler pass [`CommutativeCancellation`](qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation").

    For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import CommutativeInverseCancellation

    circuit = QuantumCircuit(2)
    circuit.z(0)
    circuit.x(1)
    circuit.cx(0, 1)
    circuit.z(0)
    circuit.x(1)

    passmanager = PassManager(CommutativeInverseCancellation())
    new_circuit = passmanager.run(circuit)
    ```

    cancels the pair of self-inverse Z-gates, and the pair of self-inverse X-gates (as the relevant gates commute with the CX-gate), producing a circuit consisting of a single CX-gate.

    The inverse checking is over-conservative for conditional and parameterized gates, and may not cancel some of such gates.

*   [`QuantumCircuit.compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") will now accept an operand with classical bits if the base circuit has none itself. The pattern of composing a circuit with measurements onto a quantum-only circuit is now valid. For example:

    ```python
    from qiskit import QuantumCircuit

    base = QuantumCircuit(3)
    terminus = QuantumCircuit(3, 3)
    terminus.measure_all()

    # This will now succeed, though it was previously a CircuitError.
    base.compose(terminus)
    ```

*   The [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") methods [`depth()`](qiskit.dagcircuit.DAGCircuit#depth "qiskit.dagcircuit.DAGCircuit.depth") and [`size()`](qiskit.dagcircuit.DAGCircuit#size "qiskit.dagcircuit.DAGCircuit.size") have a new `recurse` keyword argument for use with circuits that contain control-flow operations (such as [`IfElseOp`](qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp"), [`WhileLoopOp`](qiskit.circuit.WhileLoopOp "qiskit.circuit.WhileLoopOp"), and [`ForLoopOp`](qiskit.circuit.ForLoopOp "qiskit.circuit.ForLoopOp")). By default this is `False` and will raise an error if control-flow operations are present, to avoid poorly defined results. If set to `True`, a proxy value that attempts to fairly weigh each control-flow block relative to its condition is returned, even though the depth or size of a concrete run is generally unknowable. See each method’s documentation for how each control-flow operation affects the output.

*   [`DAGCircuit.count_ops()`](qiskit.dagcircuit.DAGCircuit#count_ops "qiskit.dagcircuit.DAGCircuit.count_ops") gained a `recurse` keyword argument for recursing into control-flow blocks. By default this is `True`, and all operations in all blocks will be returned, as well as the control-flow operations themselves.

*   Added an argument `create_preds_and_succs` to the functions [`circuit_to_dagdependency()`](converters#qiskit.converters.circuit_to_dagdependency "qiskit.converters.circuit_to_dagdependency") and [`dag_to_dagdependency()`](converters#qiskit.converters.dag_to_dagdependency "qiskit.converters.dag_to_dagdependency") that convert from [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit"), respectively, to [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency"). When the value of `create_preds_and_succs` is False, the transitive predecessors and successors for nodes in [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") are not constructed, making the conversions faster and significantly less memory-intensive. The direct predecessors and successors for nodes in [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") are constructed as usual.

    For example:

    ```python
    from qiskit.converters import circuit_to_dagdependency
    from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

    circuit_in = QuantumCircuit(2)
    circuit_in.h(qr[0])
    circuit_in.h(qr[1])

    dag_dependency = circuit_to_dagdependency(circuit_in, create_preds_and_succs=False)
    ```

*   Added new attributes [`Clifford.symplectic_matrix`](qiskit.quantum_info.Clifford#symplectic_matrix "qiskit.quantum_info.Clifford.symplectic_matrix"), `Clifford.tableau`, [`Clifford.z`](qiskit.quantum_info.Clifford#z "qiskit.quantum_info.Clifford.z"), [`Clifford.x`](qiskit.quantum_info.Clifford#x "qiskit.quantum_info.Clifford.x"), [`Clifford.phase`](qiskit.quantum_info.Clifford#phase "qiskit.quantum_info.Clifford.phase"), [`Clifford.stab`](qiskit.quantum_info.Clifford#stab "qiskit.quantum_info.Clifford.stab"), [`Clifford.stab_z`](qiskit.quantum_info.Clifford#stab_z "qiskit.quantum_info.Clifford.stab_z"), [`Clifford.stab_x`](qiskit.quantum_info.Clifford#stab_x "qiskit.quantum_info.Clifford.stab_x"), [`Clifford.stab_phase`](qiskit.quantum_info.Clifford#stab_phase "qiskit.quantum_info.Clifford.stab_phase"), [`Clifford.destab`](qiskit.quantum_info.Clifford#destab "qiskit.quantum_info.Clifford.destab"), [`Clifford.destab_z`](qiskit.quantum_info.Clifford#destab_z "qiskit.quantum_info.Clifford.destab_z"), [`Clifford.destab_x`](qiskit.quantum_info.Clifford#destab_x "qiskit.quantum_info.Clifford.destab_x"), [`Clifford.destab_phase`](qiskit.quantum_info.Clifford#destab_phase "qiskit.quantum_info.Clifford.destab_phase") to the [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") class. These can be used instead of `Clifford.table`, that will be deprecated in the future. `StabilizerTable` and `PauliTable` are pending deprecation and will be deprecated in the future release and subsequently removed after that.

*   The [`Commuting2qGateRouter`](qiskit.transpiler.passes.Commuting2qGateRouter "qiskit.transpiler.passes.Commuting2qGateRouter") constructor now has a new keyword argument, `edge_coloring`. This argument is used to provide an edge coloring of the coupling map to determine the order in which the commuting gates are applied.

*   Added a new algorithms interface for creating time evolution algorithms using the primitives [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") and [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator"). This new interface consists of:

    > *   [`TimeEvolutionProblem`](qiskit.algorithms.TimeEvolutionProblem "qiskit.algorithms.TimeEvolutionProblem")
    > *   [`TimeEvolutionResult`](qiskit.algorithms.TimeEvolutionResult "qiskit.algorithms.TimeEvolutionResult")
    > *   [`ImaginaryTimeEvolver`](qiskit.algorithms.ImaginaryTimeEvolver "qiskit.algorithms.ImaginaryTimeEvolver")
    > *   [`RealTimeEvolver`](qiskit.algorithms.RealTimeEvolver "qiskit.algorithms.RealTimeEvolver")

    This new interface is an alternative to the previously existing time evolution algorithms interface available defined with [`EvolutionProblem`](qiskit.algorithms.EvolutionProblem "qiskit.algorithms.EvolutionProblem"), [`EvolutionResult`](qiskit.algorithms.EvolutionResult "qiskit.algorithms.EvolutionResult"), [`RealEvolver`](qiskit.algorithms.RealEvolver "qiskit.algorithms.RealEvolver"), and [`ImaginaryEvolver`](qiskit.algorithms.ImaginaryEvolver "qiskit.algorithms.ImaginaryEvolver") which worked with a [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") object instead of primitives. This new interface supersedes the previous interface which will eventually be deprecated and subsequently removed in future releases.

*   Added new backend classes to [`qiskit.providers.fake_provider`](providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider"):

    > *   [`FakeAuckland`](qiskit.providers.fake_provider.FakeAuckland "qiskit.providers.fake_provider.FakeAuckland")
    > *   [`FakeOslo`](qiskit.providers.fake_provider.FakeOslo "qiskit.providers.fake_provider.FakeOslo")
    > *   [`FakeGeneva`](qiskit.providers.fake_provider.FakeGeneva "qiskit.providers.fake_provider.FakeGeneva")
    > *   [`FakePerth`](qiskit.providers.fake_provider.FakePerth "qiskit.providers.fake_provider.FakePerth")

    These new classes implement the [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") interface and are created using stored snapshots of the backend information from the IBM Quantum systems `ibm_auckland`, `ibm_oslo`, `ibm_geneva`, and `ibm_perth` systems respectively.

*   The [`Z2Symmetries`](qiskit.opflow.primitive_ops.Z2Symmetries "qiskit.opflow.primitive_ops.Z2Symmetries") class has two new methods, [`convert_clifford()`](qiskit.opflow.primitive_ops.Z2Symmetries#convert_clifford "qiskit.opflow.primitive_ops.Z2Symmetries.convert_clifford") and [`taper_clifford()`](qiskit.opflow.primitive_ops.Z2Symmetries#taper_clifford "qiskit.opflow.primitive_ops.Z2Symmetries.taper_clifford"). These two methods are the two operations necessary for taperng an operator based on the Z2 symmetries in the object and were previously performed internally via the [`taper()`](qiskit.opflow.primitive_ops.Z2Symmetries#taper "qiskit.opflow.primitive_ops.Z2Symmetries.taper") method. However, these methods are now public methods of the class which can be called individually if needed.

*   The runtime performance for conjugation of a long [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") object by a [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") using the [`PauliList.evolve()`](qiskit.quantum_info.PauliList#evolve "qiskit.quantum_info.PauliList.evolve") has significantly improved. It will now run significantly faster than before.

*   Added a new abstract class `ClassicalIOChannel` to the [`qiskit.pulse.channels`](pulse#module-qiskit.pulse.channels "qiskit.pulse.channels") module. This class is used to represent classical I/O channels and differentiate these channels from other subclasses of [`Channel`](pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel"). This new class is the base class for the [`MemorySlot`](qiskit.pulse.channels.MemorySlot "qiskit.pulse.channels.MemorySlot"), [`RegisterSlot`](qiskit.pulse.channels.RegisterSlot "qiskit.pulse.channels.RegisterSlot"), and [`SnapshotChannel`](qiskit.pulse.channels.SnapshotChannel "qiskit.pulse.channels.SnapshotChannel") classes. Accordingly, the [`pad()`](pulse#qiskit.pulse.transforms.pad "qiskit.pulse.transforms.pad") canonicalization pulse transform in [`qiskit.pulse.transforms`](pulse#module-qiskit.pulse.transforms "qiskit.pulse.transforms") will not introduce delays to any instances of `ClassicalIOChannel`

*   The [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") transpiler pass has a new keyword argument on its constructor, `trials`. The `trials` argument is used to specify the number of random seed trials to attempt. The output from the [SABRE algorithm](https://arxiv.org/abs/1809.02573) can differ greatly based on the seed used for the random number. [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") will now run the algorithm with `trials` number of random seeds and pick the best (with the fewest swaps inserted). If `trials` is not specified the pass will default to use the number of physical CPUs on the local system.

*   The [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") transpiler pass has a new keyword argument on its constructor, `swap_trials`. The `swap_trials` argument is used to specify how many random seed trials to run on the [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") pass internally. It corresponds to the `trials` arugment on the [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") pass. When set, each iteration of [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") will be run internally `swap_trials` times. If `swap_trials` is not specified the will default to use the number of physical CPUs on the local system.

*   Added a new function, [`estimate_observables()`](algorithms#qiskit.algorithms.estimate_observables "qiskit.algorithms.estimate_observables") which uses an implementation of the [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator") interface (e.g. [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator"), [`BackendEstimator`](qiskit.primitives.BackendEstimator "qiskit.primitives.BackendEstimator"), or any provider implementations such as those as those present in `qiskit-ibm-runtime` and `qiskit-aer`) to calculate the expectation values, their means and standard deviations from a list or dictionary of observables. This serves a similar purpose to the pre-existing function [`eval_observables()`](algorithms#qiskit.algorithms.eval_observables "qiskit.algorithms.eval_observables") which performed the calculation using a [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") object and has been superseded (and will be deprecated and subsequently removed in future releases) by this new function.

*   Added a new [`Operation`](qiskit.circuit.Operation "qiskit.circuit.Operation") base class which provides a lightweight abstract interface for objects that can be put on [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). This allows to store “higher-level” objects directly on a circuit (for instance, [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") objects), to directly combine such objects (for instance, to compose several consecutive [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") objects over the same qubits), and to synthesize such objects at run time (for instance, to synthesize [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") in a way that optimizes depth and/or exploits device connectivity). Previously, only subclasses of [`qiskit.circuit.Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") could be put on [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"), but this interface has become unwieldy and includes too many methods and attributes for general-purpose objects.

    The new [`Operation`](qiskit.circuit.Operation "qiskit.circuit.Operation") interface includes `name`, `num_qubits` and `num_clbits` (in the future this may be slightly adjusted), but importantly does not include `definition` (and thus does not tie synthesis to the object), does not include `condition` (this should be part of separate classical control flow), and does not include `duration` and `unit` (as these are properties of the output of the transpiler).

    As of now, [`Operation`](qiskit.circuit.Operation "qiskit.circuit.Operation") includes [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate"), [`Reset`](qiskit.circuit.library.Reset "qiskit.circuit.library.Reset"), [`Barrier`](qiskit.circuit.library.Barrier "qiskit.circuit.library.Barrier"), [`Measure`](qiskit.circuit.library.Measure "qiskit.circuit.library.Measure"), and “higher-level” objects such as [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford"). This list of “higher-level” objects will grow in the future.

*   A [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") is now added to a quantum circuit as an [`Operation`](qiskit.circuit.Operation "qiskit.circuit.Operation"), without first synthesizing a subcircuit implementing this Clifford. The actual synthesis is postponed to a later [`HighLevelSynthesis`](qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpilation pass.

    For example, the following code:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import random_clifford

    qc = QuantumCircuit(3)
    cliff = random_clifford(2)
    qc.append(cliff, [0, 1])
    ```

    no longer converts `cliff` to [`qiskit.circuit.Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction"), which includes synthesizing the clifford into a circuit, when it is appended to `qc`.

*   Added a new transpiler pass [`OptimizeCliffords`](qiskit.transpiler.passes.OptimizeCliffords "qiskit.transpiler.passes.OptimizeCliffords") that collects blocks of consecutive [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") objects in a circuit, and replaces each block with a single [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford").

    For example, the following code:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import random_clifford
    from qiskit.transpiler.passes import OptimizeCliffords
    from qiskit.transpiler import PassManager

    qc = QuantumCircuit(3)
    cliff1 = random_clifford(2)
    cliff2 = random_clifford(2)
    qc.append(cliff1, [2, 1])
    qc.append(cliff2, [2, 1])
    qc_optimized = PassManager(OptimizeCliffords()).run(qc)
    ```

    first stores the two Cliffords `cliff1` and `cliff2` on `qc` as “higher-level” objects, and then the transpiler pass [`OptimizeCliffords`](qiskit.transpiler.passes.OptimizeCliffords "qiskit.transpiler.passes.OptimizeCliffords") optimizes the circuit by composing these two Cliffords into a single Clifford. Note that the resulting Clifford is still stored on `qc` as a higher-level object. This pass is not yet included in any of preset pass managers.

*   Added a new transpiler pass [`HighLevelSynthesis`](qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") that synthesizes higher-level objects (for instance, [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") objects).

    For example, the following code:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import random_clifford
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import HighLevelSynthesis

    qc = QuantumCircuit(3)
    qc.h(0)
    cliff = random_clifford(2)
    qc.append(cliff, [0, 1])

    qc_synthesized = PassManager(HighLevelSynthesis()).run(qc)
    ```

    will synthesize the higher-level Clifford stored in `qc` using the default [`decompose_clifford()`](quantum_info#qiskit.quantum_info.decompose_clifford "qiskit.quantum_info.decompose_clifford") function.

    This new transpiler pass [`HighLevelSynthesis`](qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") is integrated into the preset pass managers, running right after [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") pass. Thus, [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") will synthesize all higher-level Cliffords present in the circuit.

    It is important to note that the work done to store [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") objects as “higher-level” objects and to transpile these objects using [`HighLevelSynthesis`](qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") pass should be completely transparent, and no code changes are required.

*   [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp")s can now be constructed with coefficient arrays that are general Python objects. This is intended for use with [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects; other objects may work, but do not have first-class support. Some [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") methods (such as conversion to other class representations) may not work when using `object` arrays, if the desired target cannot represent these general arrays.

    For example, a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") could be constructed by:

    ```python
    import numpy as np
    from qiskit.circuit import Parameter
    from qiskit.quantum_info import SparsePauliOp

    print(SparsePauliOp(["II", "XZ"], np.array([Parameter("a"), Parameter("b")])))
    ```

    which gives

    ```python
    SparsePauliOp(['II', 'XZ'],
          coeffs=[ParameterExpression(1.0*a), ParameterExpression(1.0*b)])
    ```

*   Added a new function [`plot_distribution()`](qiskit.visualization.plot_distribution "qiskit.visualization.plot_distribution") for plotting distributions over quasi-probabilities. This is suitable for `Counts`, `QuasiDistribution` and `ProbDistribution`. Raw dict can be passed as well. For example:

    ```python
    from qiskit.visualization import plot_distribution

    quasi_dist = {'0': .98, '1': -.01}
    plot_distribution(quasi_dist)
    ```

*   Introduced a new high level synthesis plugin interface which is used to enable using alternative synthesis techniques included in external packages seamlessly with the [`HighLevelSynthesis`](qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass. These alternative synthesis techniques can be specified for any “higher-level” objects of type [`Operation`](qiskit.circuit.Operation "qiskit.circuit.Operation"), as for example for [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") and [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") objects. This plugin interface is similar to the one for unitary synthesis. In the latter case, the details on writing a new plugin appear in the [`qiskit.transpiler.passes.synthesis.plugin`](transpiler_synthesis_plugins#module-qiskit.transpiler.passes.synthesis.plugin "qiskit.transpiler.passes.synthesis.plugin") module documentation.

*   Introduced a new class `HLSConfig` which can be used to specify alternative synthesis algorithms for “higher-level” objects of type [`Operation`](qiskit.circuit.Operation "qiskit.circuit.Operation"). For each higher-level object of interest, an object `HLSConfig` specifies a list of synthesis methods and their arguments. This object can be passed to [`HighLevelSynthesis`](qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass or specified as a parameter `hls_config` in [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile").

    As an example, let us assume that `op_a` and `op_b` are names of two higher-level objects, that `op_a`-objects have two synthesis methods `default` which does require any additional parameters and `other` with two optional integer parameters `option_1` and `option_2`, that `op_b`-objects have a single synthesis method `default`, and `qc` is a quantum circuit containing `op_a` and `op_b` objects. The following code snippet:

    ```python
    hls_config = HLSConfig(op_b=[("other", {"option_1": 7, "option_2": 4})])
    pm = PassManager([HighLevelSynthesis(hls_config=hls_config)])
    transpiled_qc = pm.run(qc)
    ```

    shows how to run the alternative synthesis method `other` for `op_b`-objects, while using the `default` methods for all other high-level objects, including `op_a`-objects.

*   Added new methods for executing primitives: [`BaseSampler.run()`](qiskit.primitives.BaseSampler#run "qiskit.primitives.BaseSampler.run") and [`BaseEstimator.run()`](qiskit.primitives.BaseEstimator#run "qiskit.primitives.BaseEstimator.run"). These methods execute asynchronously and return [`JobV1`](qiskit.providers.JobV1 "qiskit.providers.JobV1") objects which provide a handle to the exections. These new run methods can be passed [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects (and observables for [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator")) that are not registered in the constructor. For example:

    ```python
    estimator = Estimator()
    result = estimator.run(circuits, observables, parameter_values).result()
    ```

    This provides an alternative to the previous execution model (which is now deprecated) for the [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") and [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator") primitives which would take all the inputs via the constructor and calling the primitive object with the combination of those input parameters to use in the execution.

*   Added `shots` option for reference implementations of primitives. Random numbers can be fixed by giving `seed_primitive`. For example:

    ```python
    from qiskit.primitives import Sampler
    from qiskit import QuantumCircuit

    bell = QuantumCircuit(2)
    bell.h(0)
    bell.cx(0, 1)
    bell.measure_all()

    with Sampler(circuits=[bell]) as sampler:
        result = sampler(circuits=[0], shots=1024, seed_primitive=15)
        print([q.binary_probabilities() for q in result.quasi_dists])
    ```

*   The constructors for the [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") and [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator") primitive classes have a new optional keyword argument, `options` which is used to set the default values for the options exposed via the [`options`](qiskit.primitives.BaseSampler#options "qiskit.primitives.BaseSampler.options") attribute.

*   Added the [`PVQD`](qiskit.algorithms.PVQD "qiskit.algorithms.PVQD") class to the time evolution framework in [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms"). This class implements the projected Variational Quantum Dynamics (p-VQD) algorithm [Barison et al.](https://quantum-journal.org/papers/q-2021-07-28-512/).

    In each timestep this algorithm computes the next state with a Trotter formula and projects it onto a variational form. The projection is determined by maximizing the fidelity of the Trotter-evolved state and the ansatz, using a classical optimization routine.

    ```python
    import numpy as np

    from qiskit.algorithms.state_fidelities import ComputeUncompute
    from qiskit.algorithms.evolvers import EvolutionProblem
    from qiskit.algorithms.time_evolvers.pvqd import PVQD
    from qiskit.primitives import Estimator, Sampler
    from qiskit import BasicAer
    from qiskit.circuit.library import EfficientSU2
    from qiskit.quantum_info import Pauli, SparsePauliOp
    from qiskit.algorithms.optimizers import L_BFGS_B

    sampler = Sampler()
    fidelity = ComputeUncompute(sampler)
    estimator = Estimator()
    hamiltonian = 0.1 * SparsePauliOp([Pauli("ZZ"), Pauli("IX"), Pauli("XI")])
    observable = Pauli("ZZ")
    ansatz = EfficientSU2(2, reps=1)
    initial_parameters = np.zeros(ansatz.num_parameters)

    time = 1
    optimizer = L_BFGS_B()

    # setup the algorithm
    pvqd = PVQD(
        fidelity,
        ansatz,
        initial_parameters,
        estimator,
        num_timesteps=100,
        optimizer=optimizer,
    )

    # specify the evolution problem
    problem = EvolutionProblem(
        hamiltonian, time, aux_operators=[hamiltonian, observable]
    )

    # and evolve!
    result = pvqd.evolve(problem)
    ```

*   The [`QNSPSA.get_fidelity()`](qiskit.algorithms.optimizers.QNSPSA#get_fidelity "qiskit.algorithms.optimizers.QNSPSA.get_fidelity") static method now supports an optional `sampler` argument which is used to provide an implementation of the [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") interface (such as [`Sampler`](qiskit.primitives.Sampler "qiskit.primitives.Sampler"), [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler"), or any provider implementations such as those present in `qiskit-ibm-runtime` and `qiskit-aer`) to compute the fidelity of a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). For example:

    ```python
    from qiskit.primitives import Sampler
    from qiskit.algorithms.optimizers import QNSPSA

    fidelity = QNSPSA.get_fidelity(my_circuit, Sampler())
    ```

*   Added a new keyword argument `sampler` to the constructors of the phase estimation classes:

    > *   [`IterativePhaseEstimation`](qiskit.algorithms.IterativePhaseEstimation "qiskit.algorithms.IterativePhaseEstimation")
    > *   [`PhaseEstimation`](qiskit.algorithms.PhaseEstimation "qiskit.algorithms.PhaseEstimation")
    > *   [`HamiltonianPhaseEstimation`](qiskit.algorithms.HamiltonianPhaseEstimation "qiskit.algorithms.HamiltonianPhaseEstimation")

    This argument is used to provide an implementation of the [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") interface such as [`Sampler`](qiskit.primitives.Sampler "qiskit.primitives.Sampler"), [`BackendSampler`](qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler"), or any provider implementations such as those as those present in `qiskit-ibm-runtime` and `qiskit-aer`.

    For example:

    ```python
    from qiskit.primitives import Sampler
    from qiskit.algorithms.phase_estimators import HamiltonianPhaseEstimation
    from qiskit.synthesis import MatrixExponential
    from qiskit.quantum_info import SparsePauliOp
    from qiskit.opflow import PauliSumOp


    sampler = Sampler()
    num_evaluation_qubits = 6
    phase_est = HamiltonianPhaseEstimation(
        num_evaluation_qubits=num_evaluation_qubits, sampler=sampler
    )

    hamiltonian = PauliSumOp(SparsePauliOp.from_list([("X", 0.5), ("Y", 0.6), ("I", 0.7)]))
    result = phase_est.estimate(
        hamiltonian=hamiltonian,
        state_preparation=None,
        evolution=MatrixExponential(),
        bound=1.05,
    )
    ```

*   The [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") transpiler pass has significantly improved runtime performance due to a rewrite of the algorithm in Rust.

*   Symbolic pulse subclasses [`Gaussian`](qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian"), [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare"), [`Drag`](qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag") and [`Constant`](qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant") have been upgraded to instantiate `SymbolicPulse` rather than the subclass itself. All parametric pulse objects in pulse programs must be symbolic pulse instances, because subclassing is no longer neccesary. Note that `SymbolicPulse` can uniquely identify a particular envelope with the symbolic expression object defined in `SymbolicPulse.envelope`.

*   Added a new function, [`sampled_expectation_value()`](result#qiskit.result.sampled_expectation_value "qiskit.result.sampled_expectation_value"), that allows for computing expectation values for diagonal operators from distributions such as [`Counts`](qiskit.result.Counts "qiskit.result.Counts") and [`QuasiDistribution`](qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution"). Valid operators for use with this function are: `str`, [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli"), [`PauliOp`](qiskit.opflow.primitive_ops.PauliOp "qiskit.opflow.primitive_ops.PauliOp"), [`PauliSumOp`](qiskit.opflow.primitive_ops.PauliSumOp "qiskit.opflow.primitive_ops.PauliSumOp"), and [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp").

*   A [`SamplingVQE`](qiskit.algorithms.minimum_eigensolvers.SamplingVQE "qiskit.algorithms.minimum_eigensolvers.SamplingVQE") class is introduced, which is optimized for diagonal hamiltonians and leverages a `sampler` primitive. A [`QAOA`](qiskit.algorithms.minimum_eigensolvers.QAOA "qiskit.algorithms.minimum_eigensolvers.QAOA") class is also added that subclasses `SamplingVQE`.

    To use the new `SamplingVQE` with a reference primitive, one can do, for example:

    ```python
    from qiskit.algorithms.minimum_eigensolvers import SamplingVQE
    from qiskit.algorithms.optimizers import SLSQP
    from qiskit.circuit.library import TwoLocal
    from qiskit.primitives import Sampler
    from qiskit.opflow import PauliSumOp
    from qiskit.quantum_info import SparsePauliOp

    operator = PauliSumOp(SparsePauliOp(["ZZ", "IZ", "II"], coeffs=[1, -0.5, 0.12]))

    sampler = Sampler()
    ansatz = TwoLocal(rotation_blocks=["ry", "rz"], entanglement_blocks="cz")
    optimizer = SLSQP()

    sampling_vqe = SamplingVQE(sampler, ansatz, optimizer)
    result = sampling_vqe.compute_minimum_eigenvalue(operator)
    eigenvalue = result.eigenvalue
    ```

    Note that the evaluated auxillary operators are now obtained via the `aux_operators_evaluated` field on the results. This will consist of a list or dict of tuples containing the expectation values for these operators, as we well as the metadata from primitive run. `aux_operator_eigenvalues` is no longer a valid field.

*   Added a new `atol` keyword argument to the [`SparsePauliOp.equiv()`](qiskit.quantum_info.SparsePauliOp#equiv "qiskit.quantum_info.SparsePauliOp.equiv") method to adjust to tolerance of the equivalence check,

*   Introduced a new plugin interface for transpiler stages which is used to enable alternative [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") objects from an external package in a particular stage as part of [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or the [`StagedPassManager`](qiskit.transpiler.StagedPassManager "qiskit.transpiler.StagedPassManager") output from [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager"), [`level_0_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_0_pass_manager "qiskit.transpiler.preset_passmanagers.level_0_pass_manager"), [`level_1_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`level_2_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`level_3_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager"). Users can select a plugin to use for a transpiler stage with the `init_method`, `layout_method`, `routing_method`, `translation_method`, `optimization_method`, and `scheduling_method` keyword arguments on [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager"). A full list of plugin names currently installed can be found with the [`list_stage_plugins()`](transpiler_plugins#qiskit.transpiler.preset_passmanagers.plugin.list_stage_plugins "qiskit.transpiler.preset_passmanagers.plugin.list_stage_plugins") function. For creating plugins refer to the [`qiskit.transpiler.preset_passmanagers.plugin`](transpiler_plugins#module-qiskit.transpiler.preset_passmanagers.plugin "qiskit.transpiler.preset_passmanagers.plugin") module documentation which includes a guide for writing stage plugins.

*   The [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") has two new keyword arguments, `init_method` and `optimization_method` which are used to specify alternative plugins to use for the `init` stage and `optimization` stages respectively.

*   The [`PassManagerConfig`](qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig") class has 2 new attributes, `init_method` and `optimization_method` along with matching keyword arguments on the constructor methods. These represent the user specified `init` and `optimization` plugins to use for compilation.

*   The [`SteppableOptimizer`](qiskit.algorithms.optimizers.SteppableOptimizer "qiskit.algorithms.optimizers.SteppableOptimizer") class is added. It allows one to perfore classical optimizations step-by-step using the [`step()`](qiskit.algorithms.optimizers.SteppableOptimizer#step "qiskit.algorithms.optimizers.SteppableOptimizer.step") method. These optimizers implement the “ask and tell” interface which (optionally) allows to manually compute the required function or gradient evaluations and plug them back into the optimizer. For more information about this interface see: [ask and tell interface](https://optuna.readthedocs.io/en/stable/tutorial/20_recipes/009_ask_and_tell.html). A very simple use case when the user might want to do the optimization step by step is for readout:

    ```python
    import random
    import numpy as np
    from qiskit.algorithms.optimizers import GradientDescent

    def objective(x):
          return (np.linalg.norm(x) - 1) ** 2

    def grad(x):
          return 2 * (np.linalg.norm(x) - 1) * x / np.linalg.norm(x)


    initial_point = np.random.normal(0, 1, size=(100,))

    optimizer = GradientDescent(maxiter=20)
    optimizer.start(x0=initial_point, fun=objective, jac=grad)

    for _ in range(maxiter):
        state = optimizer.state
        # Here you can manually read out anything from the optimizer state.
        optimizer.step()

    result = optimizer.create_result()
    ```

    A more complex case would be error handling. Imagine that the function you are evaluating has a random chance of failing. In this case you can catch the error and run the function again until it yields the desired result before continuing the optimization process. In this case one would use the ask and tell interface.

    ```python
    import random
    import numpy as np
    from qiskit.algorithms.optimizers import GradientDescent

    def objective(x):
        if random.choice([True, False]):
            return None
        else:
            return (np.linalg.norm(x) - 1) ** 2

    def grad(x):
        if random.choice([True, False]):
            return None
        else:
            return 2 * (np.linalg.norm(x) - 1) * x / np.linalg.norm(x)


    initial_point = np.random.normal(0, 1, size=(100,))

    optimizer = GradientDescent(maxiter=20)
    optimizer.start(x0=initial_point, fun=objective, jac=grad)

    while optimizer.continue_condition():
        ask_data = optimizer.ask()
        evaluated_gradient = None

        while evaluated_gradient is None:
            evaluated_gradient = grad(ask_data.x_center)
            optimizer.state.njev += 1

        optmizer.state.nit += 1

        cf  = TellData(eval_jac=evaluated_gradient)
        optimizer.tell(ask_data=ask_data, tell_data=tell_data)

    result = optimizer.create_result()
    ```

    Transitioned `GradientDescent` to be a subclass of [`SteppableOptimizer`](qiskit.algorithms.optimizers.SteppableOptimizer "qiskit.algorithms.optimizers.SteppableOptimizer").

*   The `subset_fitter` method is added to the [`TensoredMeasFitter`](qiskit.utils.mitigation.TensoredMeasFitter "qiskit.utils.mitigation.TensoredMeasFitter") class. The implementation is restricted to mitigation patterns in which each qubit is mitigated individually, e.g. `[[0], [1], [2]]`. This is, however, the most widely used case. It allows the [`TensoredMeasFitter`](qiskit.utils.mitigation.TensoredMeasFitter "qiskit.utils.mitigation.TensoredMeasFitter") to be used in cases where the numberical order of the physical qubits does not match the index of the classical bit.

*   Control-flow operations are now supported through the transpiler at optimization levels 0 and 1 (e.g. calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") with keyword argument `optimization_level=1`). One can now construct a circuit such as

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(2, 1)
    qc.h(0)
    qc.measure(0, 0)
    with qc.if_test((0, True)) as else_:
      qc.x(1)
    with else_:
      qc.y(1)
    ```

    and successfully transpile this, such as by:

    ```python
    from qiskit import transpile
    from qiskit_aer import AerSimulator

    backend = AerSimulator(method="statevector")
    transpiled = transpile(qc, backend)
    ```

    The available values for the keyword argument `layout_method` are “trivial” and “dense”. For `routing_method`, “stochastic” and “none” are available. Translation (`translation_method`) can be done using “translator” or “unroller”. Optimization levels 2 and 3 are not yet supported with control flow, nor is circuit scheduling (i.e. providing a value to `scheduling_method`), though we intend to expand support for these, and the other layout, routing and translation methods in subsequent releases of Qiskit Terra.

    In order for transpilation with control-flow operations to succeed with a backend, the backend must have the requisite control-flow operations in its stated basis. Qiskit Aer, for example, does this. If you simply want to try out such transpilations, consider overriding the `basis_gates` argument to [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile").

*   The following transpiler passes have all been taught to understand control-flow constructs in the form of [`ControlFlowOp`](qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp") instructions in a circuit:

    ## Layout-related

    *   [`ApplyLayout`](qiskit.transpiler.passes.ApplyLayout "qiskit.transpiler.passes.ApplyLayout")
    *   [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout")
    *   [`EnlargeWithAncilla`](qiskit.transpiler.passes.EnlargeWithAncilla "qiskit.transpiler.passes.EnlargeWithAncilla")
    *   [`FullAncillaAllocation`](qiskit.transpiler.passes.FullAncillaAllocation "qiskit.transpiler.passes.FullAncillaAllocation")
    *   [`SetLayout`](qiskit.transpiler.passes.SetLayout "qiskit.transpiler.passes.SetLayout")
    *   [`TrivialLayout`](qiskit.transpiler.passes.TrivialLayout "qiskit.transpiler.passes.TrivialLayout")
    *   [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout")
    *   [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout")

    ## Routing-related

    *   [`CheckGateDirection`](qiskit.transpiler.passes.CheckGateDirection "qiskit.transpiler.passes.CheckGateDirection")
    *   [`CheckMap`](qiskit.transpiler.passes.CheckMap "qiskit.transpiler.passes.CheckMap")
    *   [`GateDirection`](qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection")
    *   [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap")

    ## Translation-related

    *   [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator")
    *   [`ContainsInstruction`](qiskit.transpiler.passes.ContainsInstruction "qiskit.transpiler.passes.ContainsInstruction")
    *   [`GatesInBasis`](qiskit.transpiler.passes.GatesInBasis "qiskit.transpiler.passes.GatesInBasis")
    *   [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis")
    *   [`Unroll3qOrMore`](qiskit.transpiler.passes.Unroll3qOrMore "qiskit.transpiler.passes.Unroll3qOrMore")
    *   [`UnrollCustomDefinitions`](qiskit.transpiler.passes.UnrollCustomDefinitions "qiskit.transpiler.passes.UnrollCustomDefinitions")
    *   [`Unroller`](qiskit.transpiler.passes.Unroller "qiskit.transpiler.passes.Unroller")

    ## Optimization-related

    *   [`BarrierBeforeFinalMeasurements`](qiskit.transpiler.passes.BarrierBeforeFinalMeasurements "qiskit.transpiler.passes.BarrierBeforeFinalMeasurements")
    *   [`Depth`](qiskit.transpiler.passes.Depth "qiskit.transpiler.passes.Depth")
    *   [`FixedPoint`](qiskit.transpiler.passes.FixedPoint "qiskit.transpiler.passes.FixedPoint")
    *   [`Size`](qiskit.transpiler.passes.Size "qiskit.transpiler.passes.Size")
    *   [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition")
    *   [`CXCancellation`](qiskit.transpiler.passes.CXCancellation "qiskit.transpiler.passes.CXCancellation")
    *   [`RemoveResetInZeroState`](qiskit.transpiler.passes.RemoveResetInZeroState "qiskit.transpiler.passes.RemoveResetInZeroState")

    These passes are most commonly used via the preset pass managers (those used internally by [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager")), but are also available for other uses. These passes will now recurse into control-flow operations where appropriate, updating or analysing the internal blocks.

*   Added a new [`TrotterQRTE`](qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE") class that implements the [`RealTimeEvolver`](qiskit.algorithms.RealTimeEvolver "qiskit.algorithms.RealTimeEvolver") interface that uses an [`qiskit.primitives.BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator") to perform the calculation. This new class supersedes the previously available [`qiskit.algorithms.TrotterQRTE`](qiskit.algorithms.TrotterQRTE "qiskit.algorithms.TrotterQRTE") class (which will be deprecated and subsequenty removed in future releases) that used a [`Backend`](qiskit.providers.Backend "qiskit.providers.Backend") or `QuantumInstance` to perform the calculation.

*   [`DAGCircuit.substitute_node_with_dag()`](qiskit.dagcircuit.DAGCircuit#substitute_node_with_dag "qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag") now takes `propagate_condition` as a keyword argument. This defaults to `True`, which was the previous behavior, and copies any condition on the node to be replaced onto every operation node in the replacement. If set to `False`, the condition will not be copied, which allows replacement of a conditional node with a sub-DAG that already faithfully implements the condition.

*   [`DAGCircuit.substitute_node_with_dag()`](qiskit.dagcircuit.DAGCircuit#substitute_node_with_dag "qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag") can now take a mapping for its `wires` parameter as well as a sequence. The mapping should map bits in the replacement DAG to the bits in the DAG it is being inserted into. This permits an easier style of construction for callers when the input node has both classical bits and a condition, and the replacement DAG may use these out-of-order.

*   Added the [`qiskit.algorithms.minimum_eigensolvers`](qiskit.algorithms.minimum_eigensolvers#module-qiskit.algorithms.minimum_eigensolvers "qiskit.algorithms.minimum_eigensolvers") package to include interfaces for primitive-enabled algorithms. [`VQE`](qiskit.algorithms.minimum_eigensolvers.VQE "qiskit.algorithms.minimum_eigensolvers.VQE") has been refactored in this implementation to leverage primitives.

    To use the new implementation with a reference primitive, one can do, for example:

    ```python
    from qiskit.algorithms.minimum_eigensolvers import VQE
    from qiskit.algorithms.optimizers import SLSQP
    from qiskit.circuit.library import TwoLocal
    from qiskit.primitives import Estimator
    from qiskit.quantum_info import SparsePauliOp

    h2_op = SparsePauliOp(
        ["II", "IZ", "ZI", "ZZ", "XX"],
        coeffs=[
            -1.052373245772859,
            0.39793742484318045,
            -0.39793742484318045,
            -0.01128010425623538,
            0.18093119978423156,
        ],
    )

    estimator = Estimator()
    ansatz = TwoLocal(rotation_blocks=["ry", "rz"], entanglement_blocks="cz")
    optimizer = SLSQP()

    vqe = VQE(estimator, ansatz, optimizer)
    result = vqe.compute_minimum_eigenvalue(h2_op)
    eigenvalue = result.eigenvalue
    ```

    Note that the evaluated auxillary operators are now obtained via the `aux_operators_evaluated` field on the results. This will consist of a list or dict of tuples containing the expectation values for these operators, as we well as the metadata from primitive run. `aux_operator_eigenvalues` is no longer a valid field.

<span id="release-notes-0-22-0-upgrade-notes" />

<span id="id95" />

#### Upgrade Notes

*   For [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") objects that only contain globally defined 2 qubit operations without any connectivity constaints the return from the [`Target.build_coupling_map()`](qiskit.transpiler.Target#build_coupling_map "qiskit.transpiler.Target.build_coupling_map") method will now return `None` instead of a [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") object that contains `num_qubits` nodes and no edges. This change was made to better reflect the actual connectivity constraints of the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") because in this case there are no connectivity constraints on the backend being modeled by the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target"), not a lack of connecitvity. If you desire the previous behavior for any reason you can reproduce it by checking for a `None` return and manually building a coupling map, for example:

    ```python
    from qiskit.transpiler import Target, CouplingMap
    from qiskit.circuit.library import CXGate

    target = Target(num_qubits=3)
    target.add_instruction(CXGate())
    cmap = target.build_coupling_map()
    if cmap is None:
        cmap = CouplingMap()
        for i in range(target.num_qubits):
            cmap.add_physical_qubit(i)
    ```

*   The default value for the `entanglement` keyword argument on the constructor for the [`RealAmplitudes`](qiskit.circuit.library.RealAmplitudes "qiskit.circuit.library.RealAmplitudes") and [`EfficientSU2`](qiskit.circuit.library.EfficientSU2 "qiskit.circuit.library.EfficientSU2") classes has changed from `"full"` to `"reverse_linear"`. This change was made because the output circuit is equivalent but uses only $n-1$ instead of $\frac{n(n-1)}{2}$ [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") gates. If you desire the previous default you can explicity set `entanglement="full"` when calling either constructor.

*   Added a validation check to [`BaseSampler.run()`](qiskit.primitives.BaseSampler#run "qiskit.primitives.BaseSampler.run"). It raises an error if there is no classical bit.

*   Behavior of the [`call()`](pulse#qiskit.pulse.builder.call "qiskit.pulse.builder.call") pulse builder function has been upgraded. When a [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") instance is called by this method, it internally creates a [`Reference`](qiskit.pulse.instructions.Reference "qiskit.pulse.instructions.Reference") in the current context, and immediately assigns the called program to the reference. Thus, the [`Call`](qiskit.pulse.instructions.Call "qiskit.pulse.instructions.Call") instruction is no longer generated. Along with this change, it is prohibited to call different blocks with the same `name` argument. Such operation will result in an error.

*   For most architectures starting in the following release of Qiskit Terra, 0.23, the `tweedledum` package will become an optional dependency, instead of a requirement. This is currently used by some classical phase-oracle functions. If your application or library needs this functionality, you may want to prepare by adding `tweedledum` to your package’s dependencies immediately.

    `tweedledum` is no longer a requirement on macOS arm64 (M1) with immediate effect in Qiskit Terra 0.22. This is because the provided wheels for this platform are broken, and building from the sdist is not reliable for most people. If you manually install a working version of `tweedledum`, all the dependent functionality will continue to work.

*   The `._layout` attribute of the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object has been changed from storing a [`Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout") object to storing a data class with 2 attributes, `initial_layout` which contains a [`Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout") object for the initial layout set during compilation and `input_qubit_mapping` which contains a dictionary mapping qubits to position indices in the original circuit. This change was necessary to provide all the information for a post-transpiled circuit to be able to fully reverse the permutation caused by initial layout in all situations. While this attribute is private and shouldn’t be used externally, it is the only way to track the initial layout through [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") so the change is being documented in case you’re relying on it. If you have a use case for the `_layout` attribute that is not being addressed by the Qiskit API please open an issue so we can address this feature gap.

*   The constructors for the [`SetPhase`](qiskit.pulse.instructions.SetPhase "qiskit.pulse.instructions.SetPhase"), [`ShiftPhase`](qiskit.pulse.instructions.ShiftPhase "qiskit.pulse.instructions.ShiftPhase"), [`SetFrequency`](qiskit.pulse.instructions.SetFrequency "qiskit.pulse.instructions.SetFrequency"), and [`ShiftFrequency`](qiskit.pulse.instructions.ShiftFrequency "qiskit.pulse.instructions.ShiftFrequency") classes will now raise a [`PulseError`](pulse#qiskit.pulse.PulseError "qiskit.pulse.PulseError") if the value passed in via the `channel` argument is not an instance of `PulseChannel`. This change was made to validate the input to the constructors are valid as the instructions are only valid for pulse channels and not other types of channels.

*   The [`plot_histogram()`](qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram") function has been modified to return an actual histogram of discrete binned values. The previous behavior for the function was despite the name to actually generate a visualization of the distribution of the input. Due to this disparity between the name of the function and the behavior the function behavior was changed so it’s actually generating a proper histogram of discrete data now. If you wish to preserve the previous behavior of plotting a probability distribution of the counts data you can leverage the [`plot_distribution()`](qiskit.visualization.plot_distribution "qiskit.visualization.plot_distribution") to generate an equivalent graph. For example, the previous behavior of `plot_histogram({'00': 512, '11': 500})` can be re-created with:

    ```python
    from qiskit.visualization import plot_distribution
    import matplotlib.pyplot as plt

    ax = plt.subplot()
    plot_distribution({'00': 512, '11': 500}, ax=ax)
    ax.set_ylabel('Probabilities')
    ```

*   The `qiskit.pulse.builder` contexts `inline` and `pad` have been removed. These were first deprecated in Terra 0.18.0 (July 2021). There is no replacement for `inline`; one can simply write the pulses in the containing scope. The `pad` context manager has had no effect since it was deprecated.

*   The output from the [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") transpiler pass (including when `optimization_level=3` or `routing_method` or `layout_method` are set to `'sabre'` when calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile")) with a fixed seed value may change from previous releases. This is caused by a new random number generator being used as part of the rewrite of the [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") pass in Rust which significantly improved the performance. If you rely on having consistent output you can run the pass in an earlier version of Qiskit and leverage [`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy") to save the circuit and then load it using the current version.

*   The [`Layout.add()`](qiskit.transpiler.Layout#add "qiskit.transpiler.Layout.add") behavior when not specifying a `physical_bit` has changed from previous releases. In previous releases, a new physical bit would be added based on the length of the [`Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout") object. For example if you had a [`Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout") with the physical bits 1 and 3 successive calls to [`add()`](qiskit.transpiler.Layout#add "qiskit.transpiler.Layout.add") would add physical bits 2, 4, 5, 6, etc. While if the physical bits were 2 and 3 then successive calls would add 4, 5, 6, 7, etc. This has changed so that instead [`Layout.add()`](qiskit.transpiler.Layout#add "qiskit.transpiler.Layout.add") will first add any missing physical bits between 0 and the max physical bit contained in the [`Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout"). So for the 1 and 3 example it now adds 0, 2, 4, 5 and for the 2 and 3 example it adds 0, 1, 4, 5 to the [`Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout"). This change was made for both increased predictability of the outcome, and also to fix a class of bugs caused by the unexpected behavior. As physical bits on a backend always are contiguous sequences from 0 to $n$ adding new bits when there are still unused physical bits could potentially cause the layout to use more bits than available on the backend. If you desire the previous behavior, you can specify the desired physical bit manually when calling [`Layout.add()`](qiskit.transpiler.Layout#add "qiskit.transpiler.Layout.add").

*   The deprecated method `SparsePauliOp.table` attribute has been removed. It was originally deprecated in Qiskit Terra 0.19. Instead the `paulis()` method should be used.

*   Support for returning a `PauliTable` from the [`pauli_basis()`](qiskit.quantum_info.pauli_basis "qiskit.quantum_info.pauli_basis") function has been removed. Similarly, the `pauli_list` argument on the [`pauli_basis()`](qiskit.quantum_info.pauli_basis "qiskit.quantum_info.pauli_basis") function which was used to switch to a [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") (now the only return type) has been removed. This functionality was deprecated in the Qiskit Terra 0.19 release.

*   The fake backend objects [`FakeJohannesburg`](qiskit.providers.fake_provider.FakeJohannesburg "qiskit.providers.fake_provider.FakeJohannesburg"), [`FakeJohannesburgV2`](qiskit.providers.fake_provider.FakeJohannesburgV2 "qiskit.providers.fake_provider.FakeJohannesburgV2"), [`FakeAlmaden`](qiskit.providers.fake_provider.FakeAlmaden "qiskit.providers.fake_provider.FakeAlmaden"), [`FakeAlmadenV2`](qiskit.providers.fake_provider.FakeAlmadenV2 "qiskit.providers.fake_provider.FakeAlmadenV2"), [`FakeSingapore`](qiskit.providers.fake_provider.FakeSingapore "qiskit.providers.fake_provider.FakeSingapore"), and [`FakeSingaporeV2`](qiskit.providers.fake_provider.FakeSingaporeV2 "qiskit.providers.fake_provider.FakeSingaporeV2") no longer contain the pulse defaults payloads. This means for the [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") based classes the `BackendV1.defaults()` method and pulse simulation via [`BackendV1.run()`](qiskit.providers.BackendV1#run "qiskit.providers.BackendV1.run") is no longer available. For [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") based classes the `calibration` property for instructions in the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") is no longer populated. This change was done because these systems had exceedingly large pulse defaults payloads (in total \~50MB) due to using sampled waveforms instead of parameteric pulse definitions. These three payload files took > 50% of the disk space required to install qiskit-terra. When weighed against the potential value of being able to compile with pulse awareness or pulse simulate these retired devices the file size is not worth the cost. If you require to leverage these properties you can leverage an older version of Qiskit and leverage [`qpy`](qpy#module-qiskit.qpy "qiskit.qpy") to transfer circuits from older versions of qiskit into the current release.

*   `isinstance` check with pulse classes [`Gaussian`](qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian"), [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare"), [`Drag`](qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag") and [`Constant`](qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant") will be invalidated because these pulse subclasses are no longer instantiated. They will still work in Terra 0.22, but you should begin transitioning immediately. Instead of using type information, `SymbolicPulse.pulse_type` should be used. This is assumed to be a unique string identifer for pulse envelopes, and we can use string equality to investigate the pulse types. For example,

    ```python
    from qiskit.pulse.library import Gaussian

    pulse = Gaussian(160, 0.1, 40)

    if isinstance(pulse, Gaussian):
      print("This is Gaussian pulse.")
    ```

    This code should be upgraded to

    ```python
    from qiskit.pulse.library import Gaussian

    pulse = Gaussian(160, 0.1, 40)

    if pulse.pulse_type == "Gaussian":
      print("This is Gaussian pulse.")
    ```

    With the same reason, the class attributes such as `pulse.__class__.__name__` should not be accessed to get pulse type information.

*   The exception `qiskit.exceptions.QiskitIndexError` has been removed and no longer exists as per the deprecation notice from qiskit-terra 0.18.0 (released on Jul 12, 2021).

*   The deprecated arguments `epsilon` and `factr` for the constructor of the [`L_BFGS_B`](qiskit.algorithms.optimizers.L_BFGS_B "qiskit.algorithms.optimizers.L_BFGS_B") optimizer class have been removed. These arguments were originally deprecated as part of the 0.18.0 release (released on July 12, 2021). Instead the `ftol` argument should be used, you can refer to the [scipy docs](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-lbfgsb.html) on the optimizer for more detail on the relationship between these arguments.

*   The preset pass managers for levels 1 and 2, which will be used when `optimization_level=1` or `optimization_level=2` with [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") and output from [`level_1_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager") and [`level_2_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), will now use [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and `SabreSwap` by default instead of the previous defaults [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") and [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap"). This change was made to improve the output quality of the transpiler, the [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and `SabreSwap` combination typically results in fewer [`SwapGate`](qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") objects being inserted into the output circuit. If you would like to use the previous default passes you can set `layout_method='dense'` and `routing_method='stochastic'` on [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") to leverage [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") and [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") respectively.

*   The implicit use of `approximation_degree!=1.0` by default in in the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function when `optimization_level=3` is set has been disabled. The transpiler should, by default, preserve unitarity of the input up to known transformations such as one-sided permutations and similarity transformations. This was broken by the previous use of `approximation_degree=None` leading to incorrect results in cases such as Trotterized evolution with many time steps where unitaries were being overly approximated leading to incorrect results. It was decided that transformations that break unitary equivalence should be explicitly activated by the user. If you desire the previous default behavior where synthesized `UnitaryGate` instructions are approximated up to the error rates of the target backend’s native instructions you can explicitly set `approximation_degree=None` when calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") with `optimization_level=3`, for example:

    ```python
    transpile(circuit, backend, approximation_degree=None, optimization_level=3)
    ```

*   Change the default of maximum number of allowed function evaluations (`maxfun`) in [`L_BFGS_B`](qiskit.algorithms.optimizers.L_BFGS_B "qiskit.algorithms.optimizers.L_BFGS_B") from 1000 to 15000 to match the SciPy default. This number also matches the default number of iterations (`maxiter`).

*   Updated [`ProbDistribution`](qiskit.result.ProbDistribution "qiskit.result.ProbDistribution") and [`QuasiDistribution`](qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution") to store the information of the number of bits if bitstrings without prefix “0b” are given. [`ProbDistribution.binary_probabilities()`](qiskit.result.ProbDistribution#binary_probabilities "qiskit.result.ProbDistribution.binary_probabilities") and [`QuasiDistribution.binary_probabilities()`](qiskit.result.QuasiDistribution#binary_probabilities "qiskit.result.QuasiDistribution.binary_probabilities") use the stored number of bits as the default value of the number of bits.

*   [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") and [`RZXCalibrationBuilderNoEcho`](qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho") have been upgraded to skip stretching CX gates implemented by non-echoed cross resonance (ECR) sequence to avoid termination of the pass with unexpected errors. These passes take new argument `verbose` that controls whether the passes warn when this occurs. If `verbose=True` is set, pass raises user warning when it enconters non-ECR sequence.

*   The visualization module [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization") has seen some internal reorganisation. This should not have affected the public interface, but if you were accessing any internals of the circuit drawers, they may now be in different places. The only parts of the visualization module that are considered public are the components that are documented in this online documentation.

<span id="release-notes-0-22-0-deprecation-notes" />

<span id="id96" />

#### Deprecation Notes

*   Importing the names `Int1`, `Int2`, `classical_function` and `BooleanExpression` directly from [`qiskit.circuit`](circuit#module-qiskit.circuit "qiskit.circuit") is deprecated. This is part of the move to make `tweedledum` an optional dependency rather than a full requirement. Instead, you should import these names from [`qiskit.circuit.classicalfunction`](classicalfunction#module-qiskit.circuit.classicalfunction "qiskit.circuit.classicalfunction").

*   Modules `qiskit.algorithms.factorizers` and `qiskit.algorithms.linear_solvers` are deprecated and will be removed in a future release. They are replaced by tutorials in the Qiskit Textbook: [Shor](https://qiskit.org/textbook/ch-algorithms/shor.html) [HHL](https://qiskit.org/textbook/ch-applications/hhl_tutorial.html)

*   The `random_stabilizer_table()` has been deprecated and will be removed in a future release. Instead the [`random_pauli_list()`](quantum_info#qiskit.quantum_info.random_pauli_list "qiskit.quantum_info.random_pauli_list") function should be used.

*   The pulse-module function `qiskit.pulse.utils.deprecated_functionality` is deprecated and will be removed in a future release. This was a primarily internal-only function. The same functionality is supplied by `qiskit.utils.deprecate_function`, which should be used instead.

*   The method of executing primitives has been changed. The `BaseSampler.__call__()` and `BaseEstimator.__call__()` methods were deprecated. For example:

    ```python
    estimator = Estimator(...)
    result = estimator(circuits, observables, parameters)

    sampler = Sampler(...)
    result = sampler(circuits, observables, parameters)
    ```

    should be rewritten as

    ```python
    estimator = Estimator()
    result = estimator.run(circuits, observables, parameter_values).result()

    sampler = Sampler()
    result = sampler.run(circuits, parameter_values).result()
    ```

    Using primitives as context managers is deprecated. Not all primitives have a context manager available. When available (e.g. in `qiskit-ibm-runtime`), the session’s context manager provides equivalent functionality.

    `circuits`, `observables`, and `parameters` in the constructor was deprecated. `circuits` and `observables` can be passed from `run` methods. `run` methods do not support `parameters`. Users need to resort parameter values by themselves.

*   The unused argument `qubit_channel_mapping` in the [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") and [`RZXCalibrationBuilderNoEcho`](qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho") transpiler passes have been deprecated and will be removed in a future release. This argument is no longer used and has no effect on the operation of the passes.

<span id="release-notes-0-22-0-bug-fixes" />

<span id="id97" />

#### Bug Fixes

*   Fixed an issue where [`Pauli.evolve()`](qiskit.quantum_info.Pauli#evolve "qiskit.quantum_info.Pauli.evolve") and [`PauliList.evolve()`](qiskit.quantum_info.PauliList#evolve "qiskit.quantum_info.PauliList.evolve") would raise a dtype error when evolving by certain Clifford gates which modified the Pauli’s phase. Fixed [#8438](https://github.com/Qiskit/qiskit-terra/issues/8438)

*   Fixed a bug in [`QuantumCircuit.initialize()`](qiskit.circuit.QuantumCircuit#initialize "qiskit.circuit.QuantumCircuit.initialize") and [`QuantumCircuit.prepare_state()`](qiskit.circuit.QuantumCircuit#prepare_state "qiskit.circuit.QuantumCircuit.prepare_state") that caused them to not accept a single `Qubit` as argument to initialize.

*   The method [`QuantumCircuit.while_loop()`](qiskit.circuit.QuantumCircuit#while_loop "qiskit.circuit.QuantumCircuit.while_loop") will now resolve classical bit references in its condition in the same way that [`QuantumCircuit.if_test()`](qiskit.circuit.QuantumCircuit#if_test "qiskit.circuit.QuantumCircuit.if_test") and [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if "qiskit.circuit.InstructionSet.c_if") do.

*   The [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") methods [`depth()`](qiskit.dagcircuit.DAGCircuit#depth "qiskit.dagcircuit.DAGCircuit.depth"), [`size()`](qiskit.dagcircuit.DAGCircuit#size "qiskit.dagcircuit.DAGCircuit.size") and [`DAGCircuit.count_ops()`](qiskit.dagcircuit.DAGCircuit#count_ops "qiskit.dagcircuit.DAGCircuit.count_ops") would previously silently return results that had little-to-no meaning if control-flow was present in the circuit. The [`depth()`](qiskit.dagcircuit.DAGCircuit#depth "qiskit.dagcircuit.DAGCircuit.depth") and [`size()`](qiskit.dagcircuit.DAGCircuit#size "qiskit.dagcircuit.DAGCircuit.size") methods will now correctly throw an error in these cases, but have a new `recurse` keyword argument to allow the calculation of a proxy value, while [`count_ops()`](qiskit.dagcircuit.DAGCircuit#count_ops "qiskit.dagcircuit.DAGCircuit.count_ops") will by default recurse into the blocks and count the operations within them.

*   Fixed an issue in the [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") transpiler pass where any loose [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") objects (i.e. not part of a [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister")) that were part of a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") would not be included in the output [`Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout") that was generated by the pass.

*   The [`Operator.from_circuit()`](qiskit.quantum_info.Operator#from_circuit "qiskit.quantum_info.Operator.from_circuit") constructor method has been updated so that it can handle the layout output from [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and correctly reverse the qubit permutation caused by layout in all cases. Previously, if your transpiled circuit used loose [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") objects, multiple [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") objects, or a single [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") with a name other than `"q"` the constructor would have failed to create an [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") from the circuit. Fixed [#8800](https://github.com/Qiskit/qiskit-terra/issues/8800).

*   Fixed a bug where decomposing an instruction with one qubit and one classical bit containing a single quantum gate failed. Now the following decomposes as expected:

    ```python
    block = QuantumCircuit(1, 1)
    block.h(0)

    circuit = QuantumCircuit(1, 1)
    circuit.append(block, [0], [0])

    decomposed = circuit.decompose()
    ```

*   Fixed initialization of empty symplectic matrix in [`from_symplectic()`](qiskit.quantum_info.PauliList#from_symplectic "qiskit.quantum_info.PauliList.from_symplectic") in [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") class For example:

    ```python
    from qiskit.quantum_info.operators import PauliList

    x = np.array([], dtype=bool).reshape((1,0))
    z = np.array([], dtype=bool).reshape((1,0))
    pauli_list = PauliList.from_symplectic(x, z)
    ```

*   Fix a problem in the [`GateDirection`](qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection") transpiler pass for the [`CZGate`](qiskit.circuit.library.CZGate "qiskit.circuit.library.CZGate"). The CZ gate is symmetric, so flipping the qubit arguments is allowed to match the directed coupling map.

*   Fixed issues with the `DerivativeBase.gradient_wrapper()` method when reusing a circuit sampler between the calls and binding nested parameters.

*   Fixed an issue in the `mpl` and `latex` circuit drawers, when setting the `idle_wires` option to False when there was a `barrier` in the circuit would cause the drawers to fail, has been fixed. Fixed [#8313](https://github.com/Qiskit/qiskit-terra/issues/8313)

*   Fixed an issue in [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") with the `latex` method where an `OSError` would be raised on systems whose temporary directories (*e.g* `/tmp`) are on a different filesystem than the working directory. Fixes [#8542](https://github.com/Qiskit/qiskit-terra/issues/8542)

*   Nesting a [`FlowController`](qiskit.passmanager.FlowController "qiskit.passmanager.FlowController") inside another in a [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") could previously cause some transpiler passes to become “forgotten” during transpilation, if the passes returned a new [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") rather than mutating their input. Nested [`FlowController`](qiskit.passmanager.FlowController "qiskit.passmanager.FlowController")s will now affect the transpilation correctly.

*   Comparing [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit")s for equality was previously non-deterministic if the circuits contained more than one register of the same type (*e.g.* two or more [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister")s), sometimes returning `False` even if the registers were identical. It will now correctly compare circuits with multiple registers.

*   The OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) will now correctly define the qubit parameters for [`UnitaryGate`](qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") operations that do not affect all the qubits they are defined over. Fixed [#8224](https://github.com/Qiskit/qiskit-terra/issues/8224).

*   There were two bugs in the `text` circuit drawer that were fixed. These appeared when `vertical_compression` was set to `medium`, which is the default. The first would sometimes cause text to overwrite other text or gates, and the second would sometimes cause the connections between a gate and its controls to break. See [#8588](https://github.com/Qiskit/qiskit-terra/issues/8588).

*   Fixed an issue with the [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") pass where a circuit with 1 qubit gates and a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") input would sometimes fail instead of processing the circuit as expected.

*   The [`GateDirection`](qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection") transpiler pass will now respect the available values for gate parameters when handling parametrised gates with a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target").

*   Fixed an issue in the [`SNOBFIT`](qiskit.algorithms.optimizers.SNOBFIT "qiskit.algorithms.optimizers.SNOBFIT") optimizer class when an internal error would be raised during the execution of the [`minimize()`](qiskit.algorithms.optimizers.SNOBFIT#minimize "qiskit.algorithms.optimizers.SNOBFIT.minimize") method if no input bounds where specified. This is now checked at call time to quickly raise a `ValueError` if required bounds are missing from the [`minimize()`](qiskit.algorithms.optimizers.SNOBFIT#minimize "qiskit.algorithms.optimizers.SNOBFIT.minimize") call. Fixes [#8580](https://github.com/Qiskit/qiskit-terra/issues/8580)

*   Fixed an issue in the output callable from the [`get_energy_evaluation()`](qiskit.algorithms.VQD#get_energy_evaluation "qiskit.algorithms.VQD.get_energy_evaluation") method of the [`VQD`](qiskit.algorithms.VQD "qiskit.algorithms.VQD") class will now correctly call the specified `callback` when run. Previously the callback would incorrectly not be used in this case. Fixed [#8575](https://github.com/Qiskit/qiskit-terra/issues/8575)

*   Fixed an issue when `circuit_drawer()` was used with `reverse_bits=True` on a circuit without classical bits that would cause a potentially confusing warning about `cregbundle` to be emitted. Fixed [#8690](https://github.com/Qiskit/qiskit-terra/issues/8690)

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](qasm3#module-qiskit.qasm3 "qiskit.qasm3")) will now correctly handle OpenQASM built-ins (such as `reset` and `measure`) that have a classical condition applied by [`c_if()`](qiskit.circuit.InstructionSet#c_if "qiskit.circuit.InstructionSet.c_if"). Previously the condition would have been ignored.

*   Fixed an issue with the [`SPSA`](qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA") class where internally it was trying to batch jobs into even sized batches which would raise an exception if creating even batches was not possible. This has been fixed so it will always batch jobs successfully even if they’re not evenly sized.

*   Fixed the behavior of [`Layout.add()`](qiskit.transpiler.Layout#add "qiskit.transpiler.Layout.add") which was potentially causing the output of [`transpile()`](qiskit.utils.QuantumInstance#transpile "qiskit.utils.QuantumInstance.transpile") to be invalid and contain more Qubits than what was available on the target backend. Fixed: [#8667](https://github.com/Qiskit/qiskit-terra/issues/8667)

*   Fixed an issue with the `state_to_latex()` function: passing a latex string to the optional `prefix` argument of the function would raise an error. Fixed [#8460](https://github.com/Qiskit/qiskit-terra/issues/8460)

*   The function `state_to_latex()` produced not valid LaTeX in presence of close-to-zero values, resulting in errors when `state_drawer()` is called. Fixed [#8169](https://github.com/Qiskit/qiskit-terra/issues/8169).

*   [`GradientDescent`](qiskit.algorithms.optimizers.GradientDescent "qiskit.algorithms.optimizers.GradientDescent") will now correctly count the number of iterations, function evaluations and gradient evaluations. Also the documentation now correctly states that the gradient is approximated by a forward finite difference method.

*   Fix deprecation warnings in [`NaturalGradient`](qiskit.opflow.gradients.NaturalGradient "qiskit.opflow.gradients.NaturalGradient"), which now uses the `StandardScaler` to scale the data before fitting the model if the `normalize` parameter is set to `True`.

<span id="aer-0-11-0" />

### Aer 0.11.0

No change

<span id="id98" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-38-0" />

## Qiskit 0.38.0

<span id="terra-0-21-2" />

### Terra 0.21.2

No change

<span id="release-notes-aer-0-11-0" />

<span id="id99" />

### Aer 0.11.0

<span id="release-notes-aer-0-11-0-prelude" />

<span id="id100" />

#### Prelude

The Qiskit Aer 0.11.0 release highlights are:

*   The migration to a new self-contained Python namespace `qiskit_aer`
*   The introduction of the `AerStatevector` class
*   The introduction of Aer implementations of [`primitives`](primitives#module-qiskit.primitives "qiskit.primitives"), [`Sampler`](https://qiskit.org/ecosystem/aer/stubs/qiskit_aer.primitives.Sampler.html#qiskit_aer.primitives.Sampler "(in Qiskit Aer v0.13.0)") and [`Estimator`](https://qiskit.org/ecosystem/aer/stubs/qiskit_aer.primitives.Estimator.html#qiskit_aer.primitives.Estimator "(in Qiskit Aer v0.13.0)")
*   Introduction of support for running with [cuQuantum](https://developer.nvidia.com/cuquantum-sdk)

<span id="release-notes-aer-0-11-0-new-features" />

<span id="id101" />

#### New Features

*   Added support for [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") to `from_backend()`. Now it can generate a `NoiseModel` object from an input [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") instance. When a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") input is used on `from_backend()` the two deprecated options, `standard_gates` and `warnings`, are gracefully ignored.

*   Added Aer implementation of [`primitives`](primitives#module-qiskit.primitives "qiskit.primitives"), [`Sampler`](https://qiskit.org/ecosystem/aer/stubs/qiskit_aer.primitives.Sampler.html#qiskit_aer.primitives.Sampler "(in Qiskit Aer v0.13.0)") and `BaseSampler` and [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator") interfaces leverage qiskit aer to efficiently perform the computation of the primitive operations. You can refer to the [`qiskit.primitives`](primitives#module-qiskit.primitives "qiskit.primitives") docs for a more detailed description of the primitives API.

*   Added a shared library to Qiskit Aer that allows external programs to use Aer’s simulation methods. This is an experimental feature and its API may be changed without the deprecation period.

*   Added support for M1 macOS systems. Precompiled binaries for supported Python versions >=3.8 on arm64 macOS will now be published on PyPI for this and future releases.

*   Added support for cuQuantum, NVIDIA’s APIs for quantum computing, to accelerate statevector, density matrix and unitary simulators by using GPUs. This is experiemental implementation for cuQuantum Beta 2. (0.1.0) cuStateVec APIs are enabled to accelerate instead of Aer’s implementations by building Aer by setting path of cuQuantum to `CUSTATEVEC_ROOT`. (binary distribution is not available currently.) cuStateVector is enabled by setting `device='GPU'` and `cuStateVec_threshold` options. cuStateVec is enabled when number of qubits of input circuit is equal or greater than `cuStateVec_threshold`.

*   Added partial support for running on ppc64le and s390x Linux platforms. This release will start publishing pre-compiled binaries for ppc64le and s390x Linux platforms on all Python versions. However, unlike other supported platforms not all of Qiskit’s upstream dependencies support these platforms yet. So a C/C++ compiler may be required to build and install these dependencies and a simple `pip install qiskit-aer` with just a working Python environment will not be sufficient to install Qiskit Aer. Additionally, these same constraints prevent us from testing the pre-compiled wheels before publishing them, so the same guarantees around platform support that exist for the other platforms don’t apply to these platforms.

*   Allow initialization with a label, that consists of `+-rl`. Now the following code works:

    ```python
    import qiskit
    from qiskit_aer import AerSimulator

    qc = qiskit.QuantumCircuit(4)
    qc.initialize('+-rl')
    qc.save_statevector()

    AerSimulator(method="statevector").run(qc)
    ```

<span id="release-notes-aer-0-11-0-known-issues" />

<span id="id102" />

#### Known Issues

*   When running on Linux s390x platforms (or other big endian platforms) running circuits that contain [`UnitaryGate`](qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") operations will not work because of an endianess bug. See [#1506](https://github.com/Qiskit/qiskit-aer/issues/1506) for more details.

<span id="release-notes-aer-0-11-0-upgrade-notes" />

<span id="id103" />

#### Upgrade Notes

*   MPI parallelization for large number of qubits is optimized to apply multiple chunk-swaps as all-to-all communication that can decrease data size exchanged over MPI processes. This upgrade improve scalability of parallelization.

*   Set default `fusion_max_qubit` and `fusion_threshold` depending on the configured `method` for `AerSimulator`. Previously, the default values of `fusion_max_qubit` and `fusion_threshold` were `5` and `14` respectively for all simulation methods. However, their optimal values depend on running methods. If you depended on the previous defaults you can explicitly set `fusion_max_qubit=5` or `fusion_threshold=14` to retain the previous default behavior. For example:

    ```python
    from qiskit_aer import AerSimulator

    sim = AerSimulator(method='mps', fusion_max_qubit=5, fusion_threshold=14)
    ```

*   This is update to support cuQuantum 22.5.0.41 including bug fix of thread safety in some cuStateVec APIs. Now Qiskit Aer turns on multi-threading for multi-shots and multi-chunk parallelization when enabling cuStateVec.

*   Running qiskit-aer with Python 3.6 is no longer supported. Python >= 3.7 is now required to install and run qiskit-aer.

*   The `qiskit-aer` Python package has moved to be a self-contained namespace, `qiskit_aer`. Previously, it shared a namespace with `qiskit-terra` by being `qiskit.providers.aer`. [This was problematic for several reasons](https://github.com/Qiskit/qiskit/issues/559), and this release moves away from it. For the time being `import qiskit.providers.aer` will continue to work and redirect to `qiskit_aer` automatically. Imports from the legacy `qiskit.provider.aer` namespace will emit a `DeprecationWarning` in the future. To avoid any potential issues starting with this release, updating all imports from `qiskit.providers.aer` to `qiskit_aer` and from `qiskit.Aer` to `qiskit_aer.Aer` is recommended.

*   Removed snapshot instructions (such as `SnapshotStatevector`) which were deprecated since 0.9.0. Applications that use these instructions need to be modified to use corresponding save instructions (such as `SaveStatevector`).

*   Removed the `qiskit_aer.extensions` module completely. With the removal of the snapshot instructions, this module has become empty and no longer serves a purpose.

*   The required version of Qiskit Terra has been bumped to 0.20.0.

<span id="release-notes-aer-0-11-0-bug-fixes" />

<span id="id104" />

#### Bug Fixes

*   Fixes for MPI chunk distribution. Including fix for global indexing for Thrust implementations, fix for cache blocking of non-gate operations. Also savestatevector returns same statevector to all processes (only 1st process received statevector previously.)

*   Handles a multiplexer gate as a unitary gate if it has no control qubits. Previously, if a multiplexer gate does not have control qubits, quantum state was not updated.

*   Fixes a bug in `RelaxationNoisePass` where instruction durations were always assumed to be in *dt* time units, regardless of the actual unit of the isntruction. Now unit conversion is correctly handled for all instruction duration units.

    See [#1453](https://github.com/Qiskit/qiskit-aer/issues/1453) for details.

*   Fixed simulation of `for` loops where the loop parameter was not used in the body of the loop. For example, previously this code would fail, but will now succeed:

    ```python
    import qiskit
    from qiskit_aer import AerSimulator

    qc = qiskit.QuantumCircuit(2)
    with qc.for_loop(range(4)) as i:
        qc.h(0)
        qc.cx(0, 1)

    AerSimulator(method="statevector").run(qc)
    ```

*   Fixes a bug in `NoiseModel.from_backend()` that raised an error when T2 value greater than 2 \* T1 was supplied by the backend. After this fix, it becomes to truncate T2 value up to 2 \* T1 and issue a user warning if truncates. The bug was introduced at #1391 and, before that, `NoiseModel.from_backend()` had truncated the T2 value up to 2 \* T1 silently.

    See [Issue 1464](https://github.com/Qiskit/qiskit-aer/issues/1464) for details.

*   Fix performance regression in noisy simulations due to large increase in serialization overhead for loading noise models from Python into C++ resulting from unintended nested Python multiprocessing calls. See [issue 1407](https://github.com/Qiskit/qiskit-aer/issues/1407) for details.

*   This is the fix for Issue #1557. Different seed numbers are generated for each process if seed\_simulator option is not set. This fix average seed set in Circuit for all processes to use the same seed number.

*   This is a fix of MPI parallelization for multi-chunk parallelization and multi-shot distribution over parallel processes. There were missing distribution configuration that prevents MPI distribution, is now fixed.

*   This is fix for cache blocking transpiler and chunk parallelization for GPUs or MPI. This fix fixes issue with qubits which has many control or target qubits (> blocking\_qubits). From this fix, only target qubits of the multi-controlled gate is cache blocked in blocking\_qubits. But it does not support case if number of target qubits is still larger than blocking\_qubits (i.e. large unitary matrix multiplication)

*   Fixes a bug in `QuantumError.to_dict()` where N-qubit circuit instructions where the assembled instruction always applied to qubits `[0, ..., N-1]` rather than the instruction qubits. This bug also affected device and fake backend noise models.

    See [Issue 1415](https://github.com/Qiskit/qiskit-aer/issues/1415) for details.

*   Because a seed was randomly assigned to each circuit if seed\_simulator is not set, multi-circuit simulation was not reproducible with another multi-circuit simulation. Users needed to run multiple single-circuit simulation with the seed\_simulator which is randomly assigned in the multi-circuit simulation. This fix allows users to reproduce multi-circuit simulation with another multi-circuit simulation by setting seed\_simulator of the first circuit in the first multi-circuit simulation. This fix also resolve an issue reported in [https://github.com/Qiskit/qiskit-aer/issues/1511](https://github.com/Qiskit/qiskit-aer/issues/1511), where simulation with parameter-binds returns identical results for each circuit instance.

*   Fix performance issue in multi-shots batched optimization for GPU when using Pauli noise. This fix allows multi-threading to runtime noise sampling, and uses nested OpenMP parallelization when using multiple GPUs. This is fix for issue 1473 \<[https://github.com/Qiskit/qiskit-aer/issues/1473](https://github.com/Qiskit/qiskit-aer/issues/1473)>

*   This is the fix for cuStateVec support, fix for build error because of specification change of some APIs of cuStateVec from cuQuantum version 0.40.

*   Fixes an issue when while\_loop is the tail of QuantumCircuit. while\_loop is translated to jump and mark instructions. However, if a while\_loop is at the end of a circuit, its mark instruction is truncated wrongly. This fix corrects the truncation algorithm to always remain mark instructions.

<span id="id105" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-37-2" />

## Qiskit 0.37.2

<span id="release-notes-terra-0-21-2" />

<span id="id106" />

### Terra 0.21.2

<span id="release-notes-terra-0-21-2-prelude" />

<span id="id107" />

#### Prelude

Qiskit Terra 0.21.2 is a primarily a bugfix release, and also comes with several improved documentation pages.

<span id="release-notes-terra-0-21-2-bug-fixes" />

<span id="id108" />

#### Bug Fixes

*   `aer_simulator_statevector_gpu` will now be recognized correctly as statevector method in some function when using Qiskit Aer’s GPU simulators in [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") and other algorithm runners.

*   Fixed the [`UCGate.inverse()`](qiskit.circuit.library.UCGate#inverse "qiskit.circuit.library.UCGate.inverse") method which previously did not invert the global phase.

*   [`QuantumCircuit.compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") will now function correctly when used with the `inplace=True` argument within control-flow builder contexts. Previously the instructions would be added outside the control-flow scope. Fixed [#8433](https://github.com/Qiskit/qiskit-terra/issues/8433).

*   Fixed a bug where a bound [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") was not identified as real if `symengine` was installed and the bound expression was not a plain `1j`. For example:

    ```python
    from qiskit.circuit import Parameter

    x = Parameter("x")
    expr = 1j * x
    bound = expr.bind({x: 2})
    print(bound.is_real())  # used to be True, but is now False
    ```

*   Fixed QPY serialisation and deserialisation of [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") with open controls (*i.e.* those whose `ctrl_state` is not all ones). Fixed [#8549](https://github.com/Qiskit/qiskit-terra/issues/8549).

*   All fake backends in `qiskit.providers.fake_provider.backends` have been updated to return the corresponding pulse channel objects with the method call of `drive_channel()`, `measure_channel()`, `acquire_channel()`, `control_channel()`.

*   Fixed support for running `Z2Symmetries.taper()` on larger problems. Previously, the method would require a large amount of memory which would typically cause failures for larger problem. As a side effect of this fix the performance has significantly improved.

<span id="aer-0-10-4" />

### Aer 0.10.4

No change

<span id="id109" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-37-1" />

## Qiskit 0.37.1

<span id="terra-0-21-1" />

<span id="release-notes-terra-0-21-1" />

### Terra 0.21.1

<span id="release-notes-terra-0-21-1-bug-fixes" />

<span id="id110" />

#### Bug Fixes

*   Fixed an issue in [`QuantumCircuit.decompose()`](qiskit.circuit.QuantumCircuit#decompose "qiskit.circuit.QuantumCircuit.decompose") method when passing in a list of `Gate` classes for the `gates_to_decompose` argument. If any gates in the circuit had a label set this argument wouldn’t be handled correctly and caused the output decomposition to incorrectly skip gates explicitly in the `gates_to_decompose` list.

*   Fix [`to_instruction()`](qiskit.opflow.evolutions.EvolvedOp#to_instruction "qiskit.opflow.evolutions.EvolvedOp.to_instruction") which previously tried to create a [`UnitaryGate`](qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") without exponentiating the operator to evolve. Since this operator is generally not unitary, this raised an error (and if the operator would have been unitary by chance, it would not have been the expected result).

    Now calling [`to_instruction()`](qiskit.opflow.evolutions.EvolvedOp#to_instruction "qiskit.opflow.evolutions.EvolvedOp.to_instruction") correctly produces a gate that implements the time evolution of the operator it holds:

    ```python
    >>> from qiskit.opflow import EvolvedOp, X
    >>> op = EvolvedOp(0.5 * X)
    >>> op.to_instruction()
    Instruction(
        name='unitary', num_qubits=1, num_clbits=0,
        params=[array([[0.87758256+0.j, 0.-0.47942554j], [0.-0.47942554j, 0.87758256+0.j]])]
    )
    ```

*   Fixed an issue with the [`marginal_distribution()`](result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution") function: when a numpy array was passed in for the `indices` argument the function would raise an error. Fixed [#8283](https://github.com/Qiskit/qiskit-terra/issues/8283)

*   Previously it was not possible to adjoint a [`CircuitStateFn`](qiskit.opflow.state_fns.CircuitStateFn "qiskit.opflow.state_fns.CircuitStateFn") that has been constructed from a [`VectorStateFn`](qiskit.opflow.state_fns.VectorStateFn "qiskit.opflow.state_fns.VectorStateFn"). That’s because the statevector has been converted to a circuit with the `Initialize` instruction, which is not unitary. This problem is now fixed by instead using the [`StatePreparation`](qiskit.circuit.library.StatePreparation "qiskit.circuit.library.StatePreparation") instruction, which can be used since the state is assumed to start out in the all 0 state.

    For example we can now do:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.opflow import StateFn

    left = StateFn([0, 1])
    left_circuit = left.to_circuit_op().primitive

    right_circuit = QuantumCircuit(1)
    right_circuit.x(0)

    overlap = left_circuit.inverse().compose(right_circuit)  # this line raised an error before!
    ```

*   Fix a bug in the [`Optimizer`](qiskit.algorithms.optimizers.Optimizer "qiskit.algorithms.optimizers.Optimizer") classes where re-constructing a new optimizer instance from a previously exisiting [`settings`](qiskit.algorithms.optimizers.Optimizer#settings "qiskit.algorithms.optimizers.Optimizer.settings") reset both the new and previous optimizer settings to the defaults. This notably led to a bug if [`Optimizer`](qiskit.algorithms.optimizers.Optimizer "qiskit.algorithms.optimizers.Optimizer") objects were send as input to Qiskit Runtime programs.

    Now optimizer objects are correctly reconstructed:

    ```python
    >>> from qiskit.algorithms.optimizers import COBYLA
    >>> original = COBYLA(maxiter=1)
    >>> reconstructed = COBYLA(**original.settings)
    >>> reconstructed._options["maxiter"]
    1  # used to be 1000!
    ```

*   Fixed an issue where the `limit_amplitude` argument on an individual [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") or [`Waveform`](qiskit.pulse.library.Waveform "qiskit.pulse.library.Waveform") instance was not properly reflected by parameter validation. In addition, QPY schedule [`dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") has been fixed to correctly store the `limit_amplitude` value tied to the instance, rather than saving the global class variable.

*   Fix the pairwise entanglement structure for [`NLocal`](qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") circuits. This led to a bug in the [`ZZFeatureMap`](qiskit.circuit.library.ZZFeatureMap "qiskit.circuit.library.ZZFeatureMap"), where using `entanglement="pairwise"` raised an error. Now it correctly produces the desired feature map:

    ```python
    from qiskit.circuit.library import ZZFeatureMap
    encoding = ZZFeatureMap(4, entanglement="pairwise", reps=1)
    print(encoding.decompose().draw())
    ```

    The above prints:

    ```python
         ┌───┐┌─────────────┐
    q_0: ┤ H ├┤ P(2.0*x[0]) ├──■────────────────────────────────────■────────────────────────────────────────────
         ├───┤├─────────────┤┌─┴─┐┌──────────────────────────────┐┌─┴─┐
    q_1: ┤ H ├┤ P(2.0*x[1]) ├┤ X ├┤ P(2.0*(π - x[0])*(π - x[1])) ├┤ X ├──■────────────────────────────────────■──
         ├───┤├─────────────┤└───┘└──────────────────────────────┘└───┘┌─┴─┐┌──────────────────────────────┐┌─┴─┐
    q_2: ┤ H ├┤ P(2.0*x[2]) ├──■────────────────────────────────────■──┤ X ├┤ P(2.0*(π - x[1])*(π - x[2])) ├┤ X ├
         ├───┤├─────────────┤┌─┴─┐┌──────────────────────────────┐┌─┴─┐└───┘└──────────────────────────────┘└───┘
    q_3: ┤ H ├┤ P(2.0*x[3]) ├┤ X ├┤ P(2.0*(π - x[2])*(π - x[3])) ├┤ X ├──────────────────────────────────────────
         └───┘└─────────────┘└───┘└──────────────────────────────┘└───┘
    ```

*   Fixed an issue in handling the global phase of the [`UCGate`](qiskit.circuit.library.UCGate "qiskit.circuit.library.UCGate") class.

<span id="id111" />

### Aer 0.10.4

No change

<span id="id112" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-37-0" />

## Qiskit 0.37.0

This release officially marks the end of support for the Qiskit Ignis project from Qiskit. It was originally deprecated in the 0.33.0 release and as was documented in that release the `qiskit-ignis` package has been removed from the Qiskit metapackage, which means in that future release `pip install qiskit` will no longer include `qiskit-ignis`. However, note because of limitations in python packaging we cannot automatically remove a pre-existing install of `qiskit-ignis`. If you are upgrading from a previous version it’s recommended that you manually uninstall Qiskit Ignis with `pip uninstall qiskit-ignis` or install the metapackage in a fresh python environment.

Qiskit Ignis has been supersceded by the [Qiskit Experiments](https://qiskit.org/documentation/experiments/) project. You can refer to the [migration guide](https://github.com/Qiskit/qiskit-ignis#migration-guide) for details on how to switch from Qiskit Ignis to Qiskit Experiments.

<span id="terra-0-21-0" />

### Terra 0.21.0

<span id="release-notes-0-21-0-prelude" />

<span id="id113" />

#### Prelude

The Qiskit 0.21.0 release highlights are:

> *   Support for serialization of a pulse [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") via [`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy"). The [QPY Format](qpy#qpy-format) has been updated to version 5 which includes a definition for including the pulse schedules. To support this, a new [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") class was introduced to enable defining parametric pulse waveforms via symbolic expressions.
> *   Improvements to working with preset pass managers. A new function [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") enables easily generating a pass manager equivalent to what [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") will use internally. Additionally, preset pass managers are now instances of [`StagedPassManager`](qiskit.transpiler.StagedPassManager "qiskit.transpiler.StagedPassManager") which makes it easier to modify sections.
> *   A refactor of the internal data structure of the [`QuantumCircuit.data`](qiskit.circuit.QuantumCircuit#data "qiskit.circuit.QuantumCircuit.data") attribute. It previously was a list of tuples in the form `(instruction, qubits, clbits)` and now is a list of [`CircuitInstruction`](qiskit.circuit.CircuitInstruction "qiskit.circuit.CircuitInstruction") objects. The [`CircuitInstruction`](qiskit.circuit.CircuitInstruction "qiskit.circuit.CircuitInstruction") objects is backwards compatible with the previous tuple based access, however with runtime overhead cost.

Additionally, the transpiler has been improved to enable better quality outputs. This includes the introduction of new passes such as [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") and `ToqmSwap`.

<span id="id114" />

#### New Features

*   Added a new class, [`qiskit.transpiler.StagedPassManager`](qiskit.transpiler.StagedPassManager "qiskit.transpiler.StagedPassManager"), which is a [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") subclass that has a pipeline with defined phases to perform circuit compilation. Each phase is a [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") object that will get executed in a fixed order. For example:

    ```python
    from qiskit.transpiler.passes import *
    from qiskit.transpiler import PassManager, StagedPassManager

    basis_gates = ['rx', 'ry', 'rxx']
    init = PassManager([UnitarySynthesis(basis_gates, min_qubits=3), Unroll3qOrMore()])
    translate = PassManager([Collect2qBlocks(),
                             ConsolidateBlocks(basis_gates=basis_gates),
                             UnitarySynthesis(basis_gates)])

    staged_pm = StagedPassManager(stages=['init', 'translation'], init=init, translation=translate)
    ```

*   Added the methods [`PauliList.group_commuting()`](qiskit.quantum_info.PauliList#group_commuting "qiskit.quantum_info.PauliList.group_commuting") and [`SparsePauliOp.group_commuting()`](qiskit.quantum_info.SparsePauliOp#group_commuting "qiskit.quantum_info.SparsePauliOp.group_commuting"), which partition these operators into sublists where each element commutes with all the others. For example:

    ```python
    from qiskit.quantum_info import PauliList, SparsePauliOp

    groups = PauliList(["XX", "YY", "IZ", "ZZ"]).group_commuting()
    # 'groups' is [PauliList(['IZ', 'ZZ']), PauliList(['XX', 'YY'])]

    op = SparsePauliOp.from_list([("XX", 2), ("YY", 1), ("IZ", 2j), ("ZZ", 1j)])
    groups = op.group_commuting()
    # 'groups' is [
    #     SparsePauliOp(['IZ', 'ZZ'], coeffs=[0.+2.j, 0.+1.j]),
    #     SparsePauliOp(['XX', 'YY'], coeffs=[2.+0.j, 1.+0.j]),
    # ]
    ```

*   Added a new function, [`marginal_distribution()`](result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution"), which is used to marginalize an input dictionary of bitstrings to an integer (such as [`Counts`](qiskit.result.Counts "qiskit.result.Counts")). This is similar in functionality to the existing [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") function with three key differences. The first is that [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") works with either a counts dictionary or a `Results` object while [`marginal_distribution()`](result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution") only works with a dictionary. The second is that [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") does not respect the order of indices in its `indices` argument while [`marginal_distribution()`](result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution") does and will permute the output bits based on the `indices` order. The third difference is that [`marginal_distribution()`](result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution") should be faster as its implementation is written in Rust and streamlined for just marginalizing a dictionary input.

*   Added the `@` (`__matmul__`) binary operator to `BaseOperator` subclasses in the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module. This is shorthand to call the classes’ `dot` method (`A @ B == A.dot(B)`).

*   Added a new optional argument, `reps`, to [`QuantumCircuit.decompose()`](qiskit.circuit.QuantumCircuit#decompose "qiskit.circuit.QuantumCircuit.decompose"), which allows repeated decomposition of the circuit. For example:

    ```python
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.ry(0.5, 0)

    # Equivalent to circuit.decompose().decompose()
    circuit.decompose(reps=2)

    # decompose 2 times, but only RY gate 2 times and R gate 1 times
    circuit.decompose(gates_to_decompose=['ry','r'], reps=2)
    ```

*   Added a new pulse base class [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse"). This is a replacement of the conventional [`ParametricPulse`](qiskit.pulse.library.ParametricPulse "qiskit.pulse.library.ParametricPulse"), which will be deprecated. In the new base class, pulse-envelope and parameter-validation functions are represented by symbolic-expression objects. The new class provides self-contained and portable pulse data since these symbolic equations can be easily serialized through symbolic computation libraries.

*   Added support for non-Hermitian operators in [`AerPauliExpectation`](qiskit.opflow.expectations.AerPauliExpectation "qiskit.opflow.expectations.AerPauliExpectation"). This allows the use of Aer’s fast snapshot expectation computations in algorithms such as `QEOM`.

*   Added a new circuit drawing style, `textbook`, which uses the color scheme of the Qiskit Textbook.

*   A new attribute [`QuantumCircuit.op_start_times`](qiskit.circuit.QuantumCircuit#op_start_times "qiskit.circuit.QuantumCircuit.op_start_times") is populated when one of scheduling analysis passes is run on the circuit. It can be used to obtain circuit instruction with instruction time, for example:

    ```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.providers.fake_provider import FakeMontreal

    backend = FakeMontreal()

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)

    qct = transpile(
        qc, backend, initial_layout=[0, 1], coupling_map=[[0, 1]], scheduling_method="alap"
    )
    scheduled_insts = list(zip(qct.op_start_times, qct.data))
    ```

*   Added a new method [`QuantumCircuit.clear()`](qiskit.circuit.QuantumCircuit#clear "qiskit.circuit.QuantumCircuit.clear") which is used to remove all instructions from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").

*   Added a new method [`QuantumCircuit.copy_empty_like()`](qiskit.circuit.QuantumCircuit#copy_empty_like "qiskit.circuit.QuantumCircuit.copy_empty_like") which is used to get a cleared copy of a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instance. This is logically equivalent to `qc.copy().clear()`, but significantly faster and more memory-efficient. This is useful when one needs a new empty circuit with all the same resources (qubits, classical bits, metadata, and so on) already added.

*   The [`Target.instruction_supported()`](qiskit.transpiler.Target#instruction_supported "qiskit.transpiler.Target.instruction_supported") method now supports two new keyword arguments, `operation_class` and `parameters`. Using these arguments the [`instruction_supported()`](qiskit.transpiler.Target#instruction_supported "qiskit.transpiler.Target.instruction_supported") method can now be used for checking that a specific operation with parameter values are supported by a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object. For example, if you want to check if a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") named `target` supports running a [`RXGate`](qiskit.circuit.library.RXGate "qiskit.circuit.library.RXGate") with $\theta = \frac{\pi}{2}$ you would do something like:

    ```python
    from math import pi
    from qiskit.circuit.library import RXGate

    target.instruction_supported(operation_class=RXGate, parameters=[pi/2])
    ```

    which will return `True` if `target` supports running [`RXGate`](qiskit.circuit.library.RXGate "qiskit.circuit.library.RXGate") with $\theta = \frac{\pi}{2}$ and `False` if it does not.

*   Added a Trotterization-based quantum real-time evolution algorithm [`qiskit.algorithms.TrotterQRTE`](qiskit.algorithms.TrotterQRTE "qiskit.algorithms.TrotterQRTE"). It is compliant with the new quantum time evolution framework and makes use of the [`ProductFormula`](qiskit.synthesis.ProductFormula "qiskit.synthesis.ProductFormula") and [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") implementations.

    ```python
    from qiskit.algorithms import EvolutionProblem
    from qiskit.algorithms.evolvers.trotterization import TrotterQRTE
    from qiskit.opflow import X, Z, StateFn, SummedOp

    operator = SummedOp([X, Z])
    initial_state = StateFn([1, 0])
    time = 1
    evolution_problem = EvolutionProblem(operator, time, initial_state)

    trotter_qrte = TrotterQRTE()
    evolution_result = trotter_qrte.evolve(evolution_problem)
    evolved_state_circuit = evolution_result.evolved_state
    ```

*   Added a new function [`generate_preset_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") which can be used to quickly generate a preset [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") object that mirrors the [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") used internally by the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function. For example:

    ```python
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    from qiskit.providers.fake_provider import FakeWashingtonV2

    # Generate an optimization level 3 pass manager targeting FakeWashingtonV2
    pass_manager = generate_preset_pass_manager(3, FakeWashingtonV2())
    ```

*   Added a new function [`marginal_memory()`](result#qiskit.result.marginal_memory "qiskit.result.marginal_memory") which is used to marginalize shot memory arrays. Provided with the shot memory array and the indices of interest, the function will return a maginized shot memory array. This function differs from the memory support in the [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") method which only works on the `memory` field in a `Results` object.

*   The primitives interface has been extended to accept objects in addition to indices as arguments to the `__call__` method. The `parameter_values` argument can now be optional.

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](qasm3#module-qiskit.qasm3 "qiskit.qasm3")) now supports exporting circuits with explicit delays, such as from [`QuantumCircuit.delay()`](qiskit.circuit.QuantumCircuit#delay "qiskit.circuit.QuantumCircuit.delay").

*   Added a new layout and routing method to [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") based on the paper [“Time-optimal qubit mapping”](https://dl.acm.org/doi/10.1145/3445814.3446706). To use it, the optional package [Qiskit TOQM](https://github.com/qiskit-toqm/qiskit-toqm) must be installed. The `routing_method` kwarg of [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") supports an additional value, `'toqm'` which is used to enable layout and routing via TOQM.

    To install `qiskit-toqm` along with Terra, run:

    ```python
    pip install qiskit-terra[toqm]
    ```

*   Added a new module `qiskit.quantum_info.synthesis.qsd` to apply Quantum Shannon Decomposition of arbitrary unitaries. This functionality replaces the previous isometry-based approach in the default unitary synthesis transpiler pass as well as when adding unitaries to a circuit using a [`UnitaryGate`](qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate").

    The Quantum Shannon Decomposition uses about half the cnot gates as the isometry implementation when decomposing unitary matrices of greater than two qubits.

*   Classes in the [`quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module that support scalar multiplication can now be multiplied by a scalar from either the left or the right. Previously, they would only accept scalar multipliers from the left.

*   The transpiler pass [`LookaheadSwap`](qiskit.transpiler.passes.LookaheadSwap "qiskit.transpiler.passes.LookaheadSwap") (used by [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") when `routing_method="lookahead"`) has seen some performance improvements and will now be approximately three times as fast. This is purely being more efficient in its calculations, and does not change the complexity of the algorithm. In most cases, a more modern routing algorithm like [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") (`routing_method="sabre"`) will be vastly more performant.

*   New transpiler passes have been added. The transpiler pass [`Commuting2qGateRouter`](qiskit.transpiler.passes.Commuting2qGateRouter "qiskit.transpiler.passes.Commuting2qGateRouter") uses swap strategies to route a block of commuting gates to the coupling map. Indeed, routing is a hard problem but is significantly easier when the gates commute as in CZ networks. Blocks of commuting gates are also typically found in QAOA. Such cases can be dealt with using swap strategies that apply a predefined set of layers of SWAP gates. Furthermore, the new transpiler pass `FindCommutingPauliEvolutions` identifies blocks of Pauli evolutions made of commuting two-qubit terms. Here, a swap strategy is specified by the class `SwapStrategy`. Swap strategies need to be tailored to the coupling map and, ideally, the circuit for the best results.

*   Introduced a new optimizer to Qiskit library, which adds support to the optimization of parameters of variational quantum algorithms. This is the Univariate Marginal Distribution Algorithm (UMDA), which is a specific type of the Estimation of Distribution Algorithms. For example:

    ```python
    from qiskit.opflow import X, Z, I
    from qiskit import Aer
    from qiskit.algorithms.optimizers import UMDA
    from qiskit.algorithms import QAOA
    from qiskit.utils import QuantumInstance

    H2_op = (-1.052373245772859 * I ^ I) + \
            (0.39793742484318045 * I ^ Z) + \
            (-0.39793742484318045 * Z ^ I) + \
            (-0.01128010425623538 * Z ^ Z) + \
            (0.18093119978423156 * X ^ X)

    p = 2  # Toy example: 2 layers with 2 parameters in each layer: 4 variables

    opt = UMDA(maxiter=100, size_gen=20)
    backend = Aer.get_backend('statevector_simulator')
    vqe = QAOA(opt,
               quantum_instance=QuantumInstance(backend=backend),
               reps=p)

    result = vqe.compute_minimum_eigenvalue(operator=H2_op)
    ```

*   The constructor for the [`Unroll3qOrMore`](qiskit.transpiler.passes.Unroll3qOrMore "qiskit.transpiler.passes.Unroll3qOrMore") transpiler pass has two new optional keyword arguments, `target` and `basis_gates`. These options enable you to specify the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") or supported basis gates respectively to describe the target backend. If any of the operations in the circuit are in the `target` or `basis_gates` those will not be unrolled by the pass as the target device has native support for the operation.

*   QPY serialization has been upgraded to support [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"). Now you can save pulse program in binary and load it at later time:

    ```python
    from qiskit import pulse, qpy

    with pulse.build() as schedule:
        pulse.play(pulse.Gaussian(160, 0.1, 40), pulse.DriveChannel(0))

    with open('schedule.qpy', 'wb') as fd:
        qpy.dump(schedule, fd)

    with open('schedule.qpy', 'rb') as fd:
        new_schedule = qpy.load(fd)[0]
    ```

    This uses the QPY interface common to [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). See [SCHEDULE\_BLOCK](qpy#qpy-schedule-block) for details of data structure.

*   Added a new transpiler pass, [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout"). This pass is of a new type to perform a new phase/function in the compilation pipeline, post-layout or post optimization qubit selection. The idea behind this pass is after we finish the optimization loop in transpiler we know what the final gate counts will be on each qubit in the circuit so we can potentially find a better-performing subset of qubits on a backend to execute the circuit. The pass will search for an isomorphic subgraph in the connectivity graph of the target backend and look at the full error rate of the complete circuit on any subgraph found and return the layout found with the lowest error rate for the circuit.

    This pass is similar to the [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") pass and both internally use the same VF2 implementation from [retworkx](https://github.com/Qiskit/retworkx). However, [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") is deisgned to run after initial layout, routing, basis translation, and any optimization passes run and will only work if a layout has already been applied, the circuit has been routed, and all gates are in the target basis. This is required so that when a new layout is applied the circuit can still be run on the target device. [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") on the other hand is designed to find a perfect initial layout and can work with any circuit.

*   The [`ApplyLayout`](qiskit.transpiler.passes.ApplyLayout "qiskit.transpiler.passes.ApplyLayout") transpiler pass now has support for updating a layout on a circuit after a layout has been applied once before. If the `post_layout` field is present (in addition to the required `layout` field) the `property_set` when the [`ApplyLayout`](qiskit.transpiler.passes.ApplyLayout "qiskit.transpiler.passes.ApplyLayout") pass is run the pass will update the layout to apply the new layout. This will return a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") with the qubits in the new physical order and the `layout` property set will be updated so that it maps the virtual qubits from the original layout to the physical qubits in the new `post_layout` field.

*   The preset pass managers generated by [`level_1_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`level_2_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`level_3_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") which correspond to `optimization_level` 1, 2, and 3 respectively on the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function now run the [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") pass after running the routing pass. This enables the transpiler to potentially find a different set of physical qubits on the target backend to run the circuit on which have lower error rates. The [`VF2PostLayout`](qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") pass will not be run if you manually specify a `layout_method`, `routing_method`, or `initial_layout` arguments to [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"). If the pass can find a better performing subset of qubits on backend to run the physical circuit it will adjust the layout of the circuit to use the alternative qubits instead.

*   The algorithm iteratively computes each eigenstate by starting from the ground state (which is computed as in VQE) and then optimising a modified cost function that tries to compute eigen states that are orthogonal to the states computed in the previous iterations and have the lowest energy when computed over the ansatz. The interface implemented is very similar to that of VQE and is of the form:

    ```python
    from qiskit.algorithms import VQD
    from qiskit.utils import QuantumInstance
    from qiskit.circuit.library import TwoLocal
    from qiskit.algorithms.optimizers import COBYLA
    from qiskit import BasicAer
    from qiskit.opflow import I,Z,X

    h2_op = (
        -1.052373245772859 * (I ^ I)
        + 0.39793742484318045 * (I ^ Z)
        - 0.39793742484318045 * (Z ^ I)
        - 0.01128010425623538 * (Z ^ Z)
        + 0.18093119978423156 * (X ^ X)
    )

    vqd = VQD(k =2, ansatz = TwoLocal(rotation_blocks="ry", entanglement_blocks="cz"),optimizer = COBYLA(maxiter = 0), quantum_instance = QuantumInstance(
                BasicAer.get_backend("qasm_simulator"), shots = 2048)
            )
    vqd_res = vqd.compute_eigenvalues(op)
    ```

    This particular code snippet generates 2 eigenvalues (ground and 1st excited state) Tests have also been implemented.

<span id="release-notes-0-21-0-upgrade-notes" />

<span id="id115" />

#### Upgrade Notes

*   The pulse classes in [`qiskit.pulse.library`](pulse#module-qiskit.pulse.library "qiskit.pulse.library") are now subclasses of [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") rather than [`ParametricPulse`](qiskit.pulse.library.ParametricPulse "qiskit.pulse.library.ParametricPulse"). The available classes remain unchanged as [`Gaussian`](qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian"), [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare"), [`Drag`](qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag"), and [`Constant`](qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant"). [`SymbolicPulse`](qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") has full backward compatibility, and there should be no loss of functionality.

*   The data type of each element in [`QuantumCircuit.data`](qiskit.circuit.QuantumCircuit#data "qiskit.circuit.QuantumCircuit.data") has changed. It used to be a simple 3-tuple of an [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction"), a list of [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit")s, and a list of [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit")s, whereas it is now an instance of [`CircuitInstruction`](qiskit.circuit.CircuitInstruction "qiskit.circuit.CircuitInstruction").

    The attributes of this new class are [`operation`](qiskit.circuit.CircuitInstruction#operation "qiskit.circuit.CircuitInstruction.operation"), [`qubits`](qiskit.circuit.CircuitInstruction#qubits "qiskit.circuit.CircuitInstruction.qubits") and [`clbits`](qiskit.circuit.CircuitInstruction#clbits "qiskit.circuit.CircuitInstruction.clbits"), corresponding to the elements of the previous tuple. However, [`qubits`](qiskit.circuit.CircuitInstruction#qubits "qiskit.circuit.CircuitInstruction.qubits") and [`clbits`](qiskit.circuit.CircuitInstruction#clbits "qiskit.circuit.CircuitInstruction.clbits") are now `tuple` instances, not `list`s.

    This new class will behave exactly like the old 3-tuple if one attempts to access its index its elements, or iterate through it. This includes casting the [`qubits`](qiskit.circuit.CircuitInstruction#qubits "qiskit.circuit.CircuitInstruction.qubits") and [`clbits`](qiskit.circuit.CircuitInstruction#clbits "qiskit.circuit.CircuitInstruction.clbits") elements to lists. This is to assist backwards compatibility. Starting from Qiskit Terra 0.21, this is no longer the preferred way to access these elements. Instead, you should use the attribute-access form described above.

    This has been done to allow further developments of the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") data structure in Terra, without constantly breaking backwards compatibility. Planned developments include dynamic parameterized circuits, and an overall reduction in memory usage of deep circuits.

*   The `python-constraint` dependency, which is used solely by the [`CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") transpiler pass, is no longer in the requirements list for the Qiskit Terra package. This is because the [`CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") pass is no longer used by default in any of the preset pass managers for [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"). While the pass is still available, if you’re using it you will need to manually install `python-contraint` or when you install `qiskit-terra` you can use the `csp-layout` extra, for example:

    ```python
    pip install "qiskit-terra[csp-layout]"
    ```

*   The QPY version format version emitted by [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") has been increased to version 5. This new format version is incompatible with the previous versions and will result in an error when trying to load it with a deserializer that isn’t able to handle QPY version 5. This change was necessary to fix support for representing controlled gates properly and representing non-default control states.

*   Qiskit Terra’s compiled Rust extensions now have a minimum supported Rust version (MSRV) of 1.56.1. This means when building Qiskit Terra from source the oldest version of the Rust compiler supported is 1.56.1. If you are using an older version of the Rust compiler you will need to update to a newer version to continue to build Qiskit from source. This change was necessary as a number of upstream dependencies have updated their minimum supported versions too.

*   Circuit scheduling now executes in parallel when more than one circuit is provided to [`schedule()`](compiler#qiskit.compiler.schedule "qiskit.compiler.schedule"). Refer to [#2695](https://github.com/Qiskit/qiskit-terra/issues/2695) for more details.

*   The previously deprecated `BaseBackend`, `BaseJob`, and `BaseProvider` classes have all been removed. They were originally deprecated in the 0.18.0 release. Instead of these classes you should be using the versioned providers interface classes, the latest being [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2"), [`JobV1`](qiskit.providers.JobV1 "qiskit.providers.JobV1"), and [`ProviderV1`](qiskit.providers.ProviderV1 "qiskit.providers.ProviderV1").

*   The previously deprecated `backend` argument for the constructor of the [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") transpiler pass has been removed. It was originally deprecated in the 0.19.0 release. Instead you should query the [`Backend`](qiskit.providers.Backend "qiskit.providers.Backend") object for the `instruction_schedule_map` and `qubit_channel_mapping` and pass that directly to the constructor. For example, with a [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") backend:

    ```python
    from qiskit.transpiler.passes import RZXCalibrationBuilder
    from qiskit.providers.fake_provider import FakeMumbai

    backend = FakeMumbai()
    inst_map = backend.defaults().instruction_schedule_map
    channel_map = backend.configuration().qubit_channel_mapping
    cal_pass = RZXCalibrationBuilder(
        instruction_schedule_map=inst_map,
        qubit_channel_mapping=channel_map,
    )
    ```

    or with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend:

    ```python
    from qiskit.transpiler.passes import RZXCalibrationBuilder
    from qiskit.providers.fake_provider import FakeMumbaiV2

    backend = FakeMumbaiV2()
    inst_map = backend.instruction_schedule_map
    channel_map = {bit: backend.drive_channel(bit) for bit in range(backend.num_qubits)}
    cal_pass = RZXCalibrationBuilder(
        instruction_schedule_map=inst_map,
        qubit_channel_mapping=channel_map,
    )
    ```

*   The measurement shot limit for the `BasicAer` backend has been removed.

*   For the `DAGNode`, the previously deprecated `type`, `op`, `qargs`, `cargs`, and `wire` kwargs and attributes have been removed. These were originally deprecated in the 0.19.0 release. The `op`, `qargs`, and `cargs` kwargs and attributes can be accessed only on instances of `DAGOpNode`, and the `wire` kwarg and attribute are only on instances of `DAGInNode` or `DAGOutNode`.

*   The deprecated function `pauli_group()` has been removed. It was originally deprecated in Qiskit Terra 0.17.

*   Several deprecated methods on [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") have been removed, which were originally deprecated in Qiskit Terra 0.17. These were:

    ## `sgn_prod`

    Use [`Pauli.compose()`](qiskit.quantum_info.Pauli#compose "qiskit.quantum_info.Pauli.compose") or [`Pauli.dot()`](qiskit.quantum_info.Pauli#dot "qiskit.quantum_info.Pauli.dot") instead.

    ## `to_spmatrix`

    Use [`Pauli.to_matrix()`](qiskit.quantum_info.Pauli#to_matrix "qiskit.quantum_info.Pauli.to_matrix") with argument `sparse=True` instead.

    ## `kron`

    Use [`Pauli.expand()`](qiskit.quantum_info.Pauli#expand "qiskit.quantum_info.Pauli.expand"), but beware that this returns a new object, rather than mutating the existing one.

    ## `update_z` and `update_x`

    Set the `z` and `x` attributes of the object directly.

    ## `insert_paulis`

    Use [`Pauli.insert()`](qiskit.quantum_info.Pauli#insert "qiskit.quantum_info.Pauli.insert").

    ## `append_paulis`

    Use [`Pauli.expand()`](qiskit.quantum_info.Pauli#expand "qiskit.quantum_info.Pauli.expand").

    ## `delete_qubits`

    Use [`Pauli.delete()`](qiskit.quantum_info.Pauli#delete "qiskit.quantum_info.Pauli.delete").

    ## `pauli_single`

    Construct the label manually and pass directly to the initializer, such as:

    ```python
    Pauli("I" * index + pauli_label + "I" * (num_qubits - index - len(pauli_label)))
    ```

    ## `random`

    Use [`quantum_info.random_pauli()`](quantum_info#qiskit.quantum_info.random_pauli "qiskit.quantum_info.random_pauli") instead.

*   Removed the `optimize` method from the [`Optimizer`](qiskit.algorithms.optimizers.Optimizer "qiskit.algorithms.optimizers.Optimizer") classes, which is superseded by the [`minimize()`](qiskit.algorithms.optimizers.Optimizer#minimize "qiskit.algorithms.optimizers.Optimizer.minimize") method as direct replacement. The one exception is [`SPSA`](qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA"), where the deprecation warning was not triggered so the method there is still kept.

*   [`Result`](qiskit.result.Result "qiskit.result.Result") was modified so that it always contains `date`, `status`, and `header` attributes (set to `None` if not specified).

*   For Python 3.7 [shared-memory38](https://pypi.org/project/shared-memory38/) is now a dependency. This was added as a dependency for Python 3.7 to enable leveraging the shared memory constructs in the standard library of newer versions of Python. If you’re running on Python >= 3.8 there is no extra dependency required.

*   [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") labels are now type-checked on instruction creation.

*   QPY serialization has been upgraded to serialize [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with [`QuantumCircuit.calibrations`](qiskit.circuit.QuantumCircuit#calibrations "qiskit.circuit.QuantumCircuit.calibrations"). As of QPY Version 5, only calibration entries of [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") type can be serialized.

*   The definition of [`XXPlusYYGate`](qiskit.circuit.library.XXPlusYYGate "qiskit.circuit.library.XXPlusYYGate") has been changed. See [#7969](https://github.com/Qiskit/qiskit-terra/pull/7949) for details.

*   The preset pass managers generated by [`level_1_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`level_2_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`level_3_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") and used by the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function’s `optimization_level` argument at 1, 2, and 3 respectively no longer set a hard time limit on the [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") transpiler pass. This means that the pass will no longer stop trying to find a better alternative perfect layout up until a fixed time limit (100ms for level 1, 10 sec for level 2, and 60 sec for level 3) as doing this limited the reproducibility of compilation when a perfect layout was available. This means that the output when using the pass might be different than before, although in all cases it would only change if a lower noise set of qubits can be found over the previous output. If you wish to retain the previous behavior you can create a custom [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") that sets the `time_limit` argument on the constructor for the `VF2Layout` pass.

<span id="release-notes-0-21-0-deprecation-notes" />

<span id="id116" />

#### Deprecation Notes

*   Calling [`timeline_drawer()`](qiskit.visualization.timeline_drawer "qiskit.visualization.timeline_drawer") with an unscheduled circuit has been deprecated. All circuits, even one consisting only of delay instructions, must be transpiled with the `scheduling_method` keyword argument of [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") set, to generate schedule information being stored in [`QuantumCircuit.op_start_times`](qiskit.circuit.QuantumCircuit#op_start_times "qiskit.circuit.QuantumCircuit.op_start_times").

*   The [NetworkX](https://networkx.org/) converter functions for the `DAGCircuit.to_networkx()` and `from_networkx()`, along with the `DAGDependency.to_networkx()` method have been deprecated and will be removed in a future release. Qiskit has been using [retworkx](https://qiskit.org/documentation/retworkx/) as its graph library since the qiskit-terra 0.12.0 release, and since then the networkx converter functions have been lossy. They were originally added so that users could leverage functionality in NetworkX’s algorithms library not present in retworkx. Since that time, retworkx has matured and offers more functionality, and the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") is tightly coupled to retworkx for its operation. Having these converter methods provides limited value moving forward and are therefore going to be removed in a future release.

*   Accessing several old toggles (`HAS_MATPLOTLIB`, `HAS_PDFTOCAIRO`, `HAS_PYLATEX` and `HAS_PIL`) from the [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization") module is now deprecated, and these import paths will be removed in a future version of Qiskit Terra. The same objects should instead be accessed through [`qiskit.utils.optionals`](utils#module-qiskit.utils.optionals "qiskit.utils.optionals"), which contains testers for almost all of Terra’s optional dependencies.

*   The `qiskit.test.mock` module is now deprecated. The fake backend and fake provider classes which were previously available in `qiskit.test.mock` have been accessible in [`qiskit.providers.fake_provider`](providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") since Terra 0.20.0. This change represents a proper commitment to support the fake backend classes as part of Qiskit, whereas previously they were just part of the internal testing suite, and were exposed to users as a side effect.

*   The arguments’ names when calling an [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator") or [`Sampler`](qiskit.primitives.Sampler "qiskit.primitives.Sampler") object as a function are renamed from `circuit_indices` and `observable_indices` to `circuits` and `observables`.

*   The `qobj_id` and `qobj_header` keyword arguments for the [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute") function have been deprecated and will be removed in a future release. Since the removal of the `BaseBackend` class these arguments don’t have any effect as no backend supports execution with a `Qobj` object directly and instead only work with [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects directly.

*   The arguments `x`, `z` and `label` to the initializer of [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") were documented as deprecated in Qiskit Terra 0.17, but a bug prevented the expected warning from being shown at runtime. The warning will now correctly show, and the arguments will be removed in Qiskit Terra 0.23 or later. A pair of `x` and `z` should be passed positionally as a single tuple (`Pauli((z, x))`). A string `label` should be passed positionally in the first argument (`Pauli("XYZ")`).

*   The [`SPSA.optimize()`](qiskit.algorithms.optimizers.SPSA#optimize "qiskit.algorithms.optimizers.SPSA.optimize") method is deprecated in favor of [`SPSA.minimize()`](qiskit.algorithms.optimizers.SPSA#minimize "qiskit.algorithms.optimizers.SPSA.minimize"), which can be used as direct replacement. Note that this method returns a complete result object with more information than before available.

*   The `circuits` argument of [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") has been deprecated and replaced with `programs` since now QPY supports multiple data types other than circuits.

*   `AlignmentKind.to_dict()` method has been deprecated and will be removed.

<span id="release-notes-0-21-0-bug-fixes" />

<span id="id117" />

#### Bug Fixes

*   Extra validation was added to [`DiagonalGate`](qiskit.circuit.library.DiagonalGate "qiskit.circuit.library.DiagonalGate") to check the argument has modulus one.

*   Duplicate qubit indices given to [`SparsePauliOp.from_sparse_list()`](qiskit.quantum_info.SparsePauliOp#from_sparse_list "qiskit.quantum_info.SparsePauliOp.from_sparse_list") will now correctly raise an error, instead of silently overwriting previous values. The old behavior can be accessed by passing the new keyword argument `do_checks=False`.

*   The [`timeline_drawer()`](qiskit.visualization.timeline_drawer "qiskit.visualization.timeline_drawer") visualization will no longer misalign classical register slots.

*   Parameter validation for [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare") is now consistent before and after construction. Refer to [#7882](https://github.com/Qiskit/qiskit-terra/issues/7882) for more details.

*   The [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2")-based fake backends in the [`qiskit.providers.fake_provider`](providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") module, such as [`FakeMontrealV2`](qiskit.providers.fake_provider.FakeMontrealV2 "qiskit.providers.fake_provider.FakeMontrealV2"), now support the [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") operation in their [`target`](qiskit.providers.BackendV2#target "qiskit.providers.BackendV2.target") attributes. Previously, [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects that contained delays could not be compiled to these backends.

*   Fixed a bug in `TridiagonalToeplitz.eigs_bounds()`, which caused incorrect eigenvalue bounds to be returned in some cases with negative eigenvalues. Refer to [#7939](https://github.com/Qiskit/qiskit-terra/issues/7939) for more details.

*   Fixed a bug in which the LaTeX statevector drawer ignored the `max_size` parameter.

*   Fixed support in the [`PassManagerConfig.from_backend()`](qiskit.transpiler.PassManagerConfig#from_backend "qiskit.transpiler.PassManagerConfig.from_backend") constructor method for building a [`PassManagerConfig`](qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig") object from a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") instance. Previously this wasn’t handled correctly and would fail when running with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") object.

*   Fixed support for QPY serialization ([`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump")) and deserialization ([`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load")) of a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object containing custom [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") objects. Previously, an exception would be raised by [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") when trying to reconstruct the custom [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate"). Fixed [#7999](https://github.com/Qiskit/qiskit-terra/issues/7999).

*   Fixed support for QPY serialization ([`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump")) and deserialization ([`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load")) of a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object containing custom [`MCPhaseGate`](qiskit.circuit.library.MCPhaseGate "qiskit.circuit.library.MCPhaseGate") objects. Previously, an exception would be raised by [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") when trying to reconstruct the [`MCPhaseGate`](qiskit.circuit.library.MCPhaseGate "qiskit.circuit.library.MCPhaseGate").

*   Fixed support for QPY serialization ([`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump")) and deserialization ([`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load")) of a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object containing controlled gates with an open control state. Previously, the open control state would be lost by the serialization process and the reconstructed circuit.

*   Fixed [`QuantumCircuit.reverse_bits()`](qiskit.circuit.QuantumCircuit#reverse_bits "qiskit.circuit.QuantumCircuit.reverse_bits") with circuits containing registerless [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") and [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit"). For example, the following will now work:

    ```python
    from qiskit.circuit import QuantumCircuit, Qubit, Clbit

    qc = QuantumCircuit([Qubit(), Clbit()])
    qc.h(0).c_if(qc.clbits[0], 0)
    qc.reverse_bits()
    ```

*   Fixed the `ConfigurableFakeBackend.t2` attribute, which was previously incorrectly set based on the provided `t1` value.

*   Fixed an issue with [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2")-based fake backend classes from the [`qiskit.providers.fake_provider`](providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") module such as [`FakeMontrealV2`](qiskit.providers.fake_provider.FakeMontrealV2 "qiskit.providers.fake_provider.FakeMontrealV2") where the value for the [`dt`](qiskit.providers.BackendV2#dt "qiskit.providers.BackendV2.dt") attribute (and the [`Target.dt`](qiskit.transpiler.Target#dt "qiskit.transpiler.Target.dt") attribute) were not properly being converted to seconds. This would cause issues when using these fake backends with scheduling.

*   Fixed a bug in [`plot_histogram()`](qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram") when the `number_to_keep` argument was smaller that the number of keys. The following code will no longer throw errors and will be properly aligned:

    ```python
    from qiskit.visualization import plot_histogram
    data = {'00': 3, '01': 5, '11': 8, '10': 11}
    plot_histogram(data, number_to_keep=2)
    ```

*   Improved the performance of building and working with parameterized [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instances with many gates that share a relatively small number of parameters.

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](qasm3#module-qiskit.qasm3 "qiskit.qasm3")) will no longer attempt to produce definitions for non-standard gates in the `basis_gates` option.

*   Fixed the getter of [`OptimizerResult.nit`](qiskit.algorithms.optimizers.OptimizerResult#nit "qiskit.algorithms.optimizers.OptimizerResult.nit"), which previously returned the number of Jacobian evaluations instead of the number of iterations.

*   Fixed a bug in the string representation of [`Result`](qiskit.result.Result "qiskit.result.Result") objects that caused the attributes to be specified incorrectly.

*   Fixed an issue with [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") where in some cases providing a list of basis gate strings with the `basis_gates` keyword argument or implicitly via a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") input via the `target` keyword argument would not be interpreted correctly and result in a subset of the listed gates being used for each circuit.

*   Fixed an issue in the [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass which would result in an error when a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") that didn’t have any qubit restrictions on the operations (e.g. in the case of an ideal simulator target) was specified with the `target` keyword argument for the constructor.

*   The method [`qiskit.result.marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts"), when passed a [`Result`](qiskit.result.Result "qiskit.result.Result") from a pulse backend, would fail, because it contains an array of `ExperimentResult` objects, each of which have an `QobjExperimentHeader`, and those `ExperimentHeaders` lack creg\_sizes instance-variables. If the `Result` came from a simulator backend (e.g. Aer), that instance-variable would be there. We fix `marginal_counts` so that it skips logic that needs creg\_sizes if the field is not present, or non-None.

*   The OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) will now correctly define the qubit parameters for [`UnitaryGate`](qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") operations that do not affect all the qubits they are defined over. Fixed [#8224](https://github.com/Qiskit/qiskit-terra/issues/8224).

*   Fixed an issue with reproducibility of the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function when running with `optimization_level` 1, 2, and 3. Previously, under some conditions when there were multiple perfect layouts (a layout that doesn’t require any SWAP gates) available the selected layout and output circuit could vary regardless of whether the `seed_transpiler` argument was set.

<span id="id118" />

### Aer 0.10.4

No change

<span id="release-notes-0-19-2-ibmq" />

<span id="id119" />

### IBM Q Provider 0.19.2

<span id="release-notes-0-19-2-ibmq-bug-fixes" />

<span id="id120" />

#### Bug Fixes

*   In the upcoming terra release there will be a release candidate tagged prior to the final release. However changing the version string for the package is blocked on the qiskit-ibmq-provider right now because it is trying to parse the version and is assuming there will be no prelease suffix on the version string (see [#8200](https://github.com/Qiskit/qiskit-terra/pull/8200) for the details). PR [#1135](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1135) fixes this version parsing to use the regex from the pypa/packaging project which handles all the PEP440 package versioning include pre-release suffixes. This will enable terra to release an 0.21.0rc1 tag without breaking the qiskit-ibmq-provider.
*   `threading.currentThread` and `notifyAll` were deprecated in Python 3.10 (October 2021) and will be removed in Python 3.12 (October 2023). PR [#1133](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1133) replaces them with `threading.current_thread`, `notify_all` added in Python 2.6 (October 2008).

<span id="qiskit-0-36-2" />

## Qiskit 0.36.2

<span id="terra-0-20-2" />

<span id="release-notes-terra-0-20-2" />

### Terra 0.20.2

<span id="release-notes-terra-0-20-2-prelude" />

<span id="id121" />

#### Prelude

Qiskit Terra 0.20.2 is a bugfix release, addressing some minor issues identified since the last patch release.

<span id="release-notes-terra-0-20-2-bug-fixes" />

<span id="id122" />

#### Bug Fixes

*   Fixed an issue with [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2")-based fake backend classes from the `qiskit.providers.fake_provider` module such as `FakeMontrealV2`, where the values for the [`dtm`](qiskit.providers.BackendV2#dtm "qiskit.providers.BackendV2.dtm") and [`dt`](qiskit.providers.BackendV2#dt "qiskit.providers.BackendV2.dt") attributes and the associated attribute [`Target.dt`](qiskit.transpiler.Target#dt "qiskit.transpiler.Target.dt") would not be properly converted to seconds. This would cause issues when using these fake backends with scheduling. See [#8018](https://github.com/Qiskit/qiskit-terra/issues/8018).

*   [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") will now succeed when asked to marginalize memory with an `indices` parameter containing non-zero elements. Previously, shots whose hexadecimal result representation was sufficiently small could raise a `ValueError`. See [#8044](https://github.com/Qiskit/qiskit-terra/issues/8044).

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](qasm3#module-qiskit.qasm3 "qiskit.qasm3")) will now output `input` or `output` declarations before gate declarations. This is more consistent with the current reference ANTLR grammar from the OpenQASM 3 team. See [#7964](https://github.com/Qiskit/qiskit-terra/issues/7964).

*   Fixed a bug in the [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") transpiler pass where the scaled cross-resonance pulse amplitude could appear to be parametrized even after assignment. This could cause the pulse visualization tools to use the parametrized format instead of the expected numeric one. See [#8031](https://github.com/Qiskit/qiskit-terra/pull/8031).

*   Fixed an issue with the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function when run with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2")-based backend and setting the `scheduling_method` keyword argument. Previously, the function would not correctly process the default durations of the instructions supported by the backend which would lead to an error.

*   Fixed a bug in the [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") transpiler pass that was causing pulses to sometimes be constructed with incorrect durations. See [#7994](https://github.com/Qiskit/qiskit-terra/issues/7994).

*   The [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") transpiler pass, used in [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") when `routing_method="sabre"` is set, will no longer sporadically drop classically conditioned gates and their successors from circuits during the routing phase of transpilation. See [#8040](https://github.com/Qiskit/qiskit-terra/issues/8040).

*   [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") will now allow direct iteration through its values (such as `for coefficient in statevector`) and correctly report its length under `len`. Previously it would try and and access out-of-bounds data and raise a [`QiskitError`](exceptions#qiskit.exceptions.QiskitError "qiskit.exceptions.QiskitError"). See [#8039](https://github.com/Qiskit/qiskit-terra/issues/8039).

<span id="id123" />

### Aer 0.10.4

No change

<span id="ignis-0-7-1" />

<span id="release-notes-ignis-0-7-1" />

### Ignis 0.7.1

<span id="release-notes-ignis-0-7-1-prelude" />

<span id="id124" />

#### Prelude

This is a bugfix release that primarily fixes a packaging issue that was causing the `docs/` directory, which contains the source files used to build the qiskit-ignis documentation, to get included in the Python package.

<span id="ibm-q-provider-0-19-1" />

### IBM Q Provider 0.19.1

No change

<span id="qiskit-0-36-1" />

## Qiskit 0.36.1

<span id="terra-0-20-1" />

### Terra 0.20.1

<span id="release-notes-terra-0-20-1-prelude" />

<span id="id125" />

#### Prelude

Qiskit Terra 0.20.1 is a bugfix release resolving issues identified in release 0.20.0.

<span id="release-notes-terra-0-20-1-known-issues" />

<span id="id126" />

#### Known Issues

*   QPY deserialization with the [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") function of a directly instantiated [`UCPauliRotGate`](qiskit.circuit.library.UCPauliRotGate "qiskit.circuit.library.UCPauliRotGate") object in a circuit will fail because the rotation axis argument to the class isn’t stored in a standard place. To workaround this you can instead use the subclasses: [`UCRXGate`](qiskit.circuit.library.UCRXGate "qiskit.circuit.library.UCRXGate"), [`UCRYGate`](qiskit.circuit.library.UCRYGate "qiskit.circuit.library.UCRYGate"), or [`UCRZGate`](qiskit.circuit.library.UCRZGate "qiskit.circuit.library.UCRZGate") (based on whether you’re using a rotation axis of `"X"`, `"Y"`, or `"Z"` respectively) which embeds the rotation axis in the class constructor and will work correctly in QPY.

*   Since its original introduction in Qiskit Terra 0.20, [`XXPlusYYGate`](qiskit.circuit.library.XXPlusYYGate "qiskit.circuit.library.XXPlusYYGate") has used a negative angle convention compared to all other rotation gates. In Qiskit Terra 0.21, this will be corrected to be consistent with the other rotation gates. This does not affect any other rotation gates, nor [`XXMinusYYGate`](qiskit.circuit.library.XXMinusYYGate "qiskit.circuit.library.XXMinusYYGate").

<span id="release-notes-terra-0-20-1-bug-fixes" />

<span id="id127" />

#### Bug Fixes

*   Fixed [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford"), [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") and [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral "qiskit.quantum_info.CNOTDihedral") operator initialization from compatible circuits that contain [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") instructions. These instructions are treated as identities when converting to operators.

*   Fixed an issue where the [`eval_observables()`](algorithms#qiskit.algorithms.eval_observables "qiskit.algorithms.eval_observables") function would raise an error if its `quantum_state` argument was of type `StateFn`. `eval_observables` now correctly supports all input types denoted by its type hints.

*   Fixed an issue with the visualization function [`dag_drawer()`](qiskit.visualization.dag_drawer "qiskit.visualization.dag_drawer") and method [`DAGCircuit.draw()`](qiskit.dagcircuit.DAGCircuit#draw "qiskit.dagcircuit.DAGCircuit.draw") where previously the drawer would fail when attempting to generate a visualization for a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") object that contained a [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") or [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") which wasn’t part of a `QuantumRegister` or `ClassicalRegister`. Fixed [#7915](https://github.com/Qiskit/qiskit-terra/issues/7915).

*   Fixed parameter validation for class `Drag`. Previously, it was not sensitive to large beta values with negative signs, which may have resulted in waveform samples with a maximum value exceeding the amplitude limit of 1.0.

*   The [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class used by many algorithms (like `VQE`) was hard-coding the value for a sleep while it looped waiting for the job status to be updated. It now respects the configured sleep value as set per the `wait` attribute in the initializer of [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance").

*   Fixed an issue with the [`schedule`](compiler#qiskit.compiler.schedule "qiskit.compiler.schedule") function where callers specifying a `list` of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects with a single entry would incorrectly be returned a single [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") object instead of a `list`.

*   Fixed an issue with the `plot_error_map` visualization function which prevented it from working when run with a backend that had readout error defined in the provided backend’s [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") or when running with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend. Fixed [#7879](https://github.com/Qiskit/qiskit-terra/issues/7879).

*   Fixed a bug that could result in exponential runtime and nontermination when a [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") instance is given to method `init_observables()`.

*   Fixed [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap"), and by extension [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") with `optimization_level=3`, occasionally re-ordering measurements invalidly. Previously, if two measurements wrote to the same classical bit, [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") could (depending on the coupling map) re-order them to produce a non-equivalent circuit. This behaviour was stochastic, so may not have appeared reliably. Fixed [#7950](https://github.com/Qiskit/qiskit-terra/issues/7950)

*   The [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") transpiler pass, and by extension [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") at `optimization_level=3`, now has an escape mechanism to guarantee that it can never get stuck in an infinite loop. Certain inputs previously could, with a great amount of bad luck, get stuck in a stable local minimum of the search space and the pass would never make further progress. It will now force a series of swaps that allow the routing to continue if it detects it has not made progress recently. Fixed [#7707](https://github.com/Qiskit/qiskit-terra/issues/7707).

*   Fixed an issue with QPY deserialization via the [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") function of the [`UCRXGate`](qiskit.circuit.library.UCRXGate "qiskit.circuit.library.UCRXGate"), [`UCRYGate`](qiskit.circuit.library.UCRYGate "qiskit.circuit.library.UCRYGate"), and [`UCRZGate`](qiskit.circuit.library.UCRZGate "qiskit.circuit.library.UCRZGate") classes. Previously, a QPY file that contained any of these gates would error when trying to load the file. Fixed [#7847](https://github.com/Qiskit/qiskit-terra/issues/7847).

<span id="id128" />

### Aer 0.10.4

No change

<span id="ignis-0-7-0" />

### Ignis 0.7.0

No change

<span id="id129" />

### IBM Q Provider 0.19.1

<span id="release-notes-0-19-1-ibmq" />

<span id="id130" />

### 0.19.1

<span id="release-notes-0-19-1-ibmq-bug-fixes" />

<span id="id131" />

#### Bug Fixes

*   PR [#1129](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1129) updates `least_busy()` method to no longer support BaseBackend as a valid input or output type since it has been long deprecated in qiskit-terra and has recently been removed.

<span id="qiskit-0-36-0" />

## Qiskit 0.36.0

<span id="terra-0-20-0" />

### Terra 0.20.0

No change

<span id="release-notes-aer-0-10-4" />

<span id="id132" />

### Aer 0.10.4

<span id="release-notes-aer-0-10-4-upgrade-notes" />

<span id="id133" />

#### Upgrade Notes

*   Qiskit Aer is no longer compiled with unsafe floating-point optimisations. While most of the effects should have been localised to Qiskit Aer, some aspects of subnormal handling may previously have been leaked into user code by the library incorrectly setting the “flush to zero” mode. This will not happen any more.

<span id="release-notes-aer-0-10-4-bug-fixes" />

<span id="id134" />

#### Bug Fixes

*   Fix cache blocking transpiler to recognize superop to be cache blocked. This is fix for issue 1479 \<[https://github.com/Qiskit/qiskit-aer/issues/1479](https://github.com/Qiskit/qiskit-aer/issues/1479)> now density\_matrix with noise models can be parallelized. New test, test\_noise.TestNoise.test\_kraus\_gate\_noise\_on\_QFT\_cache\_blocking is added to verify this issue. Also this fix include fix for issue 1483 \<[https://github.com/Qiskit/qiskit-aer/issues/1483](https://github.com/Qiskit/qiskit-aer/issues/1483)> discovered by adding new test case. This fixes measure over chunks for statevector.

*   Fixes a bug in `NoiseModel.from_backend()` that raised an error when T2 value greater than 2 \* T1 was supplied by the backend. After this fix, it becomes to truncate T2 value up to 2 \* T1 and issue a user warning if truncates. The bug was introduced at #1391 and, before that, `NoiseModel.from_backend()` had truncated the T2 value up to 2 \* T1 silently.

    See [Issue 1464](https://github.com/Qiskit/qiskit-aer/issues/1464) for details.

*   device=Thrust was very slow for small number of qubits because OpenMP threading was always applied. This fix applies OpenMP threads as same as device=CPU by using statevector\_parallel\_threshold.

*   Qiskit Aer will no longer set the floating-point mode to “flush to zero” when loaded. Downstream users may previously have seen warnings from Numpy such as:

    > The value of the smallest subnormal for \<class ‘numpy.float64’> type is zero.

    These will now no longer be emitted, and the floating-point handling will be correct.

*   Fixed a potential issue with running simulations on circuits that have the [`QuantumCircuit.metadata`](qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") attribute set. The [`metadata`](qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") attribute can be any python dictionary and previously qiskit-aer would attempt to JSON serialize the contents of the attribute to process it with the rest of the rest of the circuit input, even if the contents were not JSON serializable. This no longer occurs as the [`QuantumCircuit.metadata`](qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") attribute is not used to run the simulation so now the contents are no serialized and instead are directly attached to the [`qiskit.result.Result`](qiskit.result.Result "qiskit.result.Result") object without attempting to JSON serialize the contents. Fixed [#1435](https://github.com/Qiskit/qiskit-aer/issues/1435)

<span id="id135" />

### Ignis 0.7.0

No change

<span id="ibm-q-provider-0-19-0" />

<span id="release-notes-0-19-0-ibmq" />

### IBM Q Provider 0.19.0

<span id="release-notes-0-19-0-ibmq-new-features" />

<span id="id136" />

#### New Features

*   The qiskit-ibmq-provider package now supports IBM Quantum LiveData features. These features allow users to observe the real-time behavior of IBM Quantum backends while executing jobs. Specifically, the provider now includes a new tab in the backend Jupyter-related widget and supports the execution of jobs (via `qiskit.providers.ibmq.IBMQBackend.run()` method) with the live\_data\_enabled=True parameter in allowed IBM Quantum backends.
*   You can now specify a different logging level in the `options` keyword when submitting a Qiskit Runtime job with the `qiskit.providers.ibmq.runtime.IBMRuntimeService.run()` method.

<span id="release-notes-0-19-0-ibmq-upgrade-notes" />

<span id="id137" />

#### Upgrade Notes

*   Python 3.6 support has been dropped since it has reached end of life in Dec 2021.
*   qiskit.providers.ibmq.random, the random number service which was used to access the CQC randomness extractor is no longer supported and has been removed.

<span id="release-notes-0-19-0-ibmq-deprecation-notes" />

<span id="id138" />

#### Deprecation Notes

*   The `image` keyword in the `qiskit.providers.ibmq.runtime.IBMRuntimeService.run()` method is deprecated. You should instead specify the image to use in the `options` keyword.

<span id="release-notes-0-19-0-ibmq-bug-fixes" />

<span id="id139" />

#### Bug Fixes

*   Fixes issue [#190](https://github.com/Qiskit/qiskit-ibm-provider/issues/190). Now `qiskit.providers.ibmq.runtime.RuntimeEncoder` and `qiskit.providers.ibmq.runtime.RuntimeDecoder` have been updated to handle instances of the Instruction class.
*   Fixes issue [#74](https://github.com/Qiskit/qiskit-ibm-provider/issues/74) where numpy ndarrays with object types could not be serialized. `qiskit.providers.ibmq.runtime.RuntimeEncoder` and `qiskit.providers.ibmq.runtime.RuntimeDecoder` have been updated to handle these ndarrays.

<span id="qiskit-0-35-0" />

## Qiskit 0.35.0

<span id="release-notes-0-20-0" />

<span id="id140" />

### Terra 0.20.0

<span id="release-notes-0-20-0-prelude" />

<span id="id141" />

#### Prelude

The Qiskit Terra 0.20.0 release highlights are:

*   The introduction of multithreaded modules written in Rust to accelerate the performance of certain portions of Qiskit Terra and improve scaling with larger numbers of qubits. However, when building Qiskit from source a [Rust](https://www.rust-lang.org/) compiler is now required.
*   More native support for working with a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") in the transpiler. Several passes now support working directly with a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object which makes the transpiler robust in the types of backends it can target.
*   The introduction of the [`qiskit.primitives`](primitives#module-qiskit.primitives "qiskit.primitives") module. These APIs provide different abstraction levels for computing outputs of interest from [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and using backends. For example, the [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator") defines an abstract interface for estimating an expectation value of an observable. This can then be used to construct higher level algorithms and applications that are built using the estimation of expectation values without having to worry about the implementation of computing the expectation value. This decoupling allows the implementation to improve in speed and quality while adhering to the defined abstract interface. Likewise, the [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") computes quasi-probability distributions from circuit measurements. Other primitives will be introduced in the future.

This release no longer has support for Python 3.6. With this release, Python 3.7 through Python 3.10 are required.

<span id="release-notes-0-20-0-new-features" />

<span id="id142" />

#### New Features

*   Added a new constructor method for the [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") class, [`Operator.from_circuit()`](qiskit.quantum_info.Operator#from_circuit "qiskit.quantum_info.Operator.from_circuit") for creating a new [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") object from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). While this was possible normally using the default constructor, the [`Operator.from_circuit()`](qiskit.quantum_info.Operator#from_circuit "qiskit.quantum_info.Operator.from_circuit") method provides additional options to adjust how the operator is created. Primarily this lets you permute the qubit order based on a set [`Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout"). For, example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit import transpile
    from qiskit.transpiler import CouplingMap
    from qiskit.quantum_info import Operator

    circuit = QuantumCircuit(3)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.cx(1, 2)

    cmap = CouplingMap.from_line(3)
    out_circuit = transpile(circuit, initial_layout=[2, 1, 0], coupling_map=cmap)
    operator = Operator.from_circuit(out_circuit)
    ```

    the `operator` variable will have the qubits permuted based on the layout so that it is identical to what is returned by `Operator(circuit)` before transpilation.

*   Added a new method [`DAGCircuit.copy_empty_like()`](qiskit.dagcircuit.DAGCircuit#copy_empty_like "qiskit.dagcircuit.DAGCircuit.copy_empty_like") to the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class. This method is used to create a new copy of an existing [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") object with the same structure but empty of any instructions. This method is the same as the private method `_copy_circuit_metadata()`, but instead is now part of the public API of the class.

*   The fake backend and fake provider classes which were previously available in `qiskit.test.mock` are now also accessible in a new module: `qiskit.providers.fake_provider`. This new module supersedes the previous module `qiskit.test.mock` which will be deprecated in Qiskit 0.21.0.

*   Added a new gate class, [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction"), that efficiently encodes a linear function (i.e. a function that can be represented by a sequence of [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") and [`SwapGate`](qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") gates).

*   Added a new transpiler pass [`CollectLinearFunctions`](qiskit.transpiler.passes.CollectLinearFunctions "qiskit.transpiler.passes.CollectLinearFunctions") that collects blocks of consecutive [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") and [`SwapGate`](qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") gates in a circuit, and replaces each block with a [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") gate.

*   Added a new transpiler pass [`LinearFunctionsSynthesis`](qiskit.transpiler.passes.LinearFunctionsSynthesis "qiskit.transpiler.passes.LinearFunctionsSynthesis") that synthesizes any [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") gates in using the [Patel-Markov-Hayes algorithm](https://arxiv.org/abs/quant-ph/0302002). When combined with the [`CollectLinearFunctions`](qiskit.transpiler.passes.CollectLinearFunctions "qiskit.transpiler.passes.CollectLinearFunctions") transpiler pass this enables to collect blocks of consecutive [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") and [`SwapGate`](qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") gates in a circuit, and re-synthesize them using the [Patel-Markov-Hayes algorithm](https://arxiv.org/abs/quant-ph/0302002).

*   Added a new transpiler pass [`LinearFunctionsToPermutations`](qiskit.transpiler.passes.LinearFunctionsToPermutations "qiskit.transpiler.passes.LinearFunctionsToPermutations") that replaces a [`LinearFunction`](qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") gate by a [`Permutation`](qiskit.circuit.library.Permutation "qiskit.circuit.library.Permutation") circuit whenever possible.

*   [`FlowController`](qiskit.passmanager.FlowController "qiskit.passmanager.FlowController") classes (such as [`ConditionalController`](qiskit.passmanager.ConditionalController "qiskit.passmanager.ConditionalController")) can now be nested inside a [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") instance when using the [`PassManager.append()`](qiskit.transpiler.PassManager#append "qiskit.transpiler.PassManager.append") method. This enables the use of nested logic to control the execution of passes in the [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager"). For example:

    ```python
    from qiskit.transpiler import ConditionalController, PassManager
    from qiskit.transpiler.passes import (
      BasisTranslator, GatesInBasis, Optimize1qGatesDecomposition, FixedPoint, Depth
    )
    from qiskit.circuit.equivalence_library import SessionEquivalenceLibrary as sel

    pm = PassManager()

    def opt_control(property_set):
        return not property_set["depth_fixed_point"]

    def unroll_condition(property_set):
        return not property_set["all_gates_in_basis"]

    depth_check = [Depth(), FixedPoint("depth")]
    opt = [Optimize1qGatesDecomposition(['rx', 'ry', 'rz', 'rxx'])]
    unroll = [BasisTranslator(sel, ['rx', 'ry', 'rz', 'rxx'])]
    unroll_check = [GatesInBasis(['rx', 'ry', 'rz', 'rxx'])]
    flow_unroll = [ConditionalController(unroll, condition=unroll_condition)]

    pm.append(depth_check + opt + unroll_check + flow_unroll, do_while=opt_control)
    ```

    The `pm` [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") object will only execute the [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") pass (in the `unroll` step) in each loop iteration if the `unroll_condition` is met.

*   The constructors for the [`ZFeatureMap`](qiskit.circuit.library.ZFeatureMap "qiskit.circuit.library.ZFeatureMap") and [`ZZFeatureMap`](qiskit.circuit.library.ZZFeatureMap "qiskit.circuit.library.ZZFeatureMap") classes have a new keyword argument `parameter_prefix`. This new argument is used to set the prefix of parameters of the data encoding circuit. For example:

    ```python
    from qiskit.circuit.library import ZFeatureMap

    feature_map = ZFeatureMap(feature_dimension=4, parameter_prefix="my_prefix")
    feature_map.decompose().draw('mpl')
    ```

    the generated [`ZFeatureMap`](qiskit.circuit.library.ZFeatureMap "qiskit.circuit.library.ZFeatureMap") circuit has prefixed all its internal parameters with the prefix `"my_prefix"`.

*   The [`TemplateOptimization`](qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") transpiler pass can now work with [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") objects that have [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") parameters. An illustrative example of using [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter")s with [`TemplateOptimization`](qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") is the following:

    ```python
    from qiskit import QuantumCircuit, transpile, schedule
    from qiskit.circuit import Parameter

    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import TemplateOptimization

    # New contributions to the template optimization
    from qiskit.transpiler.passes.calibration import RZXCalibrationBuilder, rzx_templates

    from qiskit.test.mock import FakeCasablanca
    backend = FakeCasablanca()

    phi = Parameter('φ')

    qc = QuantumCircuit(2)
    qc.cx(0,1)
    qc.p(2*phi, 1)
    qc.cx(0,1)
    print('Original circuit:')
    print(qc)

    pass_ = TemplateOptimization(**rzx_templates.rzx_templates(['zz2']))
    qc_cz = PassManager(pass_).run(qc)
    print('ZX based circuit:')
    print(qc_cz)

    # Add the calibrations
    pass_ = RZXCalibrationBuilder(backend)
    cal_qc = PassManager(pass_).run(qc_cz.bind_parameters({phi: 0.12}))

    # Transpile to the backend basis gates
    cal_qct = transpile(cal_qc, backend)
    qct = transpile(qc.bind_parameters({phi: 0.12}), backend)

    # Compare the schedule durations
    print('Duration of schedule with the calibration:')
    print(schedule(cal_qct, backend).duration)
    print('Duration of standard with two CNOT gates:')
    print(schedule(qct, backend).duration)
    ```

    outputs

    ```python
    Original circuit:

    q_0: ──■──────────────■──
         ┌─┴─┐┌────────┐┌─┴─┐
    q_1: ┤ X ├┤ P(2*φ) ├┤ X ├
         └───┘└────────┘└───┘
    ZX based circuit:
                                             ┌─────────────┐            »
    q_0: ────────────────────────────────────┤0            ├────────────»
         ┌──────────┐┌──────────┐┌──────────┐│  Rzx(2.0*φ) │┌──────────┐»
    q_1: ┤ Rz(-π/2) ├┤ Rx(-π/2) ├┤ Rz(-π/2) ├┤1            ├┤ Rx(-2*φ) ├»
         └──────────┘└──────────┘└──────────┘└─────────────┘└──────────┘»
    «
    «q_0: ────────────────────────────────────────────────
    «     ┌──────────┐┌──────────┐┌──────────┐┌──────────┐
    «q_1: ┤ Rz(-π/2) ├┤ Rx(-π/2) ├┤ Rz(-π/2) ├┤ P(2.0*φ) ├
    «     └──────────┘└──────────┘└──────────┘└──────────┘
    Duration of schedule with the calibration:
    1600
    Duration of standard with two CNOT gates:
    6848
    ```

*   The [`DAGOpNode`](qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode"), [`DAGInNode`](qiskit.dagcircuit.DAGInNode "qiskit.dagcircuit.DAGInNode") and [`DAGOutNode`](qiskit.dagcircuit.DAGOutNode "qiskit.dagcircuit.DAGOutNode") classes now define a custom `__repr__` method which outputs a representation. Per the [Python documentation](https://docs.python.org/3/library/functions.html#repr) the output is a string representation that is roughly equivalent to the Python string used to create an equivalent object.

*   The performance of the [`SparsePauliOp.simplify()`](qiskit.quantum_info.SparsePauliOp#simplify "qiskit.quantum_info.SparsePauliOp.simplify") method has greatly improved by replacing the use of `numpy.unique` to compute unique elements of an array by a new similar function implemented in Rust that doesn’t pre-sort the array.

*   Added a new method [`equiv()`](qiskit.quantum_info.SparsePauliOp#equiv "qiskit.quantum_info.SparsePauliOp.equiv") to the [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") class for testing the equivalence of a [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") with another [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") object. Unlike the `==` operator which compares operators element-wise, [`equiv()`](qiskit.quantum_info.SparsePauliOp#equiv "qiskit.quantum_info.SparsePauliOp.equiv") compares whether two operators are equivalent or not. For example:

    ```python
    op = SparsePauliOp.from_list([("X", 1), ("Y", 1)])
    op2 = SparsePauliOp.from_list([("X", 1), ("Y", 1), ("Z", 0)])
    op3 = SparsePauliOp.from_list([("Y", 1), ("X", 1)])

    print(op == op2)  # False
    print(op == op3)  # False
    print(op.equiv(op2))  # True
    print(op.equiv(op3))  # True
    ```

*   Added new fake backend classes from snapshots of the IBM Quantum systems based on the [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") interface and provided a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") for each backend. [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") based versions of all the existing backends are added except for three old backends `FakeRueschlikon`, `FakeTenerife` and `FakeTokyo` as they do not have snapshots files available which are required for creating a new fake backend class based on [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2").

    These new V2 fake backends will enable testing and development of new features introduced by [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.backend.BackendV2") and [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") such as improving the transpiler.

*   Added a new gate class [`XXMinusYYGate`](qiskit.circuit.library.XXMinusYYGate "qiskit.circuit.library.XXMinusYYGate") to the circuit library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library")) for the XX-YY interaction. This gate can be used to implement the [bSwap gate](https://arxiv.org/abs/1208.1287) and its powers. It also arises in the simulation of superconducting fermionic models.

*   Added new gate class, [`XXPlusYYGate`](qiskit.circuit.library.XXPlusYYGate "qiskit.circuit.library.XXPlusYYGate"), to the circuit library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library")). This gate is a 2-qubit parameterized XX+YY interaction, also known as an XY gate, and is based on the gate described in [https://arxiv.org/abs/1912.04424](https://arxiv.org/abs/1912.04424).

*   The `FakeBogota`, `FakeManila`, `FakeRome`, and `FakeSantiago` fake backends which can be found in the `qiskit.providers.fake_provider` module can now be used as backends in Pulse experiments as they now include a [`PulseDefaults`](qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") created from a snapshot of the equivalent IBM Quantum machine’s properties.

*   The [`ConsolidateBlocks`](qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") pass has a new keyword argument on its constructor, `target`. This argument is used to specify a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object representing the compilation target for the pass. If it is specified it supersedes the `basis_gates` kwarg. If a target is specified, the pass will respect the gates and qubits for the instructions defined in the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") when deciding which gates to consolidate into a unitary.

*   The [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class has a new method, [`instruction_supported()`](qiskit.transpiler.Target#instruction_supported "qiskit.transpiler.Target.instruction_supported") which is used to query the target to see if an instruction (the combination of an operation and the qubit(s) it is executed on) is supported on the backend modelled by the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target").

*   Added a new kwarg, `metadata_serializer`, to the [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") function for specifying a custom `JSONEncoder` subclass for use when serializing the [`QuantumCircuit.metadata`](qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") attribute and a dual kwarg `metadata_deserializer` to the [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") function for specifying a `JSONDecoder` subclass. By default the [`dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") and [`load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") functions will attempt to JSON serialize and deserialize with the stdlib default json encoder and decoder. Since [`QuantumCircuit.metadata`](qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") can contain any Python dictionary, even those with contents not JSON serializable by the default encoder, will lead to circuits that can’t be serialized. The new `metadata_serializer` argument for [`dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") enables users to specify a custom `JSONEncoder` that will be used with the internal `json.dump()` call for serializing the [`QuantumCircuit.metadata`](qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") dictionary. This can then be paired with the new `metadata_deserializer` argument of the [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") function to decode those custom JSON encodings. If `metadata_serializer` is specified on [`dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") but `metadata_deserializer` is not specified on [`load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") calls the QPY will be loaded, but the circuit metadata may not be reconstructed fully.

    For example if you wanted to define a custom serialization for metadata and then load it you can do something like:

    ```python
    from qiskit.qpy import dump, load
    from qiskit.circuit import QuantumCircuit, Parameter
    import json
    import io

    class CustomObject:
        """Custom string container object."""

        def __init__(self, string):
            self.string = string

        def __eq__(self, other):
            return self.string == other.string

    class CustomSerializer(json.JSONEncoder):
        """Custom json encoder to handle CustomObject."""

        def default(self, o):
            if isinstance(o, CustomObject):
                return {"__type__": "Custom", "value": o.string}
            return json.JSONEncoder.default(self, o)

    class CustomDeserializer(json.JSONDecoder):
        """Custom json decoder to handle CustomObject."""

        def __init__(self, *args, **kwargs):
            super().__init__(*args, object_hook=self.object_hook, **kwargs)

        def object_hook(self, o):
            """Hook to override default decoder."""
            if "__type__" in o:
                obj_type = o["__type__"]
                if obj_type == "Custom":
                    return CustomObject(o["value"])
            return o

    theta = Parameter("theta")
    qc = QuantumCircuit(2, global_phase=theta)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()
    circuits = [qc, qc.copy()]
    circuits[0].metadata = {"key": CustomObject("Circuit 1")}
    circuits[1].metadata = {"key": CustomObject("Circuit 2")}
    with io.BytesIO() as qpy_buf:
        dump(circuits, qpy_buf, metadata_serializer=CustomSerializer)
        qpy_buf.seek(0)
        new_circuits = load(qpy_buf, metadata_deserializer=CustomDeserializer)
    ```

*   The [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") pass has a new keyword argument on its constructor, `target`. This argument is used to specify a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object representing the compilation target for the pass. If it is specified it supersedes the other arguments on the constructor, `coupling_map` and `backend_prop`.

*   The [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class has a new method, [`operation_names_for_qargs()`](qiskit.transpiler.Target#operation_names_for_qargs "qiskit.transpiler.Target.operation_names_for_qargs"). This method is used to get the operation names (i.e. lookup key in the target) for the operations on a given `qargs` tuple.

*   A new pass `DynamicalDecouplingPadding` has been added to the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module. This new pass supersedes the existing [`DynamicalDecoupling`](qiskit.transpiler.passes.DynamicalDecoupling "qiskit.transpiler.passes.DynamicalDecoupling") pass to work with the new scheduling workflow in the transpiler. It is a subclass of the `BasePadding` pass and depends on having scheduling and alignment analysis passes run prior to it in a [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager"). This new pass can take a `pulse_alignment` argument which represents a hardware constraint for waveform start timing. The spacing between gates comprising a dynamical decoupling sequence is now adjusted to satisfy this constraint so that the circuit can be executed on hardware with the constraint. This value is usually found in `BackendConfiguration.timing_constraints`. Additionally the pass also has an `extra_slack_distribution` option has been to control how to distribute the extra slack when the duration of the created dynamical decoupling sequence is shorter than the idle time of your circuit that you want to fill with the sequence. This defaults to `middle` which is identical to conventional behavior. The new strategy `split_edges` evenly divide the extra slack into the beginning and end of the sequence, rather than adding it to the interval in the middle of the sequence. This might result in better noise cancellation especially when `pulse_alignment` > 1.

*   The [`Z2Symmetries`](qiskit.opflow.primitive_ops.Z2Symmetries "qiskit.opflow.primitive_ops.Z2Symmetries") class now exposes the threshold tolerances used to chop small real and imaginary parts of coefficients. With this one can control how the coefficients of the tapered operator are simplified. For example:

    ```python
    from qiskit.opflow import Z2Symmetries
    from qiskit.quantum_info import Pauli

    z2_symmetries = Z2Symmetries(
        symmetries=[Pauli("IIZI"), Pauli("IZIZ"), Pauli("ZIII")],
        sq_paulis=[Pauli("IIXI"), Pauli("IIIX"), Pauli("XIII")],
        sq_list=[1, 0, 3],
        tapering_values=[1, -1, -1],
        tol=1e-10,
    )
    ```

    By default, coefficients are chopped with a tolerance of `tol=1e-14`.

*   Added a [`chop()`](qiskit.quantum_info.SparsePauliOp#chop "qiskit.quantum_info.SparsePauliOp.chop") method to the [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") class that truncates real and imaginary parts of coefficients individually. This is different from the [`SparsePauliOp.simplify()`](qiskit.quantum_info.SparsePauliOp#simplify "qiskit.quantum_info.SparsePauliOp.simplify") method which removes a coefficient only if the absolute value is close to 0. For example:

    ```python
    >>> from qiskit.quantum_info import SparsePauliOp
    >>> op = SparsePauliOp(["X", "Y", "Z"], coeffs=[1+1e-17j, 1e-17+1j, 1e-17])
    >>> op.simplify()
    SparsePauliOp(['X', 'Y'],
                  coeffs=[1.e+00+1.e-17j, 1.e-17+1.e+00j])
    >>> op.chop()
    SparsePauliOp(['X', 'Y'],
                  coeffs=[1.+0.j, 0.+1.j])
    ```

    Note that the chop method does not accumulate the coefficents of the same Paulis, e.g.

    ```python
    >>> op = SparsePauliOp(["X", "X"], coeffs=[1+1e-17j, 1e-17+1j)
    >>> op.chop()
    SparsePauliOp(['X', 'X'],
                  coeffs=[1.+0.j, 0.+1.j])
    ```

*   Added a new kwarg, `target`, to the constructor for the [`GatesInBasis`](qiskit.transpiler.passes.GatesInBasis "qiskit.transpiler.passes.GatesInBasis") transpiler pass. This new argument can be used to optionally specify a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object that represents the backend. When set this [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") will be used for determining whether a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") contains gates outside the basis set and the `basis_gates` argument will not be used.

*   Added partial support for running on ppc64le and s390x Linux platforms. This release will start publishing pre-compiled binaries for ppc64le and s390x Linux platforms on all Python versions. However, unlike other supported platforms not all of Qiskit’s upstream dependencies support these platforms yet. So a C/C++ compiler may be required to build and install these dependencies and a simple `pip install qiskit-terra` with just a working Python environment will not be sufficient to install Qiskit. Additionally, these same constraints prevent us from testing the pre-compiled wheels before publishing them, so the same guarantees around platform support that exist for the other platforms don’t apply here.

*   The [`Gradient`](qiskit.opflow.gradients.Gradient "qiskit.opflow.gradients.Gradient") and [`QFI`](qiskit.opflow.gradients.QFI "qiskit.opflow.gradients.QFI") classes can now calculate the imaginary part of expectation value gradients. When using a different measurement basis, i.e. `-Y` instead of `Z`, we can measure the imaginary part of gradients The measurement basis can be set with the `aux_meas_op` argument.

    For the gradients, `aux_meas_op = Z` computes `0.5Re[(⟨ψ(ω)|)O(θ)|dωψ(ω)〉]` and `aux_meas_op = -Y` computes `0.5Im[(⟨ψ(ω)|)O(θ)|dωψ(ω)〉]`. For the QFIs, `aux_meas_op = Z` computes `4Re[(dω⟨<ψ(ω)|)(dω|ψ(ω)〉)]` and `aux_meas_op = -Y` computes `4Im[(dω⟨<ψ(ω)|)(dω|ψ(ω)〉)]`. For example:

    ```python
    from qiskit import QuantumRegister, QuantumCircuit
    from qiskit.opflow import CircuitStateFn, Y
    from qiskit.opflow.gradients.circuit_gradients import LinComb
    from qiskit.circuit import Parameter

    a = Parameter("a")
    b = Parameter("b")
    params = [a, b]

    q = QuantumRegister(1)
    qc = QuantumCircuit(q)
    qc.h(q)
    qc.rz(params[0], q[0])
    qc.rx(params[1], q[0])
    op = CircuitStateFn(primitive=qc, coeff=1.0)

    aux_meas_op = -Y

    prob_grad = LinComb(aux_meas_op=aux_meas_op).convert(operator=op, params=params)
    ```

*   The [`InstructionDurations`](qiskit.transpiler.InstructionDurations "qiskit.transpiler.InstructionDurations") class now has support for working with parameters of an instruction. Each entry in an [`InstructionDurations`](qiskit.transpiler.InstructionDurations "qiskit.transpiler.InstructionDurations") object now consists of a tuple of `(inst_name, qubits, duration, parameters, unit)`. This enables an [`InstructionDurations`](qiskit.transpiler.InstructionDurations "qiskit.transpiler.InstructionDurations") to define durations for an instruction given a certain parameter value to account for different durations with different parameter values on an instruction that takes a numeric parameter.

*   Added a new value for the `style` keyword argument on the circuit drawer function [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method, `iqx_dark`. When `style` is set to `iqx_dark` with the `mpl` drawer backend, the output visualization will use a color scheme similar to the the dark mode color scheme used by the IBM Quantum composer. For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from matplotlib.pyplot import show

    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.p(0.2, 1)

    circuit.draw("mpl", style="iqx-dark")
    ```

*   Several lazy dependency checkers have been added to the new module [`qiskit.utils.optionals`](utils#module-qiskit.utils.optionals "qiskit.utils.optionals"), which can be used to query if certain Qiskit functionality is available. For example, you can ask if Qiskit has detected the presence of `matplotlib` by asking `if qiskit.utils.optionals.HAS_MATPLOTLIB`. These objects only attempt to import their dependencies when they are queried, so you can use them in runtime code without affecting import time.

*   Import time for [`qiskit`](index#module-qiskit "qiskit") has been significantly improved, especially for those with many of Qiskit Terra’s optional dependencies installed.

*   The [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") function now supports marginalizing the `memory` field of an input [`Result`](qiskit.result.Result "qiskit.result.Result") object. For example, if the input `result` argument is a qiskit [`Result`](qiskit.result.Result "qiskit.result.Result") object obtained from a 4-qubit measurement we can marginalize onto the first qubit with:

    ```python
    print(result.results[0].data.memory)
    marginal_result = marginal_counts(result, [0])
    print(marginal_result.results[0].data.memory)
    ```

    The output is:

    ```python
    ['0x0', '0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7']
    ['0x0', '0x1', '0x0', '0x1', '0x0', '0x1', '0x0', '0x1']
    ```

*   The internals of the [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") algorithm have been reimplemented to be multithreaded and are now written in the [Rust](https://www.rust-lang.org/) programming language instead of Cython. This significantly increases the run time performance of the compiler pass and by extension [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") when run with `optimization_level` 0, 1, and 2. By default the pass will use up to the number of logical CPUs on your local system but you can control the number of threads used by the pass by setting the `RAYON_NUM_THREADS` environment variable to an integer value. For example, setting `RAYON_NUM_THREADS=4` will run the [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") with 4 threads.

*   A new environment variable `QISKIT_FORCE_THREADS` is available for users to directly control whether potentially multithreaded portions of Qiskit’s code will run in multiple threads. Currently this is only used by the [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") transpiler pass but it likely will be used other parts of Qiskit in the future. When this env variable is set to `TRUE` any multithreaded code in Qiskit Terra will always use multiple threads regardless of any other runtime conditions that might have otherwise caused the function to use a single threaded variant. For example, in [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") if the pass is being run as part of a [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") call with > 1 circuit that is being executed in parallel with `multiprocessing` via [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") the [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") will not use multiple threads to avoid potentially oversubscribing CPU resources. However, if you’d like to use multiple threads in the pass along with multiple processes you can set `QISKIT_FORCE_THREADS=TRUE`.

*   New fake backend classes are available under `qiskit.providers.fake_provider`. These include mocked versions of `ibm_cairo`, `ibm_hanoi`, `ibmq_kolkata`, `ibm_nairobi`, and `ibm_washington`. As with the other fake backends, these include snapshots of calibration and error data taken from the real system, and can be used for local testing, compilation and simulation.

*   Introduced a new class [`StatePreparation`](qiskit.circuit.library.StatePreparation "qiskit.circuit.library.StatePreparation"). This class allows users to prepare a desired state in the same fashion as `Initialize` without the reset being automatically applied.

    For example, to prepare a qubit in the state $(|0\rangle - |1\rangle) / \sqrt{2}$:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.prepare_state([1/np.sqrt(2), -1/np.sqrt(2)], 0)
    circuit.draw()
    ```

    The output is as:

    ```python
         ┌─────────────────────────────────────┐
    q_0: ┤ State Preparation(0.70711,-0.70711) ├
         └─────────────────────────────────────┘
    ```

*   The [`Optimize1qGates`](qiskit.transpiler.passes.Optimize1qGates "qiskit.transpiler.passes.Optimize1qGates") transpiler pass now has support for optimizing [`U1Gate`](qiskit.circuit.library.U1Gate "qiskit.circuit.library.U1Gate"), [`U2Gate`](qiskit.circuit.library.U2Gate "qiskit.circuit.library.U2Gate"), and [`PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate") gates with unbound parameters in a circuit. Previously, if these gates had unbound parameters the pass would not use them. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.circuit import Parameter
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import Optimize1qGates, Unroller

    phi = Parameter('φ')
    alpha = Parameter('α')

    qc = QuantumCircuit(1)
    qc.u1(2*phi, 0)
    qc.u1(alpha, 0)
    qc.u1(0.1, 0)
    qc.u1(0.2, 0)

    pm = PassManager([Unroller(['u1', 'cx']), Optimize1qGates()])
    nqc = pm.run(qc)
    ```

    will be combined to the circuit with only one single-qubit gate:

    ```python
    qc = QuantumCircuit(1)
    qc.u1(2*phi + alpha + 0.3, 0)
    ```

*   The methods [`Pauli.evolve()`](qiskit.quantum_info.Pauli#evolve "qiskit.quantum_info.Pauli.evolve") and [`PauliList.evolve()`](qiskit.quantum_info.PauliList#evolve "qiskit.quantum_info.PauliList.evolve") now have a new keyword argument, `frame`, which is used to perform an evolution of a Pauli by a Clifford. If `frame='h'` (default) then it does the Heisenberg picture evolution of a Pauli by a Clifford ($P' = C^\dagger P C$), and if `frame='s'` then it does the Schrödinger picture evolution of a Pauli by a Clifford ($P' = C P C^\dagger$). The latter option yields a faster calculation, and is also useful in certain cases. This new option makes the calculation of the greedy Clifford decomposition method in `decompose_clifford` significantly faster.

*   Added a new module to Qiskit: [`qiskit.primitives`](primitives#module-qiskit.primitives "qiskit.primitives"). The primitives module is where APIs are defined which provide different abstractions around computing certain common functions from `QuantumCircuit` which abstracts away the details of the underlying execution on a `Backend`. This enables higher level algorithms and applications to concentrate on performing the computation and not need to worry about the execution and processing of results and have a standardized interface for common computations. For example, estimating an expectation value of a quantum circuit and observable can be performed by any class implementing the [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator") class and consumed in a standardized manner regardless of the underlying implementation. Applications can then be written using the primitive interface directly.

    To start the module contains two types of primitives, the [`Sampler`](qiskit.primitives.Sampler "qiskit.primitives.Sampler") (see [`BaseSampler`](qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") for the abstract class definition) and [`Estimator`](qiskit.primitives.Estimator "qiskit.primitives.Estimator") (see [`BaseEstimator`](qiskit.primitives.BaseEstimator "qiskit.primitives.BaseEstimator") for the abstract class definition). Reference implementations are included in the [`qiskit.primitives`](primitives#module-qiskit.primitives "qiskit.primitives") module and are built using the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module which perform ideal simulation of primitive operation. The expectation is that provider packages will offer their own implementations of these interfaces for providers which can efficiently implement the protocol natively (typically using a classical runtime). Additionally, in the future for providers which do not offer a native implementation of the primitives a method will be provided which will enable constructing primitive objects from a [`Backend`](qiskit.providers.Backend "qiskit.providers.Backend").

*   Added a new module, [`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy"), which contains the functionality previously exposed in `qiskit.circuit.qpy_serialization`. The public functions previously exposed at `qiskit.circuit.qpy_serialization`, [`dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") and [`load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") are now available from this new module (although they are still accessible from `qiskit.circuit.qpy_serialization` but this will be deprecated in a future release). This new module was added in the interest of the future direction of the QPY file format, which in future versions will support representing [`pulse`](pulse#module-qiskit.pulse "qiskit.pulse") [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") and [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") objects in addition to the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects it supports today.

*   Added a new attribute, [`qubit_properties`](qiskit.transpiler.Target#qubit_properties "qiskit.transpiler.Target.qubit_properties") to the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class. This attribute contains a list of [`QubitProperties`](qiskit.providers.QubitProperties "qiskit.providers.QubitProperties") objects for each qubit in the target. For example:

    ```python
    target.qubit_properties[2]
    ```

    will contain the [`QubitProperties`](qiskit.providers.QubitProperties "qiskit.providers.QubitProperties") for qubit number 2 in the target.

    For [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") authors, if you were previously defining [`QubitProperties`](qiskit.providers.QubitProperties "qiskit.providers.QubitProperties") directly on your [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") implementation by overriding [`BackendV2.qubit_properties()`](qiskit.providers.BackendV2#qubit_properties "qiskit.providers.BackendV2.qubit_properties") this will still work fine. However, if you do move the definition to the underlying [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object and remove the specialized [`BackendV2.qubit_properties()`](qiskit.providers.BackendV2#qubit_properties "qiskit.providers.BackendV2.qubit_properties") implementation which will enable using qubit properties in the transpiler and also maintain API compatibility with your previous implementation.

*   Added a new function, [`qiskit.algorithms.eval_observables()`](algorithms#qiskit.algorithms.eval_observables "qiskit.algorithms.eval_observables"), which is used to evaluate observables given a bound [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). It originates from a private method, `_eval_aux_ops()`, of the [`qiskit.algorithms.VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE") class but the new [`eval_observables()`](algorithms#qiskit.algorithms.eval_observables "qiskit.algorithms.eval_observables") function is now more general so that it can be used in other algorithms, for example time evolution algorithms.

*   The basis search strategy in [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") transpiler pass has been modified into a variant of Dijkstra search which greatly improves the runtime performance of the pass when attempting to target an unreachable basis.

*   The [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") transpiler pass is now multithreaded, which greatly improves the runtime performance of the pass. By default, it will use the number of logical CPUs on your local system, but you can control the number of threads used by the pass by setting the `RAYON_NUM_THREADS` environment variable to an integer value. For example, setting `RAYON_NUM_THREADS=4` will run the [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") pass with 4 threads.

*   The internal computations of [`Statevector.expectation_value()`](qiskit.quantum_info.Statevector#expectation_value "qiskit.quantum_info.Statevector.expectation_value") and [`DensityMatrix.expectation_value()`](qiskit.quantum_info.DensityMatrix#expectation_value "qiskit.quantum_info.DensityMatrix.expectation_value") methods have been reimplemented in the Rust programming language. This new implementation is multithreaded and by default for a [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") or [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") >= 19 qubits will spawn a thread pool with the number of logical CPUs available on the local system. You can you can control the number of threads used by setting the `RAYON_NUM_THREADS` environment variable to an integer value. For example, setting `RAYON_NUM_THREADS=4` will only use 4 threads in the thread pool.

*   Added a new [`SparsePauliOp.from_sparse_list()`](qiskit.quantum_info.SparsePauliOp#from_sparse_list "qiskit.quantum_info.SparsePauliOp.from_sparse_list") constructor that takes an iterable, where the elements represent Pauli terms that are themselves sparse, so that `"XIIIIIIIIIIIIIIIX"` can now be written as `("XX", [0, 16])`. For example, the operator

    $$
    H = X_0 Z_3 + 2 Y_1 Y_4
    $$

    can now be constructed as

    ```python
    op = SparsePauliOp.from_sparse_list([("XZ", [0, 3], 1), ("YY", [1, 4], 2)], num_qubits=5)
    # or equivalently, as previously
    op = SparsePauliOp.from_list([("IZIIX", 1), ("YIIYI", 2)])
    ```

    This facilitates the construction of very sparse operators on many qubits, as is often the case for Ising Hamiltonians.

*   The [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass has a new keyword argument on its constructor, `target`. This can be used to optionally specify a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object which represents the compilation target for the pass. When it’s specified it will supersede the values set for `basis_gates`, `coupling_map`, and `backend_props`.

*   The [`UnitarySynthesisPlugin`](qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin") abstract plugin class has a new optional attribute implementations can add, [`supports_target`](qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin#supports_target "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin.supports_target"). If a plugin has this attribute set to `True` a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object will be passed in the `options` payload under the `target` field. The expectation is that this [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object will be used in place of `coupling_map`, `gate_lengths`, `basis_gates`, and `gate_errors`.

*   Introduced a new transpiler pass workflow for building [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") objects for scheduling [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects in the transpiler. In the new workflow scheduling and alignment passes are all [`AnalysisPass`](qiskit.transpiler.AnalysisPass "qiskit.transpiler.AnalysisPass") objects that only update the property set of the pass manager, specifically new property set item `node_start_time`, which holds the absolute start time of each opnode. A separate [`TransformationPass`](qiskit.transpiler.TransformationPass "qiskit.transpiler.TransformationPass") such as [`PadDelay`](qiskit.transpiler.passes.PadDelay "qiskit.transpiler.passes.PadDelay") is subsequently used to apply scheduling to the DAG. This new workflow is both more efficient and can correct for additional timing constraints exposed by a backend.

    Previously, the pass chain would have been implemented as `scheduling -> alignment` which were both transform passes thus there were multiple [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") instances recreated during each pass. In addition, scheduling occured in each pass to obtain instruction start time. Now the required pass chain becomes `scheduling -> alignment -> padding` where the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") update only occurs at the end with the `padding` pass.

    For those who are creating custom [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") objects that involve circuit scheduling you will need to adjust your [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") to insert one of the `BasePadding` passes (currently either [`PadDelay`](qiskit.transpiler.passes.PadDelay "qiskit.transpiler.passes.PadDelay") or [`PadDynamicalDecoupling`](qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling") can be used) at the end of the scheduling pass chain. Without the padding pass the scheduling passes will not be reflected in the output circuit of the [`run()`](qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") method of your custom [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager").

    For example, if you were previously building your [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") with something like:

    ```python
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import TimeUnitConversion, ALAPSchedule, ValidatePulseGates, AlignMeasures

    pm = PassManager()
    scheduling = [
        ALAPSchedule(instruction_durations), PadDelay()),
        ValidatePulseGates(granularity=timing_constraints.granularity, min_length=timing_constraints.min_length),
        AlignMeasures(alignment=timing_constraints.acquire_alignment),
    ]
    pm.append(scheduling)
    ```

    you can instead use:

    ```python
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import TimeUnitConversion, ALAPScheduleAnalysis, ValidatePulseGates, AlignMeasures, PadDelay

    pm = PassManager()
    scheduling = [
        ALAPScheduleAnalysis(instruction_durations), PadDelay()),
        ConstrainedReschedule(acquire_alignment=timing_constraints.acquire_alignment, pulse_alignment=timing_constraints.pulse_alignment),
        ValidatePulseGates(granularity=timing_constraints.granularity, min_length=timing_constraints.min_length),
        PadDelay()
    ]
    pm.append(scheduling)
    ```

    which will both be more efficient and also align instructions based on any hardware constraints.

*   Added a new transpiler pass [`ConstrainedReschedule`](qiskit.transpiler.passes.ConstrainedReschedule "qiskit.transpiler.passes.ConstrainedReschedule") pass. The [`ConstrainedReschedule`](qiskit.transpiler.passes.ConstrainedReschedule "qiskit.transpiler.passes.ConstrainedReschedule") pass considers both hardware alignment constraints that can be definied in a [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") object, `pulse_alignment` and `acquire_alignment`. This new class supersedes the previosuly existing [`AlignMeasures`](qiskit.transpiler.passes.AlignMeasures "qiskit.transpiler.passes.AlignMeasures") as it performs the same alignment (via the property set) for measurement instructions in addition to general instruction alignment. By setting the `acquire_alignment` constraint argument for the [`ConstrainedReschedule`](qiskit.transpiler.passes.ConstrainedReschedule "qiskit.transpiler.passes.ConstrainedReschedule") pass it is a drop-in replacement of [`AlignMeasures`](qiskit.transpiler.passes.AlignMeasures "qiskit.transpiler.passes.AlignMeasures") when paired with a new `BasePadding` pass.

*   Added two new transpiler passes [`ALAPScheduleAnalysis`](qiskit.transpiler.passes.ALAPScheduleAnalysis "qiskit.transpiler.passes.ALAPScheduleAnalysis") and [`ASAPScheduleAnalysis`](qiskit.transpiler.passes.ASAPScheduleAnalysis "qiskit.transpiler.passes.ASAPScheduleAnalysis") which superscede the [`ALAPSchedule`](qiskit.transpiler.passes.ALAPSchedule "qiskit.transpiler.passes.ALAPSchedule") and [`ASAPSchedule`](qiskit.transpiler.passes.ASAPSchedule "qiskit.transpiler.passes.ASAPSchedule") as part of the reworked transpiler workflow for schedling. The new passes perform the same scheduling but in the property set and relying on a `BasePadding` pass to adjust the circuit based on all the scheduling alignment analysis.

    The standard behavior of these passes also aligns timing ordering with the topological ordering of the DAG nodes. This change may affect the scheduling outcome if it includes conditional operations, or simultaneously measuring two qubits with the same classical register (edge-case). To reproduce conventional behavior, set `clbit_write_latency` identical to the measurement instruction length.

    For example, consider scheduling an input circuit like:

    ```python
         ┌───┐┌─┐
    q_0: ┤ X ├┤M├──────────────
         └───┘└╥┘   ┌───┐
    q_1: ──────╫────┤ X ├──────
               ║    └─╥─┘   ┌─┐
    q_2: ──────╫──────╫─────┤M├
               ║ ┌────╨────┐└╥┘
    c: 1/══════╩═╡ c_0=0x1 ╞═╩═
               0 └─────────┘ 0
    ```

    ```python
    from qiskit import QuantumCircuit
    from qiskit.transpiler import InstructionDurations, PassManager
    from qiskit.transpiler.passes import ALAPScheduleAnalysis, PadDelay, SetIOLatency
    from qiskit.visualization.timeline import draw

    circuit = QuantumCircuit(3, 1)
    circuit.x(0)
    circuit.measure(0, 0)
    circuit.x(1).c_if(0, 1)
    circuit.measure(2, 0)

    durations = InstructionDurations([("x", None, 160), ("measure", None, 800)])

    pm = PassManager(
        [
          SetIOLatency(clbit_write_latency=800, conditional_latency=0),
          ALAPScheduleAnalysis(durations),
          PadDelay(),
        ]
    )
    draw(pm.run(circuit))
    ```

    As you can see in the timeline view, the measurement on `q_2` starts before the conditional X gate on the `q_1`, which seems to be opposite to the topological ordering of the node. This is also expected behavior because clbit write-access happens at the end edge of the measure instruction, and the read-access of the conditional gate happens the begin edge of the instruction. Thus topological ordering is preserved on the timeslot of the classical register, which is not captured by the timeline view. However, this assumes a paticular microarchitecture design, and the circuit is not necessary scheduled like this.

    By using the default configuration of passes, the circuit is schedule like below.

    ```python
    from qiskit import QuantumCircuit
    from qiskit.transpiler import InstructionDurations, PassManager
    from qiskit.transpiler.passes import ALAPScheduleAnalysis, PadDelay
    from qiskit.visualization.timeline import draw

    circuit = QuantumCircuit(3, 1)
    circuit.x(0)
    circuit.measure(0, 0)
    circuit.x(1).c_if(0, 1)
    circuit.measure(2, 0)

    durations = InstructionDurations([("x", None, 160), ("measure", None, 800)])

    pm = PassManager([ALAPScheduleAnalysis(durations), PadDelay()])
    draw(pm.run(circuit))
    ```

    Note that clbit is locked throughout the measurement instruction interval. This behavior is designed based on the Qiskit Pulse, in which the acquire instruction takes `AcquireChannel` and `MemorySlot` which are not allowed to overlap with other instructions, i.e. simultaneous memory access from the different instructions is prohibited. This also always aligns the timing ordering with the topological node ordering.

*   Added a new transpiler pass [`PadDynamicalDecoupling`](qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling") which supersedes the [`DynamicalDecoupling`](qiskit.transpiler.passes.DynamicalDecoupling "qiskit.transpiler.passes.DynamicalDecoupling") pass as part of the reworked transpiler workflow for scheduling. This new pass will insert dynamical decoupling sequences into the circuit per any scheduling and alignment analysis that occured in earlier passes.

*   The [`plot_gate_map()`](qiskit.visualization.plot_gate_map "qiskit.visualization.plot_gate_map") visualization function and the functions built on top of it, [`plot_error_map()`](qiskit.visualization.plot_error_map "qiskit.visualization.plot_error_map") and [`plot_circuit_layout()`](qiskit.visualization.plot_circuit_layout "qiskit.visualization.plot_circuit_layout"), have a new keyword argument, `qubit_coordinates`. This argument takes a sequence of 2D coordinates to use for plotting each qubit in the backend being visualized. If specified this sequence must have a length equal to the number of qubits on the backend and it will be used instead of the default behavior.

*   The [`plot_gate_map()`](qiskit.visualization.plot_gate_map "qiskit.visualization.plot_gate_map") visualization function and the functions built on top of it, [`plot_error_map()`](qiskit.visualization.plot_error_map "qiskit.visualization.plot_error_map") and [`plot_circuit_layout()`](qiskit.visualization.plot_circuit_layout "qiskit.visualization.plot_circuit_layout"), now are able to plot any backend not just those with the number of qubits equal to one of the IBM backends. This relies on the retworkx `spring_layout()` [function](https://qiskit.org/ecosystem/rustworkx/apiref/rustworkx.spring_layout.html) to generate the layout for the visualization. If the default layout doesn’t work with a backend’s particular coupling graph you can use the `qubit_coordinates` function to set a custom layout.

*   The [`plot_gate_map()`](qiskit.visualization.plot_gate_map "qiskit.visualization.plot_gate_map") visualization function and the functions built on top of it, [`plot_error_map()`](qiskit.visualization.plot_error_map "qiskit.visualization.plot_error_map") and [`plot_circuit_layout()`](qiskit.visualization.plot_circuit_layout "qiskit.visualization.plot_circuit_layout"), are now able to function with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") based backend. Previously, these functions only worked with `BaseBackend` or [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") based backends.

*   Added a new transpiler pass, [`SetIOLatency`](qiskit.transpiler.passes.SetIOLatency "qiskit.transpiler.passes.SetIOLatency"). This pass takes two arguments `clbit_write_latency` and `conditional_latency` to define the I/O latency for classical bits and classical conditions on a backend. This pass will then define these values on the pass manager’s property set to enable subsequent scheduling and alignment passes to correct for these latencies and provide a more presice scheduling output of a dynamic circuit.

*   A new transpiler pass [`PadDelay`](qiskit.transpiler.passes.PadDelay "qiskit.transpiler.passes.PadDelay") has been added. This pass fills idle time on the qubit wires with [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") instructions. This pass is part of the new workflow for scheduling passes in the transpiler and depends on a scheduling analysis pass (such as [`ALAPScheduleAnalysis`](qiskit.transpiler.passes.ALAPScheduleAnalysis "qiskit.transpiler.passes.ALAPScheduleAnalysis") or `ASAPScheduleAnalysis`) and any alignment passes (such as [`ConstrainedReschedule`](qiskit.transpiler.passes.ConstrainedReschedule "qiskit.transpiler.passes.ConstrainedReschedule")) to be run prior to [`PadDelay`](qiskit.transpiler.passes.PadDelay "qiskit.transpiler.passes.PadDelay").

*   The [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") transpiler pass has a new keyword argument, `target` which is used to provide a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object for the pass. When specified, the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") will be used by the pass for all information about the target device. If it is specified, the `target` option will take priority over the `coupling_map` and `properties` arguments.

*   Allow callables as optimizers in [`VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE") and [`QAOA`](qiskit.algorithms.QAOA "qiskit.algorithms.QAOA"). Now, the optimizer can either be one of Qiskit’s optimizers, such as [`SPSA`](qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA") or a callable with the following signature:

    ```python
    from qiskit.algorithms.optimizers import OptimizerResult

    def my_optimizer(fun, x0, jac=None, bounds=None) -> OptimizerResult:
        # Args:
        #     fun (callable): the function to minimize
        #     x0 (np.ndarray): the initial point for the optimization
        #     jac (callable, optional): the gradient of the objective function
        #     bounds (list, optional): a list of tuples specifying the parameter bounds

        result = OptimizerResult()
        result.x = # optimal parameters
        result.fun = # optimal function value
        return result
    ```

    The above signature also allows to directly pass any SciPy minimizer, for instance as

    ```python
    from functools import partial
    from scipy.optimize import minimize

    optimizer = partial(minimize, method="L-BFGS-B")
    ```

<span id="release-notes-0-20-0-known-issues" />

<span id="id143" />

#### Known Issues

*   When running [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") (which is done internally by performance sensitive functions such as [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble")) in a subprocess launched outside of [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map"), it is possible that the parallel dispatch performed inside [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") will hang and never return. This is due to upstream issues in CPython around the default method to launch subprocesses on Linux and macOS with Python 3.7 (see [https://bugs.python.org/issue40379](https://bugs.python.org/issue40379) for more details). If you encounter this, you have two options: you can either remove the nested parallel processes, as calling [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") from a main process should work fine; or you can manually call the CPython standard library `multiprocessing` module to perform similar parallel dispatch from a subprocess, but use the `"spawn"` or `"forkserver"` launch methods to avoid the potential to have things get stuck and never return.

<span id="release-notes-0-20-0-upgrade-notes" />

<span id="id144" />

#### Upgrade Notes

*   The classes [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit"), [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") and [`AncillaQubit`](qiskit.circuit.AncillaQubit "qiskit.circuit.AncillaQubit") now have the `__slots__` attribute. This is to reduce their memory usage. As a side effect, they can no longer have arbitrary data attached as attributes to them. This is very unlikely to have any effect on downstream code other than performance benefits.

*   The core dependency `retworkx` had its version requirement bumped to 0.11.0, up from 0.10.1. This improves the performance of transpilation pass [`ConsolidateBlocks`](qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks").

*   The minimum supported version of `symengine` is now 0.9.0. This was necessary to improve compatibility with Python’s `pickle` module which is used internally as part of parallel dispatch with [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map").

*   The default value of `QISKIT_PARALLEL` when running with Python 3.9 on Linux is now set to `TRUE`. This means when running [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") or functions that call it internally, such as [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"), the function will be executed in multiple processes and should have better run time performance. This change was made because the issues with reliability of parallel dispatch appear to have been resolved (see [#6188](https://github.com/Qiskit/qiskit-terra/issues/6188) for more details). If you still encounter issues because of this you can disable multiprocessing and revert to the previous default behavior by setting the `QISKIT_PARALLEL` environment variable to `FALSE`, or setting the `parallel` option to `False` in your user config file (also please file an issue so we can track any issues related to multiprocessing).

*   The previously deprecated `MSGate` gate class previously found in [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") has been removed. It was originally deprecated in the 0.16.0 release. Instead the [`GMS`](qiskit.circuit.library.GMS "qiskit.circuit.library.GMS") class should be used, as this allows you to create an equivalent 2 qubit MS gate in addition to an `MSGate` for any number of qubits.

*   The previously deprecated `mirror()` method of the [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") class has been removed. It was originally deprecated in 0.15.0 release. Instead you should use [`Instruction.reverse_ops()`](qiskit.circuit.Instruction#reverse_ops "qiskit.circuit.Instruction.reverse_ops").

*   The previously deprecated `num_ancilla_qubits()` method of the [`qiskit.circuit.library.PiecewiseLinearPauliRotations`](qiskit.circuit.library.PiecewiseLinearPauliRotations "qiskit.circuit.library.PiecewiseLinearPauliRotations") and [`qiskit.circuit.library.WeightedAdder`](qiskit.circuit.library.WeightedAdder "qiskit.circuit.library.WeightedAdder") classes has been removed. It was originally deprecated in the 0.16.0 release. Instead the `PiecewiseLinearPauliRotations.num_ancillas()` and `WeightedAdder.num_ancillas()` methods should be used.

*   The previously deprecated `reverse` argument on the constructor for the [`PolynomialPauliRotations`](qiskit.circuit.library.PolynomialPauliRotations "qiskit.circuit.library.PolynomialPauliRotations") class has been removed. It was originally deprecated in the 0.15.0 release. Instead you should use the [`QuantumCircuit.reverse_bits()`](qiskit.circuit.QuantumCircuit#reverse_bits "qiskit.circuit.QuantumCircuit.reverse_bits") method to reverse the [`PolynomialPauliRotations`](qiskit.circuit.library.PolynomialPauliRotations "qiskit.circuit.library.PolynomialPauliRotations") circuit if needed.

*   The previously deprecated `angle` argument on the constructors for the [`C3SXGate`](qiskit.circuit.library.C3SXGate "qiskit.circuit.library.C3SXGate") and [`C3XGate`](qiskit.circuit.library.C3XGate "qiskit.circuit.library.C3XGate") gate classes has been removed. It was originally deprecated in the 0.17.0 release. Instead for fractional 3-controlled X gates you can use the `C3XGate.power()` method.

*   Support for using `np.ndarray` objects as part of the [`params`](qiskit.circuit.Gate#params "qiskit.circuit.Gate.params") attribute of a [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") object has been removed. This has been deprecated since Qiskit Terra 0.16.0 and now will no longer work. Instead one should create a new subclass of [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") and explicitly allow a `np.ndarray` input by overloading the [`validate_parameter()`](qiskit.circuit.Gate#validate_parameter "qiskit.circuit.Gate.validate_parameter") method.

*   A new extra `csp-layout-pass` has been added to the install target for `pip install qiskit-terra`, and is also included in the `all` extra. This has no effect in Qiskit Terra 0.20, but starting from Qiskit Terra 0.21, the dependencies needed only for the [`CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") transpiler pass will be downgraded from requirements to optionals, and installed by this extra. You can prepare a package that depends on this pass by setting its requirements (or `pip install` command) to target `qiskit-terra[csp-layout-pass]`.

*   Support for running with Python 3.6 has been removed. To run Qiskit you need a minimum Python version of 3.7.

*   The [`AmplitudeEstimator`](qiskit.algorithms.AmplitudeEstimator "qiskit.algorithms.AmplitudeEstimator") now inherits from the `ABC` class from the Python standard library. This requires any subclass to implement the [`estimate()`](qiskit.algorithms.AmplitudeEstimator#estimate "qiskit.algorithms.AmplitudeEstimator.estimate") method when previously it wasn’t required. This was done because the original intent of the class was to always be a child class of `ABC`, as the [`estimate()`](qiskit.algorithms.AmplitudeEstimator#estimate "qiskit.algorithms.AmplitudeEstimator.estimate") is required for the operation of an [`AmplitudeEstimator`](qiskit.algorithms.AmplitudeEstimator "qiskit.algorithms.AmplitudeEstimator") object. However, if you were previously defining an [`AmplitudeEstimator`](qiskit.algorithms.AmplitudeEstimator "qiskit.algorithms.AmplitudeEstimator") subclass that didn’t implement [`estimate()`](qiskit.algorithms.AmplitudeEstimator#estimate "qiskit.algorithms.AmplitudeEstimator.estimate") this will now result in an error.

*   The error raised by [`HoareOptimizer`](qiskit.transpiler.passes.HoareOptimizer "qiskit.transpiler.passes.HoareOptimizer") if the optional dependency `z3` is not available has changed from [`TranspilerError`](transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.TranspilerError") to [`MissingOptionalLibraryError`](exceptions#qiskit.exceptions.MissingOptionalLibraryError "qiskit.exceptions.MissingOptionalLibraryError") (which is both a [`QiskitError`](exceptions#qiskit.exceptions.QiskitError "qiskit.exceptions.QiskitError") and an `ImportError`). This was done to be consistent with the other optional dependencies.

*   On Linux, the minimum library support has been raised from the [manylinux2010 VM](https://www.python.org/dev/peps/pep-0571/) to [manylinux2014](https://www.python.org/dev/peps/pep-0599/). This mirrors similar changes in Numpy and Scipy. There should be no meaningful effect for most users, unless your system still contains a very old version of `glibc`.

*   The [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") function when called with a [`Result`](qiskit.result.Result "qiskit.result.Result") object input, will now marginalize the `memory` field of experiment data if it’s set in the input [`Result`](qiskit.result.Result "qiskit.result.Result"). Previously, the `memory` field in the the input was not marginalized. This change was made because the previous behavior would result in the `counts` field not matching the `memory` field after [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") was called. If the previous behavior is desired it can be restored by setting `marginalize_memory=None` as an argument to [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") which will not marginalize the `memory` field.

*   The [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") transpiler pass may return different results with the same seed value set. This is due to the internal rewrite of the transpiler pass to improve runtime performance. However, this means that if you ran [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") with `optimization_level` 0, 1 (the default), or 2 with a value set for `seed_transpiler` you may get an output with different swap mapping present after upgrading to Qiskit Terra 0.20.0.

*   To build Qiskit Terra from source a [Rust](https://www.rust-lang.org/) compiler is now needed. This is due to the internal rewrite of the [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") transpiler pass which greatly improves the runtime performance of the transpiler. The rust compiler can easily be installed using rustup, which can be found here: [https://rustup.rs/](https://rustup.rs/)

*   The [`name`](qiskit.circuit.library.PauliEvolutionGate#name "qiskit.circuit.library.PauliEvolutionGate.name") attribute of the [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") class has been changed to always be `"PauliEvolution"`. This change was made to be consistent with other gates in Qiskit and enables other parts of Qiskit to quickly identify when a particular operation in a circuit is a [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate"). For example, it enables the unrolling to Pauli evolution gates.

    Previously, the name contained the operators which are evolved, which is now available via the [`PauliEvolutionGate.label`](qiskit.circuit.library.PauliEvolutionGate#label "qiskit.circuit.library.PauliEvolutionGate.label") attribute. If a circuit with a [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") is drawn, the gate will still show the same information, which gates are being evolved.

*   The previously deprecated methods:

    *   `qiskit.algorithms.VQE.get_optimal_cost`
    *   `qiskit.algorithms.VQE.get_optimal_circuit`
    *   `qiskit.algorithms.VQE.get_optimal_vector`
    *   `qiskit.algorithms.VQE.optimal_params`
    *   `qiskit.algorithms.HamiltonianPhaseEstimationResult.most_likely_phase`
    *   `qiskit.algorithms.PhaseEstimationResult.most_likely_phase`

    which were originally deprecated in the Qiskit Terra 0.18.0 release have been removed and will no longer work.

*   The `qiskit.algorithms.VariationalAlgorithm` class is now defined as an abstract base class (`ABC`) which will require classes that inherit from it to define both a `VariationalAlgorithm.initial_point` getter and setter method.

*   The `pass_manager` kwarg for the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function has been removed. It was originally deprecated in the 0.13.0 release. The preferred way to transpile a circuit with a custom [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") object is to use the [`run()`](qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") method of the [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") object.

*   The previously deprecated `ParametrizedSchedule` class has been removed and no longer exists. This class was deprecated as a part of the 0.17.0 release. Instead of using this class you can directly parametrize [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") or [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") objects by specifying a [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") object to the parametric pulse argument.

*   The module `qiskit.circuit.library.probability_distributions` has been removed and no longer exists as per the deprecation notice from qiskit-terra 0.17.0 (released Apr 1, 2021). The affected classes are `UniformDistribution`, `NormalDistribution`, and `LogNormalDistribution`. They are all moved to the [qiskit-finance](https://qiskit.org/documentation/finance/getting_started.html) library, into its circuit library module: `qiskit_finance.circuit.library.probability_distributions`.

*   The previous `qiskit.test.mock.fake_mumbai_v2.FakeMumbaiV2` class has been renamed to `FakeMumbaiFractionalCX` to differentiate it from the [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") based fake backend for the IBM Mumbai device, `qiskit.test.mock.backends.FakeMumbaiV2`. If you were previously relying on the `FakeMumbaiV2` class to get a fake backend that had fractional applications of [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") defined in its target you need to use `FakeMumbaiFractionalCX` class as the `FakeMumbaiV2` will no longer have those extra gate definitions in its [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target").

*   The resolver used by [`QuantumCircuit.append()`](qiskit.circuit.QuantumCircuit#append "qiskit.circuit.QuantumCircuit.append") (and consequently all methods that add an instruction onto a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")) to convert bit specifiers has changed to make it faster and more reliable. Certain constructs like:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(1, 1)
    qc.measure(np.array([0]), np.array([0]))
    ```

    will now work where they previously would incorrectly raise an error, but certain pathological inputs such as:

    ```python
    from sympy import E, I, pi
    qc.x(E ** (I * pi))
    ```

    will now raise errors where they may have occasionally (erroneously) succeeded before. For almost all correct uses, there should be no noticeable change except for a general speed-up.

*   The semi-public internal method `QuantumCircuit._append()` no longer checks the types of its inputs, and assumes that there are no invalid duplicates in its argument lists. This function is used by certain internal parts of Qiskit and other libraries to build up [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instances as quickly as possible by skipping the error checking when the data is already *known* to be correct. In general, users or functions taking in user data should use the public [`QuantumCircuit.append()`](qiskit.circuit.QuantumCircuit#append "qiskit.circuit.QuantumCircuit.append") method, which resolves integer bit specifiers, broadcasts its arguments and checks the inputs for correctness.

*   Cython is no longer a build dependency of Qiskit Terra and is no longer required to be installed when building Qiskit Terra from source.

*   The preset passmanagers in [`qiskit.transpiler.preset_passmanagers`](transpiler_preset#module-qiskit.transpiler.preset_passmanagers "qiskit.transpiler.preset_passmanagers") for all optimization levels 2 and 3 as generated by [`level_2_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager") and [`level_3_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") have been changed to run the [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") by default prior to the layout pass. The [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") pass will quickly check if a perfect layout can be found and supersedes what was previously done for optimization levels 2 and 3 which were using a combination of [`TrivialLayout`](qiskit.transpiler.passes.TrivialLayout "qiskit.transpiler.passes.TrivialLayout") and [`CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") to try and find a perfect layout. This will result in potentially different behavior when [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") is called by default as it removes a default path for all optimization levels >=2 of using a trivial layout (where `circuit.qubits[0]` is mapped to physical qubit 0, `circuit.qubits[1]` is mapped to physical qubit 1, etc) assuming the trivial layout is perfect. If your use case was dependent on the trivial layout you can explictly request it when transpiling by specifying `layout_method="trivial"` when calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile").

*   The preset pass manager for optimization level 1 (when calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") with `optimization_level=1` or when no `optimization_level` argument is set) as generated by [`level_1_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager") has been changed so that [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") is called by default to quickly check if a a perfect layout can be found prior to the [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout"). However, unlike with optimization level 2 and 3 a trivial layout is still attempted prior to running [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and if it’s a perfect mapping the output from [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") will be used.

<span id="release-notes-0-20-0-deprecation-notes" />

<span id="id145" />

#### Deprecation Notes

*   The `max_credits` argument to [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute"), and all of the `Qobj` configurations (e.g. [`QasmQobjConfig`](qiskit.qobj.QasmQobjConfig "qiskit.qobj.QasmQobjConfig") and [`PulseQobjConfig`](qiskit.qobj.PulseQobjConfig "qiskit.qobj.PulseQobjConfig")), is deprecated and will be removed in a future release. The credit system has not been in use on IBM Quantum backends for two years, and the option has no effect. No alternative is necessary. For example, if you were calling [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute") as:

    ```python
    job = execute(qc, backend, shots=4321, max_credits=10)
    ```

    you can simply omit the `max_credits` argument:

    ```python
    job = execute(qc, backend, shots=4321)
    ```

*   Using an odd integer for the `order` argument on the constructor of the [`SuzukiTrotter`](qiskit.synthesis.SuzukiTrotter "qiskit.synthesis.SuzukiTrotter") class is deprecated and will no longer work in a future release. The product formulae used by the [`SuzukiTrotter`](qiskit.synthesis.SuzukiTrotter "qiskit.synthesis.SuzukiTrotter") are only defined when the order is even as the Suzuki product formulae is symmetric.

*   The `qregs`, `cregs`, `layout`, and `global_phase` kwargs to the `MatplotlibDrawer`, `TextDrawing`, and `QCircuitImage` classes, and the `calibrations` kwarg to the `MatplotlibDrawer` class, are now deprecated and will be removed in a subsequent release.

<span id="release-notes-0-20-0-bug-fixes" />

<span id="id146" />

#### Bug Fixes

*   Fixed an error in the circuit conversion functions [`circuit_to_gate()`](converters#qiskit.converters.circuit_to_gate "qiskit.converters.circuit_to_gate") and [`circuit_to_instruction()`](converters#qiskit.converters.circuit_to_instruction "qiskit.converters.circuit_to_instruction") (and their associated circuit methods [`QuantumCircuit.to_gate()`](qiskit.circuit.QuantumCircuit#to_gate "qiskit.circuit.QuantumCircuit.to_gate") and [`QuantumCircuit.to_instruction()`](qiskit.circuit.QuantumCircuit#to_instruction "qiskit.circuit.QuantumCircuit.to_instruction")) when acting on a circuit with registerless bits, or bits in more than one register.

*   Fixed an issue where calling [`QuantumCircuit.copy()`](qiskit.circuit.QuantumCircuit#copy "qiskit.circuit.QuantumCircuit.copy") on the “body” circuits of a control-flow operation created with the builder interface would raise an error. For example, this was previously an error, but will now return successfully:

    ```python
    from qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister

    qreg = QuantumRegister(4)
    creg = ClassicalRegister(1)
    circ = QuantumCircuit(qreg, creg)

    with circ.if_test((creg, 0)):
        circ.h(0)

    if_else_instruction, _, _ = circ.data[0]
    true_body = if_else_instruction.params[0]
    true_body.copy()
    ```

*   Added a missing entry from the standard session equivalence library between [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") and [`CPhaseGate`](qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate") as well as between [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") and [`CRZGate`](qiskit.circuit.library.CRZGate "qiskit.circuit.library.CRZGate").

*   Fixed an issue where running the `==` operator between two [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") objects would raise an error when the two operators had different numbers of coefficients. For example:

    ```python
    op = SparsePauliOp.from_list([("X", 1), ("Y", 1)])
    op2 = SparsePauliOp.from_list([("X", 1), ("Y", 1), ("Z", 0)])
    print(op == op2)
    ```

    This would previously raise a `ValueError` instead of returning `False`.

*   Fixed support in [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") for passing a [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") object to the underlying [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") based on the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") for [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.backend.BackendV2") based backends. Previously, the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function would not do this processing and any transpiler passes which do not support working with a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object yet would not have access to the default pulse calibrations for the instructions from a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.backend.BackendV2") backend.

*   The [`AmplitudeAmplifier`](qiskit.algorithms.AmplitudeAmplifier "qiskit.algorithms.AmplitudeAmplifier") is now correctly available from the root [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") module directly. Previously it was not included in the re-exported classes off the root module and was only accessible from `qiskit.algorithms.amplitude_amplifiers`. Fixed [#7751](https://github.com/Qiskit/qiskit-terra/pull/7752).

*   Fixed an issue with the `mpl` backend for the circuit drawer function [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and the [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method where gates with conditions would not display properly when a sufficient number of gates caused the drawer to fold over to a second row. Fixed: [#7752](https://github.com/Qiskit/qiskit-terra/pull/7752).

*   Fixed an issue where the `HHL.construct_circuit()` method under certain conditions would not return a correct [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). Previously, the function had a rounding error in calculating how many qubits were necessary to represent the eigenvalues which would cause an incorrect circuit output.

*   Fixed an endianness bug in [`BaseReadoutMitigator.expectation_value()`](qiskit.result.BaseReadoutMitigator#expectation_value "qiskit.result.BaseReadoutMitigator.expectation_value") when a string `diagonal` was passed. It will now correctly be interpreted as little endian in the same manner as the rest of Qiskit Terra, instead of big endian.

*   Fixed an issue with the [`quantum_info.partial_trace()`](quantum_info#qiskit.quantum_info.partial_trace "qiskit.quantum_info.partial_trace") when the function was asked to trace out *no* subsystems, it will now correctly return the [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") of the input state with all dimensions remaining rather than throwing an error. Fixed [#7613](https://github.com/Qiskit/qiskit-terra/issues/7612)

*   Fixed an issue with the `text` backend for the circuit drawer function [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and the [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method when gates that use side text, such as the [`CPhaseGate`](qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate") and [`RZZGate`](qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate") gate classes, with classical conditions set would not display properly. Fixed [#7532](https://github.com/Qiskit/qiskit-terra/issues/7532).

*   Fixed an issue with the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). When using the `reverse_bits` option with the `mpl`, `latex`, or `text` options, bits without registers did not display in the correct order. Fixed [#7303](https://github.com/Qiskit/qiskit-terra/issues/7303).

*   Fixed an issue in the [`LocalReadoutMitigator.assignment_matrix()`](qiskit.result.LocalReadoutMitigator#assignment_matrix "qiskit.result.LocalReadoutMitigator.assignment_matrix") method where it would previously reject an input value for the `qubits` argument that wasn’t a trivial sequence of qubits in the form: `[0, 1, 2, ..., n-1]`. This has been corrected so that now any list of qubit indices to be measured are accepted by the method.

*   Fixed an issue in the [`StabilizerState.expectation_value()`](qiskit.quantum_info.StabilizerState#expectation_value "qiskit.quantum_info.StabilizerState.expectation_value") method’s expectation value calculation, where the output expectation value would be incorrect if the input [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") operator for the `oper` argument had a non-trivial phase. Fixed [#7441](https://github.com/Qiskit/qiskit-terra/issues/7441).

*   An opflow expression containing the Pauli identity `opflow.I` no longer produces an [`IGate`](qiskit.circuit.library.IGate "qiskit.circuit.library.IGate") when converted to a circuit. This change fixes a difference in expectation; the identity gate in the circuit indicates a delay however in opflow we expect a mathematical identity – meaning no operation at all.

*   The [`PauliGate`](qiskit.circuit.library.PauliGate "qiskit.circuit.library.PauliGate") no longer inserts an [`IGate`](qiskit.circuit.library.IGate "qiskit.circuit.library.IGate") for Paulis with the label `"I"`.

*   [`PauliSumOp`](qiskit.opflow.primitive_ops.PauliSumOp "qiskit.opflow.primitive_ops.PauliSumOp") equality tests now handle the case when one of the compared items is a single [`PauliOp`](qiskit.opflow.primitive_ops.PauliOp "qiskit.opflow.primitive_ops.PauliOp"). For example, `0 * X + I == I` now evaluates to True, whereas it was False prior to this release.

*   Fixed an issue with the [`ALAPSchedule`](qiskit.transpiler.passes.ALAPSchedule "qiskit.transpiler.passes.ALAPSchedule") and [`ASAPSchedule`](qiskit.transpiler.passes.ASAPSchedule "qiskit.transpiler.passes.ASAPSchedule") transpiler passes when working with instructions that had custom pulse calibrations (i.e. pulse gates) set. Previously, the scheduling passes would not use the duration from the custom pulse calibration for thse instructions which would result in the an incorrect scheduling being generated for the circuit. This has been fixed so that now the scheduling passes will use the duration of the custom pulse calibration for any instruction in the circuit which has a custom calibration.

*   Fixed support for using [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") instruction paramaters in the [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") transpiler pass. Previously, if an instruction parameter included a bound [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") the pass would not be able to handle this correctly.

*   Stopped the parser in [`QuantumCircuit.from_qasm_str()`](qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") and [`from_qasm_file()`](qiskit.circuit.QuantumCircuit#from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file") from accepting OpenQASM programs that identified themselves as being from a language version other than 2.0. This parser is only for OpenQASM 2.0; support for imported circuits from OpenQASM 3.0 will be added in an upcoming release.

*   The OpenQASM 3 exporter, [`qasm3.Exporter`](qasm3#qiskit.qasm3.Exporter "qiskit.qasm3.Exporter"), will now escape register and parameter names that clash with reserved OpenQASM 3 keywords by generating a new unique name. Registers and parameters with the same name will no longer have naming clashes in the code output from the OpenQASM 3 exporter. Fixed [#7742](https://github.com/Qiskit/qiskit-terra/issues/7742).

<span id="aer-0-10-3" />

### Aer 0.10.3

No change

<span id="id147" />

### Ignis 0.7.0

No change

<span id="ibm-q-provider-0-18-3" />

### IBM Q Provider 0.18.3

No change

<span id="qiskit-0-34-2" />

## Qiskit 0.34.2

<span id="terra-0-19-2" />

<span id="release-notes-0-19-2" />

### Terra 0.19.2

<span id="release-notes-0-19-2-prelude" />

<span id="id148" />

#### Prelude

Qiskit Terra 0.19.2 is predominantly a bugfix release, but also now comes with wheels built for Python 3.10 on all major platforms.

<span id="release-notes-0-19-2-new-features" />

<span id="id149" />

#### New Features

*   Added support for running with Python 3.10. This includes publishing precompiled binaries to PyPI for Python 3.10 on supported platforms.

<span id="release-notes-0-19-2-upgrade-notes" />

<span id="id150" />

#### Upgrade Notes

*   Starting from Python 3.10, Qiskit Terra will have reduced support for 32-bit platforms. These are Linux i686 and 32-bit Windows. These platforms with Python 3.10 are now at Tier 3 instead of Tier 2 support (per the tiers defined in: [https://qiskit.org/documentation/getting\_started.html#platform-support](https://qiskit.org/documentation/getting_started.html#platform-support)) This is because the upstream dependencies Numpy and Scipy have dropped support for them. Qiskit will still publish precompiled binaries for these platforms, but we’re unable to test the packages prior to publishing, and you will need a C/C++ compiler so that `pip` can build their dependencies from source. If you’re using one of these platforms, we recommended that you use Python 3.7, 3.8, or 3.9.

<span id="release-notes-0-19-2-bug-fixes" />

<span id="id151" />

#### Bug Fixes

*   Fixed a bug where the [`CVaRMeasurement`](qiskit.opflow.state_fns.CVaRMeasurement "qiskit.opflow.state_fns.CVaRMeasurement") attempted to convert a [`PauliSumOp`](qiskit.opflow.primitive_ops.PauliSumOp "qiskit.opflow.primitive_ops.PauliSumOp") to a dense matrix to check whether it were diagonal. For large operators (> 16 qubits) this computation was extremely expensive and raised an error if not explicitly enabled using `qiskit.utils.algorithm_globals.massive = True`. The check is now efficient even for large numbers of qubits.

*   [`DAGCircuit.draw()`](qiskit.dagcircuit.DAGCircuit#draw "qiskit.dagcircuit.DAGCircuit.draw") and the associated function [`dag_drawer()`](qiskit.visualization.dag_drawer "qiskit.visualization.dag_drawer") will now show a more useful error message when the provided filename is not valid.

*   [`QuantumCircuit.add_register()`](qiskit.circuit.QuantumCircuit#add_register "qiskit.circuit.QuantumCircuit.add_register") will no longer cause duplicate [`AncillaQubit`](qiskit.circuit.AncillaQubit "qiskit.circuit.AncillaQubit") references in a circuit when given an [`AncillaRegister`](qiskit.circuit.AncillaRegister "qiskit.circuit.AncillaRegister") whose bits are already present.

*   Fixed conversion of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")s with classical conditions on single, registerless [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") s to [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction")s when using the [`circuit_to_instruction()`](converters#qiskit.converters.circuit_to_instruction "qiskit.converters.circuit_to_instruction") function or the [`QuantumCircuit.to_instruction()`](qiskit.circuit.QuantumCircuit#to_instruction "qiskit.circuit.QuantumCircuit.to_instruction") method. For example, the following will now work:

    ```python
    from qiskit.circuit import QuantumCircuit, Qubit, Clbit

    qc = QuantumCircuit([Qubit(), Clbit()])
    qc.h(0).c_if(qc.clbits[0], 0)
    qc.to_instruction()
    ```

*   Registers will now correctly reject duplicate bits. Fixed [#7446](https://github.com/Qiskit/qiskit-terra/issues/7446).

*   The `FakeOpenPulse2Q` mock backend now has T2 times and readout errors stored for its qubits. These are arbitrary values, approximately consistent with real backends at the time of its creation.

*   Fix the qubit order of 2-qubit evolutions in the [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate"), if used with a product formula synthesis. For instance, before, the evolution of `IIZ + IZI + IZZ`

    ```python
    from qiskit.circuit.library import PauliEvolutionGate
    from qiskit.opflow import I, Z
    operator = (I ^ I ^ Z) + (I ^ Z ^ I) + (I ^ Z ^ Z)
    print(PauliEvolutionGate(operator).definition.decompose())
    ```

    produced

    ```python
         ┌───────┐
    q_0: ┤ Rz(2) ├────────
         ├───────┤
    q_1: ┤ Rz(2) ├─■──────
         └───────┘ │ZZ(2)
    q_2: ──────────■──────
    ```

    whereas now it correctly yields

    ```python
         ┌───────┐
    q_0: ┤ Rz(2) ├─■──────
         ├───────┤ │ZZ(2)
    q_1: ┤ Rz(2) ├─■──────
         └───────┘
    q_2: ─────────────────
    ```

*   Fixed a problem in the `latex` and `mpl` circuit drawers when register names with multiple underscores in the name did not display correctly.

*   Negative numbers in array outputs from the drawers will now appear as decimal numbers instead of fractions with huge numerators and denominators. Like positive numbers, they will still be fractions if the ratio is between small numbers.

*   Fixed an issue with the [`Target.get_non_global_operation_names()`](qiskit.transpiler.Target#get_non_global_operation_names "qiskit.transpiler.Target.get_non_global_operation_names") method when running on a target incorrectly raising an exception on targets with ideal global operations. Previously, if this method was called on a target that contained any ideal globally defined operations, where the instruction properties are set to `None`, this method would raise an exception instead of treating that instruction as global.

*   Fixed an issue with the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function where it could fail when being passed a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object directly with the `target` kwarg.

*   Fixed an issue with the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function where it could fail when the `backend` argument was a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") or a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") via the `target` kwarg that contained ideal globally defined operations.

*   Fixed an issue where plotting Bloch spheres could cause an `AttributeError` to be raised in Jupyter or when trying to crop figures down to size with Matplotlib 3.3 or 3.4 (but not 3.5). For example, the following code would previously crash with a message:

    ```python
    AttributeError: 'Arrow3D' object has no attribute '_path2d'
    ```

    but will now succeed with all current supported versions of Matplotlib:

    ```python
    from qiskit.visualization import plot_bloch_vector
    plot_bloch_vector([0, 1, 0]).savefig("tmp.png", bbox_inches='tight')
    ```

*   Fixed a bug in [`PauliSumOp.permute()`](qiskit.opflow.primitive_ops.PauliSumOp#permute "qiskit.opflow.primitive_ops.PauliSumOp.permute") where the object on which the method is called was permuted in-place, instead of returning a permuted copy. This bug only occured for permutations that left the number of qubits in the operator unchanged.

*   Fixed the `PauliEvolutionGate.inverse()` method, which previously computed the inverse by inverting the evolution time. This was only the correct inverse if the operator was evolved exactly. In particular, this led to the inverse of Trotterization-based time evolutions being incorrect.

*   The [`QuantumInstance.execute()`](qiskit.utils.QuantumInstance#execute "qiskit.utils.QuantumInstance.execute") method will no longer mutate its input if it is given a list of circuits.

*   Fixed QPY serialisation of custom instructions which had an explicit no-op definition. Previously these would be written and subsequently read the same way as if they were opaque gates (with no given definition). They will now correctly round-trip an empty definition. For example, the following will now be correct:

    ```python
    import io
    from qiskit.circuit import Instruction, QuantumCircuit, qpy_serialization

    # This instruction is explicitly defined as a one-qubit gate with no
    # operations.
    empty = QuantumCircuit(1, name="empty").to_instruction()
    # This instruction will perform some operations that are only known
    # by the hardware backend.
    opaque = Instruction("opaque", 1, 0, [])

    circuit = QuantumCircuit(2)
    circuit.append(empty, [0], [])
    circuit.append(opaque, [1], [])

    qpy_file = io.BytesIO()
    qpy_serialization.dump(circuit, qpy_file)
    qpy_file.seek(0)
    new_circuit = qpy_serialization.load(qpy_file)[0]

    # Previously both instructions in `new_circuit` would now be opaque, but
    # there is now a correct distinction.
    circuit == new_circuit
    ```

*   Added a missing [`BackendV2.provider`](qiskit.providers.BackendV2#provider "qiskit.providers.BackendV2.provider") attribute to implementations of the [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") abstract class. Previously, [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backends could be initialized with a provider but that was not accessible to users.

*   Fixed support for the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class when running with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend. Previously, attempting to use a [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") would have resulted in an error.

*   Fixed a bug in [`VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE") where the parameters of the ansatz were still explicitly ASCII-sorted by their name if the ansatz was resized. This led to a mismatched order of the optimized values in the `optimal_point` attribute of the result object.

    In particular, this bug occurred if no ansatz was set by the user and the VQE chose a default with 11 or more free parameters.

*   Stopped the parser in [`QuantumCircuit.from_qasm_str()`](qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") and [`from_qasm_file()`](qiskit.circuit.QuantumCircuit#from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file") from accepting OpenQASM programs that identified themselves as being from a language version other than 2.0. This parser is only for OpenQASM 2.0; support for imported circuits from OpenQASM 3.0 will be added in an upcoming release.

*   Fixed QPY serialization of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects that contained control flow instructions. Previously if you attempted to serialize a circuit containing [`IfElseOp`](qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp"), [`WhileLoopOp`](qiskit.circuit.WhileLoopOp "qiskit.circuit.WhileLoopOp"), or [`ForLoopOp`](qiskit.circuit.ForLoopOp "qiskit.circuit.ForLoopOp") the serialization would fail. Fixed [#7583](https://github.com/Qiskit/qiskit-terra/issues/7583).

*   Fixed QPY serialization of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") containing subsets of bits from a [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") or [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister"). Previously if you tried to serialize a circuit like this it would incorrectly treat these bits as standalone [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") or [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") without having a register set. For example, if you try to serialize a circuit like:

    ```python
    import io
    from qiskit import QuantumCircuit, QuantumRegister
    from qiskit.circuit.qpy_serialization import load, dump

    qr = QuantumRegister(2)
    qc = QuantumCircuit([qr[0]])
    qc.x(0)
    with open('file.qpy', 'wb') as fd:
        dump(qc, fd)
    ```

    when that circuit is loaded now the registers will be correctly populated fully even though the circuit only contains a subset of the bits from the register.

*   [`QFT`](qiskit.circuit.library.QFT "qiskit.circuit.library.QFT") will now warn if it is instantiated or built with settings that will cause it to lose precision, rather than raising an `OverflowError`. This can happen if the number of qubits is very large (slightly over 1000) without the approximation degree being similarly large. The circuit will now build successfully, but some angles might be indistinguishable from zero, due to limitations in double-precision floating-point numbers.

<span id="release-notes-aer-0-10-3" />

<span id="id152" />

### Aer 0.10.3

<span id="release-notes-aer-0-10-3-prelude" />

<span id="id153" />

#### Prelude

Qiskit Aer 0.10.3 is mainly a bugfix release, fixing several bugs that have been discovered since the 0.10.2 release. Howver, this release also introduces support for running with Python 3.10 including precompiled binary wheels on all major platforms. This release also includes precompiled binary wheels for arm64 on macOS.

<span id="release-notes-aer-0-10-3-new-features" />

<span id="id154" />

#### New Features

*   Added support for running with Python 3.10. This includes publishing precompiled binaries to PyPI for Python 3.10 on supported platforms.

*   Added support for M1 macOS systems. Precompiled binaries for supported Python versions >=3.8 on arm64 macOS will now be published on PyPI for this and future releases.

<span id="release-notes-aer-0-10-3-upgrade-notes" />

<span id="id155" />

#### Upgrade Notes

*   Qiskit Aer no longer fully supports 32 bit platforms on Python >= 3.10. These are Linux i686 and 32-bit Windows. These platforms with Python 3.10 are now at Tier 3 instead of Tier 2 support (per the tiers defined in: [https://qiskit.org/documentation/getting\_started.html#platform-support](https://qiskit.org/documentation/getting_started.html#platform-support)) This is because the upstream dependencies Numpy and Scipy have dropped support for them. Qiskit will still publish precompiled binaries for these platforms, but we’re unable to test the packages prior to publishing, and you will need a C/C++ compiler so that `pip` can build their dependencies from source. If you’re using one of these platforms, we recommended that you use Python 3.7, 3.8, or 3.9.

<span id="release-notes-aer-0-10-3-bug-fixes" />

<span id="id156" />

#### Bug Fixes

*   Fixes a bug in `RelaxationNoisePass` where instruction durations were always assumed to be in *dt* time units, regardless of the actual unit of the isntruction. Now unit conversion is correctly handled for all instruction duration units.

    See [#1453](https://github.com/Qiskit/qiskit-aer/issues/1453) for details.

*   Fixes an issue with `LocalNoisePass` for noise functions that return a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") for the noise op. These were appended to the DAG as an opaque circuit instruction that must be unrolled to be simulated. This fix composes them so that the cirucit instructions are added to the new DAG and can be simulated without additional unrolling if all circuit instructions are supported by the simulator.

    See [#1447](https://github.com/Qiskit/qiskit-aer/issues/1447) for details.

*   Multi-threaded transpilations to generate diagonal gates will now work correctly if the number of gates of a circuit exceeds `fusion_parallelization_threshold`. Previously, different threads would occasionally fuse the same element into multiple blocks, causing incorrect results.

*   Fixes a bug with truncation of circuits in parameterized Qobjs. Previously parameters of parameterized QObj could be wrongly resolved if unused qubits of their circuits were truncated, because indices of the parameters were not updated after the instructions on unmeasured qubits were removed.

    See [#1427](https://github.com/Qiskit/qiskit-aer/issues/1427) for details.

<span id="id157" />

### Ignis 0.7.0

No change

<span id="id158" />

### IBM Q Provider 0.18.3

No change

<span id="qiskit-0-34-1" />

## Qiskit 0.34.1

<span id="terra-0-19-1" />

### Terra 0.19.1

No change

<span id="aer-0-10-2" />

<span id="release-notes-0-10-2-aer" />

### Aer 0.10.2

<span id="release-notes-0-10-2-aer-bug-fixes" />

<span id="id159" />

#### Bug Fixes

*   Fixed simulation of `for` loops where the loop parameter was not used in the body of the loop. For example, previously this code would fail, but will now succeed:

    ```python
    import qiskit
    from qiskit.providers.aer import AerSimulator

    qc = qiskit.QuantumCircuit(2)
    with qc.for_loop(range(4)) as i:
        qc.h(0)
        qc.cx(0, 1)

    AerSimulator(method="statevector").run(qc)
    ```

*   Fixes a bug in `QuantumError.to_dict()` where N-qubit circuit instructions where the assembled instruction always applied to qubits `[0, ..., N-1]` rather than the instruction qubits. This bug also affected device and fake backend noise models.

    See [Issue 1415](https://github.com/Qiskit/qiskit-aer/issues/1415) for details.

<span id="id160" />

### Ignis 0.7.0

No change

<span id="id161" />

### IBM Q Provider 0.18.3

No change

<span id="qiskit-0-34-0" />

## Qiskit 0.34.0

Qiskit 0.34.0 includes a point release of Qiskit Aer: version 0.10.1, which patches performance regressions in version 0.10.0 that were discovered immediately post-release. See below for the release notes for both Qiskit Aer 0.10.0 and 0.10.1.

<span id="id162" />

### Terra 0.19.1

No change

<span id="aer-0-10-1" />

<span id="release-notes-aer-0-10-1" />

### Aer 0.10.1

<span id="release-notes-aer-0-10-1-prelude" />

<span id="id163" />

#### Prelude

The Qiskit Aer 0.10.1 patch fixes performance regressions introduced in Qiskit Aer 0.10.0.

<span id="release-notes-aer-0-10-1-bug-fixes" />

<span id="id164" />

#### Bug Fixes

*   Fix performance regression in noisy simulations due to large increase in serialization overhead for loading noise models from Python into C++ resulting from unintended nested Python multiprocessing calls. See [issue 1407](https://github.com/Qiskit/qiskit-aer/issues/1407) for details.

<span id="aer-0-10-0" />

<span id="release-notes-aer-0-10-0" />

### Aer 0.10.0

<span id="release-notes-aer-0-10-0-prelude" />

<span id="id165" />

#### Prelude

The Qiskit Aer 0.10 release includes several performance and noise model improvements. Some highlights are:

*   Improved performance for parallel shot GPU and HPC simulations
*   Support for simulation of circuits containing QASM 3.0 control-flow instructions
*   Support for relaxation noise on scheduled circuits in backend noise models
*   Support of user-created transpiler passes for defining custom gate errors and noise models, and inserting them into circuits.

<span id="release-notes-aer-0-10-0-new-features" />

<span id="id166" />

#### New Features

*   Added support of QASM 3.0 control-flow instructions introduced in Qiskit-Terra 0.19.0. Supported instructions are [`ForLoopOp`](qiskit.circuit.ForLoopOp "qiskit.circuit.ForLoopOp"), [`WhileLoopOp`](qiskit.circuit.WhileLoopOp "qiskit.circuit.WhileLoopOp"), [`ContinueLoopOp`](qiskit.circuit.ContinueLoopOp "qiskit.circuit.ContinueLoopOp"), [`BreakLoopOp`](qiskit.circuit.BreakLoopOp "qiskit.circuit.BreakLoopOp"), [`IfElseOp`](qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp").

*   Added a batched-shot simulation optimization for GPU simulations. This optional feature will use available memory on 1 or more GPUs to run multiple simulation shots in parallel for greatly improved performance on multi-shot simulations with noise models and/or intermediate measurements.

    This option is enabled by default when using `device="GPU"` and a simulation `method` of either `"statevector"` or `"density_matrix"` with the `AerSimulator`. It can be disabled by setting `batched_shots_gpu=False` in the simulator options.

    This optimization is most beneficial for small to medium numbers of qubits where there is sufficient GPU memory to run multiple simulations in parallel. The maximum number of active circuit qubits for enabling this optimization can be configured using the `batch_shots_gpu_max_qubits` simulator option. The default value of this option is 16.

*   Added the new `max_shot_size` option to a custom executor for running multiple shots of a noisy circuit in parallel.

    For example configuring `max_shot_size` with a custom executor:

    ```python
    backend = AerSimulator(
       max_shot_size=1, max_job_size=1, executor=custom_executor)
    job = backend.run(circuits)
    ```

    will split the shots of a noisy circuit into multiple circuits. After all individual shots have finished executing, the job results are automatically combined into a single [`Result`](qiskit.result.Result "qiskit.result.Result") object that is returned by `job.result()`.

*   Added the `mps_swap_direction` simulator option that allows the user to determine the direction of internal swaps, when they are inserted for a 2-qubit gate. Possible values are `"mps_swap_right"` and `"mps_swap_left"`. The direction of the swaps may affect performance, depending on the circuit.

*   Implemented a new measurement sampling optimization for the `"matrix_product_state"` simulation method of the `AerSimulator`. Currently this algorithm is used only when all qubits are measured and when the simulator `mps_sample_measure_algorithm` simulator option is set to `"mps_probabilities"`.

*   Improved the performance of the measure instruction for the `"matrix_product_state"` simulation method of the `AerSimulator`.

*   Added a `SaveClifford` instruction for saving the state of the stabilizer simulation method as a [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") object.

    Note that this instruction is essentially equivalent to the `SaveStabilizer` instruction, however that instruction will return the saved state as a [`StabilizerState`](qiskit.quantum_info.StabilizerState "qiskit.quantum_info.StabilizerState") object instead of a [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") object.

*   Added two transpiler passes for inserting instruction-dependent quantum errors into circuits:

    *   `qiskit.providers.aer.noise.LocalNoisePass`
    *   `qiskit.providers.aer.noise.RelaxationNoisePass`

    The `LocalNoisePass` pass can be used to implement custom parameterized noise models by defining a noise generating function of the form

    ```python
    def fn(
        inst: Instruction,
        qubits: Optional[List[int]] = None,
    ) -> InstructionLike
    ```

    which returns a noise instruction (eg. a `QuantumError` or other instruction) that can depend on any properties or parameters of the instruction and qubit arguements.

    This function can be applied to all instructions in a circuit, or a specified subset (See the `LocalNoisePass` documentation for additional details.)

    The `RelaxationNoisePass` is a special case of the `LocalNoisePass` using a predefined noise function that returns a tensor product of `thermal_relaxation_error()` on each qubit in an instruction, dependent on the instruction’s duration and the supplied relaxation time constant parameters of the pass.

*   The basic device noise model implemented by `NoiseModel.from_backend()` and `AerSimulator.from_backend()` has been upgraded to allow adding duration-dependent relaxation errors on circuit delay gates using the `RelaxationNoisePass`.

    To enable this noise when running noisy simulations you must first schedule your circuit to insert scheduled delay instructions as follows:

    ```python
    backend = AerSimulator.from_backend(ibmq_backend)
    scheduled_circuit = qiskit.transpile(
        circuit, backend=backend, scheduling_method='asap')
    result = backend.run(scheduled_circuit).result()
    ```

    If the circuit is transpiled without being scheduled (and also contains no delay instructions) the noisy simulation will not include the effect of delay relaxation errors. In this case the simulation will be equivalent to the previous qiskit-aer 0.9 simulation where relaxation noise is only added to gate instructions based on their duration as obtained from the backend properties.

*   The constructor of `QuantumError` now accepts several new types of input as `noise_ops` argument, for example:

    ```python
    import numpy as np

    from qiskit import QuantumCircuit
    from qiskit.circuit.library import IGate, XGate, Reset
    from qiskit.quantum_info import Kraus
    from qiskit.providers.aer.noise import QuantumError

    # Quantum channels
    kraus = Kraus([
        np.array([[1, 0], [0, np.sqrt(1 - 0.9)]], dtype=complex),
        np.array([[0, 0], [0, np.sqrt(0.9)]], dtype=complex)
    ])
    print(QuantumError(kraus))

    # Construction from a QuantumCircuit
    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    error = QuantumError(qc)

    # Construction from a tuple of (Instruction, List[int]), where the list of
    # integers represents the qubits.
    error = QuantumError((Reset(), [0]))

    # Construction from an iterable of objects in the same form as above, but
    # where each also has an associated probability.
    error = QuantumError([
        ((IGate(), [0]), 0.9),
        ((XGate(), [0]), 0.1),
    ])

    # A short-hand for the iterable form above, where the qubits are implicit,
    # and each instruction is over all qubits.
    error = QuantumError([(IGate(), 0.9), (XGate(), 0.1)])
    ```

    Note that the original JSON-based input format is deperecated.

*   Added a utility function `qiskit.providers.aer.utils.transform_noise_model()` for constructing a noise model by applying a supplied function to all `QuantumError`s in the noise model.

*   Added two utility functions `qiskit.providers.aer.utils.transpile_quantum_error()` and `qiskit.providers.aer.utils.transpile_noise_model()` for transpiling the circuits contained in `QuantumError`, and all errors in a `NoiseModel`.

*   Added the ability to add `QuantumError` objects directly to a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") without converting to a [`Kraus`](qiskit.quantum_info.Kraus "qiskit.quantum_info.Kraus") instruction.

    Circuits containing quantum errors can now be run on the `AerSimulator` and `QasmSimulator` simulators as an alternative to, or in addition to, building a `NoiseModel` for defining noisy circuit instructions.

    Example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.providers.aer import AerSimulator
    from qiskit.providers.aer.noise import pauli_error

    error_h = pauli_error([('I', 0.95), ('X', 0.05)])
    error_cx = pauli_error([('II', 0.9), ('XX', 0.1)])

    qc = QuantumCircuit(3)
    qc.h(0)
    qc.append(error_h, [0])
    qc.cx(0, 1)
    qc.append(error_cx, [0, 1])
    qc.cx(0, 2)
    qc.append(error_cx, [0, 2])
    qc.measure_all()

    backend = AerSimulator(method='stabilizer')
    result = backend.run(qc).result()
    result.get_counts(0)
    ```

    Circuits containing quantum errors can also be evaluated using the [`quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") quantum channel and [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes.

<span id="release-notes-aer-0-10-0-upgrade-notes" />

<span id="id167" />

#### Upgrade Notes

*   The return type of several save instructions have been changed to be the corresponding Qiskit Terra classes rather than raw NumPy arrays or dictionaries. The types that have changed are

    *   `save_statevector()` now returns as a [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector")
    *   `save_density_matrix()` now returns as a [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix")
    *   `save_stabilizer()` now returns as [`StabilizerState`](qiskit.quantum_info.StabilizerState "qiskit.quantum_info.StabilizerState")
    *   `save_unitary()` now returns as [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator")
    *   `save_superop()` now returns as [`SuperOp`](qiskit.quantum_info.SuperOp "qiskit.quantum_info.SuperOp")
    *   `save_probabilities_dict()` now returns as a [`ProbDistribution`](qiskit.result.ProbDistribution "qiskit.result.ProbDistribution")

*   Changed the default value of `standard_gates` to `None` for all functions in `qiskit.providers.aer.noise.errors.standard_errors` as those functions are updated so that they use standard gates by default.

*   When an unsupported argument is supplied to `approximate_quantum_error()`, it will now raise a `NoiseError` instead of a `RuntimeError`.

<span id="release-notes-aer-0-10-0-deprecation-notes" />

<span id="id168" />

#### Deprecation Notes

*   Using NumPy `ndarray` methods and attributes on the return type of `save_statevector()`, `save_density_matrix()`, `save_unitary()`, and `save_superop()` has been deprecated, and will stop working in a future release. These instructions now return [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") classes for their return types. Partial backwards compatability with treating these objects as NumPy arrays is implemented by forwarding methods to the internal array during the deprecation period.

*   Passing in a [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") object for the `backend` argument of `NoiseModel.from_backend()` has been deprecated, as it is incompatible with duration dependent delay noises, and will be removed in a future release. Pass in a Qiskit Terra [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") object instead.

*   Deprecated the `number_of_qubits` option of the `QuantumError` constructor in favor of automatic determination of the dimension.

*   Deprecated the `standard_gates` option of the `QuantumError` constructor in favor of externalizing such basis-change functionality. In many cases, you can transform any error into an error defined only with specific gates using `approximate_quantum_error()`.

*   Deprecated the `standard_gates` option of all functions in `qiskit.providers.aer.noise.errors.standard_errors` in favor of returning errors in the form of a mixture of standard gates as much as possible by default.

*   Deprecated all functions in `errorutils` because they are helper functions meant to be used only for implementing functions in `qiskit.providers.aer.noise.errors.standard_errors` and they should have been provided as private functions.

*   Deprecated the `standard_gates` option of `NoiseModel.from_backend()` in favor of externalizing such basis-change functionality.

*   Deprecated `NoiseModel.from_dict()` to make the noise model independent of Qobj (JSON) format.

*   Deprecated all public variables, functions and classes in `qiskit.providers.aer.noise.utils.noise_transformation` except for `approximate_quantum_error()` and `approximate_noise_model()`, because they are helper functions meant to be used only for implementing the `approximate_*` functions and they should have been provided as private functions.

*   Deprecated `remap_noise_model()` since the C++ code now automatically truncates and remaps noise models if it truncates circuits.

<span id="release-notes-aer-0-10-0-other-notes" />

#### Other Notes

*   Changes in the implementation of the function `approximate_quantum_error()` may change the resulting approximate error compared to Qiskit Aer 0.9.

<span id="id169" />

### Ignis 0.7.0

No change

<span id="release-notes-0-18-3-ibmq" />

<span id="id170" />

### IBM Q Provider 0.18.3

<span id="release-notes-0-18-3-ibmq-bug-fixes" />

<span id="id171" />

#### Bug Fixes

*   Fix delivered in [#1100](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1100) for an issue with JSON encoding and decoding when using `ParameterExpression`s in conjunction with Qiskit Terra 0.19.1 and above. Previously, the `Parameter` instances reconstructed from the JSON output would have different unique identifiers, causing them to seem unequal to the input. They will now have the correct backing identities.

<span id="qiskit-0-33-1" />

## Qiskit 0.33.1

<span id="release-notes-0-19-1-terra" />

<span id="id172" />

### Terra 0.19.1

<span id="release-notes-0-19-1-terra-prelude" />

<span id="id173" />

#### Prelude

Qiskit Terra 0.19.1 is a bugfix release, solving some issues in 0.19.0 concerning circuits constructed by the control-flow builder interface, conditional gates and QPY serialisation of newer Terra objects.

<span id="release-notes-0-19-1-terra-deprecation-notes" />

<span id="id174" />

#### Deprecation Notes

*   The loose functions `qiskit.circuit.measure.measure()` and `qiskit.circuit.reset.reset()` are deprecated, and will be removed in a future release. Instead, you should access these as methods on [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"):

    ```python
    from qiskit import QuantumCircuit
    circuit = QuantumCircuit(1, 1)

    # Replace this deprecated form ...
    from qiskit.circuit.measure import measure
    measure(circuit, 0, 0)

    # ... with either of the next two lines:
    circuit.measure(0, 0)
    QuantumCircuit.measure(circuit, 0, 0)
    ```

<span id="release-notes-0-19-1-terra-bug-fixes" />

<span id="id175" />

#### Bug Fixes

*   Fixed an error in the circuit conversion functions [`circuit_to_gate()`](converters#qiskit.converters.circuit_to_gate "qiskit.converters.circuit_to_gate") and [`circuit_to_instruction()`](converters#qiskit.converters.circuit_to_instruction "qiskit.converters.circuit_to_instruction") (and their associated circuit methods [`QuantumCircuit.to_gate()`](qiskit.circuit.QuantumCircuit#to_gate "qiskit.circuit.QuantumCircuit.to_gate") and [`QuantumCircuit.to_instruction()`](qiskit.circuit.QuantumCircuit#to_instruction "qiskit.circuit.QuantumCircuit.to_instruction")) when acting on a circuit with registerless bits, or bits in more than one register. Previously, the number of bits necessary for the created gate or instruction would be calculated incorrectly, often causing an exception during the conversion.

*   Fixed an issue where calling [`QuantumCircuit.copy()`](qiskit.circuit.QuantumCircuit#copy "qiskit.circuit.QuantumCircuit.copy") on the “body” circuits of a control-flow operation created with the builder interface would raise an error. For example, this was previously an error, but will now return successfully:

    ```python
    from qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister

    qreg = QuantumRegister(4)
    creg = ClassicalRegister(1)
    circ = QuantumCircuit(qreg, creg)

    with circ.if_test((creg, 0)):
        circ.h(0)

    if_else_instruction, _, _ = circ.data[0]
    true_body = if_else_instruction.params[0]
    true_body.copy()
    ```

*   The control-flow builder interface now supports using [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister")s as conditions in nested control-flow scopes. Previously, doing this would not raise an error immediately, but the internal circuit blocks would not have the correct registers defined, and so later logic that worked with the inner blocks would fail.

    For example, previously the drawers would fail when trying to draw an inner block conditioned on a classical register, whereas now it will succeed, such as in this example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.circuit import QuantumRegister, ClassicalRegister

    qreg = QuantumRegister(4)
    creg = ClassicalRegister(1)
    circ = QuantumCircuit(qreg, creg)

    with circ.for_loop(range(10)) as a:
        circ.ry(a, 0)
        with circ.if_test((creg, 1)):
            circ.break_loop()

    print(circ.draw(cregbundle=False))
    print(circ.data[0][0].blocks[0].draw(cregbundle=False))
    ```

*   Fixed `qpy_serialization` support for serializing [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects that are using [`ParameterVector`](qiskit.circuit.ParameterVector "qiskit.circuit.ParameterVector") or `ParameterVectorElement` as parameters. Previously, a `ParameterVectorElement` parameter was just treated as a [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") for QPY serialization which meant the [`ParameterVector`](qiskit.circuit.ParameterVector "qiskit.circuit.ParameterVector") context was lost in QPY and the output order of [`parameters`](qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") could be incorrect.

    To fix this issue a new QPY format version, [Version 3](qpy#qpy-version-3), was required. This new format version includes a representation of the `ParameterVectorElement` class which is described in the `qpy_serialization` documentation at [PARAMETER\_VECTOR\_ELEMENT](qpy#qpy-param-vector).

*   Fixed the `qpy_serialization` support for serializing a [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") object. Previously, the [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") was treated as a custom gate for serialization and would be deserialized as a [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") object that had the same definition and name as the original [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate"). However, this would lose the original state from the [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate"). This has been fixed so that starting in this release a [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") in the circuit will be preserved 1:1 across QPY serialization now. The only limitation with this is that it does not support custom [`EvolutionSynthesis`](qiskit.synthesis.EvolutionSynthesis "qiskit.synthesis.EvolutionSynthesis") classes. Only the classes available from [`qiskit.synthesis`](synthesis#module-qiskit.synthesis "qiskit.synthesis") can be used with a [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") for qpy serialization.

    To fix this issue a new QPY format version, [Version 3](qpy#qpy-version-3), was required. This new format version includes a representation of the [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") class which is described in the `qpy_serialization` documentation at [PAULI\_EVOLUTION](qpy#pauli-evo-qpy).

*   Two loose functions `qiskit.circuit.measure.measure()` and `qiskit.circuit.reset.reset()` were accidentally removed without a deprecation period. They have been reinstated, but are marked as deprecated in favour of the methods [`QuantumCircuit.measure()`](qiskit.circuit.QuantumCircuit#measure "qiskit.circuit.QuantumCircuit.measure") and [`QuantumCircuit.reset()`](qiskit.circuit.QuantumCircuit#reset "qiskit.circuit.QuantumCircuit.reset"), respectively, and will be removed in a future release.

<span id="release-notes-0-19-1-terra-other-notes" />

<span id="id176" />

#### Other Notes

*   The new control-flow builder interface uses various context managers and helper objects to do its work. These should not be considered part of the public API, and are liable to be changed and removed without warning. The *usage* of the builder interface has stability guarantees, in the sense that the behaviour described by [`QuantumCircuit.for_loop()`](qiskit.circuit.QuantumCircuit#for_loop "qiskit.circuit.QuantumCircuit.for_loop"), [`while_loop()`](qiskit.circuit.QuantumCircuit#while_loop "qiskit.circuit.QuantumCircuit.while_loop") and [`if_test()`](qiskit.circuit.QuantumCircuit#if_test "qiskit.circuit.QuantumCircuit.if_test") for the builder interface are subject to the standard deprecation policies, but the actual objects used to effect this are not. You should not rely on the objects (such as `IfContext` or `ControlFlowBuilderBlock`) existing in their current locations, or having any methods or attributes attached to them.

    This was not previously clear in the 0.19.0 release. All such objects now have a warning in their documentation strings making this explicit. It is likely in the future that their locations and backing implementations will become quite different.

<span id="aer-0-9-1" />

### Aer 0.9.1

No change

<span id="id177" />

### Ignis 0.7.0

No change

<span id="ibm-q-provider-0-18-2" />

<span id="release-notes-0-18-2-ibmq" />

### IBM Q Provider 0.18.2

<span id="release-notes-0-18-2-ibmq-bug-fixes" />

<span id="id178" />

#### Bug Fixes

*   Fix delivered in [#1065](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1065) for the issue where job kept crashing when `Parameter` was passed in circuit metadata.
*   Fix delivered in [#1094](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1094) for the issue wherein `qiskit.providers.ibmq.runtime.RuntimeEncoder` does an extra decompose() if the circuit being serialized is a `BlueprintCircuit`.

<span id="qiskit-0-33-0" />

## Qiskit 0.33.0

This release officially marks the end of support for the Qiskit Aqua project in Qiskit. It was originally deprecated in the 0.25.0 release and as was documented in that release the `qiskit-aqua` package has been removed from the Qiskit metapackage, which means `pip install qiskit` will no longer include `qiskit-aqua`. However, because of limitations in python packaging we cannot automatically remove a pre-existing install of `qiskit-aqua` when upgrading a previous version of Qiskit to this release (or a future release) with `pip install -U qiskit`. If you are upgrading from a previous version it’s recommended that you manually uninstall Qiskit Aqua with `pip uninstall qiskit-aqua` or install in a fresh python environment.

The application modules that were provided by `qiskit-aqua` have been split into several new packages: `qiskit-optimization`, `qiskit-nature`, `qiskit-machine-learning`, and `qiskit-finance`. These packages can be installed by themselves (via the standard pip install command, e.g. `pip install qiskit-nature`) or with the rest of the Qiskit metapackage as optional extras (e.g. `pip install 'qiskit[finance,optimization]'` or `pip install 'qiskit[all]'`). The core algorithms and the operator flow now exist as part of Qiskit Terra at `qiskit.algorithms` and `qiskit.opflow`. Depending on your existing usage of Aqua you should either use the application packages or the new modules in Qiskit Terra. For more details on how to migrate from Qiskit Aqua you can refer to the [Aqua Migration Guide](https://github.com/Qiskit/qiskit-aqua/blob/main/docs/tutorials/Qiskit%20Algorithms%20Migration%20Guide.ipynb).

This release also officially deprecates the Qiskit Ignis project. Accordingly, in a future release the `qiskit-ignis` package will be removed from the Qiskit metapackage, which means in that future release `pip install qiskit` will no longer include `qiskit-ignis`. Qiskit Ignis has been supersceded by the [Qiskit Experiments](https://qiskit.org/documentation/experiments/) project and active development has ceased. While deprecated, critical bug fixes and compatibility fixes will continue to be made to provide users a sufficient opportunity to migrate off of Ignis. After the deprecation period (which will be no shorter than 3 months from this release) the project will be retired and archived. You can refer to the [migration guide](https://github.com/Qiskit/qiskit-ignis#migration-guide) for details on how to switch from Qiskit Ignis to Qiskit Experiments.

<span id="terra-0-19-0" />

<span id="release-notes-0-19-0" />

### Terra 0.19.0

<span id="release-notes-0-19-0-prelude" />

<span id="id179" />

#### Prelude

The Qiskit Terra 0.19 release highlights are:

*   A new version of the abstract Qiskit/hardware interface, in the form of [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2"), which comes with a new data structure [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") to allow backends to better model their constraints for the [transpiler](transpiler#qiskit-transpiler).
*   An [extensible plugin interface](transpiler_plugins#qiskit-transpiler-plugins) to the [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass, allowing users or other packages to extend Qiskit Terra’s synthesis routines with new methods.
*   Control-flow instructions, for representing `for` and `while` loops and `if`/`else` statements in [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). The simulators in Qiskit Aer will soon be able to work with these new instructions, allowing you to write more dynamic quantum programs.
*   Preliminary support for the evolving [OpenQASM 3 specification](https://openqasm.com/). You can use the new [`qiskit.qasm3`](qasm3#module-qiskit.qasm3 "qiskit.qasm3") module to serialize your [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")s into OpenQASM 3, including the new control-flow constructs.

This release marks the end of support for Python 3.6 in Qiskit. This release of Qiskit Terra, and any subsequent bugfix releases in the 0.19.x series, will be the last to work with Python 3.6. Starting from the next minor release (0.20.0) of Qiskit Terra, the minimum required Python version will be 3.7.

As always, there are many more features and fixes in this release as well, which you can read about below.

<span id="release-notes-0-19-0-new-features" />

<span id="id180" />

#### New Features

*   [`QuantumCircuit.decompose()`](qiskit.circuit.QuantumCircuit#decompose "qiskit.circuit.QuantumCircuit.decompose") and its corresponding transpiler pass [`Decompose`](qiskit.transpiler.passes.Decompose "qiskit.transpiler.passes.Decompose") now optionally accept a parameter containing a collection of gate names. If this parameter is given, then only gates with matching names will be decomposed. This supports Unix-shell-style wildcard matches. For example:

    ```python
    qc.decompose(["h", "r[xz]"])
    ```

    will decompose any `h`, `rx` or `rz` gates, but leave (for example) `x` gates untouched.

*   Added the `termination_checker` argument to the [`SPSA`](qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA") optimizer. This allows the user to implement a custom termination criterion.

    ```python
    import numpy as np
    from qiskit.algorithms.optimizers import SPSA

    def objective(x):
        return np.linalg.norm(x) + .04*np.random.rand(1)

    class TerminationChecker:

        def __init__(self, N : int):
            """
            Callback to terminate optimization when the average decrease over
            the last N data points is smaller than the specified tolerance.
            """
            self.N = N
            self.values = []

        def __call__(self, nfev, parameters, value, stepsize, accepted) -> bool:
            """
            Returns:
                True if the optimization loop should be terminated.
            """
            self.values.append(value)

            if len(self.values) > self.N:
                last_values = self.values[-self.N:]
                pp = np.polyfit(range(self.N), last_values, 1)
                slope = pp[0] / self.N

                if slope > 0:
                    return True
            return False

    maxiter = 400
    spsa = SPSA(maxiter=maxiter, termination_checker=TerminationChecker(10))
    parameters, value, niter = spsa.optimize(2, objective, initial_point=np.array([0.5, 0.5]))
    ```

*   Added a new version of the [`Backend`](qiskit.providers.Backend "qiskit.providers.Backend") interface, [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2"). This new version is a large change from the previous version, [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") and changes both the user access pattern for properties of the backend (like number of qubits, etc) and how the backend represents its constraints to the transpiler. The execution of circuits (via the [`run()`](qiskit.providers.BackendV2#run "qiskit.providers.BackendV2.run") method) remains unchanged. With a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend instead of having a separate [`configuration()`](qiskit.providers.BackendV1#configuration "qiskit.providers.BackendV1.configuration"), [`properties()`](qiskit.providers.BackendV1#properties "qiskit.providers.BackendV1.properties"), and `defaults()` methods that construct [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration"), [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties"), and [`PulseDefaults`](qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") objects respectively, like in the [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") interface, the attributes contained in those output objects are accessible directly as attributes of the [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") object. For example, to get the number of qubits for a backend with [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") you would do:

    ```python
    num_qubits = backend.configuration().n_qubits
    ```

    while with [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") it is:

    ```python
    num_qubits = backend.num_qubits
    ```

    The other change around this is that the number of attributes exposed in the abstract [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") class is designed to be a hardware/vendor agnostic set of the required or optional fields that the rest of Qiskit can use today with any backend. Subclasses of the abstract [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") class can add support for additional attributes and methods beyond those defined in [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2"), but these will not be supported universally throughout Qiskit.

    The other critical change that is primarily important for provider authors is how a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") exposes the properties of a particular backend to the transpiler. With [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") this is done via a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object. The [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target"), which is exposed via the [`target`](qiskit.providers.BackendV2#target "qiskit.providers.BackendV2.target") attribute, is used to represent the set of constraints for running circuits on a particular backend. It contains the subset of information previously exposed by the [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration"), [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties"), and [`PulseDefaults`](qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") classes which the transpiler can actively use. When migrating a provider to use [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") (or when creating a new provider package) the construction of backend objects will primarily be around creating a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object for the backend.

*   Added a new [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class to the [`transpiler`](transpiler#module-qiskit.transpiler "qiskit.transpiler") module. The [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class is designed to represent the constraints of backend to the compiler. The [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class is intended to be used with a [`BackendV2`](qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend and is how backends will model their constraints for the transpiler moving forward. It combines the previously distinct fields used for controlling the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") target device (e.g. `basis_gates`, `coupling_map`, `instruction_durations`, etc) into a single data structure. It also adds additional functionality on top of what was available previously such as representing heterogeneous gate sets, multi-qubit gate connectivity, and tuned variants of the same gates. Currently the transpiler doesn’t factor in all these constraints, but over time it will grow to leverage the extra functionality.

*   The [`Options`](qiskit.providers.Options "qiskit.providers.Options") class now has optional support for specifying validators. This enables [`Backend`](qiskit.providers.Backend "qiskit.providers.Backend") authors to optionally specify basic validation on the user supplied values for fields in the [`Options`](qiskit.providers.Options "qiskit.providers.Options") object. For example, if you had an [`Options`](qiskit.providers.Options "qiskit.providers.Options") object defined with:

    ```python
    from qiskit.providers.Options
    options = Options(shots=1024)
    ```

    you can set a validator on shots for it to be between 1 and 4096 with:

    ```python
    options.set_validator('shots', (1, 4096))
    ```

    With the validator set any call to the [`update_options()`](qiskit.providers.Options#update_options "qiskit.providers.Options.update_options") method will check that if `shots` is being updated the proposed new value is within the valid range.

*   Added a new transpiler analysis pass, [`ContainsInstruction`](qiskit.transpiler.passes.ContainsInstruction "qiskit.transpiler.passes.ContainsInstruction"), to the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module. This pass is used to determine if a circuit contains a specific instruction. It takes in a single parameter at initialization, the name of the instruction to check for and set a boolean in the property set whether the circuit contains that instruction or not. For example:

    ```python
    from qiskit.transpiler.passes import ContainsInstruction
    from qiskit.circuit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()

    property_set = {}
    # Contains Hadamard
    contains_h = ContainsInstruction("h")
    contains_h(circuit, property_set)
    assert property_set["contains_h"] == True
    # Not contains SX
    contains_sx = ContainsInstruction("sx")
    contains_sx(circuit, property_set)
    assert property_set["contains_sx"] == False
    ```

*   Added a utility function [`qiskit.utils.detach_prefix()`](utils#qiskit.utils.detach_prefix "qiskit.utils.detach_prefix") that is a counterpart of [`apply_prefix()`](utils#qiskit.utils.apply_prefix "qiskit.utils.apply_prefix"). The new function returns a tuple of scaled value and prefix from a given float value. For example, a value `1.3e8` will be converted into `(130, "M")` that can be used to display a value in the user friendly format, such as `130 MHz`.

*   The values `"gate_error"` and `"balanced"` are now available for the `objective` option in the construction of the `BIPMapping` object, and `"balanced"` is now the default.

    The `"gate_error"` objective requires passing a [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") instance in the `backend_prop` kwarg, which contains the 2q-gate gate errors used in the computation of the objectives. The `"balanced"` objective will use the [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") instance if it is given, but otherwise will assume a CX error rate as given in the new parameter `default_cx_error_rate`. The relative weights of the gate-error and depth components of the balanced objective can be controlled with the new `depth_obj_weight` parameter.

*   Every attribute of the [`VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE") class that is set at the initialization is now accessible with getters and setters. Further, the default values of the VQE attributes `ansatz` and `optimizer` can be reset by assigning `None` to them:

    ```python
    vqe = VQE(my_ansatz, my_optimizer)
    vqe.ansatz = None   # reset to default: RealAmplitudes ansatz
    vqe.optimizer = None  # reset to default: SLSQP optimizer
    ```

*   Added a new method [`PauliList.group_qubit_wise_commuting()`](qiskit.quantum_info.PauliList#group_qubit_wise_commuting "qiskit.quantum_info.PauliList.group_qubit_wise_commuting") that partitions a [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") into sets of mutually qubit-wise commuting [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") operators. For example:

    ```python
    from qiskit.quantum_info import PauliList, Pauli
    pauli_list = PauliList([Pauli("IY"), Pauli("XX"), Pauli("YY"), Pauli("YX")])
    pauli_list.group_qubit_wise_commuting()
    ```

*   Added a new coupling-map constructor method [`CouplingMap.from_hexagonal_lattice()`](qiskit.transpiler.CouplingMap#from_hexagonal_lattice "qiskit.transpiler.CouplingMap.from_hexagonal_lattice") for constructing a hexagonal lattice coupling map. For example, to construct a 2x2 hexagonal lattice coupling map:

    ```python
    from qiskit.transpiler import CouplingMap
    cmap = CouplingMap.from_hexagonal_lattice(2, 2)
    cmap.draw()
    ```

*   New fake backend classes are available under `qiskit.test.mock`. These include mocked versions of `ibmq_brooklyn`, `ibmq_manila`, `ibmq_jakarta`, and `ibmq_lagos`. As with the other fake backends, these include snapshots of calibration data (i.e. `backend.defaults()`) and error data (i.e. `backend.properties()`) taken from the real system, and can be used for local testing, compilation and simulation.

*   Added the [`OperatorBase.is_hermitian()`](qiskit.opflow.OperatorBase#is_hermitian "qiskit.opflow.OperatorBase.is_hermitian") method to check whether the operator is Hermitian or not. [`NumPyEigensolver`](qiskit.algorithms.NumPyEigensolver "qiskit.algorithms.NumPyEigensolver") and [`NumPyMinimumEigensolver`](qiskit.algorithms.NumPyMinimumEigensolver "qiskit.algorithms.NumPyMinimumEigensolver") use `eigh` or `eigsh` to solve the eigenvalue problem when the operator is Hermitian.

*   Added a new constructor method [`PassManagerConfig.from_backend()`](qiskit.transpiler.PassManagerConfig#from_backend "qiskit.transpiler.PassManagerConfig.from_backend"). It constructs a [`PassManagerConfig`](qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig") object with user options and the configuration of a backend. With this feature, a preset passmanager can be built easier. For example:

    ```python
    from qiskit.transpiler.passmanager_config import PassManagerConfig
    from qiskit.transpiler.preset_passmanagers import level_1_pass_manager
    from qiskit.test.mock import FakeMelbourne

    pass_manager = level_1_pass_manager(
      PassManagerConfig.from_backend(FakeMelbourne(), seed_transpiler=42)
    )
    ```

*   A new transpiler pass, [`PulseGates`](qiskit.transpiler.passes.PulseGates "qiskit.transpiler.passes.PulseGates"), was added, which automatically extracts user-provided calibrations from the instruction schedule map and attaches the gate schedule to the given (transpiled) quantum circuit as a pulse gate.

    The [`PulseGates`](qiskit.transpiler.passes.PulseGates "qiskit.transpiler.passes.PulseGates") transpiler pass is applied to all optimization levels from 0 to 3. No gate implementation is updated unless the end-user explicitly overrides the `backend.defaults().instruction_schedule_map`. This pass saves users from individually calling [`QuantumCircuit.add_calibration()`](qiskit.circuit.QuantumCircuit#add_calibration "qiskit.circuit.QuantumCircuit.add_calibration") for every circuit run on the hardware.

    To supplement this new pass, a schedule was added to [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") and is implicitly updated with a metadata field `"publisher"`. Backend-calibrated gate schedules have a special publisher kind to avoid overriding circuits with calibrations of already known schedules. Usually, end-users don’t need to take care of this metadata as it is applied automatically. You can call [`InstructionScheduleMap.has_custom_gate()`](qiskit.pulse.InstructionScheduleMap#has_custom_gate "qiskit.pulse.InstructionScheduleMap.has_custom_gate") to check if the map has custom gate calibration.

    See the below code example to learn how to apply custom gate implementation for all circuits under execution.

    ```python
    from qiskit.test.mock import FakeGuadalupe
    from qiskit import pulse, circuit, transpile

    backend = FakeGuadalupe()

    with pulse.build(backend, name="x") as x_q0:
        pulse.play(pulse.Constant(160, 0.1), pulse.drive_channel(0))

    backend.defaults().instruction_schedule_map.add("x", (0,), x_q0)

    circs = []
    for _ in range(100):
        circ = circuit.QuantumCircuit(1)
        circ.sx(0)
        circ.rz(1.57, 0)
        circ.x(0)
        circ.measure_active()
        circs.append(circ)

    circs = transpile(circs, backend)
    circs[0].calibrations  # This returns calibration only for x gate
    ```

    Note that the instruction schedule map is a mutable object. If you override one of the entries and use that backend for other experiments, you may accidentally update the gate definition.

    ```python
    backend = FakeGuadalupe()

    instmap = backend.defaults().instruction_schedule_map
    instmap.add("x", (0, ), my_x_gate_schedule)

    qc = QuantumCircuit(1, 1)
    qc.x(0)
    qc.measure(0, 0)

    qc = transpile(qc, backend)  # This backend uses custom X gate
    ```

    If you want to update the gate definitions of a specific experiment, you need to first deepcopy the instruction schedule map and directly pass it to the transpiler.

*   Introduced a new option `qubit_subset` to the constructor of `BIPMapping`. The option enables us to specify physical qubits to be used (in `coupling_map` of the device) during the mapping in one line:

    ```python
    mapped_circ = BIPMapping(
        coupling_map=CouplingMap([[0, 1], [1, 2], [1, 3], [3, 4]]),
        qubit_subset=[1, 3, 4]
    )(circ)
    ```

    Previously, to do the same thing, we had to supply a reduced `coupling_map` which contains only the qubits to be used, embed the resulting circuit onto the original `coupling_map` and update the `QuantumCircuit._layout` accordingly:

    ```python
    reduced_coupling = coupling_map.reduce(qubit_to_use)
    mapped = BIPMapping(reduced_coupling)(circ)
    # skip the definition of fill_with_ancilla()
    # recover circuit on original coupling map
    layout = Layout({q: qubit_to_use[i] for i, q in enumerate(mapped.qubits)})
    for reg in mapped.qregs:
        layout.add_register(reg)
    property_set = {"layout": fill_with_ancilla(layout)}
    recovered = ApplyLayout()(mapped, property_set)
    # recover layout
    overall_layout = Layout({v: qubit_to_use[q] for v, q in mapped._layout.get_virtual_bits().items()})
    for reg in mapped.qregs:
        overall_layout.add_register(reg)
    recovered._layout = fill_with_ancilla(overall_layout)
    ```

*   Added the `ignore_pauli_phase` and `copy` arguments to the constructor of [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp"). `ignore_pauli_phase` prevents the `phase` attribute of an input [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") from being read, which is more performant if the [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") is already known to have all phases as zero in the internal ZX convention. `copy` allows users to avoid the copy of the input data when they explicitly set `copy=False`.

*   Improved performance of the following [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") operations:

    *   [`simplify()`](qiskit.quantum_info.SparsePauliOp#simplify "qiskit.quantum_info.SparsePauliOp.simplify") (see [#7122](https://github.com/Qiskit/qiskit-terra/issues/7122))
    *   [`compose()`](qiskit.quantum_info.SparsePauliOp#compose "qiskit.quantum_info.SparsePauliOp.compose") (see [#7126](https://github.com/Qiskit/qiskit-terra/issues/7126))
    *   `_add()` (see [#7138](https://github.com/Qiskit/qiskit-terra/issues/7138))
    *   [`from_list()`](qiskit.quantum_info.SparsePauliOp#from_list "qiskit.quantum_info.SparsePauliOp.from_list") and `__init__()` (see other discussion in [#7138](https://github.com/Qiskit/qiskit-terra/issues/7138)).

*   Added the [`SparsePauliOp.sum()`](qiskit.quantum_info.SparsePauliOp#sum "qiskit.quantum_info.SparsePauliOp.sum") method to add together many [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp")s. This method has significantly better performance than adding the instances together in a loop. For example, the previous way to add several [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp")s together would be to do:

    ```python
    from qiskit.quantum_info import SparsePauliOp, random_pauli_list
    sparse_ops = [SparsePauliOp(random_pauli_list(10, 10)) for _ in [None]*1000]

    total = sparse_ops[0]
    for op in sparse_ops[1:]:
        total += op
    ```

    This can now be done far more efficiently (in both speed and typing!) as:

    ```python
    SparsePauliOp.sum(sparse_ops)
    ```

*   Added an argument `limit_amplitude` to the constructor of `ParametricPulse`, which is the base class of [`Gaussian`](qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian"), [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare"), [`Drag`](qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag") and [`Constant`](qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant"), to allowing disabling the amplitude limit of 1 on a pulse-by-pulse basis. With `limit_amplitude=False`, individual pulses may have an amplitude exceeding unity without raising a [`PulseError`](pulse#qiskit.pulse.PulseError "qiskit.pulse.PulseError"). See [#6544](https://github.com/Qiskit/qiskit-terra/issues/6544) for more detail.

*   Using [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") or [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") with the `latex` drawer will now generate a file in an image format inferred from the filename extension, for example:

    ```python
    import qiskit

    circuit = qiskit.QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.draw('latex', filename='./file.jpg')
    ```

    This will save the circuit drawing in the JPEG format. Previously, the image always be in PNG format. Refer to [#6448](https://github.com/Qiskit/qiskit-terra/issues/6448) for more details.

    Now, if it encounters a filename extension which is not supported, for example:

    ```python
    circuit.draw('latex', filename='./file.spooky')
    ```

    it will raise a `ValueError` to change the filename extension to a supported image format.

*   Added the parameter `filename` to [`plot_gate_map()`](qiskit.visualization.plot_gate_map "qiskit.visualization.plot_gate_map") and [`plot_coupling_map()`](qiskit.visualization.plot_coupling_map "qiskit.visualization.plot_coupling_map"), which allows saving the resulting images to a file.

*   Introduced an approximate quantum compiler and a corresponding unitary synthesis plugin implementation. The main AQC class is [`AQC`](qiskit.transpiler.synthesis.aqc.AQC "qiskit.transpiler.synthesis.aqc.AQC") for a standalone version that compiles a unitary matrix into an approximate circuit. The plugin may be invoked by [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") when the `unitary_synthesis_method` argument is set to `'aqc'`. See [`qiskit.transpiler.synthesis.aqc`](synthesis_aqc#module-qiskit.transpiler.synthesis.aqc "qiskit.transpiler.synthesis.aqc") for full details.

*   Added a `filter_function` argument to [`QuantumCircuit.depth()`](qiskit.circuit.QuantumCircuit#depth "qiskit.circuit.QuantumCircuit.depth") and [`QuantumCircuit.size()`](qiskit.circuit.QuantumCircuit#size "qiskit.circuit.QuantumCircuit.size") in order to analyze circuit operations according to some criteria.

    For example, to get the number of two-qubit gates, you can do:

    ```python
    circuit.size(lambda x: x[0].num_qubits == 2)
    ```

    Or to get the depth of T gates acting on the zeroth qubit:

    ```python
    circuit.depth(lambda x: x[0].name == 't' and circuit.qubits[0] in x[1])
    ```

*   Added a new transpiler pass, [`CollectMultiQBlocks`](qiskit.transpiler.passes.CollectMultiQBlocks "qiskit.transpiler.passes.CollectMultiQBlocks"), to the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module. This pass is used to collect sequences of uninterrupted gates acting on groups of qubits. It provides a similar function to the existing [`Collect2qBlocks`](qiskit.transpiler.passes.Collect2qBlocks "qiskit.transpiler.passes.Collect2qBlocks") pass, but while that pass is designed and optimized to find 2 qubit blocks this new pass will work to find blocks of any size.

*   There is a builder interface for the new control-flow operations on [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"), such as the new [`ForLoopOp`](qiskit.circuit.ForLoopOp "qiskit.circuit.ForLoopOp"), [`IfElseOp`](qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp"), and [`WhileLoopOp`](qiskit.circuit.WhileLoopOp "qiskit.circuit.WhileLoopOp"). The interface uses the same circuit methods, *i.e.* [`QuantumCircuit.for_loop()`](qiskit.circuit.QuantumCircuit#for_loop "qiskit.circuit.QuantumCircuit.for_loop"), [`QuantumCircuit.if_test()`](qiskit.circuit.QuantumCircuit#if_test "qiskit.circuit.QuantumCircuit.if_test") and [`QuantumCircuit.while_loop()`](qiskit.circuit.QuantumCircuit#while_loop "qiskit.circuit.QuantumCircuit.while_loop"), which are overloaded so that if the `body` parameter is not given, they return a context manager. Entering one of these context managers pushes a scope into the circuit, and captures all gate calls (and other scopes) and the resources these use, and builds up the relevant operation at the end. For example, you can now do:

    ```python
    qc = QuantumCircuit(2, 2)
    with qc.for_loop(range(5)) as i:
        qc.rx(i * math.pi / 4, 0)
    ```

    This will produce a [`ForLoopOp`](qiskit.circuit.ForLoopOp "qiskit.circuit.ForLoopOp") on `qc`, which knows that qubit 0 is the only resource used within the loop body. These context managers can be nested, and will correctly determine their widths. You can use [`QuantumCircuit.break_loop()`](qiskit.circuit.QuantumCircuit#break_loop "qiskit.circuit.QuantumCircuit.break_loop") and [`QuantumCircuit.continue_loop()`](qiskit.circuit.QuantumCircuit#continue_loop "qiskit.circuit.QuantumCircuit.continue_loop") within a context, and it will expand to be the correct width for its containing loop, even if it is nested in further [`QuantumCircuit.if_test()`](qiskit.circuit.QuantumCircuit#if_test "qiskit.circuit.QuantumCircuit.if_test") blocks.

    The [`if_test()`](qiskit.circuit.QuantumCircuit#if_test "qiskit.circuit.QuantumCircuit.if_test") context manager provides a chained manager which, if desired, can be used to create an `else` block, such as by:

    ```python
    qreg = QuantumRegister(2)
    creg = ClassicalRegister(2)
    qc = QuantumCircuit(qreg, creg)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure(0, 0)
    with qc.if_test((creg, 0)) as else_:
        qc.x(1)
    with else_:
        qc.z(1)
    ```

    The manager will ensure that the `if` and `else` bodies are defined over the same set of resources.

*   Introduced a new transpiler pass [`InverseCancellation`](qiskit.transpiler.passes.InverseCancellation "qiskit.transpiler.passes.InverseCancellation") that generalizes the [`CXCancellation`](qiskit.transpiler.passes.CXCancellation "qiskit.transpiler.passes.CXCancellation") pass to cancel any self-inverse gates or gate-inverse pairs. It can be used by initializing [`InverseCancellation`](qiskit.transpiler.passes.InverseCancellation "qiskit.transpiler.passes.InverseCancellation") and passing a gate to cancel, for example:

    ```python
    from qiskit.transpiler.passes import InverseCancellation
    from qiskit import QuantumCircuit
    from qiskit.circuit.library import HGate
    from qiskit.transpiler import PassManager

    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.h(0)
    pass_ = InverseCancellation([HGate()])
    pm = PassManager(pass_)
    new_circ = pm.run(qc)
    ```

*   The constructor of [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") has two new kwargs `instruction_schedule_map` and `qubit_channel_mapping` which take a [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") and list of channel name lists for each qubit respectively. These new arguments are used to directly specify the information needed from a backend target. They should be used instead of passing a `BaseBackend` or [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") object directly to the pass with the `backend` argument.

*   The [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector")s of states comprised only of qubits can now be drawn in LaTeX in ket notation. In ket notation the entries of the statevector are processed such that exact factors like fractions or square roots of two are drawn as such. The particular convention can be chosen by passing the `convention` keyword argument as either `"ket"` or `"vector"` as appropriate:

    ```python
    import math
    from qiskit.quantum_info import Statevector

    sv = Statevector([math.sqrt(0.5), 0, 0, -math.sqrt(0.5)])
    sv.draw("latex", convention="ket")
    sv.draw("latex", convention="vector")
    ```

*   Added a new transpiler pass [`EchoRZXWeylDecomposition`](qiskit.transpiler.passes.EchoRZXWeylDecomposition "qiskit.transpiler.passes.EchoRZXWeylDecomposition") that allows users to decompose an arbitrary two-qubit gate in terms of echoed RZX-gates by leveraging Cartan’s decomposition. In combination with other transpiler passes, this can be used to transpile arbitrary circuits to RZX-gate-based and pulse-efficient circuits that implement the same unitary.

*   The [`SPSA`](qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA") and [`QNSPSA`](qiskit.algorithms.optimizers.QNSPSA "qiskit.algorithms.optimizers.QNSPSA") optimizer classes are now capable of batching as many circuit evaluations as possible for both the iterations and the initial calibrations. This can be leveraged by setting the `max_evals_grouped` kwarg on the constructor for [`VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE") when using either [`SPSA`](qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA") or [`QNSPSA`](qiskit.algorithms.optimizers.QNSPSA "qiskit.algorithms.optimizers.QNSPSA") as the `optimizer` parameter. For example:

    ```python
    from qiskit.circuit.library import TwoLocal
    from qiskit.algorithms import VQE
    from qiskit.algorithms.optimizers import QNSPSA
    from qiskit.test.mock import FakeMontreal

    backend = FakeMontreal()
    ansatz = TwoLocal(2, rotation_blocks=["ry", "rz"], entanglement_blocks="cz")
    qnspsa = QNSPSA(fidelity, maxiter=5)
    vqe = VQE(
        ansatz=ansatz,
        optimizer=qnspsa,
        max_evals_grouped=100,
        quantum_instance=backend,
    )
    ```

*   This release introduces a decomposition method for two-qubit gates which targets user-defined sets of RZX gates. Transpiler users can enable decomposition for \{`RZX(pi/2)`, `RZX(pi/4)`, and `RZX(pi/6)`} specifically by including `'rzx'` in their `basis_gates` list when calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"). Quantum information package users can find the method itself under the [`XXDecomposer`](qiskit.quantum_info.XXDecomposer "qiskit.quantum_info.XXDecomposer") class.

*   Added a transpiler pass [`Optimize1qGatesSimpleCommutation`](qiskit.transpiler.passes.Optimize1qGatesSimpleCommutation "qiskit.transpiler.passes.Optimize1qGatesSimpleCommutation"), which optimizes a circuit according to a strategy of commuting single-qubit gates around to discover resynthesis opportunities.

*   Added a `max_job_tries` parameter to [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance"), to limit the number of times a job will attempt to be executed on a backend. Previously the submission and fetching of results would be attempted infinitely, even if the job was cancelled or errored on the backend. The default is now 50, and the previous behaviour can be achieved by setting `max_job_tries=-1`. Fixes [#6872](https://github.com/Qiskit/qiskit-terra/issues/6872) and [#6821](https://github.com/Qiskit/qiskit-terra/issues/6821).

*   The `latex` output method for the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method can now draw circuits that contain gates with single bit condition. This was added for compatibility of latex drawer with the new feature of supporting classical conditioning of gates on single classical bits.

*   The `"mpl"` output method for the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method can now draw circuits that contain gates with single bit condition. This was added for compatibility of the `"mpl"` drawer with the new feature of supporting classical conditioning of gates on single classical bits.

*   The `text` output method for the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method can now draw circuits that contain gates with single bit condition. This was added for compatibility of text drawer with the new feature of supporting classical conditioning of gates on single classical bits.

*   A new analysis transpiler pass, [`GatesInBasis`](qiskit.transpiler.passes.GatesInBasis "qiskit.transpiler.passes.GatesInBasis"), was added to [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes"). This pass is used to check if the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") being transpiled has all the gates in the configured basis set or not. It will set the attribute `"all_gates_in_basis"` in the property set to `True` if all the gates in the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") are in the configured basis set or `False` if they are not. For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler.passes import GatesInBasis

    # Instatiate Pass
    basis_gates = ["cx", "h"]
    basis_check_pass = GatesInBasis(basis_gates)
    # Build circuit
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()
    # Run pass on circuit
    property_set = {}
    basis_check_pass(circuit, property_set=property_set)
    assert property_set["all_gates_in_basis"]
    ```

*   Added two new constructor methods, [`from_heavy_hex()`](qiskit.transpiler.CouplingMap#from_heavy_hex "qiskit.transpiler.CouplingMap.from_heavy_hex") and [`from_heavy_square()`](qiskit.transpiler.CouplingMap#from_heavy_square "qiskit.transpiler.CouplingMap.from_heavy_square"), to the [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") class. These constructor methods are used to create a [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") that are a heavy hex or heavy square graph as described in [Chamberland *et al.*, 2020](https://journals.aps.org/prx/abstract/10.1103/PhysRevX.10.011022).

    For example:

    ```python
    from qiskit.transpiler import CouplingMap

    cmap = CouplingMap.from_heavy_hex(5)
    cmap.draw()
    ```

    ```python
    from qiskit.transpiler import CouplingMap

    cmap = CouplingMap.from_heavy_square(5)
    cmap.draw()
    ```

*   The `HHL` algorithm can now find solutions when its matrix has negative eigenvalues. To enable this, the algorithm now adds an extra qubit to represent the sign of the value, and the helper algorithm [`ExactReciprocal`](qiskit.circuit.library.ExactReciprocal "qiskit.circuit.library.ExactReciprocal") was updated to process this new information. See [#6971](https://github.com/Qiskit/qiskit-terra/pull/6971) for more details.

*   Added two new classes, [`CompleteMeasFitter`](qiskit.utils.mitigation.CompleteMeasFitter "qiskit.utils.mitigation.CompleteMeasFitter") and [`TensoredMeasFitter`](qiskit.utils.mitigation.TensoredMeasFitter "qiskit.utils.mitigation.TensoredMeasFitter") to the [`qiskit.utils.mitigation`](utils_mitigation#module-qiskit.utils.mitigation "qiskit.utils.mitigation") module. These classes are for use only as values for the `measurement_error_mitigation_cls` kwarg of the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class. The instantiation and usage of these classes (or anything else in [`qiskit.utils.mitigation`](utils_mitigation#module-qiskit.utils.mitigation "qiskit.utils.mitigation")) outside of the `measurement_error_mitigation_cls` kwarg should be treated as an internal private API and not relied upon.

*   The [`ListOp`](qiskit.opflow.list_ops.ListOp "qiskit.opflow.list_ops.ListOp") class in [`qiskit.opflow`](opflow#module-qiskit.opflow "qiskit.opflow") now has a [`coeffs`](qiskit.opflow.list_ops.ListOp#coeffs "qiskit.opflow.list_ops.ListOp.coeffs") attribute, which returns a list of the coefficients of the operator list, with the overall coefficient ([`ListOp.coeff`](qiskit.opflow.list_ops.ListOp#coeff "qiskit.opflow.list_ops.ListOp.coeff")) distributed multiplicatively into the list. Note that [`ListOp`](qiskit.opflow.list_ops.ListOp "qiskit.opflow.list_ops.ListOp") objects may be nested (contained in `oplist` of a [`ListOp`](qiskit.opflow.list_ops.ListOp "qiskit.opflow.list_ops.ListOp") object), and in these cases an exception is raised if the coeffs method is called. The [`ListOp.coeffs`](qiskit.opflow.list_ops.ListOp#coeffs "qiskit.opflow.list_ops.ListOp.coeffs") method conveniently duck-types against the `coeffs` property method of the non-nesting [`PauliSumOp`](qiskit.opflow.primitive_ops.PauliSumOp "qiskit.opflow.primitive_ops.PauliSumOp") class.

*   The [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") class is now subscriptable. User can now retrieve the nth coefficient in a [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") by index as `statevec[n]`.

*   Added the [`Statevector.inner`](qiskit.quantum_info.Statevector#inner "qiskit.quantum_info.Statevector.inner") method to calculate inner products of [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") instances. For example:

    ```python
    statevec_inner_other = statevec.inner(other)
    ```

    will return the inner product of `statevec` with `other`. While `statevec` must be a [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector"), `other` can be anything that can be constructed into a [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector"), such as a Numpy array.

*   Added a new parameter, `add_bits`, to [`QuantumCircuit.measure_all()`](qiskit.circuit.QuantumCircuit#measure_all "qiskit.circuit.QuantumCircuit.measure_all"). By default it is set to `True` to maintain the previous behaviour of adding a new [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") of the same size as the number of qubits to store the measurements. If set to `False`, the measurements will be stored in the already existing classical bits. For example, if you created a circuit with existing classical bits like:

    ```python
    from qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister

    qr = QuantumRegister(2)
    cr = ClassicalRegister(2, "meas")
    circuit = QuantumCircuit(qr, cr)
    ```

    calling `circuit.measure_all(add_bits=False)` will use the existing classical register `cr` as the output target of the `Measurement` objects added to the circuit.

*   [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") now delegates its numeric conversions to the underlying symbolic library, even if there are potentially unbound parameters. This allows conversions of expressions such as:

    ```python
    >>> from qiskit.circuit import Parameter
    >>> x = Parameter('x')
    >>> float(x - x + 2.3)
    2.3
    ```

    where the underlying expression has a fixed value, but the parameter `x` is not yet bound.

*   Added an [`Optimizer.minimize()`](qiskit.algorithms.optimizers.Optimizer#minimize "qiskit.algorithms.optimizers.Optimizer.minimize") method to all optimizers: [`Optimizer`](qiskit.algorithms.optimizers.Optimizer "qiskit.algorithms.optimizers.Optimizer") and derived classes. This method mimics the signature of SciPy’s `minimize()` function and returns an [`OptimizerResult`](qiskit.algorithms.optimizers.OptimizerResult "qiskit.algorithms.optimizers.OptimizerResult").

    For example

    ```python
    import numpy as np
    from qiskit.algorithms.optimizers import COBYLA

    def loss(x):
        return -(x[0] - 1) ** 2 - (x[1] + 1) ** 3

    initial_point = np.array([0, 0])
    optimizer = COBYLA()
    result = optimizer.minimize(loss, initial_point)

    optimal_parameters = result.x
    minimum_value = result.fun
    num_function_evals = result.nfev
    ```

*   Added a [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") to the circuit library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library")) which defines a gate performing time evolution of (sums or sums-of-sums of) [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli")s. The synthesis of this gate is performed by [`EvolutionSynthesis`](qiskit.synthesis.EvolutionSynthesis "qiskit.synthesis.EvolutionSynthesis") and is decoupled from the gate itself. Currently available synthesis methods are:

    *   [`LieTrotter`](qiskit.synthesis.LieTrotter "qiskit.synthesis.LieTrotter"): first order Trotterization
    *   [`SuzukiTrotter`](qiskit.synthesis.SuzukiTrotter "qiskit.synthesis.SuzukiTrotter"): higher order Trotterization
    *   [`MatrixExponential`](qiskit.synthesis.MatrixExponential "qiskit.synthesis.MatrixExponential"): exact, matrix-based evolution

    For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import PauliEvolutionGate
    from qiskit.quantum_info import SparsePauliOp
    from qiskit.synthesis import SuzukiTrotter

    operator = SparsePauliOp.from_list([
        ("XIZ", 0.5), ("ZZX", 0.5), ("IYY", -1)
    ])
    time = 0.12  # evolution time
    synth = SuzukiTrotter(order=4, reps=2)

    evo = PauliEvolutionGate(operator, time=time, synthesis=synth)

    circuit = QuantumCircuit(3)
    circuit.append(evo, range(3))
    ```

*   A new function [`plot_coupling_map()`](qiskit.visualization.plot_coupling_map "qiskit.visualization.plot_coupling_map") has been introduced, which extends the functionality of the existing function [`plot_gate_map()`](qiskit.visualization.plot_gate_map "qiskit.visualization.plot_gate_map"), by accepting three parameters: `num_qubit`, `qubit_coordinates`, and `coupling_map` (instead of `backend`), to allow an arbitrary qubit coupling map to be plotted.

*   Qiskit Terra now has initial support for serializing [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")s to [OpenQASM 3](https://github.com/Qiskit/openqasm):

    ```python
    from qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit import qasm3

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)

    print(qasm3.dumps(qc))
    ```

    This initial release has limited support for named registers, basic built-in instructions (such as measure, barrier and reset), user-defined gates, user-defined instructions (as subroutines), and the new control-flow constructs also introduced in this release:

    ```python
    from qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit import qasm3
    import math

    composite_circ_qreg = QuantumRegister(2)
    composite_circ = QuantumCircuit(composite_circ_qreg, name="composite_circ")
    composite_circ.h(0)
    composite_circ.x(1)
    composite_circ.cx(0, 1)
    composite_circ_gate = composite_circ.to_gate()

    qr = QuantumRegister(2, "qr")
    cr = ClassicalRegister(2, "cr")
    qc = QuantumCircuit(qr, cr)
    with qc.for_loop(range(4)) as i:
        qc.rx(i * math.pi / 4, 0)
        qc.cx(0, 1)
    qc.barrier()
    qc.append(composite_circ_gate, [0, 1])
    qc.measure([0, 1], [0, 1])

    print(qasm3.dumps(qc))
    ```

*   The [`QDrift`](qiskit.opflow.evolutions.QDrift "qiskit.opflow.evolutions.QDrift") class was reformulated as a synthesis method for [`PauliEvolutionGate`](qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate"), deriving from [`TrotterizationBase`](qiskit.opflow.evolutions.TrotterizationBase "qiskit.opflow.evolutions.TrotterizationBase").

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import PauliEvolutionGate
    from qiskit.synthesis import QDrift
    from qiskit.opflow import X, Y, Z

    qdrift = QDrift(reps=2)
    operator = (X ^ 3) + (Y ^ 3) + (Z ^ 3)
    time = 2.345  # evolution time

    evolution_gate = PauliEvolutionGate(operator, time, synthesis=qdrift)

    circuit = QuantumCircuit(3)
    circuit.append(evolution_gate, range(3))
    ```

*   QPY serialization is now capable of representing [`global_phase`](qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") attributes of a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object that are an `int`, [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") object, or [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") object. Previous versions of QPY would only accept a [`global_phase`](qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") that was a `float`.

    This requires the QPY format [Version 2](qpy#qpy-version-2) which was introduced in this release to represent the additional types.

*   A new [`find_bit()`](qiskit.circuit.QuantumCircuit#find_bit "qiskit.circuit.QuantumCircuit.find_bit") method has been added to the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class, which allows lookups of the index and registers of a provided [`Bit`](qiskit.circuit.Bit "qiskit.circuit.Bit") on the given circuit. The method returns a two-element `namedtuple` containing 0) the index of the `Bit` in either [`qubits`](qiskit.circuit.QuantumCircuit#qubits "qiskit.circuit.QuantumCircuit.qubits") (for a [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit")) or [`clbits`](qiskit.circuit.QuantumCircuit#clbits "qiskit.circuit.QuantumCircuit.clbits") (for a [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit")) and 1) a list of length-2 tuples containing each circuit [`Register`](qiskit.circuit.Register "qiskit.circuit.Register") which contains the `Bit`, and the index in that `Register` at which the `Bit` can be found.

    For example:

    ```python
    from qiskit.circuit import QuantumCircuit, QuantumRegister, Qubit

    reg1 = QuantumRegister(3, 'foo')
    qubit = Qubit()
    reg2 = QuantumRegister(2, 'bar')

    qc = QuantumCircuit(reg1, [qubit], reg2)

    print(qc.find_bit(reg1[2]))
    print(qc.find_bit(qubit))
    ```

    would generate:

    ```python
    BitLocations(index=2, registers=[(QuantumRegister(3, 'foo'), 2)])
    BitLocations(index=3, registers=[])
    ```

*   Three new [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") subclasses have been added to support control flow operations in dynamic circuits: [`WhileLoopOp`](qiskit.circuit.WhileLoopOp "qiskit.circuit.WhileLoopOp"), [`ForLoopOp`](qiskit.circuit.ForLoopOp "qiskit.circuit.ForLoopOp"), and [`IfElseOp`](qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp"). Additionally, two subclasses, [`BreakLoopOp`](qiskit.circuit.BreakLoopOp "qiskit.circuit.BreakLoopOp"), and [`ContinueLoopOp`](qiskit.circuit.ContinueLoopOp "qiskit.circuit.ContinueLoopOp"), have been added to support breaking from and continuing to the next iteration of a loop context, respectively.

    These can be created as stand-alone [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction")s, or appended to an existing [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instance via their respective methods, [`QuantumCircuit.while_loop()`](qiskit.circuit.QuantumCircuit#while_loop "qiskit.circuit.QuantumCircuit.while_loop"), [`for_loop()`](qiskit.circuit.QuantumCircuit#for_loop "qiskit.circuit.QuantumCircuit.for_loop"), [`if_test()`](qiskit.circuit.QuantumCircuit#if_test "qiskit.circuit.QuantumCircuit.if_test"), [`if_else()`](qiskit.circuit.QuantumCircuit#if_else "qiskit.circuit.QuantumCircuit.if_else"), [`break_loop()`](qiskit.circuit.QuantumCircuit#break_loop "qiskit.circuit.QuantumCircuit.break_loop"), and [`continue_loop()`](qiskit.circuit.QuantumCircuit#continue_loop "qiskit.circuit.QuantumCircuit.continue_loop").

*   Added the [`BaseReadoutMitigator`](qiskit.result.BaseReadoutMitigator "qiskit.result.BaseReadoutMitigator") abstract base class for implementing classical measurement error mitigators. These objects are intended for mitigation measurement errors in [`Counts`](qiskit.result.Counts "qiskit.result.Counts") objects returned from execution of circuits on backends with measurement errors.

    Readout mitigator classes have two main methods:

    *   [`expectation_value()`](qiskit.result.BaseReadoutMitigator#expectation_value "qiskit.result.BaseReadoutMitigator.expectation_value") which computes an mitigated expectation value and standard error of a diagonal operator from a noisy [`Counts`](qiskit.result.Counts "qiskit.result.Counts") object.
    *   [`quasi_probabilities()`](qiskit.result.BaseReadoutMitigator#quasi_probabilities "qiskit.result.BaseReadoutMitigator.quasi_probabilities") that computes an error mitigated [`QuasiDistribution`](qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution"), including standard error, from a noisy counts object.

    Note that currently the [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") module and the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class still use the legacy mitigators migrated from Qiskit Ignis in [`qiskit.utils.mitigation`](utils_mitigation#module-qiskit.utils.mitigation "qiskit.utils.mitigation"). It is planned to upgrade the module to use the new mitigator classes and deprecate the legacy mitgation code in a future release.

*   Added the [`LocalReadoutMitigator`](qiskit.result.LocalReadoutMitigator "qiskit.result.LocalReadoutMitigator") class for performing measurement readout error mitigation of local measurement errors. Local measuerment errors are those that are described by a tensor-product of single-qubit measurement errors.

    This class can be initialized with a list of $N$ single-qubit of measurement error assignment matrices or from a backend using the readout error information in the backend properties.

    Mitigation is implemented using local assignment-matrix inversion which has complexity of $O(2^N)$ for $N$-qubit mitigation of [`QuasiDistribution`](qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution") and expectation values.

*   Added the [`CorrelatedReadoutMitigator`](qiskit.result.CorrelatedReadoutMitigator "qiskit.result.CorrelatedReadoutMitigator") class for performing measurement readout error mitigation of correlated measurement errors. This class can be initialized with a single $2^N \times 2^N$ measurement error assignment matrix that descirbes the error probabilities. Mitigation is implemented via inversion of assigment matrix which has mitigation complexity of $O(4^N)$ of [`QuasiDistribution`](qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution") and expectation values.

*   Added a [`QuasiDistribution.stddev_upper_bound`](qiskit.result.QuasiDistribution#stddev_upper_bound "qiskit.result.QuasiDistribution.stddev_upper_bound") attribute and a kwarg to the constructor of the [`QuasiDistribution`](qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution") class, which is used for storing standard errors in quasi-probability estimates. This is used by [`BaseReadoutMitigator`](qiskit.result.BaseReadoutMitigator "qiskit.result.BaseReadoutMitigator") classes to store the standard error in mitigated quasi probabilities.

*   Added a [`shots()`](qiskit.result.Counts#shots "qiskit.result.Counts.shots") method to [`qiskit.result.Counts`](qiskit.result.Counts "qiskit.result.Counts") to return the sum of all outcomes in the counts.

*   When running the [`Grover`](qiskit.algorithms.Grover "qiskit.algorithms.Grover") algorithm class if the optimal power is known and only a single circuit is run, the [`AmplificationProblem.is_good_state`](qiskit.algorithms.AmplificationProblem#is_good_state "qiskit.algorithms.AmplificationProblem.is_good_state") callback function is no longer required to be set and the Grover search will return the most likely bitstring. Generally, if the optimal power of the Grover operator is not known, the [`Grover`](qiskit.algorithms.Grover "qiskit.algorithms.Grover") algorithm checks different powers (i.e. iterations) and applies the [`is_good_state`](qiskit.algorithms.AmplificationProblem#is_good_state "qiskit.algorithms.AmplificationProblem.is_good_state") function to check whether a good bitstring has been measured. For example, you are now able to run something like:

    ```python
    from qiskit.algorithms import Grover, AmplificationProblem
    from qiskit.providers.aer import AerSimulator
    from qiskit.quantum_info import Statevector

    # Fixed Grover power: 2.
    grover = Grover(iterations=2, quantum_instance=AerSimulator())

    # The ``is_good_state`` argument not required here since Grover search
    # will be run only once, with a power of 2.
    problem = AmplificationProblem(Statevector.from_label("111"))

    # Run Grover search and print the best measurement
    result = grover.amplify(problem)
    print(result.top_measurement)  # should print 111
    ```

*   Added method [`remove_cregs()`](qiskit.dagcircuit.DAGCircuit#remove_cregs "qiskit.dagcircuit.DAGCircuit.remove_cregs") to class [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") to support classical register removal.

*   Added method [`remove_clbits()`](qiskit.dagcircuit.DAGCircuit#remove_clbits "qiskit.dagcircuit.DAGCircuit.remove_clbits") to class [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") to support the removal of idle classical bits. Any classical registers referencing a removed bit are also removed.

*   Added a new method, [`replace_block_with_op()`](qiskit.dagcircuit.DAGCircuit#replace_block_with_op "qiskit.dagcircuit.DAGCircuit.replace_block_with_op"), to the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class. This method is used to replace a block of nodes in the DAG with a single operation. The canonical example is for the [`ConsolidateBlocks`](qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") pass which replaces blocks of nodes with equivalent `UnitaryGate` nodes.

*   Added a new analysis transpiler pass, [`Collect1qRuns`](qiskit.transpiler.passes.Collect1qRuns "qiskit.transpiler.passes.Collect1qRuns"), to the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module. This pass is used to find sequences of uninterrupted gates acting on a single qubit. It is similar to the [`Collect2qBlocks`](qiskit.transpiler.passes.Collect2qBlocks "qiskit.transpiler.passes.Collect2qBlocks") and [`CollectMultiQBlocks`](qiskit.transpiler.passes.CollectMultiQBlocks "qiskit.transpiler.passes.CollectMultiQBlocks") but optimized for single qubit runs instead of multiple qubit blocks.

*   Various transpilation internals now use new features in [retworkx](https://github.com/Qiskit/retworkx) 0.10 when operating on the internal circuit representation. This can often result in speedups in calls to [`transpile`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") of around 10-40%, with greater effects at higher optimization levels. See [#6302](https://github.com/Qiskit/qiskit-terra/pull/6302) for more details.

*   The [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass in [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") has a new kwarg in the constructor, `min_qubits`. When specified this can be set to an `int` value which is the minimum size `UnitaryGate` object to run the unitary synthesis on. If a `UnitaryGate` in a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") uses fewer qubits it will be skipped by that instance of the pass.

*   The `Eigensolver` and `MinimumEigensolver` interfaces now support the type `Dict[str, Optional[OperatorBase]]` for the `aux_operators` parameter in their respective `compute_eigenvalues()` and `compute_minimum_eigenvalue()` methods. In this case, the auxiliary eigenvalues are also stored in a dictionary under the same keys provided by the `aux_operators` dictionary. Keys that correspond to an operator that does not commute with the main operator are dropped.

*   The [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator"), [`GateDirection`](qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection"), and [`CheckGateDirection`](qiskit.transpiler.passes.CheckGateDirection "qiskit.transpiler.passes.CheckGateDirection") transpiler passes have a new `target` kwarg in their constructors, which can be used to set a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object as the target for the pass. If it is set it will be used instead of the `target_basis` (in the case of the [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") pass) or `coupling_map` (in the case of the [`GateDirection`](qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection") and [`CheckGateDirection`](qiskit.transpiler.passes.CheckGateDirection "qiskit.transpiler.passes.CheckGateDirection") passes) arguments.

*   Allow two transpiler stages in the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance"), one for parameterized circuits and a second one for bound circuits (i.e. no free parameters) only. If a quantum instance with passes for unbound and bound circuits is passed into a [`CircuitSampler`](qiskit.opflow.converters.CircuitSampler "qiskit.opflow.converters.CircuitSampler"), the sampler will attempt to apply the unbound pass once on the parameterized circuit, cache it, and only apply the bound pass for all future evaluations.

    This enables variational algorithms like the [`VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE") to run a custom pass manager for parameterized circuits once and, additionally, another the transpiler again with a different custom pass manager on the bound circuits in each iteration. Being able to run different pass managers is important because not all passes support parameterized circuits (for example [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") only works with bound circuit parameters).

    For example, this feature allows using the pulse-efficient CX decomposition in the VQE, as

    ```python
    from qiskit.algorithms import VQE
    from qiskit.opflow import Z
    from qiskit.circuit.library.standard_gates.equivalence_library import StandardEquivalenceLibrary as std_eqlib
    from qiskit.transpiler import PassManager, PassManagerConfig, CouplingMap
    from qiskit.transpiler.preset_passmanagers import level_1_pass_manager
    from qiskit.transpiler.passes import (
        Collect2qBlocks, ConsolidateBlocks, Optimize1qGatesDecomposition,
        RZXCalibrationBuilderNoEcho, UnrollCustomDefinitions, BasisTranslator
    )
    from qiskit.transpiler.passes.optimization.echo_rzx_weyl_decomposition import EchoRZXWeylDecomposition
    from qiskit.test.mock import FakeBelem
    from qiskit.utils import QuantumInstance

    # Replace by a real backend! If not ensure qiskit-aer is installed to simulate the backend
    backend = FakeBelem()

    # Build the pass manager for the parameterized circuit
    rzx_basis = ['rzx', 'rz', 'x', 'sx']
    coupling_map = CouplingMap(backend.configuration().coupling_map)
    config = PassManagerConfig(basis_gates=rzx_basis, coupling_map=coupling_map)
    pre = level_1_pass_manager(config)

    # Build a pass manager for the CX decomposition (works only on bound circuits)
    post = PassManager([
        # Consolidate consecutive two-qubit operations.
        Collect2qBlocks(),
        ConsolidateBlocks(basis_gates=['rz', 'sx', 'x', 'rxx']),

        # Rewrite circuit in terms of Weyl-decomposed echoed RZX gates.
        EchoRZXWeylDecomposition(backend),

        # Attach scaled CR pulse schedules to the RZX gates.
        RZXCalibrationBuilderNoEcho(backend),

        # Simplify single-qubit gates.
        UnrollCustomDefinitions(std_eqlib, rzx_basis),
        BasisTranslator(std_eqlib, rzx_basis),
        Optimize1qGatesDecomposition(rzx_basis),
    ])

    quantum_instance = QuantumInstance(backend, pass_manager=pre, bound_pass_manager=post)

    vqe = VQE(quantum_instance=quantum_instance)
    result = vqe.compute_minimum_eigenvalue(Z ^ Z)
    ```

*   Introduced a new unitary synthesis plugin interface which is used to enable using alternative synthesis techniques included in external packages seamlessly with the [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass. Users can select a plugin to use when calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") by setting the `unitary_synthesis_method` kwarg to the plugin’s name. A full list of installed plugins can be found using the [`qiskit.transpiler.passes.synthesis.plugin.unitary_synthesis_plugin_names()`](qiskit.transpiler.passes.synthesis.plugin.unitary_synthesis_plugin_names "qiskit.transpiler.passes.synthesis.plugin.unitary_synthesis_plugin_names") function. For example, if you installed a package that includes a synthesis plugin named `special_synth` you could use it with:

    ```python
    from qiskit import transpile

    transpile(qc, unitary_synthesis_method='special_synth', optimization_level=3)
    ```

    This will replace all uses of the [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") with the method included in the external package that exports the `special_synth` plugin.

    The plugin interface is built around setuptools [entry points](https://setuptools.readthedocs.io/en/latest/userguide/entry_point.html) which enable packages external to Qiskit to advertise they include a synthesis plugin. For details on writing a new plugin refer to the [`qiskit.transpiler.passes.synthesis.plugin`](transpiler_synthesis_plugins#module-qiskit.transpiler.passes.synthesis.plugin "qiskit.transpiler.passes.synthesis.plugin") module documentation.

*   Added a new transpiler pass, [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout"). This pass models the layout allocation problem as a subgraph isomorphism problem and uses the [VF2 algorithm](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.101.5342\&rep=rep1\&type=pdf) implementation in [rustworkx](https://qiskit.org/documentation/rustworkx/stubs/rustworkx.vf2_mapping.html) to find a perfect layout (a layout which would not require additional routing) if one exists. The functionality exposed by this new pass is very similar to exisiting [`CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") but [`VF2Layout`](qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") is significantly faster.

<span id="release-notes-0-19-0-known-issues" />

<span id="id181" />

#### Known Issues

*   The `"ket"` convention in the `"latex"` drawer of [`Statevector.draw()`](qiskit.quantum_info.Statevector#draw "qiskit.quantum_info.Statevector.draw") is only valid for states comprising purely of qubits. If you are using states with some spaces of dimension greater than two, you should either pass `convention="vector"`, or use a different drawer.

*   The OpenQASM 3 export capabilities are in a beta state, and some features of Qiskit Terra’s [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") are not yet supported. In particular, you may see errors if you try to export custom subroutines with classical parameters, and there is no provision yet for exporting pulse-calibrated operations into [OpenPulse](https://openqasm.com/language/openpulse.html).

*   When running the [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") in isolation with the `target` argument set to a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object, where some single-qubit gates can only apply to non-overlapping sets of qubits, the output circuit might incorrectly include operations on a qubit that are not allowed by the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target"). For example, if you ran:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter
    from qiskit.circuit.library import UGate, RZGate, XGate, SXGate, CXGate
    from qiskit.circuit.equivalence_library import SessionEquivalenceLibrary as sel

    from qiskit.transpiler import PassManager, Target, InstructionProperties
    from qiskit.transpiler.passes import BasisTranslator

    gmap = Target()

    # U gate in qubit 0.
    theta = Parameter('theta')
    phi = Parameter('phi')
    lam = Parameter('lambda')
    u_props = {
        (0,): InstructionProperties(duration=5.23e-8, error=0.00038115),
    }
    gmap.add_instruction(UGate(theta, phi, lam), u_props)

    # Rz gate in qubit 1.
    phi = Parameter("phi")
    rz_props = {
        (1,): InstructionProperties(duration=0.0, error=0),
    }
    gmap.add_instruction(RZGate(phi), rz_props)

    # X gate in qubit 1.
    x_props = {
        (1,): InstructionProperties(
            duration=3.5555555555555554e-08, error=0.00020056469709026198
        ),
    }
    gmap.add_instruction(XGate(), x_props)

    # SX gate in qubit 1.
    sx_props = {
        (1,): InstructionProperties(
            duration=3.5555555555555554e-08, error=0.00020056469709026198
        ),
    }
    gmap.add_instruction(SXGate(), sx_props)

    cx_props = {
        (0, 1): InstructionProperties(duration=5.23e-7, error=0.00098115),
        (1, 0): InstructionProperties(duration=4.52e-7, error=0.00132115),
    }
    gmap.add_instruction(CXGate(), cx_props)

    bt_pass = BasisTranslator(sel, target_basis=None, target=gmap)

    qc = QuantumCircuit(2)
    qc.iswap(0, 1)
    output = bt_pass(qc)
    ```

    `output` will have [`RZGate`](qiskit.circuit.library.RZGate "qiskit.circuit.library.RZGate") and [`SXGate`](qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate") on qubit 0, even though this is forbidden. To correct this you can normally run the basis translator a second time (i.e. `output = bt_pass(output)` in the above example) to correct this. This should not affect the output of running the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function and is only an issue if you run the pass by itself.

<span id="release-notes-0-19-0-upgrade-notes" />

<span id="id182" />

#### Upgrade Notes

*   Starting with this version, `from qiskit import *` will not import submodules, but only a selected list of objects. This might break existing code using `from qiskit import *` and referring to objects that are not part of the current namespace. As a reminder, `import *` is considered bad practice and it should not be used in production code. Qiskit sets `__all__` in `qiskit/__init__.py` as a way to mitigate the effects of said bad practice. If your code raises `name '<something>' is not defined`, add `from qiskit import <something>` and try again.

*   The preset pass managers for optimization levels 0, 1, 2, and 3 which are generated by [`level_0_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_0_pass_manager "qiskit.transpiler.preset_passmanagers.level_0_pass_manager"), [`level_1_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`level_2_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`level_3_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") respectively will no longer unconditionally run the [`TimeUnitConversion`](qiskit.transpiler.passes.TimeUnitConversion "qiskit.transpiler.passes.TimeUnitConversion"). Previously, the preset pass managers would always run this pass regardless of the inputs to the transpiler and the circuit. Now this pass will only be run if a `scheduling_method` parameter is set or the circuit contains a [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") instruction and the `instruction_durations` parameter is set. This change was made in the interest of runtime performance as in some cases running [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") on circuits with a large number of gates and no delays, timing, or scheduling being used the [`TimeUnitConversion`](qiskit.transpiler.passes.TimeUnitConversion "qiskit.transpiler.passes.TimeUnitConversion") could be the largest bottleneck in the transpilation.

*   The default method for `BIPMapping` is now `balanced` rather than `depth`. This new objective generally achieves a better result, as it factors in both the circuit depth and the gate error.

*   The `sort_parameters_by_name` of the [`VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE") class has been removed, following its deprecation in Qiskit Terra 0.18. There is no alternative provided, as the new ordering of parameters is the more natural sort order.

*   The circuit drawers [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") and [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") with the `latex` option will now save their images in a format determined the file extension (if a file name is provided). Previously, they would always save in PNG format. They now raise `ValueError` if the image format is not known. This was done to make it easier to save the image in different formats.

*   The core dependency `retworkx` had its version requirement bumped to 0.10.1, up from 0.9. This enables several performance improvements across different transpilation passes.

*   The previously deprecated `condition` kwarg, which was deprecated as part of the 0.15.0 release, has been removed from [`DAGCircuit.apply_operation_back()`](qiskit.dagcircuit.DAGCircuit#apply_operation_back "qiskit.dagcircuit.DAGCircuit.apply_operation_back") and [`DAGCircuit.apply_operation_front()`](qiskit.dagcircuit.DAGCircuit#apply_operation_front "qiskit.dagcircuit.DAGCircuit.apply_operation_front"). Instead set the `condition` attribute on the [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") instances being added to the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") using [`Instruction.c_if()`](qiskit.circuit.Instruction#c_if "qiskit.circuit.Instruction.c_if").

*   The `DAGCircuit.extend_back()` method has been removed. It was originally deprecated in the 0.13.0 release. Instead you can use the [`DAGCircuit.compose()`](qiskit.dagcircuit.DAGCircuit#compose "qiskit.dagcircuit.DAGCircuit.compose") method which is more general and provides the same functionality.

*   The `DAGCircuit.compose_back()` method has been removed. It was originally deprecated in the 0.13.0 release. Instead you can use the [`DAGCircuit.compose()`](qiskit.dagcircuit.DAGCircuit#compose "qiskit.dagcircuit.DAGCircuit.compose") method which is more general and provides the same functionality.

*   The `edge_map` kwarg of the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") method [`compose()`](qiskit.dagcircuit.DAGCircuit#compose "qiskit.dagcircuit.DAGCircuit.compose") has been removed. It was originally deprecated in the 0.14.0 release. The method takes a `qubits` and `clbits` kwargs to specify the positional order of bits to compose onto instead of using a dictionary mapping that `edge_map` previously provided.

*   The `DAGCircuit.twoQ_gates()` method has been removed. It was originally deprecated in the 0.13.0 release. Instead, [`DAGCircuit.two_qubit_ops()`](qiskit.dagcircuit.DAGCircuit#two_qubit_ops "qiskit.dagcircuit.DAGCircuit.two_qubit_ops") should be used.

*   The `DAGCircuit.threeQ_or_more_gates()` method has been removed. It was originally deprecated in the 0.13.0 release. Instead, [`DAGCircuit.multi_qubit_ops()`](qiskit.dagcircuit.DAGCircuit#multi_qubit_ops "qiskit.dagcircuit.DAGCircuit.multi_qubit_ops") method should be used.

*   Named access for the first positional argument for the constructor of the [`SingleQubitUnitary`](qiskit.extensions.SingleQubitUnitary "qiskit.extensions.SingleQubitUnitary") class with `u` has been removed. It was originally deprecated in the 0.14.0 release. Instead, the first positional argument can be set using the name `unitary_matrix` (or just set it positionally instead of by name).

*   Named access for the first positional argument for the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`squ`](qiskit.circuit.QuantumCircuit#squ "qiskit.circuit.QuantumCircuit.squ") with `u` has been removed. It was originally deprecated in the 0.14.0 release. Instead the first positional argument can be set using the name `unitary_matrix` (or just set it positionally instead of by name).

*   The unused `proc` and `nested_scope` kwargs for the `qasm()` method of the QASM node classes in the `qiskit.qasm.node` module have been removed. They were originally deprecated in the 0.15.0 release.

*   The unused `proc` and `nested_scope` kwargs for the `latex()` method of the QASM node classes in the `qiskit.qasm.node` module have been removed. They were originally deprecated in the 0.15.0 release.

*   The unused `proc` and `nested_scope` kwargs for the `real()` method of the QASM node classes in the `qiskit.qasm.node` module have been removed. They were originally deprecated in the 0.15.0 release.

*   The output of [`Statevector.draw()`](qiskit.quantum_info.Statevector#draw "qiskit.quantum_info.Statevector.draw") when using `"latex"` output is now the new `"ket"` convention if plotting a state comprised purely of qubits. This was changed to make reading the output clearer, especially in educational contexts, because it shows the ket labels, and only displays the nonzero elements.

*   When running [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute") with a [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") backend the default values for the kwargs `shots`, `max_credits`, `meas_level`, `meas_return` and `memory_slot_size` will now be whatever the set default is on the target backend’s [`options`](qiskit.providers.BackendV1#options "qiskit.providers.BackendV1.options") attribute. Previously these defaults were set to match the default values when calling [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute") with a legacy `BaseBackend` backend. For example:

    ```python
    from qiskit.test.mock import FakeMumbai
    from qiskit import QuantumCircuit, execute

    circuit = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    backend = FakeMumbai()
    backend.set_options(shots=4096)
    execute(qc, backend)
    ```

    will now run with `4096` shots. While in previous releases it would run with `1024`.

*   The minimum supported version of Matplotlib has been raised from 2.1.0 to 3.3.0. You will now need to have Matplotlib 3.3.0 installed if you’re using Matplotlib-based visualization functions such as the `'mpl'` backend for the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function or the [`plot_bloch_vector()`](qiskit.visualization.plot_bloch_vector "qiskit.visualization.plot_bloch_vector") function. This was done for two reasons, the first is because recent versions of Matplotlib have deprecated the use of APIs around 3D visualizations that were compatible with older releases and second installing older versions of Matplotlib was becoming increasingly difficult as matplotlib’s upstream dependencies have caused incompatiblities that made testing moving forward more difficult.

*   The internal use of the random number generator in [`random_circuit()`](circuit#qiskit.circuit.random.random_circuit "qiskit.circuit.random.random_circuit") was adjusted, which will change the output from previous versions, even with a fixed seed. This was done to greatly improve the runtime scaling with the number of qubits being used. If you were depending on an identical output from a previous version it is recommended that you use `qpy_serialization.dump()` to save the random circuit generated with a previous version and instead of re-generating it with the new release, and instead just use `qpy_serialization.load()` to load that saved circuit.

*   The use of `*` (`__mul__`) for the [`dot()`](qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot") method and `@` (`__matmul__`) for the [`compose()`](qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose") method of `BaseOperator` (which is the parent of all the operator classes in [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") including classes like [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") and [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli")) is no longer supported. The use of these operators were previously deprecated in 0.17.0 release. Instead you should use the [`dot()`](qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot") and [`compose()`](qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose") methods directly, or the `&` operator (`__and__`) can be used for [`compose()`](qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose"). For example, if you were previously using the operator like:

    ```python
    from qiskit.quantum_info import random_hermitian

    op_a = random_hermitian(4)
    op_b = random_hermitian(4)

    new_op = op_a @ op_b
    ```

    this should be changed to be:

    ```python
    from qiskit.quantum_info import random_hermitian

    op_a = random_hermitian(4)
    op_b = random_hermitian(4)
    new_op = op_a.compose(op_b)
    ```

    or:

    ```python
    new_op = op_a & op_b
    ```

*   Various methods of assigning parameters to operands of pulse program instructions have been removed, having been deprecated in Qiskit Terra 0.17. These include:

    *   the `assign()` method of `pulse.Instruction`.
    *   the `assign()` method of `Channel`, which is the base of [`AcquireChannel`](qiskit.pulse.channels.AcquireChannel "qiskit.pulse.channels.AcquireChannel"), [`SnapshotChannel`](qiskit.pulse.channels.SnapshotChannel "qiskit.pulse.channels.SnapshotChannel"), [`MemorySlot`](qiskit.pulse.channels.MemorySlot "qiskit.pulse.channels.MemorySlot") and [`RegisterSlot`](qiskit.pulse.channels.RegisterSlot "qiskit.pulse.channels.RegisterSlot").
    *   the `assign()` and `assign_parameters()` methods of `ParametricPulse`, which is the base of `pulse.Gaussian`, `pulse.GaussianSquare`, `pulse.Drag` and `pulse.Constant`.

    These parameters should be assigned from the pulse program ([`pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") and [`pulse.ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock")) rather than operands of the pulse program instruction.

*   The `flatten()` method of `pulse.Instruction` and [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") has been removed and no longer exists as per the deprecation notice from Qiskit Terra 0.17. This transformation is defined as a standalone function in `qiskit.pulse.transforms.canonicalization.flatten()`.

*   `qiskit.pulse.interfaces.ScheduleComponent` has been removed and no longer exists as per the deprecation notice from Qiskit Terra 0.15. No alternative class will be provided.

*   Legacy pulse drawer arguments have been removed from `pulse.Waveform.draw()`, [`Schedule.draw()`](qiskit.pulse.Schedule#draw "qiskit.pulse.Schedule.draw") and [`ScheduleBlock.draw()`](qiskit.pulse.ScheduleBlock#draw "qiskit.pulse.ScheduleBlock.draw") and no longer exist as per the deprecation notice from Qiskit Terra 0.16. Now these draw methods support only V2 pulse drawer arguments. See method documentations for details.

*   The `qiskit.pulse.reschedule` module has been removed and this import path no longer exist as per the deprecation notice from Qiskit Terra 0.14. Use [`qiskit.pulse.transforms`](pulse#module-qiskit.pulse.transforms "qiskit.pulse.transforms") instead.

*   A protected method `Schedule._children()` has been removed and replaced by a protected instance variable as per the deprecation notice from Qiskit Terra 0.17. This is now provided as a public attribute [`Schedule.children`](qiskit.pulse.Schedule#children "qiskit.pulse.Schedule.children").

*   Timeslot relevant methods and properties have been removed and no longer exist in [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") as per the deprecation notice from Qiskit Terra 0.17. Since this representation doesn’t have notion of instruction time `t0`, the timeslot information will be available after it is transformed to a [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule"). Corresponding attributes have been provided after this conversion, but they are no longer supported. The following attributes are removed:

    *   `timeslots`
    *   `start_time`
    *   `stop_time`
    *   `ch_start_time`
    *   `ch_stop_time`
    *   `shift`
    *   `insert`

*   Alignment pulse schedule transforms have been removed and no longer exist as per the deprecation notice from Qiskit Terra 0.17. These transforms are integrated and implemented in the `AlignmentKind` context of the schedule block. The following explicit transform functions are removed:

    *   `qiskit.pulse.transforms.align_equispaced`
    *   `qiskit.pulse.transforms.align_func`
    *   `qiskit.pulse.transforms.align_left`
    *   `qiskit.pulse.transforms.align_right`
    *   `qiskit.pulse.transforms.align_sequential`

*   Redundant pulse builder commands have been removed and no longer exist as per the deprecation notice from Qiskit Terra 0.17. `pulse.builder.call_schedule` and `pulse.builder.call_circuit` have been integrated into [`pulse.builder.call()`](pulse#qiskit.pulse.builder.call "qiskit.pulse.builder.call").

*   An internal filter override that caused all Qiskit deprecation warnings to be displayed has been removed. This means that the behaviour will now revert to the standard Python behaviour for deprecations; you should only see a `DeprecationWarning` if it was triggered by code in the main script file, interpreter session or Jupyter notebook. The user will no longer be blamed with a warning if internal Qiskit functions call deprecated behaviour. If you write libraries, you should occasionally run with the default warning filters disabled, or have tests which always run with them disabled. See the [Python documentation on warnings](https://docs.python.org/3/library/warnings.html), and in particular the [section on testing for deprecations](https://docs.python.org/3/library/warnings.html#updating-code-for-new-versions-of-dependencies) for more information on how to do this.

*   Certain warnings used to be only issued once, even if triggered from multiple places. This behaviour has been removed, so it is possible that if you call deprecated functions, you may see more warnings than you did before. You should change any deprecated function calls to the suggested versions, because the deprecated forms will be removed in future Qiskit releases.

*   The deprecated `qiskit.schemas` module and the `qiskit.validation` module which build jsonschema validator from the schemas have been removed. This was deprecated in the 0.17.0 release and has been replaced with a [dedicated repository for the IBM Quantum API payload schemas](https://github.com/Qiskit/ibm-quantum-schemas).

    If you were relying on the schema files previously packaged in `qiskit.schemas` or the validators built on them you should use that repository and create validators from the schema files it contains.

*   The functions `qiskit.qobj.validate_qobj_against_schema` and `qiskit.qobj.common.validator` along with the `validate` kwarg of the methods [`QasmQobj.to_dict()`](qiskit.qobj.QasmQobj#to_dict "qiskit.qobj.QasmQobj.to_dict"), [`PulseQobj.to_dict()`](qiskit.qobj.PulseQobj#to_dict "qiskit.qobj.PulseQobj.to_dict"), and `Qobj.to_dict()` have been removed. These were deprecated in the 0.17.0 release. If you were using these function you will have to manually build jsonschema validation functions for `Qobj` objects using the jsonschema files from [the dedicated repository for the IBM Quantum API payload schemas](https://github.com/Qiskit/ibm-quantum-schemas).

*   The `fastjsonschema` and `jsonschema` packages are no longer in the requirements list for qiskit-terra. The internal use of jsonschema has been removed and they are no longer required to use qiskit-terra.

*   The exception raised by the [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") function when invalid parameters are passed in for constructing a [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") have changed from a `SchemaValidationError` to a [`QiskitError`](exceptions#qiskit.exceptions.QiskitError "qiskit.exceptions.QiskitError"). This was necessary because the `SchemaValidationError` class was removed along with the rest of the deprecated `qiskit.schemas` and `qiskit.validation`. This also makes it more consistent with other error conditions from [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") which were already raising a [`QiskitError`](exceptions#qiskit.exceptions.QiskitError "qiskit.exceptions.QiskitError").

*   The default routing pass and layout pass for transpiler optimization level 3 has changed to use [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") and [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") respectively. This was done to improve the quality of the output result, as using the sabre passes produces better results than using [`StochasticSwap`](qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") and [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout"), which were used as the defaults in prior releases. This change will improve the quality of the results when running [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute") functions with the `optimization_level` kwarg set to `3`. While this is generally an improvement, if you need to retain the previous behavior for any reason you can do this by explicitly setting the `routing_method="stochastic"` and `layout_method="dense"` when calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") with `optimization_level=3`.

*   The return type of [`pauli_basis()`](qiskit.quantum_info.pauli_basis "qiskit.quantum_info.pauli_basis") will change from `PauliTable` to [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") in a future release of Qiskit Terra. To immediately swap to the new behaviour, pass the keyword argument `pauli_list=True`.

*   The [`name`](qiskit.extensions.SingleQubitUnitary#name "qiskit.extensions.SingleQubitUnitary.name") attribute of the [`SingleQubitUnitary`](qiskit.extensions.SingleQubitUnitary "qiskit.extensions.SingleQubitUnitary") gate class has been changed from `unitary` to `squ`. This was necessary to avoid a conflict with the `UnitaryGate` class’s name which was also `unitary` since the 2 gates are not the same and don’t have the same implementation (and can’t be used interchangeably).

*   The minimum version of [Symengine](https://pypi.org/project/symengine) required for installing has been increased to 0.8.0. This was necessary to fix some issues with the handling of `numpy.float16` and `numpy.float32` values when running [`bind()`](qiskit.circuit.ParameterExpression#bind "qiskit.circuit.ParameterExpression.bind") to bind parameters in a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression").

*   A new dependency [stevedore](https://pypi.org/project/stevedore/) has been added to the requirements list. This is required by qiskit-terra as it is used to build the unitary synthesis plugin interface.

<span id="release-notes-0-19-0-deprecation-notes" />

<span id="id184" />

#### Deprecation Notes

*   The `gate` attribute and initialization parameter of [`qiskit.transpiler.passes.Decompose`](qiskit.transpiler.passes.Decompose "qiskit.transpiler.passes.Decompose") is deprecated, and will be removed in a future release. Instead of this single gate, you should pass a list of gate names to the new parameter `gates_to_decompose`. This was done as the new form allows you to select more than one gate as a decomposition target, which is more flexible, and does not need to re-run the pass several times to decompose a set of gates.

*   There has been a significant transpiler pass reorganization regarding calibrations. The import paths:

    ```python
    from qiskit.transpiler.passes.scheduling.calibration_creators import RZXCalibrationBuilder
    from qiskit.transpiler.passes.scheduling.calibration_creators import RZXCalibrationBuilderNoEcho
    ```

    are deprecated, and will be removed in a future release. The import path:

    ```python
    from qiskit.transpiler.passes.scheduling.rzx_templates import rzx_templates
    ```

    is also deprecated, and will be removed in a future release. You should use the new import paths:

    ```python
    from qiskit.transpiler.passes import RZXCalibrationBuilder
    from qiskit.transpiler.passes import RZXCalibrationBuilderNoEcho
    from qiskit.transpiler.passes.calibration.rzx_templates import rzx_templates
    ```

*   The [`DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") class is being deprecated as a standalone class and will be used in the future only as the parent class for [`DAGOpNode`](qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode"), [`DAGInNode`](qiskit.dagcircuit.DAGInNode "qiskit.dagcircuit.DAGInNode"), and [`DAGOutNode`](qiskit.dagcircuit.DAGOutNode "qiskit.dagcircuit.DAGOutNode"). As part of this deprecation, the following kwargs and associated attributes in [`DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") are also being deprecated: `type`, `op`, and `wire`.

*   For the constructor of the [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") passing a backend either as the first positional argument or with the named `backend` kwarg is deprecated and will no longer work in a future release. Instead a [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") should be passed directly to the `instruction_schedule_map` kwarg and a list of channel name lists for each qubit should be passed directly to `qubit_channel_mapping`. For example, if you were calling the pass like:

    ```python
    from qiskit.transpiler.passes import RZXCalibrationBuilder
    from qiskit.test.mock import FakeMumbai

    backend = FakeMumbai()
    cal_pass = RZXCalibrationBuilder(backend)
    ```

    instead you should call it like:

    ```python
    from qiskit.transpiler.passes import RZXCalibrationBuilder
    from qiskit.test.mock import FakeMumbai

    backend = FakeMumbai()
    inst_map = backend.defaults().instruction_schedule_map
    channel_map = self.backend.configuration().qubit_channel_mapping
    cal_pass = RZXCalibrationBuilder(
        instruction_schedule_map=inst_map,
        qubit_channel_mapping=channel_map,
    )
    ```

    This change is necessary because as a general rule backend objects are not pickle serializable and it would break when it was used with multiple processes inside of [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") when compiling multiple circuits at once.

*   The `label` property of class [`MCMT`](qiskit.circuit.library.MCMT "qiskit.circuit.library.MCMT") and subclass [`MCMTVChain`](qiskit.circuit.library.MCMTVChain "qiskit.circuit.library.MCMTVChain") has been deprecated and will be removed in a future release. Consequently, the `label` kwarg on the constructor for both classes is also deprecated, along with the `label` kwarg of method [`MCMT.control()`](qiskit.circuit.library.MCMT#control "qiskit.circuit.library.MCMT.control"). Currently, the `label` property is used to name the controlled target when it is comprised of more than one target qubit, however, this was never intended to be user-specifiable, and can result in an incorrect MCMT gate if the name of a well-known operation is used. After deprecation, the `label` property will no longer be user-specifiable. However, you can get the generated name of the controlled target via

    ```python
    MCMT.data[0][0].base_gate.name
    ```

*   The `subgraph()` method of the [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") class is deprecated and will be removed in a future release. Instead the [`reduce()`](qiskit.transpiler.CouplingMap#reduce "qiskit.transpiler.CouplingMap.reduce") method should be used, which does the same thing except it preserves the node list order for the output [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") (while `subgraph()` did not preserve list order).

*   Creating an instance of [`InstructionSet`](qiskit.circuit.InstructionSet "qiskit.circuit.InstructionSet") with the `circuit_cregs` keyword argument is deprecated. In general, these classes never need to be constructed by users (but are used internally), but should you need to, you should pass a callable as the `resource_requester` keyword argument. For example:

    ```python
    from qiskit.circuit import Clbit, ClassicalRegister, InstructionSet
    from qiskit.circuit.exceptions import CircuitError

    def my_requester(bits, registers):
        bits_set = set(bits)
        bits_flat = tuple(bits)
        registers_set = set(registers)

        def requester(specifier):
            if isinstance(specifer, Clbit) and specifier in bits_set:
                return specifier
            if isinstance(specifer, ClassicalRegster) and specifier in register_set:
                return specifier
            if isinstance(specifier, int) and 0 <= specifier < len(bits_flat):
                return bits_flat[specifier]
            raise CircuitError(f"Unknown resource: {specifier}")

        return requester

    my_bits = [Clbit() for _ in [None]*5]
    my_registers = [ClassicalRegister(n) for n in range(3)]

    InstructionSet(resource_requester=my_requester(my_bits, my_registers))
    ```

*   The use of the measurement mitigation classes `qiskit.ignis.mitigation.CompleteMeasFitter` and `qiskit.ignis.mitigation.TensoredMeasFitter` from `qiskit-ignis` as values for the `measurement_error_mitigation_cls` kwarg of the constructor for the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class is deprecated and will be removed in a future release. Instead the equivalent classes from [`qiskit.utils.mitigation`](utils_mitigation#module-qiskit.utils.mitigation "qiskit.utils.mitigation"), [`CompleteMeasFitter`](qiskit.utils.mitigation.CompleteMeasFitter "qiskit.utils.mitigation.CompleteMeasFitter") and [`TensoredMeasFitter`](qiskit.utils.mitigation.TensoredMeasFitter "qiskit.utils.mitigation.TensoredMeasFitter") should be used. This was necessary as the `qiskit-ignis` project is now deprecated and will no longer be supported in the near future. It’s worth noting that unlike the equivalent classes from `qiskit-ignis` the versions from [`qiskit.utils.mitigation`](utils_mitigation#module-qiskit.utils.mitigation "qiskit.utils.mitigation") are supported only in their use with [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") (i.e. as a class not an instance with the `measurement_error_mitigation_cls` kwarg) and not intended for standalone use.

*   The `Optimizer.optimize()` method for all the optimizers ([`Optimizer`](qiskit.algorithms.optimizers.Optimizer "qiskit.algorithms.optimizers.Optimizer") and derived classes) is now deprecated and will be removed in a future release. Instead, the [`Optimizer.minimize()`](qiskit.algorithms.optimizers.Optimizer#minimize "qiskit.algorithms.optimizers.Optimizer.minimize") method should be used which mimics the signature of SciPy’s `minimize()` function.

    To replace the current optimize call with minimize you can replace

    ```python
    xopt, fopt, nfev = optimizer.optimize(
        num_vars,
        objective_function,
        gradient_function,
        variable_bounds,
        initial_point,
    )
    ```

    with

    ```python
    result = optimizer.minimize(
        fun=objective_function,
        x0=initial_point,
        jac=gradient_function,
        bounds=variable_bounds,
    )
    xopt, fopt, nfev = result.x, result.fun, result.nfev
    ```

*   Importing the `qiskit.util` module will now issue a `DeprecationWarning`. Users should instead import all the same functionality from [`qiskit.utils`](utils#module-qiskit.utils "qiskit.utils"). The `util` module has been deprecated since Terra 0.17, but previously did not issue a warning. It will be removed in Terra 0.20.

*   The property `table` is deprecated, and will be removed in a future release. This is because [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") has been updated to internally use `PauliList` instead of `PauliTable`. This is in order to significantly improve performance. You should now access the [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") data by using the [`SparsePauliOp.paulis`](qiskit.quantum_info.SparsePauliOp#paulis "qiskit.quantum_info.SparsePauliOp.paulis") attribute.

<span id="release-notes-0-19-0-bug-fixes" />

<span id="id185" />

#### Bug Fixes

*   Fixed a bug where many layout methods would ignore 3-or-more qubit gates, resulting in unexpected layout-allocation decisions. The transpiler pass [`Unroll3qOrMore`](qiskit.transpiler.passes.Unroll3qOrMore "qiskit.transpiler.passes.Unroll3qOrMore") is now being executed before the layout pass in all the preset pass managers when [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") is called. Fixed [#7156](https://github.com/Qiskit/qiskit-terra/issues/7156).

*   Disassembled circuits now inherit calibrations from assembled [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") and experiments. Fixes [#5348](https://github.com/Qiskit/qiskit-terra/issues/5348).

*   Fixed setting the `ansatz` or `optimizer` attributes of a [`VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE") instance to `None` resulting in a buggy behavior. See [#7093](https://github.com/Qiskit/qiskit-terra/issues/7093) for details.

*   Fixed addition of [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList")s with `qargs`. The method used to raise a runtime error if the operands had different numbers of qubits.

*   Fixed an issue causing an error when trying to compute a gradient with the [`CircuitGradient`](qiskit.opflow.gradients.CircuitGradient "qiskit.opflow.gradients.CircuitGradient") class for a gate that was not a supported gate. This bugfix transpiles a given gate to the set of supported gates for a requested gradient method. Fixes [#6918](https://github.com/Qiskit/qiskit-terra/issues/6918).

*   Removed calibration results when using error mitigation with the [`execute()`](qiskit.utils.QuantumInstance#execute "qiskit.utils.QuantumInstance.execute") method of [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance"). Fixes [#7129](https://github.com/Qiskit/qiskit-terra/issues/7129).

*   Fixed a deprecation warning emitted when running [`QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") or [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") with Sympy 1.9 installed, mentioning the Sympy function `expr_free_symbols()`. The circuit drawers previously made use of this method when finding instances of symbolic constants.

*   Fixed an issue where the `ax` kwarg and the `figwidth` option in the `style` kwarg for the `mpl` circuit drawer did not scale properly. Users can now pass an `ax` from a Matplotlib subplot to the `mpl` circuit drawer and the circuit will be drawn within the boundaries of that subplot. Alternatively, users can set the `figwidth` in inches in the `style` dict kwarg and the drawing will scale to the width in inches that was set. Fixed [#6367](https://github.com/Qiskit/qiskit-terra/issues/6367).

*   Fixed an issue with the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). When displaying a `measure` instruction targeted on a classical bit instead of a register, using the `latex` drawer option, the drawer would fail.

*   Fixed an issue with the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). With any of the 3 drawer options, `mpl`, `latex`, or `text`, if a gate with a classical condition was encountered that was conditioned on a classical bit without a register, the drawer would fail.

*   Fixed an issue with the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). With any of the 3 drawer options, `mpl`, `latex`, or `text`, if a gate with a classical condition was conditioned on the same classical bit as a `measure` and the bit that the measure targeted did not have a register, the drawer would fail.

*   [`C3SXGate`](qiskit.circuit.library.C3SXGate "qiskit.circuit.library.C3SXGate") now has a correct decomposition and matrix representation. Previously it was equivalent to `SdgXGate().control(3)`, rather than the intended `SXGate().control(3)`.

*   The member `name` of `qiskit.test.mock.utils.ConfigurableFakeBackend` has been changed to `backend_name`. This was done to avoid a conflict with the [`name()`](qiskit.providers.BackendV1#name "qiskit.providers.BackendV1.name") method inherited from the parent abstract [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") class. This makes `ConfigurableFakeBackend` compatible with anything expecting a [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") object. However, if you were using the `name` attribute directly before you will now need to either call it as a method or access the `backend_name` attribute instead.

*   Fixed an issue where calling [`QuantumCircuit.decompose()`](qiskit.circuit.QuantumCircuit#decompose "qiskit.circuit.QuantumCircuit.decompose") on a circuit containing an [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") whose [`definition`](qiskit.circuit.Instruction#definition "qiskit.circuit.Instruction.definition") attribute was empty would leave the instruction in place, instead of decomposing it into zero operations. For example, with a circuit:

    ```python
    from qiskit.circuit import QuantumCircuit
    empty = QuantumCircuit(1, name="decompose me!")
    circuit = QuantumCircuit(1)
    circuit.append(empty.to_gate(), [0])
    ```

    Previously, calling `circuit.decompose()` would not change the circuit. Now, the decomposition will correct decompose `empty` into zero instructions. See [#6997](https://github.com/Qiskit/qiskit-terra/pull/6997) for more.

*   Fixed an issue with the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). When displaying a `measure` instruction containing a classical `condition` using the `mpl` or `latex` options, the `condition` information would sometimes overwrite the `measure` display.

*   Fixed an issue with the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). The `mpl` drawer used hex notation to display the `condition` value, whereas the `text` and `latex` drawers used decimal notation. Now all three drawers use hex notation.

*   Fixed a bug in the Hoare optimizer transpilation pass where it could attempt to remove a gate twice if it could be separately combined with both its predecessor and its successor to form the identity. Refer to [#7271](https://github.com/Qiskit/qiskit-terra/issues/7271) for more details.

*   Making an instruction conditional with the standard [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if "qiskit.circuit.InstructionSet.c_if") method with integer indices is now consistent with the numbering scheme used by the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") the instructions are part of. Previously, if there were two [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister")s with overlapping [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit")s, the numbering would be incorrect. See [#7246](https://github.com/Qiskit/qiskit-terra/issues/7246) for more detail.

*   Making an instruction conditional with the standard [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if "qiskit.circuit.InstructionSet.c_if") method will now succeed, even if there are no [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister")s in the circuit. See [#7250](https://github.com/Qiskit/qiskit-terra/issues/7250) for more detail.

*   Making an instruction conditional with the standard [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if "qiskit.circuit.InstructionSet.c_if") method when using a [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") that is contained in a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") of size one will now correctly create a condition on the bit, not the register. See [#7255](https://github.com/Qiskit/qiskit-terra/pull/7255) for more detail.

*   Trying to make an instruction conditional with the standard [`InstructionSet.c_if()`](qiskit.circuit.InstructionSet#c_if "qiskit.circuit.InstructionSet.c_if") method will now correctly raise an error if the classical resource is not present in the circuit. See [#7255](https://github.com/Qiskit/qiskit-terra/pull/7255) for more detail.

*   Fixed a compatibility issue with Matplotlib 3.5, where the Bloch sphere would fail to render if it had any vectors attached, such as by using [`plot_bloch_vector`](qiskit.visualization.plot_bloch_vector "qiskit.visualization.plot_bloch_vector"). See [#7272](https://github.com/Qiskit/qiskit-terra/issues/7272) for more detail.

*   Fixed an issue with the [`NLocal.add_layer()`](qiskit.circuit.library.NLocal#add_layer "qiskit.circuit.library.NLocal.add_layer") method incorrectly appending layers if the [`NLocal`](qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") object had already been built.

*   Fixed an issue with pickling [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") object when using Python 3.6. See [#6944](https://github.com/Qiskit/qiskit-terra/issues/6944) for details.

*   Complex valued pulse parameter assignment with symengine has been fixed. For example,

    ```python
    from qiskit import circuit, pulse
    import numpy as np

    amp = circuit.Parameter("amp")
    phase = circuit.Parameter("phase")

    with pulse.build() as sched:
        pulse.play(pulse.Gaussian(160, amp * np.exp(1j * phase), 40), pulse.DriveChannel(0))
    sched.assign_parameters({amp: 0.1, phase: 1.57}, inplace=True)
    ```

    The assigned amplitude has been shown as `ParameterExpression(0.1*exp(1.57*I))` after the use of `symengine` was introduced in the 0.18.0 release. This is now correctly evaluated and shown as `7.96327e-05 + 0.0999999683j`.

*   Fixed an issue where [`QAOA.construct_circuit()`](qiskit.algorithms.QAOA#construct_circuit "qiskit.algorithms.QAOA.construct_circuit") with different operators with same number of qubits would generate the same circuit each time. See [#7223](https://github.com/Qiskit/qiskit-terra/issues/7223) for more detail.

*   Fixed an issue where [`QAOAAnsatz`](qiskit.circuit.library.QAOAAnsatz "qiskit.circuit.library.QAOAAnsatz") had an incorrect number of parameters if identities of `PauliSumOp` were given, e.g., `PauliSumOp.from_list([("III", 1)])`. See [#7225](https://github.com/Qiskit/qiskit-terra/pull/7225) for more detail.

*   Fixed a bug where the [`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") method could return OpenQASM 2 instructions with invalid identifiers. The same bug was fixed for `UnitaryGate`.

*   Fixed an issue where trying to display registerless bits would cause a failure of the `mpl` and the `latex` circuit drawers. A leading `_` has been removed from the display of registerless bits’ numbers in the `text` drawer. Fixed [#6732](https://github.com/Qiskit/qiskit-terra/issues/6732).

*   For one-bit registers, all of the circuit drawers now display only the register name and no longer show the `0` subscript. Fixed [#5784](https://github.com/Qiskit/qiskit-terra/issues/5784).

*   Fixed naming collisions of implicit registers in [`QuantumCircuit.qasm`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") when dealing with registerless qubits and clbits. Previously, registerless qubits and clbits were put into corresponding `qreg` and `creg` both called `regless`, despite the collision. They will now have separate, deterministically generated names, which will not clash with any user-defined register names in the circuit.

*   Fixed an issue in scheduling of circuits with clbits operations, e.g. measurements, conditional gates, updating [`ASAPSchedule`](qiskit.transpiler.passes.ASAPSchedule "qiskit.transpiler.passes.ASAPSchedule"), [`ALAPSchedule`](qiskit.transpiler.passes.ALAPSchedule "qiskit.transpiler.passes.ALAPSchedule"), and [`AlignMeasures`](qiskit.transpiler.passes.AlignMeasures "qiskit.transpiler.passes.AlignMeasures"). The updated schedulers assume all clbits I/O operations take no time, `measure` writes the measured value to a clbit at the end, and `c_if` reads the conditional value in clbit(s) at the beginning. Fixed [#7006](https://github.com/Qiskit/qiskit-terra/issues/7006).

*   Calling [`transpile`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") on an empty list will now correctly return an empty list without issuing a warning. Fixed [#7287](https://github.com/Qiskit/qiskit-terra/issues/7287).

*   Fixed an issue in [`PiecewiseChebyshev`](qiskit.circuit.library.PiecewiseChebyshev "qiskit.circuit.library.PiecewiseChebyshev") when the function to be approximated was constant. In these cases, you should now pass the constant directly as the `f_x` argument, rather than using a function, such as:

    ```python
    from qiskit.circuit.library.arithmetic import PiecewiseChebyshev

    PiecewiseChebyshev(1.0, degree=3)
    ```

    See [#6707](https://github.com/Qiskit/qiskit-terra/pull/6707) for more details.

*   If an `HHL` algorithm instance was constructed without a [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") (the default), attempts to use the getter and setter properties to read or set an instance later would fail. The getters and setters now work as expected.

*   The [`QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") method now edits the names of copies of the instructions present in the circuit, not the original instructions that live in `circuit.data`. Refer to [#6952](https://github.com/Qiskit/qiskit-terra/issues/6952) for more details.

*   Fixed a bug in [`PauliSumOp.permute()`](qiskit.opflow.primitive_ops.PauliSumOp#permute "qiskit.opflow.primitive_ops.PauliSumOp.permute") causing the error:

    ```python
    QiskitError: 'Pauli string label "" is not valid.'
    ```

    if the permutation had the same number of Pauli terms. Calling `permute([2, 1, 0])` on `X ^ Y ^ Z` no longer raises an error, and now returns `Z ^ Y ^ X`.

*   Fixed a bug where the parameter bounds for the mixer parameters in the [`QAOAAnsatz`](qiskit.circuit.library.QAOAAnsatz "qiskit.circuit.library.QAOAAnsatz") were not been set.

*   Fixed determination of final operations (barriers and measures) in pass [`RemoveFinalMeasurements`](qiskit.transpiler.passes.RemoveFinalMeasurements "qiskit.transpiler.passes.RemoveFinalMeasurements") and in method [`remove_final_measurements()`](qiskit.circuit.QuantumCircuit#remove_final_measurements "qiskit.circuit.QuantumCircuit.remove_final_measurements") of class [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") which previously considered only nodes immediately preceding an output node.

*   Fixed determination of final operations in pass [`RemoveFinalMeasurements`](qiskit.transpiler.passes.RemoveFinalMeasurements "qiskit.transpiler.passes.RemoveFinalMeasurements") and in method [`remove_final_measurements()`](qiskit.circuit.QuantumCircuit#remove_final_measurements "qiskit.circuit.QuantumCircuit.remove_final_measurements") of class [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") which could wrongly consider a barrier to be final, even if other circuit operations followed it.

*   Fixed multi-bit classical register removal in pass [`RemoveFinalMeasurements`](qiskit.transpiler.passes.RemoveFinalMeasurements "qiskit.transpiler.passes.RemoveFinalMeasurements") and in method [`remove_final_measurements()`](qiskit.circuit.QuantumCircuit#remove_final_measurements "qiskit.circuit.QuantumCircuit.remove_final_measurements") of class [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") where classical registers were not removed even if other bits were idle, unless a final measure was done into each and every bit. Now, classical registers that become idle as a result of removing final measurements and barriers are always removed. Classical bits are removed if they are referenced only by removed registers or are not referenced at all and became idle due to the removal. This fix also adds proper handling of registers with shared underlying bits.

*   Fixed an issue with [`RemoveFinalMeasurements`](qiskit.transpiler.passes.RemoveFinalMeasurements "qiskit.transpiler.passes.RemoveFinalMeasurements") which could cause the resulting [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") to become invalid. See [#7196](https://github.com/Qiskit/qiskit-terra/pull/7196) for more details.

*   Fixed an issue with method [`remove_final_measurements()`](qiskit.circuit.QuantumCircuit#remove_final_measurements "qiskit.circuit.QuantumCircuit.remove_final_measurements") of class [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") that caused [`QuantumCircuit.clbits`](qiskit.circuit.QuantumCircuit#clbits "qiskit.circuit.QuantumCircuit.clbits") to be incorrect after invocation. Refer to [#7089](https://github.com/Qiskit/qiskit-terra/issues/7089) for details.

*   When tapering an empty zero operator in [`qiskit.opflow`](opflow#module-qiskit.opflow "qiskit.opflow"), the code, on detecting it was zero, logged a warning and returned the original operator. Such operators are commonly found in the auxiliary operators, when using Qiskit Nature, and the above behavior caused `VQE` to throw an exception as tapered non-zero operators were a different number of qubits from the tapered zero operators (since taper has returned the input operator unchanged). The code will now correctly taper a zero operator such that the number of qubits is reduced as expected and matches to tapered non-zero operators e.g `` `0*"IIII"` `` when we are tapering by 3 qubits will become `0*"I"`.

*   Fixed an issue with the [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function, where a custom style set via the user config file (i.e. `settings.conf`) would ignore the set value of the `circuit_mpl_style` field if the `style` kwarg on the function/method was not set.

<span id="release-notes-0-19-0-other-notes" />

<span id="id186" />

#### Other Notes

*   The string cast for [`qiskit.circuit.ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") does not have full precision anymore. This removes the trailing 0s when printing parameters that are bound to floats. This has consequences for QASM serialization and the circuit text drawer:

    ```python
    >>> from qiskit.circuit import Parameter
    >>> x = Parameter('x')
    >>> str(x.bind({x:0.5}))
    '0.5'   # instead of '0.500000000000000'
    ```

*   The [`QAOAAnsatz`](qiskit.circuit.library.QAOAAnsatz "qiskit.circuit.library.QAOAAnsatz") has been updated to use the parameter symbol `γ` for the cost operator and `β` for the mixer operator, as is the standard notation in QAOA literature.

<span id="id187" />

### Aer 0.9.1

No change

<span id="release-notes-ignis-0-7-0" />

<span id="id188" />

### Ignis 0.7.0

<span id="release-notes-ignis-0-7-0-prelude" />

<span id="id189" />

#### Prelude

This release deprecates the Qiskit Ignis project, it has been supersceded by the [Qiskit Experiments](https://qiskit.org/documentation/experiments/) project and active development has ceased. While deprecated, critical bug fixes and compatibility fixes will continue to be made to provide users a sufficient opportunity to migrate off of Ignis. After the deprecation period (which will be no shorter than 3 months from this release) the project will be retired and archived.

<span id="release-notes-ignis-0-7-0-new-features" />

<span id="id190" />

#### New Features

*   Updated the accreditation protocol to use fitting routine from [https://arxiv.org/abs/2103.06603](https://arxiv.org/abs/2103.06603). `AccreditationFitter` now has methods FullAccreditation (previous protocol) and MeanAccreditation (new protocol). In addtition data entry has been changed to either use the result object AppendResult or a list of strings AppendStrings. `qiskit.ignis.verification.QOTPCorrectString()` was also added.

*   Added the option for the fast analytical generation of syndrome graphs. The `RepetitionCode` now has a new bool argument `brute`, which allows to still use the brute force method. Helper class `RepetitionCodeSyndromeGenerator` added to facilitate this.

*   The `RepetitionCode` now has keyword arguments `resets` and `delay`. The former determines whether reset gates are inserted after measurement. The latter allows a time (in dt) to be specificed for a delay after each measurement (and reset, if applicable).

    The `syndrome_measurement()` method of `RepetitionCode` now has keyword arguments `final` and `delay`. The former determines whether to add reset gates according to the global `resets`, or to overwrite it with appropriate behavior for the final round of syndrome measurements. The latter allows a time (in dt) to be specificed for a delay after each measurement (and reset, if applicable).

*   The `RepetitionCode` class now supports encoding with x basis states. This can be used by setting the `xbasis` keyword argument when constructing a `RepetitionCode` object.

<span id="release-notes-ignis-0-7-0-upgrade-notes" />

<span id="id191" />

#### Upgrade Notes

*   The keyword argument `reset` has been removed from the the `syndrome_measurement()` method of `RepetitionCode`. This is replaced by the global `resets` keyword argument for the class as well as the keyword argument `final` for `syndrome_measurement`. In cases where one would previously add the final measurement round using `reset=False` to avoid the final reset gates, one should now use `final=True`.

*   Remove `ParametrizedSchedule` from `update_u_gates()`.

    `ParametrizedSchedule` was deprecated as a part of Qiskit-terra 0.17.0 and will be removed in next release. The function now updates u gates with `Schedule` programs involving unassigned `Parameter` objects.

<span id="release-notes-ignis-0-7-0-deprecation-notes" />

<span id="id192" />

#### Deprecation Notes

*   Deprecating methods in `AccreditationFitter` namely bound\_variation\_distance and single\_protocol\_run

*   The Qiskit Ignis project as a whole has been deprecated and the project will be retired and archived in the future. While deprecated only compatibility fixes and fixes for critical bugs will be made to the proejct. Instead of using Qiskit Ignis you should migrate to use [Qiskit Experiments](https://qiskit.org/documentation/experiments/) instead. You can refer to the migration guide:

    [https://github.com/Qiskit/qiskit-ignis#migration-guide](https://github.com/Qiskit/qiskit-ignis#migration-guide)

<span id="qiskit-0-32-1" />

## Qiskit 0.32.1

<span id="terra-0-18-3" />

### Terra 0.18.3

No change

<span id="id193" />

### Aer 0.9.1

No change

<span id="ignis-0-6-0" />

### Ignis 0.6.0

No change

<span id="aqua-0-9-5" />

### Aqua 0.9.5

No change

<span id="ibm-q-provider-0-18-1" />

<span id="release-notes-0-18-1-ibmq" />

### IBM Q Provider 0.18.1

<span id="release-notes-0-18-1-ibmq-bug-fixes" />

<span id="id194" />

#### Bug Fixes

*   Fixes [#209](https://github.com/Qiskit-Partners/qiskit-ibm/issues/209) where the websocket connection kept timing out when streaming results for a runtime job, due to inactivity, when the job is in a pending state for a long time.

<span id="qiskit-0-32-0" />

## Qiskit 0.32.0

<span id="id195" />

### Terra 0.18.3

No change

<span id="id196" />

### Aer 0.9.1

No change

<span id="id197" />

### Ignis 0.6.0

No change

<span id="id198" />

### Aqua 0.9.5

No change

<span id="ibm-q-provider-0-18-0" />

<span id="release-notes-0-18-0-ibmq" />

### IBM Q Provider 0.18.0

<span id="release-notes-0-18-0-ibmq-new-features" />

<span id="id199" />

#### New Features

*   You can now pass `program_id` parameter to `qiskit.providers.ibmq.runtime.IBMRuntimeService.jobs()` method to filter jobs by Program ID.
*   You can view the last updated date of a runtime program using `update_date` property.
*   If you are the author of a runtime program, you can now use `qiskit.providers.ibmq.runtime.RuntimeProgram.data` property to retrieve the program data as a string.
*   You can now use the `qiskit.providers.ibmq.runtime.IBMRuntimeService.update_program()` method to update the metadata for a Qiskit Runtime program. Program metadata can be specified using the `metadata` parameter or individual parameters, such as `name` and `description`. If the same metadata field is specified in both places, the individual parameter takes precedence.
*   You can now use the `qiskit.providers.ibmq.runtime.IBMRuntimeService.update_program()` method to update the data of an existing runtime program.

<span id="release-notes-0-18-0-ibmq-upgrade-notes" />

<span id="id200" />

#### Upgrade Notes

*   Runtime programs will no longer have a `version` field.
*   By default, `qiskit.providers.ibmq.runtime.IBMRuntimeService.pprint_programs()` now only prints the summary of each runtime program instead of all of the details. There is a new parameter `detailed` that can be set to `True` to print all details.
*   `limit` and `skip` parameters have been added to `qiskit.providers.ibmq.runtime.IBMRuntimeService.programs()` and `qiskit.providers.ibmq.runtime.IBMRuntimeService.pprint_programs()`. `limit` can be used to set the number of runtime programs returned and `skip` is the number of programs to skip when retrieving programs.
*   The data parameter to `qiskit.providers.ibmq.runtime.IBMRuntimeService.upload_program()` can now only be of type string. It can be either the program data, or path to the file that contains program data.
*   `qiskit.providers.ibmq.runtime.IBMRuntimeService.upload_program()` now takes only two parameters, `data`, which is the program passed as a string or the path to the program file and the `metadata`, which is passed as a dictionary or path to the metadata JSON file. In `metadata` the `backend_requirements`, `parameters`, `return_values` and `interim_results` are now grouped under a specifications `spec` section. `parameters`, `return_values` and `interim_results` should now be specified as JSON Schema.
*   `qiskit.providers.ibmq.AccountProvider.run_circuits()` method now takes a backend\_name parameter, which is a string, instead of backend, which is a `Backend` object.
*   The default number of `shots` (represents the number of repetitions of each circuit, for sampling) in `qiskit.providers.ibmq.IBMQBackend.run()`, has been increased from 1024 to 4000.

<span id="release-notes-0-18-0-ibmq-bug-fixes" />

<span id="id201" />

#### Bug Fixes

*   Fixes the issue wherein a runtime job result cannot be retrieved multiple times if the result contains a numpy array.

<span id="qiskit-0-31-0" />

## Qiskit 0.31.0

<span id="id202" />

### Terra 0.18.3

No change

<span id="release-notes-0-9-1-aer" />

<span id="id203" />

### Aer 0.9.1

<span id="release-notes-0-9-1-aer-upgrade-notes" />

<span id="id204" />

#### Upgrade Notes

*   `optimize_ideal_threshold` and `optimize_noisy_threshold` have been removed from the lists of simulator defaults and the documentation. These have had no effect since Aer 0.5.1, but these references to them had remained accidentally.

<span id="release-notes-0-9-1-aer-bug-fixes" />

<span id="id205" />

#### Bug Fixes

*   Fixes [#1351](https://github.com/Qiskit/qiskit-aer/issues/1351) where running an empty [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with a noise model set would cause the simulator to crash.
*   Fixes [#1347](https://github.com/Qiskit/qiskit-aer/issues/1347) where the behaviour of using the `set_options()` and `set_option()` methods of simulator backends could lead to different behavior for some options.
*   Fixes an bug where using a Dask Client executor would cause an error at job submission due to the executor Client not being pickleable.
*   Fixed an issue with the matrix\_product\_state simulation method where the accumulation of small rounding errors during measurement of many quits could sometimes cause a segmentation fault.
*   Fixes an unintended change between qiskit-aer 0.8.0 and 0.9.0 where when running a list of circuits with an invalid circuit using the `automatic` simulation method of the `AerSimulator` or `QasmSimulator` would raise an exception for an invalid input qobj rather than return partial results for the circuits that were valid.
*   Fixes an issue with the standalone simulator where it would return a [IBM Quantum API schema](https://github.com/Qiskit/ibm-quantum-schemas) invalid response in the case of an error that prevented the simulation from running.
*   Fixes [#1346](https://github.com/Qiskit/qiskit-aer/issues/1346) which was a bug in the handling of the `parameter_binds` kwarg of the backend `run()` method that would result in an error if the parameterized circuit was transpiled to a different set of basis gates than the original parameterizations.

<span id="id206" />

### Ignis 0.6.0

No change

<span id="id207" />

### Aqua 0.9.5

No change

<span id="ibm-q-provider-0-17-0" />

<span id="release-notes-0-17-0-ibmq" />

### IBM Q Provider 0.17.0

<span id="release-notes-0-17-0-ibmq-new-features" />

<span id="id208" />

#### New Features

*   A runtime program’s visibility can now be specified on upload using `is_public` parameter in `qiskit.providers.ibmq.runtime.IBMRuntimeService.upload_program()`.
*   You can now specify a parent experiment ID when creating an experiment with `qiskit.providers.ibmq.experiment.IBMExperimentService.create_experiment()`. Experiments can also be filtered by their parent experiment ID in `qiskit.providers.ibmq.experiment.IBMExperimentService.experiments()`.
*   Runtime image can now be specified using the image parameter in `qiskit.providers.ibmq.runtime.IBMRuntimeService.run()`. Note that not all accounts are authorized to select a different image.

<span id="release-notes-0-17-0-ibmq-upgrade-notes" />

<span id="id209" />

#### Upgrade Notes

*   `qiskit.providers.ibmq.runtime.RuntimeEncoder` and `qiskit.providers.ibmq.runtime.RuntimeDecoder` are updated to support Python `datetime`, which is not JSON serializable by default.

<span id="release-notes-0-17-0-ibmq-bug-fixes" />

<span id="id210" />

#### Bug Fixes

*   Fixes the issue where `qiskit.providers.ibmq.managed.IBMQJobManager.retrieve_job_set()` only retrieves the first 10 jobs in a `qiskit.providers.ibmq.managed.ManagedJobSet`.
*   `qiskit.providers.ibmq.runtime.RuntimeDecoder` can now restore dictionary integer keys in optimizer settings from a JSON string representation dumped by the `qiskit.providers.ibmq.runtime.RuntimeEncoder`.

<span id="qiskit-0-30-1" />

## Qiskit 0.30.1

<span id="release-notes-0-18-3" />

<span id="id211" />

### Terra 0.18.3

<span id="id212" />

#### Prelude

This bugfix release fixes a few minor issues in 0.18, including a performance regression in [`assemble`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") when dealing with executing [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects on pulse-enabled backends.

<span id="release-notes-0-18-3-bug-fixes" />

<span id="id213" />

#### Bug Fixes

*   Fixed [#7004](https://github.com/Qiskit/qiskit-terra/issues/7004) where `AttributeError` was raised when executing [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") on a pulse backend. These blocks are now correctly treated as pulse jobs, like [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule").
*   Fixed an issue causing an error when binding a complex parameter value to an operator’s coefficient. Casts to `float` in [`PrimitiveOp`](qiskit.opflow.primitive_ops.PrimitiveOp "qiskit.opflow.primitive_ops.PrimitiveOp") were generalized to casts to `complex` if necessary, but will remain `float` if there is no imaginary component. Fixes [#6976](https://github.com/Qiskit/qiskit-terra/issues/6976).
*   Update the 1-qubit gate errors in [`plot_error_map`](qiskit.visualization.plot_error_map "qiskit.visualization.plot_error_map") to use the sx gate instead of the u2 gate, consistent with IBMQ backends.

<span id="aer-0-9-0" />

### Aer 0.9.0

No change

<span id="id214" />

### Ignis 0.6.0

No change

<span id="id215" />

### Aqua 0.9.5

No change

<span id="ibm-q-provider-0-16-0" />

### IBM Q Provider 0.16.0

No change

<span id="qiskit-0-30-0" />

## Qiskit 0.30.0

<span id="terra-0-18-2" />

### Terra 0.18.2

No change

<span id="release-notes-aer-0-9-0" />

<span id="id216" />

### Aer 0.9.0

<span id="release-notes-aer-0-9-0-prelude" />

<span id="id217" />

#### Prelude

The 0.9 release includes new backend options for parallel exeuction of large numbers of circuits on a HPC cluster using a Dask distributed, along with other general performance improvements and bug fixes.

<span id="release-notes-0-9-0-aer-new-features" />

<span id="id218" />

#### New Features

*   Added support for set\_matrix\_product\_state.

*   Add qiskit library [`SXdgGate`](qiskit.circuit.library.SXdgGate "qiskit.circuit.library.SXdgGate") and [`CUGate`](qiskit.circuit.library.CUGate "qiskit.circuit.library.CUGate") to the supported basis gates for the Aer simulator backends. Note that the [`CUGate`](qiskit.circuit.library.CUGate "qiskit.circuit.library.CUGate") gate is only natively supported for the `statevector` and `unitary` methods. For other simulation methods it must be transpiled to the supported basis gates for that method.

*   Adds support for N-qubit Pauli gate ( `qiskit.circuit.library.generalized_gates.PauliGate`) to all simulation methods of the `AerSimulator` and `QasmSimulator`.

*   Adds the ability to set a custom executor and configure job splitting for executing multiple circuits in parallel on a HPC clustor. A custom executor can be set using the `executor` option, and job splitting is configured by using the `max_job_size` option.

    For example configuring a backend and executing using

    ```python
    backend = AerSimulator(max_job_size=1, executor=custom_executor)
    job = backend.run(circuits)
    ```

    will split the exection into multiple jobs each containing a single circuit. If job splitting is enabled the `run` method will return a `AerJobSet` object containing all the individual `AerJob` classes. After all individual jobs finish running the job results are automatically combined into a single Result object that is returned by `job.result()`.

    Supported executors include those in the Python `concurrent.futures` [module](https://docs.python.org/3/library/concurrent.futures.html) (eg. `ThreadPoolExecutor`, `ProcessPoolExecutor`), and [Dask](http://dask.org) distributed Client executors if the optional dask library is installed. Using a Dask executor allows configuring parallel execution of multiple circuits on HPC clusters.

*   Adds ability to record logging data for the `matrix_product_state` simulation method to the experiment result metadata by setting the backend option `mps_log_data=True`. The saved data includes the bond dimensions and the discarded value (the sum of the squares of the Schmidt coeffients that were discarded by approximation) after every relevant circuit instruction.

*   The `run()` method for the `AerSimulator`, `QasmSimulator`, `StatevectorSimulator`, and `UnitarySimulator` has a new kwarg, `parameter_binds` which is used to provide a list of values to use for any unbound parameters in the inbound circuit. For example:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter
    from qiskit.providers.aer import AerSimulator

    shots = 1000
    backend = AerSimulator()
    circuit = QuantumCircuit(2)
    theta = Parameter('theta')
    circuit.rx(theta, 0)
    circuit.cx(0, 1)
    circuit.measure_all()
    parameter_binds = [{theta: [0, 3.14, 6.28]}]
    backend.run(circuit, shots=shots, parameter_binds=parameter_binds).result()
    ```

    will run the input circuit 3 times with the values 0, 3.14, and 6.28 for theta. When running with multiple parameters the length of the value lists must all be the same. When running with multiple circuits, the length of `parameter_binds` must match the number of input circuits (you can use an empty dict, `{}`, if there are no binds for a circuit).

*   The `PulseSimulator` can now take [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects on the `run()`. Previously, it only would except [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") objects as input to `run()`. When a circuit or list of circuits is passed to the simulator it will call [`schedule()`](compiler#qiskit.compiler.schedule "qiskit.compiler.schedule") to convert the circuits to a schedule before executing the circuit. For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.compiler import transpile
    from qiskit.test.mock import FakeVigo
    from qiskit.providers.aer.backends import PulseSimulator

    backend = PulseSimulator.from_backend(FakeVigo())

    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()

    transpiled_circuit = transpile(circuit, backend)
    backend.run(circuit)
    ```

<span id="release-notes-aer-0-9-0-known-issues" />

<span id="id219" />

#### Known Issues

*   The `SaveExpectationValue` and `SaveExpectationValueVariance` have been disabled for the extended\_stabilizer method of the `QasmSimulator` and `AerSimulator` due to returning the incorrect value for certain Pauli operator components. Refer to #1227 \<[https://github.com/Qiskit/qiskit-aer/issues/1227](https://github.com/Qiskit/qiskit-aer/issues/1227)> for more information and examples.

<span id="release-notes-aer-0-9-0-upgrade-notes" />

<span id="id220" />

#### Upgrade Notes

*   The default basis for the `NoiseModel` class has been changed from `["id", "u3", "cx"]` to `["id", "rz", "sx", "cx"]` due to the deprecation of the `u3` circuit method in qiskit-terra and change of qiskit-ibmq-provider backend basis gates. To use the old basis gates you can initialize a noise model with custom basis gates as `NoiseModel(basis_gates=["id", "u3", "cx"])`.
*   Removed the `backend_options` kwarg from the `run` methnod of Aer backends that was deprecated in qiskit-aer 0.7. All run options must now be passed as separate kwargs.
*   Removed passing `system_model` as a positional arg for the `run` method of the `PulseSimulator`.

<span id="release-notes-aer-0-9-0-deprecation-notes" />

<span id="id221" />

#### Deprecation Notes

*   Passing an assembled qobj directly to the `run()` method of the Aer simulator backends has been deprecated in favor of passing transpiled circuits directly as `backend.run(circuits, **run_options)`.
*   All snapshot instructions in `qiskit.providers.aer.extensions` have been deprecated. For replacement use the save instructions from the `qiskit.providers.aer.library` module.
*   Adding non-local quantum errors to a `NoiseModel` has been deprecated due to inconsistencies in how this noise is applied to the optimized circuit. Non-local noise should be manually added to a scheduled circuit in Qiskit using a custom transpiler pass before being run on the simulator.
*   Use of the `method` option of the `StatevectorSimulator`, and `UnitarySimulator` to run a GPU simulation has been deprecated. To run a GPU simulation on a compatible system use the option `device='GPU'` instead.

<span id="release-notes-aer-0-9-0-bug-fixes" />

<span id="id222" />

#### Bug Fixes

*   Fixes performance issue with how the `basis_gates` configuration attribute was set. Previously there were unintended side-effects to the backend class which could cause repeated simulation runtime to incrementally increase. Refer to #1229 \<[https://github.com/Qiskit/qiskit-aer/issues/1229](https://github.com/Qiskit/qiskit-aer/issues/1229)> for more information and examples.
*   Fixed bug in MPS::apply\_kraus. After applying the kraus matrix to the relevant qubits, we should propagate the changes to the neighboring qubits.
*   Fixes a bug where qiskit-terra assumes that qubits in a multiplexer gate are first the targets and then the controls of the gate while qiskit-aer assumes the opposite order.
*   Fixes a bug introduced in 0.8.0 where GPU simulations would allocate unneeded host memory in addition to the GPU memory.
*   Fixes bug where the initialize instruction would disable measurement sampling optimization for the statevector and matrix product state simulation methods even when it was the first circuit instruction or applied to all qubits and hence deterministic.
*   Fix issue #1196 by using the inner products with the computational basis states to calculate the norm rather than the norm estimation algorithm.
*   Fixes a bug in the `stabilizer` simulator method of the `QasmSimulator` and `AerSimulator` where the expectation value for the `save_expectation_value` and `snapshot_expectation_value` could have the wrong sign for certain `Y` Pauli’s.
*   Fixes bug where the if the required memory is smaller than the system memory the multi-chunk simulation method was enabled and simulation was still started. This case will now throw an insufficient memory exception.
*   Fixes issue where setting the `shots` option for a backend with `set_options(shots=k)` was always running the default number of shots (1024) rather than the specified value.
*   Fixes a bug in how the `AerSimulator` handled the option value for `max_parallel_experiments=1`. Previously this was treated the same as `max_parallel_experiments=0`.
*   Fixes bug in the `extended_stabilizer` simulation method where it incorrectly treated qelay gate and multi-qubit Pauli instructions as unsupported.
*   Fixes typo in the `AerSimulator` and `QasmSimulator` options for the `extended_stabilizer_norm_estimation_repetitions` option.
*   Fixes bug with applying the `unitary` gate in using the `matrix_product_state` simulation method which did not correctly support permutations in the ordering of the qubits on which the gate is applied.
*   Fixes an issue where gate fusion could still be enabled for the `matrix_product_state` simulation method even though it is not supported. Now fusion is always disabled for this method.
*   Fixed bug in the `matrix_product_state` simulation method in computing the normalization following truncation of the Schmidt coefficients after performing the SVD.

<span id="release-notes-aer-0-9-0-other-notes" />

<span id="id223" />

#### Other Notes

*   Improves the performance of the measurement sampling algorithm for the `matrix_product_state` simulation method. The new default behaviour is to always sample using the improved `mps_apply_measure` method. The `mps_probabilities` sampling method be still used by setting the custom option value `mps_sample_measure_algorithm="mps_probabilities"`.

<span id="id224" />

### Ignis 0.6.0

No change

<span id="id225" />

### Aqua 0.9.5

No change

<span id="id226" />

### IBM Q Provider 0.16.0

No change

<span id="qiskit-0-29-1" />

## Qiskit 0.29.1

<span id="release-notes-0-18-2" />

<span id="id227" />

### Terra 0.18.2

<span id="release-notes-0-18-2-bug-fixes" />

<span id="id228" />

#### Bug Fixes

*   Fixed an issue with the [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") function when called with the `backend` kwarg set and the `parametric_pulses` kwarg was set to an empty list the output qobj would contain the `parametric_pulses` setting from the given backend’s [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") instead of the expected empty list. Fixed [#6898](https://github.com/Qiskit/qiskit-terra/issues/6898)
*   The Matplotlib circuit drawer will no longer duplicate drawings when using `ipykernel>=6.0.0`. Fixes [#6889](https://github.com/Qiskit/qiskit-terra/issues/6889).

<span id="aer-0-8-2" />

### Aer 0.8.2

No change

<span id="id229" />

### Ignis 0.6.0

No change

<span id="release-notes-aqua-0-9-5" />

<span id="id230" />

### Aqua 0.9.5

<span id="release-notes-aqua-0-9-5-bug-fixes" />

<span id="id231" />

#### Bug Fixes

*   Fixed a handling error in the Yahoo provider when only one ticker is entered. Added exception error if no ticker is entered. Limit yfinance to >=0.1.62 as previous versions have a JSON decoder error.

<span id="id232" />

### IBM Q Provider 0.16.0

No change

<span id="qiskit-0-29-0" />

## Qiskit 0.29.0

<span id="terra-0-18-1" />

<span id="release-notes-0-18-1" />

### Terra 0.18.1

<span id="release-notes-0-18-1-prelude" />

<span id="id233" />

#### Prelude

This bugfix release fixes a few minor issues and regressions in the 0.18.0 release. There is also a minor change to how `pip` handles the `[all]` extra when installing `qiskit-terra` directly, compared to 0.18.0.

<span id="release-notes-0-18-1-upgrade-notes" />

<span id="id234" />

#### Upgrade Notes

*   `pip install qiskit-terra[all]` will no longer attempt to install the `bip-mapper` extra. This is because the dependency `cplex` is not well supported on the range of Python versions and OSes that Terra supports, and a failed extra dependency would fail the entire package resolution. If you are using Python 3.7 or 3.8 and are on Linux-x64 or -ppc64le, macOS-x64 or Windows-x64 you should be able to install `qiskit-terra[bip-mapper]` explicitly, if desired, while other combinations of OS, platform architectures and Python versions will likely fail.

<span id="release-notes-0-18-1-bug-fixes" />

<span id="id235" />

#### Bug Fixes

*   Fixed an issue where the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class would potentially try to use the `CompleteMeasFitter` class before it was imported resulting in an error. Fixed [#6774](https://github.com/Qiskit/qiskit-terra/issues/6774)
*   Fixed the missing Linux aarch64 wheels which were not published for the 0.18.0 release. They should now continue to be built as expected for all future releases.
*   Fixed an issue with the mock backends located in `qiskit.test.mock` where in some situations (mainly fake backends with stored [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") running a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with `qiskit-aer` installed) passing run time options to the `run()` method of a fake backend object would not actually be passed to the simulator underlying the `run()` method and not have any effect. Fixed [#6741](https://github.com/Qiskit/qiskit-terra/issues/6741)
*   Fix a bug in [`EvolvedOperatorAnsatz`](qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz") when the global phase is 0 (such as for [`QAOAAnsatz`](qiskit.circuit.library.QAOAAnsatz "qiskit.circuit.library.QAOAAnsatz")) but was still a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression").
*   Fixed an issue with the [`settings`](qiskit.algorithms.optimizers.QNSPSA#settings "qiskit.algorithms.optimizers.QNSPSA.settings") attribute of [`QNSPSA`](qiskit.algorithms.optimizers.QNSPSA "qiskit.algorithms.optimizers.QNSPSA"), which was missing the `fidelity` argument from the output. This is now correctly included in the attribute’s output.
*   Fixed an issue with the `subgraph()` method of the [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") class where it would incorrectly add nodes to the output [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") object when the `nodelist` argument contained a non-contiguous list of qubit indices. This has been fixed so regardless of the input indices in `nodelist` the output [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") will only contained the specified nodes reindexed starting at 0. Fixes [#6736](https://github.com/Qiskit/qiskit-terra/issues/6736)
*   Previously, [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") failed to properly optimize one qubit gates that are sufficiently close to the identity matrix. This was fixed so that any gates that differ from the identity by less than 1e-15 are removed.
*   Fixed the generation and loading of QPY files with `qiskit.circuit.qpy_serialization.dump()` and `qiskit.circuit.qpy_serialization.load()` for [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects that contain instructions with classical conditions on a single [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") instead of a [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister"). While the use of single [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") conditions is not yet fully supported, if you were using them in a circuit they are now correctly serialized by QPY.

<span id="id236" />

### Aer 0.8.2

No change

<span id="id237" />

### Ignis 0.6.0

No change

<span id="aqua-0-9-4" />

### Aqua 0.9.4

No change

<span id="release-notes-ibmq-0-16-0" />

<span id="id238" />

### IBM Q Provider 0.16.0

<span id="release-notes-ibmq-0-16-0-new-features" />

<span id="id239" />

#### New Features

*   A user can now set and retrieve preferences for `qiskit.providers.ibmq.experiment.IBMExperimentService`. Preferences are saved on disk in the `$HOME/.qiskit/qiskitrc` file. Currently the only preference option is `auto_save`, which tells applications that use this service, such as qiskit-experiments, whether you want changes to be automatically saved. Usage examples:

    ```python
    provider.experiment.save_preferences(auto_save=True) # set and save preferences
    provider.experiment.preferences                      # return all saved preferences
    ```

*   The methods `qiskit.providers.ibmq.experiment.IBMExperimentService.create_figure()` and `qiskit.providers.ibmq.experiment.IBMExperimentService.update_figure()` now accept the `sync_upload` keyword. This controls whether or not the figure will be uploaded asynchronously or synchronously to backend storage. By default `sync_upload` is `True` for synchronous upload.

<span id="release-notes-ibmq-0-16-0-upgrade-notes" />

<span id="id240" />

#### Upgrade Notes

*   `IBMExperimentService` is updated to work with the new `qiskit-experiments`. As a result, the syntax of the experiment service is drastically changed. This change, however, takes the experiment service out of beta mode, and future changes will provide backward compatibility according to Qiskit deprecation policy.
*   `qiskit.providers.ibmq.runtime.utils.RuntimeEncoder` now convert a callable object to `None`, since callables are not JSON serializable.
*   `qiskit.providers.ibmq.IBMQBackend.run()` no longer accepts validate\_qobj as a parameter. If you were relying on this schema validation you should pull the schemas from the [Qiskit/ibm-quantum-schemas](https://github.com/Qiskit/ibm-quantum-schemas) and directly validate your payloads with that.

<span id="qiskit-0-28-0" />

## Qiskit 0.28.0

<span id="terra-0-18-0" />

<span id="release-notes-0-18-0" />

### Terra 0.18.0

<span id="release-notes-0-18-0-prelude" />

<span id="id241" />

#### Prelude

This release includes many new features and bug fixes. The highlights of this release are the introduction of two new transpiler passes, `BIPMapping` and [`DynamicalDecoupling`](qiskit.transpiler.passes.DynamicalDecoupling "qiskit.transpiler.passes.DynamicalDecoupling"), which when combined with the new `pulse_optimize` kwarg on the [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") pass enables recreating the Quantum Volume 64 results using the techniques described in: [https://arxiv.org/abs/2008.08571](https://arxiv.org/abs/2008.08571). These new transpiler passes and options and are also generally applicable to optimizing any circuit.

<span id="release-notes-0-18-0-new-features" />

<span id="id242" />

#### New Features

*   The `measurement_error_mitgation` kwarg for the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") constructor can now be set to the `TensoredMeasFitter` class from qiskit-ignis in addition to `CompleteMeasFitter` that was already supported. If you use `TensoredMeasFitter` you will also be able to set the new `mit_pattern` kwarg to specify the qubits on which to use `TensoredMeasFitter` You can refer to the documentation for `mit_pattern` in the `TensoredMeasFitter` documentation for the expected format.

*   The decomposition methods for single-qubit gates, specified via the `basis` kwarg, in [`OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") has been expanded to now also include the `'ZSXX'` basis, for making use of direct $X$ gate as well as $\sqrt{X}$ gate.

*   Added two new passes [`AlignMeasures`](qiskit.transpiler.passes.AlignMeasures "qiskit.transpiler.passes.AlignMeasures") and [`ValidatePulseGates`](qiskit.transpiler.passes.ValidatePulseGates "qiskit.transpiler.passes.ValidatePulseGates") to the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module. These passes are a hardware-aware optimization, and a validation routine that are used to manage alignment restrictions on time allocation of instructions for a backend.

    If a backend has a restriction on the alignment of `Measure` instructions (in terms of quantization in time), the [`AlignMeasures`](qiskit.transpiler.passes.AlignMeasures "qiskit.transpiler.passes.AlignMeasures") pass is used to adjust delays in a scheduled circuit to ensure that any `Measure` instructions in the circuit are aligned given the constraints of the backend. The [`ValidatePulseGates`](qiskit.transpiler.passes.ValidatePulseGates "qiskit.transpiler.passes.ValidatePulseGates") pass is used to check if any custom pulse gates (gates that have a custom pulse definition in the [`calibrations`](qiskit.circuit.QuantumCircuit#calibrations "qiskit.circuit.QuantumCircuit.calibrations") attribute of a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object) are valid given an alignment constraint for the target backend.

    In the built-in `preset_passmangers` used by the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function, these passes get automatically triggered if the alignment constraint, either via the dedicated `timing_constraints` kwarg on [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or has an `timing_constraints` attribute in the [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") object of the backend being targetted.

    The backends from IBM Quantum Services (accessible via the [qiskit-ibmq-provider](https://pypi.org/project/qiskit-ibmq-provider/) package) will provide the alignment information in the near future.

    > For example:

    ```python
    from qiskit import circuit, transpile
    from qiskit.test.mock import FakeArmonk

    backend = FakeArmonk()

    qc = circuit.QuantumCircuit(1, 1)
    qc.x(0)
    qc.delay(110, 0, unit="dt")
    qc.measure(0, 0)
    qc.draw('mpl')
    ```

    ```python
    qct = transpile(qc, backend, scheduling_method='alap',
                    timing_constraints={'acquire_alignment': 16})
    qct.draw('mpl')
    ```

*   A new transpiler pass class `qiskit.transpiler.passes.BIPMapping` that tries to find the best layout and routing at once by solving a BIP (binary integer programming) problem as described in [arXiv:2106.06446](https://arxiv.org/abs/2106.06446) has been added.

    The `BIPMapping` pass (named “mapping” to refer to “layout and routing”) represents the mapping problem as a BIP (binary integer programming) problem and relies on CPLEX (`cplex`) to solve the BIP problem. The dependent libraries including CPLEX can be installed along with qiskit-terra:

    ```python
    pip install qiskit-terra[bip-mapper]
    ```

    Since the free version of CPLEX can solve only small BIP problems, i.e. mapping of circuits with less than about 5 qubits, the paid version of CPLEX may be needed to map larger circuits.

    The BIP mapper scales badly with respect to the number of qubits or gates. For example, it would not work with `coupling_map` beyond 10 qubits because the BIP solver (CPLEX) could not find any solution within the default time limit.

    Note that, if you want to fix physical qubits to be used in the mapping (e.g. running Quantum Volume (QV) circuits), you need to specify `coupling_map` which contains only the qubits to be used.

    Here is a minimal example code to build pass manager to transpile a QV circuit:

    ```python
    num_qubits = 4  # QV16
    circ = QuantumVolume(num_qubits=num_qubits)

    backend = ...
    basis_gates = backend.configuration().basis_gates
    coupling_map = CouplingMap.from_line(num_qubits)  # supply your own coupling map

    def _not_mapped(property_set):
        return not property_set["is_swap_mapped"]

    def _opt_control(property_set):
        return not property_set["depth_fixed_point"]

    from qiskit.circuit.equivalence_library import SessionEquivalenceLibrary as sel
    pm = PassManager()
    # preparation
    pm.append([
        Unroll3qOrMore(),
        TrivialLayout(coupling_map),
        FullAncillaAllocation(coupling_map),
        EnlargeWithAncilla(),
        BarrierBeforeFinalMeasurements()
    ])
    # mapping
    pm.append(BIPMapping(coupling_map))
    pm.append(CheckMap(coupling_map))
    pm.append(Error(msg="BIP mapper failed to map", action="raise"),
              condition=_not_mapped)
    # post optimization
    pm.append([
        Depth(),
        FixedPoint("depth"),
        Collect2qBlocks(),
        ConsolidateBlocks(basis_gates=basis_gates),
        UnitarySynthesis(basis_gates),
        Optimize1qGatesDecomposition(basis_gates),
        CommutativeCancellation(),
        UnrollCustomDefinitions(sel, basis_gates),
        BasisTranslator(sel, basis_gates)
    ], do_while=_opt_control)

    transpile_circ = pm.run(circ)
    ```

*   A new constructor method [`initialize_from()`](qiskit.pulse.Schedule#initialize_from "qiskit.pulse.Schedule.initialize_from") was added to the [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") and [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") classes. This method initializes a new empty schedule which takes the attributes from other schedule. For example:

    ```python
    sched = Schedule(name='my_sched')
    new_sched = Schedule.initialize_from(sched)

    assert sched.name == new_sched.name
    ```

*   A new kwarg, `line_discipline`, has been added to the [`job_monitor()`](tools#qiskit.tools.job_monitor "qiskit.tools.job_monitor") function. This kwarg enables changing the carriage return characters used in the `job_monitor` output. The `line_discipline` kwarg defaults to `'\r'`, which is what was in use before.

*   The abstract `Pulse` class (which is the parent class for classes such as [`Waveform`](qiskit.pulse.library.Waveform "qiskit.pulse.library.Waveform"), [`Constant`](qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant"), and [`Gaussian`](qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian") now has a new kwarg on the constructor, `limit_amplitude`, which can be set to `False` to disable the previously hard coded amplitude limit of `1`. This can also be set as a class attribute directly to change the global default for a Pulse class. For example:

    ```python
    from qiskit.pulse.library import Waveform

    # Change the default value of limit_amplitude to False
    Waveform.limit_amplitude = False
    wave = Waveform(2.0 * np.exp(1j * 2 * np.pi * np.linspace(0, 1, 1000)))
    ```

*   A new class, [`PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList"), has been added to the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module. This class is used to efficiently represent a list of [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") operators. This new class inherets from the same parent class as the existing `PauliTable` (and therefore can be mostly used interchangeably), however it differs from the `PauliTable` because the [`qiskit.quantum_info.PauliList`](qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") class can handle Z4 phases.

*   Added a new transpiler pass, [`RemoveBarriers`](qiskit.transpiler.passes.RemoveBarriers "qiskit.transpiler.passes.RemoveBarriers"), to [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes"). This pass is used to remove all barriers in a circuit.

*   Add a new optimizer class, [`SciPyOptimizer`](qiskit.algorithms.optimizers.SciPyOptimizer "qiskit.algorithms.optimizers.SciPyOptimizer"), to the [`qiskit.algorithms.optimizers`](qiskit.algorithms.optimizers#module-qiskit.algorithms.optimizers "qiskit.algorithms.optimizers") module. This class is a simple wrapper class of the `scipy.optimize.minimize` function ([documentation](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html)) which enables the use of all optimization solvers and all parameters (e.g. callback) which are supported by `scipy.optimize.minimize`. For example:

    ```python
    from qiskit.algorithms.optimizers import SciPyOptimizer

    values = []

    def callback(x):
        values.append(x)

    optimizer = SciPyOptimizer("BFGS", options={"maxiter": 1000}, callback=callback)
    ```

*   The [`HoareOptimizer`](qiskit.transpiler.passes.HoareOptimizer "qiskit.transpiler.passes.HoareOptimizer") pass has been improved so that it can now replace a [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") in a circuit with with the base gate if all the control qubits are in the $|1\rangle$ state.

*   Added two new methods, [`is_successor()`](qiskit.dagcircuit.DAGCircuit#is_successor "qiskit.dagcircuit.DAGCircuit.is_successor") and [`is_predecessor()`](qiskit.dagcircuit.DAGCircuit#is_predecessor "qiskit.dagcircuit.DAGCircuit.is_predecessor"), to the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class. These functions are used to check if a node is either a successor or predecessor of another node on the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit").

*   A new transpiler pass, [`RZXCalibrationBuilderNoEcho`](qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho"), was added to the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module. This pass is similar to the existing [`RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") in that it creates calibrations for an `RZXGate(theta)`, however [`RZXCalibrationBuilderNoEcho`](qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho") does this without inserting the echo pulses in the pulse schedule. This enables exposing the echo in the cross-resonance sequence as gates so that the transpiler can simplify them. The [`RZXCalibrationBuilderNoEcho`](qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho") pass only supports the hardware-native direction of the [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate").

*   A new kwarg, `wrap`, has been added to the [`compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). This enables choosing whether composed circuits should be wrapped into an instruction or not. By default this is `False`, i.e. no wrapping. For example:

    ```python
    from qiskit import QuantumCircuit
    circuit = QuantumCircuit(2)
    circuit.h([0, 1])
    other = QuantumCircuit(2)
    other.x([0, 1])
    print(circuit.compose(other, wrap=True))  # wrapped
    print(circuit.compose(other, wrap=False))  # not wrapped
    ```

*   A new attribute, [`control_channels`](qiskit.providers.models.PulseBackendConfiguration#control_channels "qiskit.providers.models.PulseBackendConfiguration.control_channels"), has been added to the [`PulseBackendConfiguration`](qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") class. This attribute represents the control channels on a backend as a mapping of qubits to a list of [`ControlChannel`](qiskit.pulse.channels.ControlChannel "qiskit.pulse.channels.ControlChannel") objects.

*   A new kwarg, `epsilon`, has been added to the constructor for the `Isometry` class and the corresponding [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`isometry()`](qiskit.circuit.QuantumCircuit#isometry "qiskit.circuit.QuantumCircuit.isometry"). This kwarg enables optionally setting the epsilon tolerance used by an `Isometry` gate. For example:

    ```python
    import numpy as np
    from qiskit import QuantumRegister, QuantumCircuit

    tolerance = 1e-8
    iso = np.eye(2,2)
    num_q_output = int(np.log2(iso.shape[0]))
    num_q_input = int(np.log2(iso.shape[1]))
    q = QuantumRegister(num_q_output)
    qc = QuantumCircuit(q)

    qc.isometry(iso, q[:num_q_input], q[num_q_input:], epsilon=tolerance)
    ```

*   Added a transpiler pass, [`DynamicalDecoupling`](qiskit.transpiler.passes.DynamicalDecoupling "qiskit.transpiler.passes.DynamicalDecoupling"), to [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") for inserting dynamical decoupling sequences in idle periods of a circuit (after mapping to physical qubits and scheduling). The pass allows control over the sequence of DD gates, the spacing between them, and the qubits to apply on. For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import XGate
    from qiskit.transpiler import PassManager, InstructionDurations
    from qiskit.transpiler.passes import ALAPSchedule, DynamicalDecoupling
    from qiskit.visualization import timeline_drawer

    circ = QuantumCircuit(4)
    circ.h(0)
    circ.cx(0, 1)
    circ.cx(1, 2)
    circ.cx(2, 3)
    circ.measure_all()

    durations = InstructionDurations(
        [("h", 0, 50), ("cx", [0, 1], 700), ("reset", None, 10),
         ("cx", [1, 2], 200), ("cx", [2, 3], 300),
         ("x", None, 50), ("measure", None, 1000)]
    )

    dd_sequence = [XGate(), XGate()]

    pm = PassManager([ALAPSchedule(durations),
                      DynamicalDecoupling(durations, dd_sequence)])
    circ_dd = pm.run(circ)
    timeline_drawer(circ_dd)
    ```

*   The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") has a new kwarg, `encoding`, which can be used to optionally set the character encoding of an output QASM file generated by the function. This can be set to any valid codec or alias string from the Python standard library’s [codec module](https://docs.python.org/3/library/codecs.html#standard-encodings).

*   Added a new class, [`EvolvedOperatorAnsatz`](qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz"), to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module. This library circuit, which had previously been located in [Qiskit Nature](https://qiskit.org/documentation/nature/) , can be used to construct ansatz circuits that consist of time-evolved operators, where the evolution time is a variational parameter. Examples of such ansatz circuits include `UCCSD` class in the `chemistry` module of Qiskit Nature or the [`QAOAAnsatz`](qiskit.circuit.library.QAOAAnsatz "qiskit.circuit.library.QAOAAnsatz") class.

*   A new fake backend class is available under `qiskit.test.mock` for the `ibmq_guadalupe` backend. As with the other fake backends, this includes a snapshot of calibration data (i.e. `backend.defaults()`) and error data (i.e. `backend.properties()`) taken from the real system, and can be used for local testing, compilation and simulation.

*   A new method [`children()`](qiskit.pulse.Schedule#children "qiskit.pulse.Schedule.children") for the [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") class has been added. This method is used to return the child schedule components of the [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") object as a tuple. It returns nested schedules without flattening. This method is equivalent to the private `_children()` method but has a public and stable interface.

*   A new optimizer class, [`GradientDescent`](qiskit.algorithms.optimizers.GradientDescent "qiskit.algorithms.optimizers.GradientDescent"), has been added to the [`qiskit.algorithms.optimizers`](qiskit.algorithms.optimizers#module-qiskit.algorithms.optimizers "qiskit.algorithms.optimizers") module. This optimizer class implements a standard gradient descent optimization algorithm for use with quantum variational algorithms, such as [`VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE"). For a detailed description and examples on how to use this class, please refer to the [`GradientDescent`](qiskit.algorithms.optimizers.GradientDescent "qiskit.algorithms.optimizers.GradientDescent") class documentation.

*   A new optimizer class, [`QNSPSA`](qiskit.algorithms.optimizers.QNSPSA "qiskit.algorithms.optimizers.QNSPSA"), has been added to the [`qiskit.algorithms.optimizers`](qiskit.algorithms.optimizers#module-qiskit.algorithms.optimizers "qiskit.algorithms.optimizers") module. This class implements the [Quantum Natural SPSA (QN-SPSA)](https://arxiv.org/abs/2103.09232) algorithm, a generalization of the 2-SPSA algorithm, and estimates the Quantum Fisher Information Matrix instead of the Hessian to obtain a stochastic estimate of the Quantum Natural Gradient. For examples on how to use this new optimizer refer to the [`QNSPSA`](qiskit.algorithms.optimizers.QNSPSA "qiskit.algorithms.optimizers.QNSPSA") class documentation.

*   A new kwarg, `second_order`, has been added to the constructor of the [`SPSA`](qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA") class in the [`qiskit.algorithms.optimizers`](qiskit.algorithms.optimizers#module-qiskit.algorithms.optimizers "qiskit.algorithms.optimizers") module. When set to `True` this enables using [second-order SPSA](https://ieeexplore.ieee.org/document/657661). Second order SPSA, or 2-SPSA, is an extension of the ordinary SPSA algorithm that enables estimating the Hessian alongside the gradient, which is used to precondition the gradient before the parameter update step. As a second-order method, this tries to improve convergence of SPSA. For examples on how to use this option refer to the [`SPSA`](qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA") class documentation.

*   When using the `latex` or `latex_source` output mode of [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") or the [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") the `style` kwarg can now be used just as with the `mpl` output formatting. However, unlike the `mpl` output mode only the `displaytext` field will be used when using the `latex` or `latex_source` output modes (because neither supports color).

*   When using the `mpl` or `latex` output methods for the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function or the [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"), you can now use math mode formatting for text and set color formatting (`mpl` only) by setting the `style` kwarg as a dict with a user-generated name or label. For example, to add subscripts and to change a gate color:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.circuit.library import HGate
    qc = QuantumCircuit(3)
    qc.append(HGate(label='h1'), [0])
    qc.append(HGate(label='h2'), [1])
    qc.append(HGate(label='h3'), [2])
    qc.draw('mpl', style={'displaytext': {'h1': 'H_1', 'h2': 'H_2', 'h3': 'H_3'},
        'displaycolor': {'h2': ('#EEDD00', '#FF0000')}})
    ```

*   Added three new classes, [`CDKMRippleCarryAdder`](qiskit.circuit.library.CDKMRippleCarryAdder "qiskit.circuit.library.CDKMRippleCarryAdder"), `ClassicalAdder` and [`DraperQFTAdder`](qiskit.circuit.library.DraperQFTAdder "qiskit.circuit.library.DraperQFTAdder"), to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module. These new circuit classes are used to perform classical addition of two equally-sized qubit registers. For two registers $|a\rangle_n$ and $|b\rangle_n$ on $n$ qubits, the three new classes perform the operation:

    $$
    |a\rangle_n |b\rangle_n \mapsto |a\rangle_n |a + b\rangle_{n + 1}.
    $$

    For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import CDKMRippleCarryAdder
    from qiskit.quantum_info import Statevector

    # a encodes |01> = 1
    a = QuantumCircuit(2)
    a.x(0)

    # b encodes |10> = 2
    b = QuantumCircuit(2)
    b.x(1)

    # adder on 2-bit numbers
    adder = CDKMRippleCarryAdder(2)

    # add the state preparations to the front of the circuit
    adder.compose(a, [0, 1], inplace=True, front=True)
    adder.compose(b, [2, 3], inplace=True, front=True)

    # simulate and get the state of all qubits
    sv = Statevector(adder)
    counts = sv.probabilities_dict()
    state = list(counts.keys())[0]  # we only have a single state

    # skip the input carry (first bit) and the register |a> (last two bits)
    result = state[1:-2]
    print(result)  # '011' = 3 = 1 + 2
    ```

*   Added two new classes, [`RGQFTMultiplier`](qiskit.circuit.library.RGQFTMultiplier "qiskit.circuit.library.RGQFTMultiplier") and [`HRSCumulativeMultiplier`](qiskit.circuit.library.HRSCumulativeMultiplier "qiskit.circuit.library.HRSCumulativeMultiplier"), to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module. These classes are used to perform classical multiplication of two equally-sized qubit registers. For two registers $|a\rangle_n$ and $|b\rangle_n$ on $n$ qubits, the two new classes perform the operation

    $$
    |a\rangle_n |b\rangle_n |0\rangle_{2n} \mapsto |a\rangle_n |b\rangle_n |a \cdot b\rangle_{2n}.
    $$

    For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import RGQFTMultiplier
    from qiskit.quantum_info import Statevector

    num_state_qubits = 2

    # a encodes |11> = 3
    a = QuantumCircuit(num_state_qubits)
    a.x(range(num_state_qubits))

    # b encodes |11> = 3
    b = QuantumCircuit(num_state_qubits)
    b.x(range(num_state_qubits))

    # multiplier on 2-bit numbers
    multiplier = RGQFTMultiplier(num_state_qubits)

    # add the state preparations to the front of the circuit
    multiplier.compose(a, [0, 1], inplace=True, front=True)
    multiplier.compose(b, [2, 3], inplace=True, front=True)

    # simulate and get the state of all qubits
    sv = Statevector(multiplier)
    counts = sv.probabilities_dict(decimals=10)
    state = list(counts.keys())[0]  # we only have a single state

    # skip both input registers
    result = state[:-2*num_state_qubits]
    print(result)  # '1001' = 9 = 3 * 3
    ```

*   The [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") class now can accept a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") or [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") value for the `duration` kwarg on its constructor and for its [`duration`](qiskit.circuit.Delay#duration "qiskit.circuit.Delay.duration") attribute.

    For example:

    ```python
    idle_dur = Parameter('t')
    qc = QuantumCircuit(1, 1)
    qc.x(0)
    qc.delay(idle_dur, 0, 'us')
    qc.measure(0, 0)
    print(qc)  # parameterized delay in us (micro seconds)

    # assign before transpilation
    assigned = qc.assign_parameters({idle_dur: 0.1})
    print(assigned)  # delay in us
    transpiled = transpile(assigned, some_backend_with_dt)
    print(transpiled)  # delay in dt

    # assign after transpilation
    transpiled = transpile(qc, some_backend_with_dt)
    print(transpiled)  # parameterized delay in dt
    assigned = transpiled.assign_parameters({idle_dur: 0.1})
    print(assigned)  # delay in dt
    ```

*   A new binary serialization format, QPY, has been introduced. It is designed to be a fast binary serialization format that is backwards compatible (QPY files generated with older versions of Qiskit can be loaded by newer versions of Qiskit) that is native to Qiskit. The QPY serialization tooling is available via the `qiskit.circuit.qpy_serialization` module. For example, to generate a QPY file:

    ```python
    from datetime import datetime

    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit import qpy_serialization

    qc = QuantumCircuit(
      2, metadata={'created_at': datetime.utcnow().isoformat()}
    )
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    circuits = [qc] * 5

    with open('five_bells.qpy', 'wb') as qpy_file:
        qpy_serialization.dump(circuits, qpy_file)
    ```

    Then the five circuits saved in the QPY file can be loaded with:

    ```python
    from qiskit.circuit.qpy_serialization

    with open('five_bells.qpy', 'rb') as qpy_file:
        circuits = qpy_serialization.load(qpy_file)
    ```

    The QPY file format specification is available in the module documentation.

*   The [`TwoQubitBasisDecomposer`](qiskit.quantum_info.TwoQubitBasisDecomposer "qiskit.quantum_info.TwoQubitBasisDecomposer") class has been updated to perform pulse optimal decompositions for a basis with CX, √X, and virtual Rz gates as described in [https://arxiv.org/pdf/2008.08571](https://arxiv.org/pdf/2008.08571). Pulse optimal here means that the duration of gates between the CX gates of the decomposition is reduced in exchange for possibly more local gates before or after all the CX gates such that, when composed into a circuit, there is the possibility of single qubit compression with neighboring gates reducing the overall sequence duration.

    A new keyword argument, `` `pulse_optimize ``, has been added to the constructor for [`TwoQubitBasisDecomposer`](qiskit.quantum_info.TwoQubitBasisDecomposer "qiskit.quantum_info.TwoQubitBasisDecomposer") to control this:

    *   `None`: Attempt pulse optimal decomposition. If a pulse optimal decomposition is unknown for the basis of the decomposer, drop back to the standard decomposition without warning. This is the default setting.
    *   `True`: Attempt pulse optimal decomposition. If a pulse optimal decomposition is unknown for the basis of the decomposer, raise QiskitError.
    *   `False`: Do not attempt pulse optimal decomposition.

    For example:

    ```python
    from qiskit.quantum_info import TwoQubitBasisDecomposer
    from qiskit.circuit.library import CXGate
    from qiskit.quantum_info import random_unitary

    unitary_matrix = random_unitary(4)

    decomposer = TwoQubitBasisDecomposer(CXGate(), euler_basis="ZSX", pulse_optimize=True)
    circuit = decomposer(unitary_matrix)
    ```

*   The transpiler pass `UnitarySynthesis` located in [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") has been updated to support performing pulse optimal decomposition. This is done primarily with the the `pulse_optimize` keyword argument which was added to the constructor and used to control whether pulse optimal synthesis is performed. The behavior of this kwarg mirrors the `pulse_optimize` kwarg in the [`TwoQubitBasisDecomposer`](qiskit.quantum_info.TwoQubitBasisDecomposer "qiskit.quantum_info.TwoQubitBasisDecomposer") class’s constructor. Additionally, the constructor has another new keyword argument, `synth_gates`, which is used to specify the list of gate names over which synthesis should be attempted. If `None` and `pulse_optimize` is `False` or `None`, use `"unitary"`. If None and pulse\_optimize is `True`, use `"unitary"` and `"swap"`. Since the direction of the CX gate in the synthesis is arbitrary, another keyword argument, `natural_direction`, is added to consider first a coupling map and then [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") durations in choosing for which direction of CX to generate the synthesis.

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler import PassManager, CouplingMap
    from qiskit.transpiler.passes import TrivialLayout, UnitarySynthesis
    from qiskit.test.mock import FakeVigo
    from qiskit.quantum_info.random import random_unitary

    backend = FakeVigo()
    conf = backend.configuration()
    coupling_map = CouplingMap(conf.coupling_map)
    triv_layout_pass = TrivialLayout(coupling_map)
    circ = QuantumCircuit(2)
    circ.unitary(random_unitary(4), [0, 1])
    unisynth_pass = UnitarySynthesis(
        basis_gates=conf.basis_gates,
        coupling_map=None,
        backend_props=backend.properties(),
        pulse_optimize=True,
        natural_direction=True,
        synth_gates=['unitary'])
    pm = PassManager([triv_layout_pass, unisynth_pass])
    optimal_circ = pm.run(circ)
    ```

*   A new basis option, `'XZX'`, was added for the `basis` argument [`OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") class.

*   Added a new method, [`get_instructions()`](qiskit.circuit.QuantumCircuit#get_instructions "qiskit.circuit.QuantumCircuit.get_instructions"), was added to the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This method is used to return all [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") objects in the circuit which have a [`name`](qiskit.circuit.Instruction#name "qiskit.circuit.Instruction.name") that matches the provided `name` argument along with its associated `qargs` and `cargs` lists of [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") and [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") objects.

*   A new optional extra `all` has been added to the qiskit-terra package. This enables installing all the optional requirements with a single extra, for example: `pip install 'qiskit-terra[all]'`, Previously, it was necessary to list all the extras individually to install all the optional dependencies simultaneously.

*   Added two new classes [`ProbDistribution`](qiskit.result.ProbDistribution "qiskit.result.ProbDistribution") and [`QuasiDistribution`](qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution") for dealing with probability distributions and quasiprobability distributions respectively. These objects both are dictionary subclasses that add additional methods for working with probability and quasiprobability distributions.

*   Added a new [`settings`](qiskit.algorithms.optimizers.Optimizer#settings "qiskit.algorithms.optimizers.Optimizer.settings") property to the [`Optimizer`](qiskit.algorithms.optimizers.Optimizer "qiskit.algorithms.optimizers.Optimizer") abstract base class that all the optimizer classes in the [`qiskit.algorithms.optimizers`](qiskit.algorithms.optimizers#module-qiskit.algorithms.optimizers "qiskit.algorithms.optimizers") module are based on. This property will return a Python dictionary of the settings for the optimizer that can be used to instantiate another instance of the same optimizer class. For example:

    ```python
    from qiskit.algorithms.optimizers import GradientDescent

    optimizer = GradientDescent(maxiter=10, learning_rate=0.01)
    settings = optimizer.settings
    new_optimizer = GradientDescent(**settings)
    ```

    The `settings` dictionary is also potentially useful for serializing optimizer objects using JSON or another serialization format.

*   A new function, `set_config()`, has been added to the `qiskit.user_config` module. This function enables setting values in a user config from the Qiskit API. For example:

    ```python
    from qiskit.user_config import set_config
    set_config("circuit_drawer", "mpl", section="default", file="settings.conf")
    ```

    which will result in adding a value of `circuit_drawer = mpl` to the `default` section in the `settings.conf` file.

    If no `file_path` argument is specified, the currently used path to the user config file (either the value of the `QISKIT_SETTINGS` environment variable if set or the default location `~/.qiskit/settings.conf`) will be updated. However, changes to the existing config file will not be reflected in the current session since the config file is parsed at import time.

*   Added a new state class, [`StabilizerState`](qiskit.quantum_info.StabilizerState "qiskit.quantum_info.StabilizerState"), to the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module. This class represents a stabilizer simulator state using the convention from [Aaronson and Gottesman (2004)](https://arxiv.org/abs/quant-ph/0406196).

*   Two new options, `'value'` and `'value_desc'` were added to the `sort` kwarg of the [`qiskit.visualization.plot_histogram()`](qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram") function. When `sort` is set to either of these options the output visualization will sort the x axis based on the maximum probability for each bitstring. For example:

    ```python
    from qiskit.visualization import plot_histogram

    counts = {
      '000': 5,
      '001': 25,
      '010': 125,
      '011': 625,
      '100': 3125,
      '101': 15625,
      '110': 78125,
      '111': 390625,
    }
    plot_histogram(counts, sort='value')
    ```

<span id="release-notes-0-18-0-known-issues" />

<span id="id243" />

#### Known Issues

*   When running [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") (and functions that internally call [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") such as [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble")) on Python 3.9 with `QISKIT_PARALLEL` set to True in some scenarios it is possible for the program to deadlock and never finish running. To avoid this from happening the default for Python 3.9 was changed to not run in parallel, but if `QISKIT_PARALLEL` is explicitly enabled then this can still occur.

<span id="release-notes-0-18-0-upgrade-notes" />

<span id="id244" />

#### Upgrade Notes

*   The minimum version of the [retworkx](https://pypi.org/project/retworkx/) dependency was increased to version 0.9.0. This was done to use new APIs introduced in that release which improved the performance of some transpiler passes.

*   The default value for `QISKIT_PARALLEL` on Python 3.9 environments has changed to `False`, this means that when running on Python 3.9 by default multiprocessing will not be used. This was done to avoid a potential deadlock/hanging issue that can occur when running multiprocessing on Python 3.9 (see the known issues section for more detail). It is still possible to manual enable it by explicitly setting the `QISKIT_PARALLEL` environment variable to `TRUE`.

*   The existing fake backend classes in `qiskit.test.mock` now strictly implement the [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") interface. This means that if you were manually constructing [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") or [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") object for use with the `run()` method this will no longer work. The `run()` method only accepts [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") or [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") objects now. This was necessary to enable testing of new backends implemented without qobj which previously did not have any testing inside qiskit terra. If you need to leverage the fake backends with [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") or [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") new fake legacy backend objects were added to explicitly test the legacy providers interface. This will be removed after the legacy interface is deprecated and removed. Moving forward new fake backends will only implement the [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") interface and will not add new legacy backend classes for new fake backends.

*   When creating a [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") object with an invalid string label, a [`QiskitError`](exceptions#qiskit.exceptions.QiskitError "qiskit.exceptions.QiskitError") is now raised. This is a change from previous releases which would raise an `AttributeError` on an invalid string label. This change was made to ensure the error message is more informative and distinct from a generic `AttributeError`.

*   The output program representation from the pulse builder ([`qiskit.pulse.builder.build()`](pulse#qiskit.pulse.builder.build "qiskit.pulse.builder.build")) has changed from a [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") to a [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"). This new representation disables some timing related operations such as shift and insert. However, this enables parameterized instruction durations within the builder context. For example:

    ```python
    from qiskit import pulse
    from qiskit.circuit import Parameter

    dur = Parameter('duration')

    with pulse.build() as sched:
        with pulse.align_sequential():
            pulse.delay(dur, pulse.DriveChannel(1))
            pulse.play(pulse.Gaussian(dur, 0.1, dur/4), pulse.DriveChannel(0))

    assigned0 = sched.assign_parameters({dur: 100})
    assigned1 = sched.assign_parameters({dur: 200})
    ```

    You can directly pass the duration-assigned schedules to the assembler (or backend), or you can attach them to your quantum circuit as pulse gates.

*   The [tweedledum](https://pypi.org/project/tweedledum/) library which was previously an optional dependency has been made a requirement. This was done because of the wide use of the [`PhaseOracle`](qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") (which depends on having tweedledum installed) with several algorithms from [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms").

*   The optional extra `full-featured-simulators` which could previously used to install `qiskit-aer` with something like `pip install qiskit-terra[full-featured-simulators]` has been removed from the qiskit-terra package. If this was being used to install `qiskit-aer` with `qiskit-terra` instead you should rely on the [qiskit](https://pypi.org/project/qiskit/) metapackage or just install qiskit-terra and qiskit-aer together with `pip install qiskit-terra qiskit-aer`.

*   A new requirement [symengine](https://pypi.org/project/symengine) has been added for Linux (on x86\_64, aarch64, and ppc64le) and macOS users (x86\_64 and arm64). It is an optional dependency on Windows (and available on PyPi as a precompiled package for 64bit Windows) and other architectures. If it is installed it provides significantly improved performance for the evaluation of [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") and [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects.

*   All library circuit classes, i.e. all [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") derived classes in [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library"), are now wrapped in a [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") (or [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate"), if they are unitary). For example, importing and drawing the [`QFT`](qiskit.circuit.library.QFT "qiskit.circuit.library.QFT") circuit:

    before looked like

    ```python
                                              ┌───┐
    q_0: ────────────────────■────────■───────┤ H ├─X─
                       ┌───┐ │        │P(π/2) └───┘ │
    q_1: ──────■───────┤ H ├─┼────────■─────────────┼─
         ┌───┐ │P(π/2) └───┘ │P(π/4)                │
    q_2: ┤ H ├─■─────────────■──────────────────────X─
         └───┘
    ```

    and now looks like

    ```python
         ┌──────┐
    q_0: ┤0     ├
         │      │
    q_1: ┤1 QFT ├
         │      │
    q_2: ┤2     ├
         └──────┘
    ```

    To obtain the old circuit, you can call the [`decompose()`](qiskit.circuit.QuantumCircuit#decompose "qiskit.circuit.QuantumCircuit.decompose") method on the circuit

    This change was primarily made for consistency as before this release some circuit classes in [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") were previously wrapped in an [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") or [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") but not all.

<span id="release-notes-0-18-0-deprecation-notes" />

<span id="id245" />

#### Deprecation Notes

*   The class `qiskit.exceptions.QiskitIndexError` is deprecated and will be removed in a future release. This exception was not actively being used by anything in Qiskit, if you were using it you can create a custom exception class to replace it.
*   The kwargs `epsilon` and `factr` for the [`qiskit.algorithms.optimizers.L_BFGS_B`](qiskit.algorithms.optimizers.L_BFGS_B "qiskit.algorithms.optimizers.L_BFGS_B") constructor and `factr` kwarg of the [`P_BFGS`](qiskit.algorithms.optimizers.P_BFGS "qiskit.algorithms.optimizers.P_BFGS") optimizer class are deprecated and will be removed in a future release. Instead, please use the `eps` karg instead of `epsilon`. The `factr` kwarg is replaced with `ftol`. The relationship between the two is `ftol = factr * numpy.finfo(float).eps`. This change was made to be consistent with the usage of the `scipy.optimize.minimize` functions `'L-BFGS-B'` method. See the: `scipy.optimize.minimize(method='L-BFGS-B')` [documentation](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-lbfgsb.html) for more information on how these new parameters are used.
*   The legacy providers interface, which consisted of the `qiskit.providers.BaseBackend`, `qiskit.providers.BaseJob`, and `qiskit.providers.BaseProvider` abstract classes, has been deprecated and will be removed in a future release. Instead you should use the versioned interface, which the current abstract class versions are [`qiskit.providers.BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1"), [`qiskit.providers.JobV1`](qiskit.providers.JobV1 "qiskit.providers.JobV1"), and [`qiskit.providers.ProviderV1`](qiskit.providers.ProviderV1 "qiskit.providers.ProviderV1"). The V1 objects are mostly backwards compatible to ease migration from the legacy interface to the versioned one. However, expect future versions of the abstract interfaces to diverge more. You can refer to the [`qiskit.providers`](providers#module-qiskit.providers "qiskit.providers") documentation for more high level details about the versioned interface.
*   The `condition` kwarg to the [`DAGDepNode`](qiskit.dagcircuit.DAGDepNode "qiskit.dagcircuit.DAGDepNode") constructor along with the corresponding `condition` attribute of the [`DAGDepNode`](qiskit.dagcircuit.DAGDepNode "qiskit.dagcircuit.DAGDepNode") have been deprecated and will be removed in a future release. Instead, you can access the `condition` of a `DAGDepNode` if the node is of type `op`, by using `DAGDepNode.op.condition`.
*   The `condition` attribute of the [`DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") class has been deprecated and will be removed in a future release. Instead, you can access the `condition` of a `DAGNode` object if the node is of type `op`, by using `DAGNode.op.condition`.
*   The pulse builder ([`qiskit.pulse.builder.build()`](pulse#qiskit.pulse.builder.build "qiskit.pulse.builder.build")) syntax `qiskit.pulse.builder.inline()` is deprecated and will be removed in a future release. Instead of using this context, you can just remove alignment contexts within the inline context.
*   The pulse builder ([`qiskit.pulse.builder.build()`](pulse#qiskit.pulse.builder.build "qiskit.pulse.builder.build")) syntax `qiskit.pulse.builder.pad()` is deprecated and will be removed in a future release. This was done because the [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") now being returned by the pulse builder doesn’t support the `.insert` method (and there is no insert syntax in the builder). The use of timeslot placeholders to block the insertion of other instructions is no longer necessary.

<span id="release-notes-0-18-0-bug-fixes" />

<span id="id246" />

#### Bug Fixes

*   The [`OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") and [`TwoQubitBasisDecomposer`](qiskit.quantum_info.TwoQubitBasisDecomposer "qiskit.quantum_info.TwoQubitBasisDecomposer") classes for one and two qubit gate synthesis have been improved to tighten up tolerances, improved repeatability and simplification, and fix several global-phase-tracking bugs.

*   Fixed an issue in the assignment of the [`name`](qiskit.circuit.Gate#name "qiskit.circuit.Gate.name") attribute to [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") generated by multiple calls to the ``inverse`()`` method. Prior to this fix when the ``inverse`()`` was called it would unconditionally append `_dg` on each call to inverse. This has been corrected so on a second call of ``inverse`()`` the `_dg` suffix is now removed.

*   Fixes the triviality check conditions of [`CZGate`](qiskit.circuit.library.CZGate "qiskit.circuit.library.CZGate"), [`CRZGate`](qiskit.circuit.library.CRZGate "qiskit.circuit.library.CRZGate"), [`CU1Gate`](qiskit.circuit.library.CU1Gate "qiskit.circuit.library.CU1Gate") and `MCU1Gate` in the [`HoareOptimizer`](qiskit.transpiler.passes.HoareOptimizer "qiskit.transpiler.passes.HoareOptimizer") pass. Previously, in some cases the optimizer would remove these gates breaking the semantic equivalence of the transformation.

*   Fixed an issue when converting a [`ListOp`](qiskit.opflow.list_ops.ListOp "qiskit.opflow.list_ops.ListOp") object of [`PauliSumOp`](qiskit.opflow.primitive_ops.PauliSumOp "qiskit.opflow.primitive_ops.PauliSumOp") objects using [`PauliExpectation`](qiskit.opflow.expectations.PauliExpectation "qiskit.opflow.expectations.PauliExpectation") or [`AerPauliExpectation`](qiskit.opflow.expectations.AerPauliExpectation "qiskit.opflow.expectations.AerPauliExpectation"). Previously, it would raise a warning about it converting to a Pauli representation which is potentially expensive. This has been fixed by instead of internally converting the [`ListOp`](qiskit.opflow.list_ops.ListOp "qiskit.opflow.list_ops.ListOp") to a [`SummedOp`](qiskit.opflow.list_ops.SummedOp "qiskit.opflow.list_ops.SummedOp") of [`PauliOp`](qiskit.opflow.primitive_ops.PauliOp "qiskit.opflow.primitive_ops.PauliOp") objects, it now creates a [`PauliSumOp`](qiskit.opflow.primitive_ops.PauliSumOp "qiskit.opflow.primitive_ops.PauliSumOp") which is more efficient. Fixed [#6159](https://github.com/Qiskit/qiskit-terra/issues/6159)

*   Fixed an issue with the [`NLocal`](qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") class in the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module where it wouldn’t properly raise an exception at object initialization if an invalid type was used for the `reps` kwarg which would result in an unexpected runtime error later. A `TypeError` will now be properly raised if the `reps` kwarg is not an `int` value. Fixed [#6515](https://github.com/Qiskit/qiskit-terra/issues/6515)

*   Fixed an issue where the [`TwoLocal`](qiskit.circuit.library.TwoLocal "qiskit.circuit.library.TwoLocal") class in the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module did not accept numpy integer types (e.g. `numpy.int32`, `numpy.int64`, etc) as a valid input for the `entanglement` kwarg. Fixed [#6455](https://github.com/Qiskit/qiskit-terra/issues/6455)

*   When loading an OpenQASM2 file or string with the `from_qasm_file()` or `from_qasm_str()` constructors for the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class, if the OpenQASM2 circuit contains an instruction with the name `delay` this will be mapped to a [`qiskit.circuit.Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") instruction. For example:

    ```python
    from qiskit import QuantumCircuit

    qasm = """OPENQASM 2.0;
    include "qelib1.inc";
    opaque delay(time) q;
    qreg q[1];
    delay(172) q[0];
    u3(0.1,0.2,0.3) q[0];
    """
    circuit = QuantumCircuit.from_qasm_str(qasm)
    circuit.draw()
    ```

    Fixed [#6510](https://github.com/Qiskit/qiskit-terra/issues/6510)

*   Fixed an issue with addition between [`PauliSumOp`](qiskit.opflow.primitive_ops.PauliSumOp "qiskit.opflow.primitive_ops.PauliSumOp") objects that had [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") coefficients. Previously this would result in a `QiskitError` exception being raised because the addition of the [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") was not handled correctly. This has been fixed so that addition can be performed between [`PauliSumOp`](qiskit.opflow.primitive_ops.PauliSumOp "qiskit.opflow.primitive_ops.PauliSumOp") objects with [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") coefficients.

*   Fixed an issue with the initialization of the [`AmplificationProblem`](qiskit.algorithms.AmplificationProblem "qiskit.algorithms.AmplificationProblem") class. The `is_good_state` kwarg was a required field but incorrectly being treated as optional (and documented as such). This has been fixed and also updated so unless the input `oracle` is a [`PhaseOracle`](qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") object (which provides it’s on evaluation method) the field is required and will raise a `TypeError` when constructed without `is_good_state`.

*   Fixed an issue where adding a control to a [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") with open controls would unset the inner open controls. Fixes [#5857](https://github.com/Qiskit/qiskit-terra/issues/5857)

*   Fixed an issue with the [`convert()`](qiskit.opflow.expectations.PauliExpectation#convert "qiskit.opflow.expectations.PauliExpectation.convert") method of the [`PauliExpectation`](qiskit.opflow.expectations.PauliExpectation "qiskit.opflow.expectations.PauliExpectation") class where calling it on an operator that was non-Hermitian would return an incorrect result. Fixed [#6307](https://github.com/Qiskit/qiskit-terra/issues/6307)

*   Fixed an issue with the [`qiskit.pulse.transforms.inline_subroutines()`](pulse#qiskit.pulse.transforms.inline_subroutines "qiskit.pulse.transforms.inline_subroutines") function which would previously incorrectly not remove all the nested components when called on nested schedules. Fixed [#6321](https://github.com/Qiskit/qiskit-terra/issues/6321)

*   Fixed an issue when passing a partially bound callable created with the Python standard library’s `functools.partial()` function as the `schedule` kwarg to the [`add()`](qiskit.pulse.InstructionScheduleMap#add "qiskit.pulse.InstructionScheduleMap.add") method of the [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") class, which would previously result in an error. Fixed [#6278](https://github.com/Qiskit/qiskit-terra/issues/6278)

*   Fixed an issue with the [`PiecewiseChebyshev`](qiskit.circuit.library.PiecewiseChebyshev "qiskit.circuit.library.PiecewiseChebyshev") when setting the [`breakpoints`](qiskit.circuit.library.PiecewiseChebyshev#breakpoints "qiskit.circuit.library.PiecewiseChebyshev.breakpoints") to `None` on an existing object was incorrectly being treated as a breakpoint. This has been corrected so that when it is set to `None` this will switch back to the default behavior of approximating over the full interval. Fixed [#6198](https://github.com/Qiskit/qiskit-terra/issues/6198)

*   Fixed an issue with the [`num_connected_components()`](qiskit.circuit.QuantumCircuit#num_connected_components "qiskit.circuit.QuantumCircuit.num_connected_components") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") which was returning the incorrect number of components when the circuit contains two or more gates conditioned on classical registers. Fixed [#6477](https://github.com/Qiskit/qiskit-terra/issues/6477)

*   Fixed an issue with the [`qiskit.opflow.expectations`](qiskit.opflow.expectations#module-qiskit.opflow.expectations "qiskit.opflow.expectations") module where coefficients of a statefunction were not being multiplied correctly. This also fixed the calculations of Gradients and QFIs when using the [`PauliExpectation`](qiskit.opflow.expectations.PauliExpectation "qiskit.opflow.expectations.PauliExpectation") or [`AerPauliExpectation`](qiskit.opflow.expectations.AerPauliExpectation "qiskit.opflow.expectations.AerPauliExpectation") classes. For example, previously:

    ```python
    from qiskit.opflow import StateFn, I, One

    exp = ~StateFn(I) @ (2 * One)
    ```

    evaluated to `2` for [`AerPauliExpectation`](qiskit.opflow.expectations.AerPauliExpectation "qiskit.opflow.expectations.AerPauliExpectation") and to `4` for other expectation converters. Since `~StateFn(I) @ (2 * One)` is a shorthand notation for `~(2 * One) @ I @ (2 * One)`, the now correct coefficient of `4` is returned for all expectation converters. Fixed [#6497](https://github.com/Qiskit/qiskit-terra/issues/6497)

*   Fixed the bug that caused `to_circuit()` to fail when `PauliOp` had a phase. At the same time, it was made more efficient to use `PauliGate`.

*   Fixed an issue where the QASM output generated by the [`qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") for composite gates such as [`MCXGate`](qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate") and its variants ( [`MCXGrayCode`](qiskit.circuit.library.MCXGrayCode "qiskit.circuit.library.MCXGrayCode"), [`MCXRecursive`](qiskit.circuit.library.MCXRecursive "qiskit.circuit.library.MCXRecursive"), and [`MCXVChain`](qiskit.circuit.library.MCXVChain "qiskit.circuit.library.MCXVChain")) would be incorrect. Now if a [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") in the circuit is not present in `qelib1.inc`, its definition is added to the output QASM string. Fixed [#4943](https://github.com/Qiskit/qiskit-terra/issues/4943) and [#3945](https://github.com/Qiskit/qiskit-terra/issues/3945)

*   Fixed an issue with the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). When using the `mpl` or `latex` output modes, with the `cregbundle` kwarg set to `False` and the `reverse_bits` kwarg set to `True`, the bits in the classical registers displayed in the same order as when `reverse_bits` was set to `False`.

*   Fixed an issue when using the `qiskit.extensions.Initialize` instruction which was not correctly setting the global phase of the synthesized definition when constructed. Fixed [#5320](https://github.com/Qiskit/qiskit-terra/issues/5230)

*   Fixed an issue where the bit-order in [`qiskit.circuit.library.PhaseOracle.evaluate_bitstring()`](qiskit.circuit.library.PhaseOracle#evaluate_bitstring "qiskit.circuit.library.PhaseOracle.evaluate_bitstring") did not agree with the order of the measured bitstring. This fix also affects the execution of the [`Grover`](qiskit.algorithms.Grover "qiskit.algorithms.Grover") algorithm class if the oracle is specified as a [`PhaseOracle`](qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle"), which now will now correctly identify the correct bitstring. Fixed [#6314](https://github.com/Qiskit/qiskit-terra/issues/6314)

*   Fixes a bug in [`Optimize1qGatesDecomposition()`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") previously causing certain short sequences of gates to erroneously not be rewritten.

*   Fixed an issue in the `qiskit.opflow.gradients.Gradient.gradient_wrapper()` method with the gradient calculation. Previously, if the operator was not diagonal an incorrect result would be returned in some situations. This has been fixed by using an expectation converter to ensure the result is always correct.

*   Fixed an issue with the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with all output modes where it would incorrectly render a custom instruction that includes classical bits in some circumstances. Fixed [#3201](https://github.com/Qiskit/qiskit-terra/issues/3201), [#3202](https://github.com/Qiskit/qiskit-terra/issues/3202), and [#6178](https://github.com/Qiskit/qiskit-terra/issues/6178)

*   Fixed an issue in [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and the [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method of the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class when using the `mpl` output mode, controlled-Z Gates were incorrectly drawn as asymmetrical. Fixed [#5981](https://github.com/Qiskit/qiskit-terra/issues/5981)

*   Fixed an issue with the `OptimizeSwapBeforeMeasure` transpiler pass where in some situations a [`SwapGate`](qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") that that contained a classical condition would be removed. Fixed [#6192](https://github.com/Qiskit/qiskit-terra/issues/6192)

*   Fixed an issue with the phase of the [`qiskit.opflow.gradients.QFI`](qiskit.opflow.gradients.QFI "qiskit.opflow.gradients.QFI") class when the `qfi_method` is set to `lin_comb_full` which caused the incorrect observable to be evaluated.

*   Fixed an issue with [`VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE") algorithm class when run with the [`L_BFGS_B`](qiskit.algorithms.optimizers.L_BFGS_B "qiskit.algorithms.optimizers.L_BFGS_B") or [`P_BFGS`](qiskit.algorithms.optimizers.P_BFGS "qiskit.algorithms.optimizers.P_BFGS") optimizer classes and gradients are used, the gradient was incorrectly passed as a numpy array instead of the expected list of floats resulting in an error. This has been resolved so you can use gradients with [`VQE`](qiskit.algorithms.VQE "qiskit.algorithms.VQE") and the [`L_BFGS_B`](qiskit.algorithms.optimizers.L_BFGS_B "qiskit.algorithms.optimizers.L_BFGS_B") or [`P_BFGS`](qiskit.algorithms.optimizers.P_BFGS "qiskit.algorithms.optimizers.P_BFGS") optimizers.

<span id="release-notes-0-18-0-other-notes" />

<span id="id247" />

#### Other Notes

*   The deprecation of the `parameters()` method for the `Instruction` class has been reversed. This method was originally deprecated in the 0.17.0, but it is still necessary for several applications, including when running calibration experiments. This method will continue to be supported and will **not** be removed.

<span id="id248" />

### Aer 0.8.2

No change

<span id="id249" />

### Ignis 0.6.0

No change

<span id="id250" />

### Aqua 0.9.4

No change

<span id="ibm-q-provider-0-15-0" />

### IBM Q Provider 0.15.0

<span id="release-notes-ibmq-0-15-0-new-features" />

<span id="id251" />

#### New Features

*   Add support for new method `qiskit.providers.ibmq.runtime.RuntimeJob.error_message()` which will return a string representing the reason if the job failed.

*   The inputs parameter to `qiskit.providers.ibmq.runtime.IBMRuntimeService.run()` method can now be specified as a `qiskit.providers.ibmq.runtime.ParameterNamespace` instance which supports auto-complete features. You can use `qiskit.providers.ibmq.runtime.RuntimeProgram.parameters()` to retrieve an `ParameterNamespace` instance.

    For example:

    ```python
    from qiskit import IBMQ

    provider = IBMQ.load_account()

    # Set the "sample-program" program parameters.
    params = provider.runtime.program(program_id="sample-program").parameters()
    params.iterations = 2

    # Configure backend options
    options = {'backend_name': 'ibmq_qasm_simulator'}

    # Execute the circuit using the "circuit-runner" program.
    job = provider.runtime.run(program_id="sample-program",
                               options=options,
                               inputs=params)
    ```

*   The user can now set the visibility (private/public) of a Qiskit Runtime program using `qiskit.providers.ibmq.runtime.IBMRuntimeService.set_program_visibility()`.

*   An optional boolean parameter pending has been added to `qiskit.providers.ibmq.runtime.IBMRuntimeService.jobs()` and it allows filtering jobs by their status. If pending is not specified all jobs are returned. If pending is set to True, ‘QUEUED’ and ‘RUNNING’ jobs are returned. If pending is set to False, ‘DONE’, ‘ERROR’ and ‘CANCELLED’ jobs are returned.

*   Add support for the `use_measure_esp` flag in the `qiskit.providers.ibmq.IBMQBackend.run()` method. If `True`, the backend will use ESP readout for all measurements which are the terminal instruction on that qubit. If used and the backend does not support ESP readout, an error is raised.

<span id="release-notes-ibmq-0-15-0-upgrade-notes" />

<span id="id252" />

#### Upgrade Notes

*   `qiskit.providers.ibmq.runtime.RuntimeProgram.parameters()` is now a method that returns a `qiskit.providers.ibmq.runtime.ParameterNamespace` instance, which you can use to fill in runtime program parameter values and pass to `qiskit.providers.ibmq.runtime.IBMRuntimeService.run()`.
*   The `open_pulse` flag in backend configuration no longer indicates whether a backend supports pulse-level control. As a result, `qiskit.providers.ibmq.IBMQBackend.configuration()` may return a [`PulseBackendConfiguration`](qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") instance even if its `open_pulse` flag is `False`.
*   Job share level is no longer supported due to low adoption and the corresponding interface will be removed in a future release. This means you should no longer pass share\_level when creating a job or use `qiskit.providers.ibmq.job.IBMQJob.share_level()` method to get a job’s share level.

<span id="release-notes-ibmq-0-15-0-deprecation-notes" />

<span id="id253" />

#### Deprecation Notes

*   The `id` instruction has been deprecated on IBM hardware backends. Instead, please use the `delay` instruction which implements variable-length delays, specified in units of `dt`. When running a circuit containing an `id` instruction, a warning will be raised on job submission and any `id` instructions in the job will be automatically replaced with their equivalent `delay` instruction.

<span id="qiskit-0-27-0" />

## Qiskit 0.27.0

<span id="terra-0-17-4" />

### Terra 0.17.4

No change

<span id="id254" />

### Aer 0.8.2

No change

<span id="id255" />

### Ignis 0.6.0

No change

<span id="aqua-0-9-2" />

### Aqua 0.9.2

<span id="release-notes-aqua-0-9-2-fixes" />

<span id="id256" />

#### Bug Fixes

*   Removed version caps from the requirements list to enable installing with newer versions of dependencies.

<span id="ibm-q-provider-0-14-0" />

### IBM Q Provider 0.14.0

<span id="release-notes-ibmq-0-14-0-new-features" />

<span id="id257" />

#### New Features

*   You can now use the `qiskit.providers.ibmq.runtime.RuntimeJob.logs()` method to retrieve job logs. Note that logs are only available after the job finishes.

*   A new backend configuration attribute `input_allowed` now tells you the types of input supported by the backend. Valid input types are `job`, which means circuit jobs, and `runtime`, which means Qiskit Runtime.

    You can also use `input_allowed` in backend filtering. For example:

    ```python
    from qiskit import IBMQ

    provider = IBMQ.load_account()
    # Get a list of all backends that support runtime.
    runtime_backends = provider.backends(input_allowed='runtime')
    ```

<span id="release-notes-ibmq-0-14-0-upgrade-notes" />

<span id="id258" />

#### Upgrade Notes

*   `qiskit-ibmq-provider` now uses a new package `websocket-client` as its websocket client, and packages `websockets` and `nest-asyncio` are no longer required. `setup.py` and `requirements.txt` have been updated accordingly.

<span id="release-notes-ibmq-0-14-0-bug-fixes" />

<span id="id259" />

#### Bug Fixes

*   Fixes the issue that uses `shots=1` instead of the documented default when no `shots` is specified for `run_circuits()`.

*   Fixes the issue wherein a `QiskitBackendNotFoundError` exception is raised when retrieving a runtime job that was submitted using a different provider than the one used for retrieval.

*   Streaming runtime program interim results with proxies is now supported. You can specify the proxies to use when enabling the account as usual, for example:

    ```python
    from qiskit import IBMQ

    proxies = {'urls': {'https://127.0.0.1:8085'}}
    provider = IBMQ.enable_account(API_TOKEN, proxies=proxies)
    ```

<span id="qiskit-0-26-1" />

## Qiskit 0.26.1

<span id="release-notes-0-17-4" />

<span id="id260" />

### Terra 0.17.4

<span id="release-notes-0-17-4-bug-fixes" />

<span id="id261" />

#### Bug Fixes

*   Fixed an issue with the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") with [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") backends with the `` `max_experiments `` attribute set to a value less than the number of circuits to run. Previously the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") would not correctly split the circuits to run into separate jobs, which has been corrected.

<span id="id262" />

### Aer 0.8.2

No change

<span id="id263" />

### Ignis 0.6.0

No change

<span id="aqua-0-9-1" />

### Aqua 0.9.1

No change

<span id="ibm-q-provider-0-13-1" />

### IBM Q Provider 0.13.1

No change

<span id="qiskit-0-26-0" />

## Qiskit 0.26.0

<span id="terra-0-17-3" />

<span id="release-notes-0-17-3" />

### Terra 0.17.3

<span id="release-notes-0-17-3-prelude" />

<span id="id264" />

#### Prelude

This release includes 2 new classes, [`ProbDistribution`](qiskit.result.ProbDistribution "qiskit.result.ProbDistribution") and [`QuasiDistribution`](qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution"), which were needed for compatibility with the recent qiskit-ibmq-provider release’s beta support for the [qiskit-runtime](https://github.com/Qiskit-Partners/qiskit-runtime). These were only added for compatibility with that new feature in the qiskit-ibmq-provider release and the API for these classes is considered experimental and not considered stable for the 0.17.x release series. The interface may change when 0.18.0 is released in the future.

<span id="release-notes-0-17-3-bug-fixes" />

<span id="id265" />

#### Bug Fixes

*   Fixed an issue in [`plot_histogram()`](qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram") function where a `ValueError` would be raised when the function run on distributions with unequal lengths.

<span id="id266" />

### Aer 0.8.2

No change

<span id="id267" />

### Ignis 0.6.0

No change

<span id="id268" />

### Aqua 0.9.1

No change

<span id="id269" />

### IBM Q Provider 0.13.1

<span id="release-notes-ibmq-0-13-0-prelude" />

<span id="id270" />

#### Prelude

This release introduces a new feature `Qiskit Runtime Service`. Qiskit Runtime is a new architecture offered by IBM Quantum that significantly reduces waiting time during computational iterations. You can execute your experiments near the quantum hardware, without the interactions of multiple layers of classical and quantum hardware slowing it down.

Qiskit Runtime allows authorized users to upload their Qiskit quantum programs, which are Python code that takes certain inputs, performs quantum and maybe classical computation, and returns the processing results. The same or other authorized users can then invoke these quantum programs by simply passing in the required input parameters.

Note that Qiskit Runtime is currently in private beta for select account but will be released to the public in the near future.

<span id="release-notes-ibmq-0-13-0-new-features" />

<span id="id271" />

#### New Features

*   `qiskit.providers.ibmq.experiment.analysis_result.AnalysisResult` now has an additional `verified` attribute which identifies if the `quality` has been verified by a human.

*   `qiskit.providers.ibmq.experiment.Experiment` now has an additional `notes` attribute which can be used to set notes on an experiment.

*   This release introduces a new feature `Qiskit Runtime Service`. Qiskit Runtime is a new architecture that significantly reduces waiting time during computational iterations. This new service allows authorized users to upload their Qiskit quantum programs, which are Python code that takes certain inputs, performs quantum and maybe classical computation, and returns the processing results. The same or other authorized users can then invoke these quantum programs by simply passing in the required input parameters.

    An example of using this new service:

    ```python
    from qiskit import IBMQ

    provider = IBMQ.load_account()
    # Print all avaiable programs.
    provider.runtime.pprint_programs()

    # Prepare the inputs. See program documentation on input parameters.
    inputs = {...}
    options = {"backend_name": provider.backend.ibmq_montreal.name()}

    job = provider.runtime.run(program_id="runtime-simple",
                               options=options,
                               inputs=inputs)
    # Check job status.
    print(f"job status is {job.status()}")

    # Get job result.
    result = job.result()
    ```

<span id="release-notes-ibmq-0-13-0-upgrade-notes" />

<span id="id272" />

#### Upgrade Notes

*   The deprecated `Human Bad`, `Computer Bad`, `Computer Good` and `Human Good` enum values have been removed from `qiskit.providers.ibmq.experiment.constants.ResultQuality`. They are replaced with `Bad` and `Good` values which should be used with the `verified` attribute on `qiskit.providers.ibmq.experiment.analysis_result.AnalysisResult`:

    | Old Quality   | New Quality | Verified |
    | ------------- | ----------- | -------- |
    | Human Bad     | Bad         | True     |
    | Computer Bad  | Bad         | False    |
    | Computer Good | Good        | False    |
    | Human Good    | Good        | True     |

    Furthermore, the `NO_INFORMATION` enum has been renamed to `UNKNOWN`.

*   The `qiskit.providers.ibmq.IBMQBackend.defaults()` method now always returns pulse defaults if they are available, regardless whether open pulse is enabled for the provider.

<span id="release-notes-ibmq-0-13-0-bug-fixes" />

<span id="id273" />

#### Bug Fixes

*   Fixes the issue wherein passing in a noise model when sending a job to an IBMQ simulator would raise a `TypeError`. Fixes [#894](https://github.com/Qiskit/qiskit-ibmq-provider/issues/894)

<span id="release-notes-ibmq-0-13-0-other-notes" />

<span id="id275" />

#### Other Notes

*   The `qiskit.providers.ibmq.experiment.analysis_result.AnalysisResult` `fit` attribute is now optional.

<span id="qiskit-0-25-4" />

## Qiskit 0.25.4

<span id="terra-0-17-2" />

<span id="release-notes-0-17-2" />

### Terra 0.17.2

<span id="release-notes-0-17-2-prelude" />

<span id="id276" />

#### Prelude

This is a bugfix release that fixes several issues from the 0.17.1 release. Most importantly this release fixes compatibility for the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class when running on backends that are based on the [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") abstract class. This fixes all the algorithms and applications built on [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") or [`qiskit.opflow`](opflow#module-qiskit.opflow "qiskit.opflow") when running on newer backends.

<span id="release-notes-0-17-2-bug-fixes" />

<span id="id277" />

#### Bug Fixes

*   Fixed an issue with the [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") transpiler pass which in some cases would translate gates already in the target basis. This would potentially result in both longer execution time and less optimal results. Fixed [#6085](https://github.com/Qiskit/qiskit-terra/issues/6085)
*   Fixed an issue in the `SPSA` when the optimizer was initialized with a callback function via the `callback` kwarg would potentially cause an error to be raised.
*   Fixed an issue in the [`qiskit.quantum_info.Statevector.expectation_value()`](qiskit.quantum_info.Statevector#expectation_value "qiskit.quantum_info.Statevector.expectation_value") and ```qiskit.quantum_info.DensityMatrix.expectation_value`methods where the ``qargs`()``` kwarg was ignored if the operator was a [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") or [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") operator object. Fixed [#6303](https://github.com/Qiskit/qiskit-terra/issues/6303)
*   Fixed an issue in the [`qiskit.quantum_info.Pauli.evolve()`](qiskit.quantum_info.Pauli#evolve "qiskit.quantum_info.Pauli.evolve") method which could have resulted in the incorrect Pauli being returned when evolving by a [`CZGate`](qiskit.circuit.library.CZGate "qiskit.circuit.library.CZGate"), [`CYGate`](qiskit.circuit.library.CYGate "qiskit.circuit.library.CYGate"), or a [`SwapGate`](qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") gate.
*   Fixed an issue in the `qiskit.opflow.SparseVectorStateFn.to_dict_fn()` method, which previously had at most one entry for the all zero state due to an index error.
*   Fixed an issue in the `qiskit.opflow.SparseVectorStateFn.equals()` method so that is properly returning `True` or `False` instead of a sparse vector comparison of the single elements.
*   Fixes an issue in the [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") probability methods [`qiskit.quantum_info.Statevector.probabilities()`](qiskit.quantum_info.Statevector#probabilities "qiskit.quantum_info.Statevector.probabilities"), [`qiskit.quantum_info.Statevector.probabilities_dict()`](qiskit.quantum_info.Statevector#probabilities_dict "qiskit.quantum_info.Statevector.probabilities_dict"), [`qiskit.quantum_info.DensityMatrix.probabilities()`](qiskit.quantum_info.DensityMatrix#probabilities "qiskit.quantum_info.DensityMatrix.probabilities"), [`qiskit.quantum_info.DensityMatrix.probabilities_dict()`](qiskit.quantum_info.DensityMatrix#probabilities_dict "qiskit.quantum_info.DensityMatrix.probabilities_dict") where the returned probabilities could have incorrect ordering for certain values of the `qargs` kwarg. Fixed [#6320](https://github.com/Qiskit/qiskit-terra/issues/6320)
*   Fixed an issue where the `TaperedPauliSumOp` class did not support the multiplication with [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") object and also did not have a necessary `assign_parameters()` method for working with [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects. Fixed [#6127](https://github.com/Qiskit/qiskit-terra/issues/6127)
*   Fixed compatibility for the [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class when running on backends that are based on the [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") abstract class. Fixed [#6280](https://github.com/Qiskit/qiskit-terra/issues/6280)

<span id="id278" />

### Aer 0.8.2

No change

<span id="id279" />

### Ignis 0.6.0

No change

<span id="id280" />

### Aqua 0.9.1

No change

<span id="ibm-q-provider-0-12-3" />

### IBM Q Provider 0.12.3

No change

<span id="qiskit-0-25-3" />

## Qiskit 0.25.3

<span id="terra-0-17-1" />

### Terra 0.17.1

No change

<span id="release-notes-aer-0-8-2" />

<span id="id281" />

### Aer 0.8.2

<span id="release-notes-aer-0-8-2-known-issues" />

<span id="id282" />

#### Known Issues

*   The `SaveExpectationValue` and `SaveExpectationValueVariance` have been disabled for the extended\_stabilizer method of the `QasmSimulator` and `AerSimulator` due to returning the incorrect value for certain Pauli operator components. Refer to #1227 \<[https://github.com/Qiskit/qiskit-aer/issues/1227](https://github.com/Qiskit/qiskit-aer/issues/1227)> for more information and examples.

<span id="release-notes-aer-0-8-2-bug-fixes" />

<span id="id283" />

#### Bug Fixes

*   Fixes performance issue with how the `basis_gates` configuration attribute was set. Previously there were unintended side-effects to the backend class which could cause repeated simulation runtime to incrementally increase. Refer to #1229 \<[https://github.com/Qiskit/qiskit-aer/issues/1229](https://github.com/Qiskit/qiskit-aer/issues/1229)> for more information and examples.
*   Fixes a bug with the `"multiplexer"` simulator instruction where the order of target and control qubits was reversed to the order in the Qiskit instruction.
*   Fixes a bug introduced in 0.8.0 where GPU simulations would allocate unneeded host memory in addition to the GPU memory.
*   Fixes a bug in the `stabilizer` simulator method of the `QasmSimulator` and `AerSimulator` where the expectation value for the `save_expectation_value` and `snapshot_expectation_value` could have the wrong sign for certain `Y` Pauli’s.

<span id="id284" />

### Ignis 0.6.0

No change

<span id="id285" />

### Aqua 0.9.1

No change

<span id="id286" />

### IBM Q Provider 0.12.3

No change

<span id="qiskit-0-25-2" />

## Qiskit 0.25.2

<span id="id287" />

### Terra 0.17.1

No change

<span id="aer-0-8-1" />

### Aer 0.8.1

No change

<span id="id288" />

### Ignis 0.6.0

No change

<span id="id289" />

### Aqua 0.9.1

No change

<span id="id290" />

### IBM Q Provider 0.12.3

<span id="release-notes-ibmq-0-12-3-other-notes" />

<span id="id291" />

#### Other Notes

*   The `qiskit.providers.ibmq.experiment.analysis_result.AnalysisResult` `fit` attribute is now optional.

<span id="qiskit-0-25-1" />

## Qiskit 0.25.1

<span id="release-notes-0-17-1" />

<span id="id292" />

### Terra 0.17.1

<span id="release-notes-0-17-1-prelude" />

<span id="id293" />

#### Prelude

This is a bugfix release that fixes several issues from the 0.17.0 release. Most importantly this release fixes the incorrectly constructed sdist package for the 0.17.0 release which was not actually buildable and was blocking installation on platforms without precompiled binaries available.

<span id="release-notes-0-17-1-bug-fixes" />

<span id="id294" />

#### Bug Fixes

*   Fixed an issue where the [`global_phase`](qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") attribute would not be preserved in the output [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object when the [`qiskit.circuit.QuantumCircuit.reverse_bits()`](qiskit.circuit.QuantumCircuit#reverse_bits "qiskit.circuit.QuantumCircuit.reverse_bits") method was called. For example:

    ```python
    import math
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(3, 2, global_phase=math.pi)
    qc.h(0)
    qc.s(1)
    qc.cx(0, 1)
    qc.measure(0, 1)
    qc.x(0)
    qc.y(1)

    reversed = qc.reverse_bits()
    print(reversed.global_phase)
    ```

    will now correctly print $\pi$.

*   Fixed an issue where the transpiler pass [`Unroller`](qiskit.transpiler.passes.Unroller "qiskit.transpiler.passes.Unroller") didn’t preserve global phase in case of nested instructions with one rule in their definition. Fixed [#6134](https://github.com/Qiskit/qiskit-terra/issues/6134)

*   Fixed an issue where the `parameter` attribute of a [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") object built from a `UnitaryGate` was not being set to the unitary matrix of the `UnitaryGate` object. Previously, `control()` was building a [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") with the `parameter` attribute set to the controlled version of `UnitaryGate` matrix. This would lead to a modification of the `parameter` of the base `UnitaryGate` object and subsequent calls to [`inverse()`](qiskit.circuit.ControlledGate#inverse "qiskit.circuit.ControlledGate.inverse") was creating the inverse of a double-controlled `UnitaryGate`. Fixed [#5750](https://github.com/Qiskit/qiskit-terra/issues/5750)

*   Fixed an issue with the preset pass managers [`level_0_pass_manager`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_0_pass_manager "qiskit.transpiler.preset_passmanagers.level_0_pass_manager") and [`level_1_pass_manager`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager") (which corresponds to `optimization_level` 0 and 1 for [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile")) where in some cases they would produce circuits not in the requested basis.

*   Fix a bug where using [`SPSA`](qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA") with automatic calibration of the learning rate and perturbation (i.e. `learning_rate` and `perturbation` are `None` in the initializer), stores the calibration for all future optimizations. Instead, the calibration should be done for each new objective function.

<span id="aer-release-notes-0-8-1" />

<span id="id295" />

### Aer 0.8.1

<span id="aer-release-notes-0-8-1-bug-fixes" />

<span id="id296" />

#### Bug Fixes

*   Fixed an issue with use of the `matrix_product_state` method of the `AerSimulator` and `QasmSimulator` simulators when running a noisy simulation with Kraus errors. Previously, the matrix product state simulation method would not propogate changes to neighboring qubits after applying the Kraus matrix. This has been fixed so the output from the simulation is correct. Fixed [#1184](https://github.com/Qiskit/qiskit-aer/issues/1184) and [#1205](https://github.com/Qiskit/qiskit-aer/issues/1205)
*   Fixed an issue where the `qiskit.extensions.Initialize` instruction would disable measurement sampling optimization for the `statevector` and `matrix_product_state` simulation methods of the `AerSimulator` and `QasmSimulator` simulators, even when it was the first circuit instruction or applied to all qubits and hence deterministic. Fixed [#1210](https://github.com/Qiskit/qiskit-aer/issues/1210)
*   Fix an issue with the `SaveStatevector` and `SnapshotStatevector` instructions when used with the `extended_stabilizer` simulation method of the `AerSimulator` and `QasmSimulator` simulators where it would return an unnormalized statevector. Fixed [#1196](https://github.com/Qiskit/qiskit-aer/issues/1210)
*   The `matrix_product_state` simulation method now has support for it’s previously missing set state instruction, `qiskit.providers.aer.library.SetMatrixProductState`, which enables setting the state of a simulation in a circuit.

<span id="id297" />

### Ignis 0.6.0

No change

<span id="id298" />

### Aqua 0.9.1

<span id="ibm-q-provider-0-12-2" />

### IBM Q Provider 0.12.2

No change

<span id="qiskit-0-25-0" />

## Qiskit 0.25.0

This release officially deprecates the Qiskit Aqua project. Accordingly, in a future release the `qiskit-aqua` package will be removed from the Qiskit metapackage, which means in that future release `pip install qiskit` will no longer include `qiskit-aqua`. The application modules that are provided by qiskit-aqua have been split into several new packages: `qiskit-optimization`, `qiskit-nature`, `qiskit-machine-learning`, and `qiskit-finance`. These packages can be installed by themselves (via the standard pip install command, e.g. `pip install qiskit-nature`) or with the rest of the Qiskit metapackage as optional extras (e.g. `pip install 'qiskit[finance,optimization]'` or `pip install 'qiskit[all]'` The core algorithms and the operator flow now exist as part of qiskit-terra at [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") and [`qiskit.opflow`](opflow#module-qiskit.opflow "qiskit.opflow"). Depending on your existing usage of Aqua you should either use the application packages or the new modules in Qiskit Terra. For more details on how to migrate from Qiskit Aqua, you can refer to the [migration guide](https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide).

<span id="terra-0-17-0" />

<span id="release-notes-0-17-0" />

### Terra 0.17.0

<span id="release-notes-0-17-0-prelude" />

<span id="id299" />

#### Prelude

The Qiskit Terra 0.17.0 includes many new features and bug fixes. The major new feature for this release is the introduction of the [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") and [`qiskit.opflow`](opflow#module-qiskit.opflow "qiskit.opflow") modules which were migrated and adapted from the `qiskit.aqua` project.

<span id="release-notes-0-17-0-new-features" />

<span id="id300" />

#### New Features

*   The `qiskit.pulse.call()` function can now take a [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") object along with a parameterized subroutine. This enables assigning different values to the [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects for each subroutine call.

    For example,

    ```python
    from qiskit.circuit import Parameter
    from qiskit import pulse

    amp = Parameter('amp')

    with pulse.build() as subroutine:
        pulse.play(pulse.Gaussian(160, amp, 40), DriveChannel(0))

    with pulse.build() as main_prog:
        pulse.call(subroutine, amp=0.1)
        pulse.call(subroutine, amp=0.3)
    ```

*   The [`qiskit.providers.models.QasmBackendConfiguration`](qiskit.providers.models.QasmBackendConfiguration "qiskit.providers.models.QasmBackendConfiguration") has a new field `processor_type` which can optionally be used to provide information about a backend’s processor in the form: `{"family": <str>, "revision": <str>, segment: <str>}`. For example: `{"family": "Canary", "revision": "1.0", segment: "A"}`.

*   The [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule"), `qiskit.pulse.Instruction`, and `qiskit.pulse.Channel` classes now have a `parameter` property which will return any [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects used in the object and a [`is_parameterized()`](qiskit.pulse.Schedule#is_parameterized "qiskit.pulse.Schedule.is_parameterized") method which will return `True` if any parameters are used in the object.

    For example:

    ```python
    from qiskit.circuit import Parameter
    from qiskit import pulse

    shift = Parameter('alpha')

    schedule = pulse.Schedule()
    schedule += pulse.SetFrequency(shift, pulse.DriveChannel(0))

    assert schedule.is_parameterized() == True
    print(schedule.parameters)
    ```

*   Added a [`PiecewiseChebyshev`](qiskit.circuit.library.PiecewiseChebyshev "qiskit.circuit.library.PiecewiseChebyshev") to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") for implementing a piecewise Chebyshev approximation of an input function. For a given function $f(x)$ and degree $d$, this class class implements a piecewise polynomial Chebyshev approximation on $n$ qubits to $f(x)$ on the given intervals. All the polynomials in the approximation are of degree $d$.

    For example:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit
    from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
    f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
    pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
    pw_approximation._build()
    qc = QuantumCircuit(pw_approximation.num_qubits)
    qc.h(list(range(num_state_qubits)))
    qc.append(pw_approximation.to_instruction(), qc.qubits)
    qc.draw(output='mpl')
    ```

*   The [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") class now has a [`readout_length()`](qiskit.providers.models.BackendProperties#readout_length "qiskit.providers.models.BackendProperties.readout_length") method, which returns the readout length \[sec] of the given qubit.

*   A new class, [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"), has been added to the [`qiskit.pulse`](pulse#module-qiskit.pulse "qiskit.pulse") module. This class provides a new representation of a pulse program. This representation is best suited for the pulse builder syntax and is based on relative instruction ordering.

    This representation takes `alignment_context` instead of specifying starting time `t0` for each instruction. The start time of instruction is implicitly allocated with the specified transformation and relative position of instructions.

    The [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") allows for lazy instruction scheduling, meaning we can assign arbitrary parameters to the duration of instructions.

    For example:

    ```python
    from qiskit.pulse import ScheduleBlock, DriveChannel, Gaussian
    from qiskit.pulse.instructions import Play, Call
    from qiskit.pulse.transforms import AlignRight
    from qiskit.circuit import Parameter

    dur = Parameter('rabi_duration')

    block = ScheduleBlock(alignment_context=AlignRight())
    block += Play(Gaussian(dur, 0.1, dur/4), DriveChannel(0))
    block += Call(measure_sched)  # subroutine defined elsewhere
    ```

    this code defines an experiment scanning a Gaussian pulse’s duration followed by a measurement `measure_sched`, i.e. a Rabi experiment. You can reuse the `block` object for every scanned duration by assigning a target duration value.

*   Added a new function [`array_to_latex()`](qiskit.visualization.array_to_latex "qiskit.visualization.array_to_latex") to the [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization") module that can be used to represent and visualize vectors and matrices with LaTeX.

    ```python
    from qiskit.visualization import array_to_latex
    from numpy import sqrt, exp, pi
    mat = [[0, exp(pi*.75j)],
           [1/sqrt(8), 0.875]]
    array_to_latex(mat)
    ```

*   The [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes now have [`draw()`](qiskit.quantum_info.Statevector#draw "qiskit.quantum_info.Statevector.draw") methods which allow objects to be drawn as either text matrices, IPython Latex objects, Latex source, Q-spheres, Bloch spheres and Hinton plots. By default the output type is the equivalent output from `__repr__` but this default can be changed in a user config file by setting the `state_drawer` option. For example:

    ```python
    from qiskit.quantum_info import DensityMatrix
    dm = DensityMatrix.from_label('r0')
    dm.draw('latex')
    ```

    ```python
    from qiskit.quantum_info import Statevector
    sv = Statevector.from_label('+r')
    sv.draw('qsphere')
    ```

    Additionally, the [`draw()`](qiskit.quantum_info.DensityMatrix#draw "qiskit.quantum_info.DensityMatrix.draw") method is now used for the ipython display of these classes, so if you change the default output type in a user config file then when a [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") or a [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") object are displayed in a jupyter notebook that output type will be used for the object.

*   Pulse `qiskit.pulse.Instruction` objects and parametric pulse objects (eg [`Gaussian`](qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian") now support using [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") and [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects for the `duration` parameter. For example:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.pulse import Gaussian

    dur = Parameter('x_pulse_duration')
    double_dur = dur * 2
    rx_pulse = Gaussian(dur, 0.1, dur/4)
    double_rx_pulse = Gaussian(double_dir, 0.1, dur/4)
    ```

    Note that while we can create an instruction with a parameterized `duration` adding an instruction with unbound parameter `duration` to a schedule is supported only by the newly introduced representation [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"). See the known issues release notes section for more details.

*   The [`run()`](qiskit.providers.basicaer.QasmSimulatorPy#run "qiskit.providers.basicaer.QasmSimulatorPy.run") method for the [`QasmSimulatorPy`](qiskit.providers.basicaer.QasmSimulatorPy "qiskit.providers.basicaer.QasmSimulatorPy"), [`StatevectorSimulatorPy`](qiskit.providers.basicaer.StatevectorSimulatorPy "qiskit.providers.basicaer.StatevectorSimulatorPy"), and [`UnitarySimulatorPy`](qiskit.providers.basicaer.UnitarySimulatorPy "qiskit.providers.basicaer.UnitarySimulatorPy") backends now takes a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") (or a list of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects) as its input. The previous [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") object is still supported for now, but will be deprecated in a future release.

    For an example of how to use this see:

    ```python
    from qiskit import transpile, QuantumCircuit

    from qiskit.providers.basicaer import BasicAer

    backend = BasicAer.get_backend('qasm_simulator')

    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()

    tqc = transpile(circuit, backend)
    result = backend.run(tqc, shots=4096).result()
    ```

*   The [`CommutativeCancellation`](qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation") transpiler pass has a new optional kwarg on the constructor `basis_gates`, which takes the a list of the names of basis gates for the target backend. When specified the pass will only use gates in the `basis_gates` kwarg. Previously, the pass would automatically replace consecutive gates which commute with [`ZGate`](qiskit.circuit.library.ZGate "qiskit.circuit.library.ZGate") with the [`U1Gate`](qiskit.circuit.library.U1Gate "qiskit.circuit.library.U1Gate") unconditionally. The `basis_gates` kwarg enables you to specify which z-rotation gates are present in the target basis to avoid this.

*   The constructors of the [`Bit`](qiskit.circuit.Bit "qiskit.circuit.Bit") class and subclasses, [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit"), [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit"), and [`AncillaQubit`](qiskit.circuit.AncillaQubit "qiskit.circuit.AncillaQubit"), have been updated such that their two parameters, `register` and `index` are now optional. This enables the creation of bit objects that are independent of a register.

*   A new class, [`BooleanExpression`](qiskit.circuit.classicalfunction.BooleanExpression "qiskit.circuit.classicalfunction.BooleanExpression"), has been added to the [`qiskit.circuit.classicalfunction`](classicalfunction#module-qiskit.circuit.classicalfunction "qiskit.circuit.classicalfunction") module. This class allows for creating an oracle from a Python boolean expression. For example:

    ```python
    from qiskit.circuit import BooleanExpression, QuantumCircuit

    expression = BooleanExpression('~x & (y | z)')
    circuit = QuantumCircuit(4)
    circuit.append(expression, [0, 1, 2, 3])
    circuit.draw('mpl')
    ```

    ```python
    circuit.decompose().draw('mpl')
    ```

    The [`BooleanExpression`](qiskit.circuit.classicalfunction.BooleanExpression "qiskit.circuit.classicalfunction.BooleanExpression") also includes a method, [`from_dimacs_file()`](qiskit.circuit.classicalfunction.BooleanExpression#from_dimacs_file "qiskit.circuit.classicalfunction.BooleanExpression.from_dimacs_file"), which allows loading formulas described in the [DIMACS-CNF](https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html) format. For example:

    ```python
    from qiskit.circuit import BooleanExpression, QuantumCircuit

    boolean_exp = BooleanExpression.from_dimacs_file("simple_v3_c2.cnf")
    circuit = QuantumCircuit(boolean_exp.num_qubits)
    circuit.append(boolean_exp, range(boolean_exp.num_qubits))
    circuit.draw('text')
    ```

    ```python
         ┌───────────────────┐
    q_0: ┤0                  ├
         │                   │
    q_1: ┤1                  ├
         │  SIMPLE_V3_C2.CNF │
    q_2: ┤2                  ├
         │                   │
    q_3: ┤3                  ├
         └───────────────────┘
    ```

    ```python
    circuit.decompose().draw('text')
    ```

    ```python
    q_0: ──o────o────────────
           │    │
    q_1: ──■────o────■───────
           │    │    │
    q_2: ──■────┼────o────■──
         ┌─┴─┐┌─┴─┐┌─┴─┐┌─┴─┐
    q_3: ┤ X ├┤ X ├┤ X ├┤ X ├
         └───┘└───┘└───┘└───┘
    ```

*   Added a new class, [`PhaseOracle`](qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle"), has been added to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module. This class enables the construction of phase oracle circuits from Python boolean expressions.

    ```python
    from qiskit.circuit.library.phase_oracle import PhaseOracle

    oracle = PhaseOracle('x1 & x2 & (not x3)')
    oracle.draw('mpl')
    ```

    These phase oracles can be used as part of a larger algorithm, for example with [`qiskit.algorithms.AmplificationProblem`](qiskit.algorithms.AmplificationProblem "qiskit.algorithms.AmplificationProblem"):

    ```python
    from qiskit.algorithms import AmplificationProblem, Grover
    from qiskit import BasicAer

    backend = BasicAer.get_backend('qasm_simulator')

    problem = AmplificationProblem(oracle, is_good_state=oracle.evaluate_bitstring)
    grover = Grover(quantum_instance=backend)
    result = grover.amplify(problem)
    result.top_measurement
    ```

    The [`PhaseOracle`](qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") class also includes a [`from_dimacs_file()`](qiskit.circuit.library.PhaseOracle#from_dimacs_file "qiskit.circuit.library.PhaseOracle.from_dimacs_file") method which enables constructing a phase oracle from a file describing a formula in the [DIMACS-CNF](https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html) format.

    ```python
    from qiskit.circuit.library.phase_oracle import PhaseOracle

    oracle = PhaseOracle.from_dimacs_file("simple_v3_c2.cnf")
    oracle.draw('text')
    ```

    ```python
    state_0: ─o───────o──────────────
              │ ┌───┐ │ ┌───┐
    state_1: ─■─┤ X ├─■─┤ X ├─■──────
              │ └───┘   └───┘ │ ┌───┐
    state_2: ─■───────────────o─┤ Z ├
                                └───┘
    ```

*   All transpiler passes (ie any instances of `BasePass`) are now directly callable. Calling a pass provides a convenient interface for running the pass on a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object.

    For example, running a single transformation pass, such as [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator"), can be done with:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.transpiler.passes import BasisTranslator
    from qiskit.circuit.equivalence_library import SessionEquivalenceLibrary as sel

    circuit = QuantumCircuit(1)
    circuit.h(0)

    pass_instance = BasisTranslator(sel, ['rx', 'rz', 'cx'])
    result = pass_instance(circuit)
    result.draw(output='mpl')
    ```

    When running an analysis pass, a property set (as `dict` or as `PropertySet`) needs to be added as a parameter and it might be modified “in-place”. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.transpiler.passes import Depth

    circuit = QuantumCircuit(1)
    circuit.h(0)

    property_set = {}
    pass_instance = Depth()
    pass_instance(circuit, property_set)
    print(property_set)
    ```

*   The [`QasmQobjConfig`](qiskit.qobj.QasmQobjConfig "qiskit.qobj.QasmQobjConfig") class now has an optional kwarg for `meas_level` and `meas_return`. These fields can be used to enable generating [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") job payloads that support `meas_level=1` (kerneled data) for circuit jobs (previously this was only exposed for [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") objects). The [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") function has been updated to set this field for [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") objects it generates.

*   A new [`tensor()`](qiskit.circuit.QuantumCircuit#tensor "qiskit.circuit.QuantumCircuit.tensor") method has been added to the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This method enables tensoring another circuit with an existing circuit. This method works analogously to [`qiskit.quantum_info.Operator.tensor()`](qiskit.quantum_info.Operator#tensor "qiskit.quantum_info.Operator.tensor") and is consistent with the little-endian convention of Qiskit.

    For example:

    ```python
    from qiskit import QuantumCircuit
    top = QuantumCircuit(1)
    top.x(0);
    bottom = QuantumCircuit(2)
    bottom.cry(0.2, 0, 1);
    bottom.tensor(top).draw(output='mpl')
    ```

*   The [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class now supports arbitrary free form metadata with the [`metadata`](qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") attribute. A user (or program built on top of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")) can attach metadata to a circuit for use in tracking the circuit. For example:

    ```python
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(2, user_metadata_field_1='my_metadata',
                        user_metadata_field_2='my_other_value')
    ```

    or:

    ```python
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(2)
    qc.metadata = {'user_metadata_field_1': 'my_metadata',
                   'user_metadata_field_2': 'my_other_value'}
    ```

    This metadata will **not** be used for influencing the execution of the circuit but is just used for tracking the circuit for the lifetime of the object. The `metadata` attribute will persist between any circuit transforms including [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"). The expectation is for providers to associate the metadata in the result it returns, so that users can filter results based on circuit metadata the same way they can currently do with `QuantumCircuit.name`.

*   Add a new operator class [`CNOTDihedral`](qiskit.quantum_info.CNOTDihedral "qiskit.quantum_info.CNOTDihedral") has been added to the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module. This class is used to represent the CNOT-Dihedral group, which is generated by the quantum gates [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate"), [`TGate`](qiskit.circuit.library.TGate "qiskit.circuit.library.TGate"), and [`XGate`](qiskit.circuit.library.XGate "qiskit.circuit.library.XGate").

*   Adds a `&` (`__and__`) binary operator to `BaseOperator` subclasses (eg [`qiskit.quantum_info.Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator")) in the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module. This is shorthand to call the classes [`compose()`](qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose") method (ie `A & B == A.compose(B)`).

    For example:

    ```python
    import qiskit.quantum_info as qi

    qi.Pauli('X') & qi.Pauli('Y')
    ```

*   Adds a `&` (`__and__`) binary operator to [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes. This is shorthand to call the classes [`evolve()`](qiskit.quantum_info.Statevector#evolve "qiskit.quantum_info.Statevector.evolve") method (ie `psi & U == psi.evolve(U)`).

    For example:

    ```python
    import qiskit.quantum_info as qi

    qi.Statevector.from_label('0') & qi.Pauli('X')
    ```

*   A new a new 2-qubit gate, [`ECRGate`](qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate"), the echo cross-resonance (ECR), has been added to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module along with a corresponding method, [`ecr()`](qiskit.circuit.QuantumCircuit#ecr "qiskit.circuit.QuantumCircuit.ecr") for the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. The ECR gate is two $CR(\frac{π}{4})$ pulses with an [`XGate`](qiskit.circuit.library.XGate "qiskit.circuit.library.XGate") between them for the echo. This gate is locally equivalent to a [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") (can convert to a CNOT with local pre- or post-rotation). It is the native gate on current IBM hardware and compiling to it allows the pre-/post-rotations to be merged into the rest of the circuit.

*   A new kwarg `approximation_degree` has been added to the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function for enabling approximate compilation. Valid values range from 0 to 1, and higher means less approximation. This is a heuristic dial to experiment with circuit approximations. The concrete interpretation of this number is left to each pass, which may use it to perform some approximate version of the pass. Specific examples include the [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") pass or the or translators to discrete gate sets. If a pass does not support this option, it implies exact transformation.

*   Two new transpiler passess, [`GateDirection`](qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection") and [`qiskit.transpiler.passes.CheckGateDirection`](qiskit.transpiler.passes.CheckGateDirection "qiskit.transpiler.passes.CheckGateDirection"), were added to the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module. These new passes are inteded to be more general replacements for `CXDirection` and `CheckCXDirection` (which are both now deprecated, see the deprecation notes for more details) that perform the same function but work with other gates beside just [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate").

*   When running on Windows, parallel execution with the [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") function can now be enabled (it is still disabled by default). To do this you can either set `parallel = True` in a user config file, or set the `QISKIT_PARALLEL` environment variable to `TRUE` (this will also effect [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") which both use [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") internally). It is important to note that when enabling parallelism on Windows there are limitations around how Python launches processes for Windows, see the Known Issues section below for more details on the limitations with parallel execution on Windows.

*   A new function, [`hellinger_distance()`](quantum_info#qiskit.quantum_info.hellinger_distance "qiskit.quantum_info.hellinger_distance"), for computing the Hellinger distance between two counts distributions has been added to the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module.

*   The [`decompose_clifford()`](quantum_info#qiskit.quantum_info.decompose_clifford "qiskit.quantum_info.decompose_clifford") function in the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module (which gets used internally by the [`qiskit.quantum_info.Clifford.to_circuit()`](qiskit.quantum_info.Clifford#to_circuit "qiskit.quantum_info.Clifford.to_circuit") method) has a new kwarg `method` which enables selecting the synthesis method used by either setting it to `'AG'` or `'greedy'`. By default for more than three qubits it is set to `'greedy'` which uses a non-optimal greedy compilation routine for Clifford elements synthesis, by Bravyi et. al., which typically yields better CX cost compared to the previously used Aaronson-Gottesman method (for more than two qubits). You can use the `method` kwarg to revert to the previous default Aaronson-Gottesman method by setting `method='AG'`.

*   The `Initialize` class in the [`qiskit.extensions`](extensions#module-qiskit.extensions "qiskit.extensions") module can now be constructed using an integer. The ‘1’ bits of the integer will insert a `Reset` and an [`XGate`](qiskit.circuit.library.XGate "qiskit.circuit.library.XGate") into the circuit for the corresponding qubit. This will be done using the standard little-endian convention is qiskit, ie the rightmost bit of the integer will set qubit 0. For example, setting the parameter in `Initialize` equal to `5` will set qubits 0 and 2 to value 1.

    ```python
    from qiskit.extensions import Initialize

    initialize = Initialize(13)
    initialize.definition.draw('mpl')
    ```

*   The `Initialize` class in the [`qiskit.extensions`](extensions#module-qiskit.extensions "qiskit.extensions") module now supports constructing directly from a Pauli label (analogous to the [`qiskit.quantum_info.Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label "qiskit.quantum_info.Statevector.from_label") method). The Pauli label refer to basis states of the Pauli eigenstates Z, X, Y. These labels use Qiskit’s standard little-endian notation, for example a label of `'01'` would initialize qubit 0 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    ```python
    from qiskit.extensions import Initialize

    initialize = Initialize("10+-lr")
    initialize.definition.draw('mpl')
    ```

*   The kwarg, `template_list`, for the constructor of the [`qiskit.transpiler.passes.TemplateOptimization`](qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") transpiler pass now supports taking in a list of both [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") objects. Previously, only [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") were accepted (which were internally converted to [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") objects) in the input list.

*   A new transpiler pass, [`qiskit.transpiler.passes.RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder"), capable of generating calibrations and adding them to a quantum circuit has been introduced. This pass takes calibrated [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") objects and creates the calibrations for [`qiskit.circuit.library.RZXGate`](qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate") objects with an arbitrary rotation angle. The schedules are created by stretching and compressing the `GaussianSquare` pulses of the echoed-cross resonance gates.

*   New template circuits for using [`qiskit.circuit.library.RZXGate`](qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate") are added to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module (eg [`rzx_yz`](circuit_library#qiskit.circuit.library.rzx_yz "qiskit.circuit.library.rzx_yz")). This enables pairing the [`TemplateOptimization`](qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") pass with the [`qiskit.transpiler.passes.RZXCalibrationBuilder`](qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") pass to automatically find and replace gate sequences, such as `CNOT - P(theta) - CNOT`, with more efficent circuits based on [`qiskit.circuit.library.RZXGate`](qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate") with a calibration.

*   The matplotlib output type for the [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and the [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method for the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class now supports configuration files for setting the visualization style. In previous releases, there was basic functionality that allowed users to pass in a `style` kwarg that took in a `dict` to customize the colors and other display features of the `mpl` drawer. This has now been expanded so that these dictionaries can be loaded from JSON files directly without needing to pass a dictionary. This enables users to create new style files and use that style for visualizations by passing the style filename as a string to the `style` kwarg.

    To leverage this feature you must set the `circuit_mpl_style_path` option in a user config file. This option should be set to the path you want qiskit to search for style JSON files. If specifying multiple path entries they should be separated by `:`. For example, setting `circuit_mpl_style_path = ~/.qiskit:~/user_styles` in a user config file will look for JSON files in both `~/.qiskit` and `~/user_styles`.

*   A new kwarg, `format_marginal` has been added to the function `marginal_counts()` which when set to `True` formats the counts output according to the `cregs` in the circuit and missing indices are represented with a `_`. For example:

    ```python
    from qiskit import QuantumCircuit, execute, BasicAer, result
    from qiskit.result.utils import marginal_counts
    qc = QuantumCircuit(5, 5)
    qc.x(0)
    qc.measure(0, 0)

    result = execute(qc, BasicAer.get_backend('qasm_simulator')).result()
    print(marginal_counts(result.get_counts(), [0, 2, 4], format_marginal=True))
    ```

*   Improved the performance of [`qiskit.quantum_info.Statevector.expectation_value()`](qiskit.quantum_info.Statevector#expectation_value "qiskit.quantum_info.Statevector.expectation_value") and [`qiskit.quantum_info.DensityMatrix.expectation_value()`](qiskit.quantum_info.DensityMatrix#expectation_value "qiskit.quantum_info.DensityMatrix.expectation_value") when the argument operator is a [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") or [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") operator.

*   The user config file has 2 new configuration options, `num_processes` and `parallel`, which are used to control the default behavior of [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map"). The `parallel` option is a boolean that is used to dictate whether [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") will run in multiple processes or not. If it set to `False` calls to [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") will be executed serially, while setting it to `True` will enable parallel execution. The `num_processes` option takes an integer which sets how many CPUs to use when executing in parallel. By default it will use the number of CPU cores on a system.

*   There are 2 new environment variables, `QISKIT_PARALLEL` and `QISKIT_NUM_PROCS`, that can be used to control the default behavior of [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map"). The `QISKIT_PARALLEL` option can be set to the `TRUE` (any capitalization) to set the default to run in multiple processes when [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") is called. If it is set to any other value [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") will be executed serially. `QISKIT_NUM_PROCS` takes an integer (for example `QISKIT_NUM_PROCS=5`) which will be used as the default number of processes to run with. Both of these will take precedence over the equivalent option set in the user config file.

*   A new method, [`gradient()`](qiskit.circuit.ParameterExpression#gradient "qiskit.circuit.ParameterExpression.gradient"), has been added to the [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") class. This method is used to evaluate the gradient of a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") object.

*   The `__eq__` method (ie what is called when the `==` operator is used) for the [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") now allows for the comparison with a numeric value. Previously, it was only possible to compare two instances of [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") with `==`. For example:

    ```python
    from qiskit.circuit import Parameter

    x = Parameter("x")
    y = x + 2
    y = y.assign(x, -1)

    assert y == 1
    ```

*   The [`PauliFeatureMap`](qiskit.circuit.library.PauliFeatureMap "qiskit.circuit.library.PauliFeatureMap") class in the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module now supports adjusting the rotational factor, $\alpha$, by either setting using the kwarg `alpha` on the constructor or setting the [`alpha`](qiskit.circuit.library.PauliFeatureMap#alpha "qiskit.circuit.library.PauliFeatureMap.alpha") attribute after creation. Previously this value was fixed at `2.0`. Adjusting this attribute allows for better control of decision boundaries and provides additional flexibility handling the input features without needing to explicitly scale them in the data set.

*   A new [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") class, [`PauliGate`](qiskit.circuit.library.PauliGate "qiskit.circuit.library.PauliGate"), has been added the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module and corresponding method, [`pauli()`](qiskit.circuit.QuantumCircuit#pauli "qiskit.circuit.QuantumCircuit.pauli"), was added to the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This new gate class enables applying several individual pauli gates to different qubits at the simultaneously. This is primarily useful for simulators which can use this new gate to more efficiently implement multiple simultaneous Pauli gates.

*   Improve the [`qiskit.quantum_info.Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") operator. This class now represents and element from the full N-qubit Pauli group including complex coefficients. It now supports the Operator API methods including [`compose()`](qiskit.quantum_info.Pauli#compose "qiskit.quantum_info.Pauli.compose"), [`dot()`](qiskit.quantum_info.Pauli#dot "qiskit.quantum_info.Pauli.dot"), [`tensor()`](qiskit.quantum_info.Pauli#tensor "qiskit.quantum_info.Pauli.tensor") etc, where compose and dot are defined with respect to the full Pauli group.

    This class also allows conversion to and from the string representation of Pauli’s for convenience.

    For example

    ```python
    from qiskit.quantum_info import Pauli

    P1 = Pauli('XYZ')
    P2 = Pauli('YZX')
    P1.dot(P2)
    ```

    Pauli’s can also be directly appended to [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects

    ```python
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import Pauli

    circ = QuantumCircuit(3)
    circ.append(Pauli('XYZ'), [0, 1, 2])
    circ.draw(output='mpl')
    ```

    Additional methods allow computing when two Pauli’s commute (using the [`commutes()`](qiskit.quantum_info.Pauli#commutes "qiskit.quantum_info.Pauli.commutes") method) or anticommute (using the [`anticommutes()`](qiskit.quantum_info.Pauli#anticommutes "qiskit.quantum_info.Pauli.anticommutes") method), and computing the Pauli resulting from Clifford conjugation $P^\prime = C.P.C^\dagger$ using the [`evolve()`](qiskit.quantum_info.Pauli#evolve "qiskit.quantum_info.Pauli.evolve") method.

    See the API documentation of the [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") class for additional information.

*   A new function, [`random_pauli()`](quantum_info#qiskit.quantum_info.random_pauli "qiskit.quantum_info.random_pauli"), for generating a random element of the N-qubit Pauli group has been added to the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module.

*   A new class, [`PiecewisePolynomialPauliRotations`](qiskit.circuit.library.PiecewisePolynomialPauliRotations "qiskit.circuit.library.PiecewisePolynomialPauliRotations"), has been added to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module. This circuit library element is used for mapping a piecewise polynomial function, $f(x)$, which is defined through breakpoints and coefficients, on qubit amplitudes. The breakpoints $(x_0, ..., x_J)$ are a subset of $[0, 2^n-1]$, where $n$ is the number of state qubits. The corresponding coefficients $[a_{j,1},...,a_{j,d}]$, where $d$ is the highest degree among all polynomials. Then $f(x)$ is defined as:

    $$
    \begin{split}f(x) = \begin{cases}
        0, x < x_0 \\
        \sum_{i=0}^{i=d}a_{j,i} x^i, x_j \leq x < x_{j+1}
        \end{cases}\end{split}
    $$

    where we implicitly assume $x_{J+1} = 2^n$. And the mapping applied to the amplitudes is given by

    $$
    F|x\rangle |0\rangle = \cos(p_j(x))|x\rangle |0\rangle + \sin(p_j(x))|x\rangle |1\rangle
    $$

    This mapping is based on controlled Pauli Y-rotations and constructed using the [`PolynomialPauliRotations`](qiskit.circuit.library.PolynomialPauliRotations "qiskit.circuit.library.PolynomialPauliRotations").

*   A new module [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") has been introduced. This module contains functionality equivalent to what has previously been provided by the `qiskit.aqua.algorithms` module (which is now deprecated) and provides the building blocks for constructing quantum algorithms. For details on migrating from `qiskit-aqua` to this new module, please refer to the [migration guide](https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide).

*   A new module [`qiskit.opflow`](opflow#module-qiskit.opflow "qiskit.opflow") has been introduced. This module contains functionality equivalent to what has previously been provided by the `qiskit.aqua.operators` module (which is now deprecated) and provides the operators and state functions which are used to build quantum algorithms. For details on migrating from `qiskit-aqua` to this new module, please refer to the [migration guide](https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide).

*   This is the first release that includes precompiled binary wheels for the for Linux aarch64 systems. If you are running a manylinux2014 compatible aarch64 Linux system there are now precompiled wheels available on PyPI, you are no longer required to build from source to install qiskit-terra.

*   The [`qiskit.quantum_info.process_fidelity()`](quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity") function is now able to be used with a non-unitary target channel. In this case the returned value is equivalent to the [`qiskit.quantum_info.state_fidelity()`](quantum_info#qiskit.quantum_info.state_fidelity "qiskit.quantum_info.state_fidelity") of the normalized [`qiskit.quantum_info.Choi`](qiskit.quantum_info.Choi "qiskit.quantum_info.Choi") matrices for the channels.

    Note that the [`qiskit.quantum_info.average_gate_fidelity()`](quantum_info#qiskit.quantum_info.average_gate_fidelity "qiskit.quantum_info.average_gate_fidelity") and [`qiskit.quantum_info.gate_error()`](quantum_info#qiskit.quantum_info.gate_error "qiskit.quantum_info.gate_error") functions still require the target channel to be unitary and will raise an exception if it is not.

*   Added a new pulse builder function, `qiskit.pulse.macro()`. This enables normal Python functions to be decorated as macros. This enables pulse builder functions to be used within the decorated function. The builder macro can then be called from within a pulse building context, enabling code reuse.

    For Example:

    ```python
    from qiskit import pulse

    @pulse.macro
    def measure(qubit: int):
        pulse.play(pulse.GaussianSquare(16384, 256, 15872),
                   pulse.MeasureChannel(qubit))
        mem_slot = pulse.MemorySlot(0)
        pulse.acquire(16384, pulse.AcquireChannel(0), mem_slot)
        return mem_slot

    with pulse.build(backend=backend) as sched:
        mem_slot = measure(0)
        print(f"Qubit measured into {mem_slot}")

    sched.draw()
    ```

*   A new class, [`PauliTwoDesign`](qiskit.circuit.library.PauliTwoDesign "qiskit.circuit.library.PauliTwoDesign"), was added to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") which implements a particular form of a 2-design circuit from [https://arxiv.org/pdf/1803.11173.pdf](https://arxiv.org/pdf/1803.11173.pdf) For instance, this circuit can look like:

    ```python
    from qiskit.circuit.library import PauliTwoDesign
    circuit = PauliTwoDesign(4, reps=2, seed=5, insert_barriers=True)
    circuit.decompose().draw(output='mpl')
    ```

*   A new pulse drawer `qiskit.visualization.pulse_v2.draw()` (which is aliased as `qiskit.visualization.pulse_drawer_v2`) is now available. This new pulse drawer supports multiple new features not present in the original pulse drawer ([`pulse_drawer()`](qiskit.visualization.pulse_drawer "qiskit.visualization.pulse_drawer")).

    *   Truncation of long pulse instructions.
    *   Visualization of parametric pulses.
    *   New stylesheets `IQXStandard`, `IQXSimple`, `IQXDebugging`.
    *   Visualization of system info (channel frequency, etc…) by specifying [`qiskit.providers.Backend`](qiskit.providers.Backend "qiskit.providers.Backend") objects for visualization.
    *   Specifying `axis` objects for plotting to allow further extension of generated plots, i.e., for publication manipulations.

    New stylesheets can take callback functions that dynamically modify the apperance of the output image, for example, reassembling a collection of channels, showing details of instructions, updating appearance of pulse envelopes, etc… You can create custom callback functions and feed them into a stylesheet instance to modify the figure appearance without modifying the drawer code. See pulse drawer module docstrings for details.

    Note that file saving is now delegated to Matplotlib. To save image files, you need to call `savefig` method with returned `Figure` object.

*   Adds a [`reverse_qargs()`](qiskit.quantum_info.Statevector#reverse_qargs "qiskit.quantum_info.Statevector.reverse_qargs") method to the [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes. This method reverses the order of subsystems in the states and is equivalent to the [`qiskit.circuit.QuantumCircuit.reverse_bits()`](qiskit.circuit.QuantumCircuit#reverse_bits "qiskit.circuit.QuantumCircuit.reverse_bits") method for N-qubit states. For example:

    > ```python
    > from qiskit.circuit.library import QFT
    > from qiskit.quantum_info import Statevector
    >
    > circ = QFT(3)
    >
    > state1 = Statevector.from_instruction(circ)
    > state2 = Statevector.from_instruction(circ.reverse_bits())
    >
    > state1.reverse_qargs() == state2
    > ```

*   Adds a [`reverse_qargs()`](qiskit.quantum_info.Operator#reverse_qargs "qiskit.quantum_info.Operator.reverse_qargs") method to the [`qiskit.quantum_info.Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") class. This method reverses the order of subsystems in the operator and is equivalent to the [`qiskit.circuit.QuantumCircuit.reverse_bits()`](qiskit.circuit.QuantumCircuit#reverse_bits "qiskit.circuit.QuantumCircuit.reverse_bits") method for N-qubit operators. For example:

    > ```python
    > from qiskit.circuit.library import QFT
    > from qiskit.quantum_info import Operator
    >
    > circ = QFT(3)
    >
    > op1 = Operator(circ)
    > op2 = Operator(circ.reverse_bits())
    >
    > op1.reverse_qargs() == op2
    > ```

*   The `latex` output method for the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method now will use a user defined label on gates in the output visualization. For example:

    ```python
    import math

    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.rx(math.pi/2, 0, label='My Special Rotation')

    qc.draw(output='latex')
    ```

*   The `routing_method` kwarg for the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function now accepts a new option, `'none'`. When `routing_method='none'` no routing pass will be run as part of the transpilation. If the circuit does not fit coupling map a [`TranspilerError`](transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.exceptions.TranspilerError") exception will be raised.

*   A new gate class, [`RVGate`](qiskit.circuit.library.RVGate "qiskit.circuit.library.RVGate"), was added to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module along with the corresponding [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`rv()`](qiskit.circuit.QuantumCircuit#rv "qiskit.circuit.QuantumCircuit.rv"). The [`RVGate`](qiskit.circuit.library.RVGate "qiskit.circuit.library.RVGate") is a general rotation gate, similar to the [`UGate`](qiskit.circuit.library.UGate "qiskit.circuit.library.UGate"), but instead of specifying Euler angles the three components of a rotation vector are specified where the direction of the vector specifies the rotation axis and the magnitude specifies the rotation angle about the axis in radians. For example:

    ```python
    import math

    import np

    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(1)
    theta = math.pi / 5
    phi = math.pi / 3
    # RGate axis:
    axis = np.array([math.cos(phi), math.sin(phi)])
    rotation_vector = theta * axis
    qc.rv(*rotation_vector, 0)
    ```

*   Unbound [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects used in a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object will now be sorted by name. This will take effect for the parameters returned by the [`parameters`](qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") attribute. Additionally, the [`qiskit.circuit.QuantumCircuit.bind_parameters()`](qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") and [`qiskit.circuit.QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") methods can now take in a list of a values which will bind/assign them to the parameters in name-sorted order. Previously these methods would only take a dictionary of parameters and values. For example:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter

    circuit = QuantumCircuit(1)
    circuit.rx(Parameter('x'), 0)
    circuit.ry(Parameter('y'), 0)

    print(circuit.parameters)

    bound = circuit.bind_parameters([1, 2])
    bound.draw(output='mpl')
    ```

*   The constructors for the [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes can now take a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object in to build a [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") object from that circuit, assuming that the qubits are initialized in $|0\rangle$. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import Statevector

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)

    statevector = Statevector(qc)
    statevector.draw(output='latex')
    ```

*   New fake backend classes are available under `qiskit.test.mock`. These included mocked versions of `ibmq_casablanca`, `ibmq_sydney`, `ibmq_mumbai`, `ibmq_lima`, `ibmq_belem`, `ibmq_quito`. As with the other fake backends, these include snapshots of calibration data (i.e. `backend.defaults()`) and error data (i.e. `backend.properties()`) taken from the real system, and can be used for local testing, compilation and simulation.

<span id="release-notes-0-17-0-known-issues" />

<span id="id303" />

#### Known Issues

*   Attempting to add an `qiskit.pulse.Instruction` object with a parameterized `duration` (ie the value of `duration` is an unbound [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") or [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") object) to a [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") is not supported. Attempting to do so will result in `UnassignedDurationError` [`PulseError`](pulse#qiskit.pulse.PulseError "qiskit.pulse.PulseError") being raised. This is a limitation of how the `Instruction` overlap constraints are evaluated currently. This is supported by [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"), in which the overlap constraints are evaluated just before the execution.

*   On Windows systems when parallel execution is enabled for [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") parallelism may not work when called from a script running outside of a `if __name__ == '__main__':` block. This is due to how Python launches parallel processes on Windows. If a `RuntimeError` or `AttributeError` are raised by scripts that call [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") (including using functions that use `parallel_map()` internally like [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile")) with Windows and parallelism enabled you can try embedding the script calls inside `if __name__ == '__main__':` to workaround the issue. For example:

    ```python
    from qiskit import QuantumCircuit, QiskitError
    from qiskit import execute, Aer

    qc1 = QuantumCircuit(2, 2)
    qc1.h(0)
    qc1.cx(0, 1)
    qc1.measure([0,1], [0,1])
    # making another circuit: superpositions
    qc2 = QuantumCircuit(2, 2)
    qc2.h([0,1])
    qc2.measure([0,1], [0,1])
    execute([qc1, qc2], Aer.get_backend('qasm_simulator'))
    ```

    should be changed to:

    ```python
    from qiskit import QuantumCircuit, QiskitError
    from qiskit import execute, Aer

    def main():
        qc1 = QuantumCircuit(2, 2)
        qc1.h(0)
        qc1.cx(0, 1)
        qc1.measure([0,1], [0,1])
        # making another circuit: superpositions
        qc2 = QuantumCircuit(2, 2)
        qc2.h([0,1])
        qc2.measure([0,1], [0,1])
        execute([qc1, qc2], Aer.get_backend('qasm_simulator'))

    if __name__ == '__main__':
        main()
    ```

    if any errors are encountered with parallelism on Windows.

<span id="release-notes-0-17-0-upgrade-notes" />

<span id="id304" />

#### Upgrade Notes

*   The preset pass managers [`level_1_pass_manager`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`level_2_pass_manager`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`level_3_pass_manager`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") (which are used for `optimization_level` 1, 2, and 3 in the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute") functions) now unconditionally use the [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") pass for 1 qubit gate optimization. Previously, these pass managers would use the [`Optimize1qGates`](qiskit.transpiler.passes.Optimize1qGates "qiskit.transpiler.passes.Optimize1qGates") pass if the basis gates contained `u1`, `u2`, or `u3`. If you want to still use the old [`Optimize1qGates`](qiskit.transpiler.passes.Optimize1qGates "qiskit.transpiler.passes.Optimize1qGates") you will need to construct a custom [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") with the pass.

*   Following transpilation of a parameterized [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"), the [`global_phase`](qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") attribute of output circuit may no longer be returned in a simplified form, if the global phase is a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression").

    For example:

    ```python
    qc = QuantumCircuit(1)
    theta = Parameter('theta')

    qc.rz(theta, 0)
    qc.rz(-theta, 0)

    print(transpile(qc, basis_gates=['p']).global_phase)
    ```

    previously returned `0`, but will now return `-0.5*theta + 0.5*theta`. This change was necessary was to avoid a large runtime performance penalty as simplifying symbolic expressions can be quite slow, especially if there are many [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects in a circuit.

*   The [`BasicAerJob`](qiskit.providers.basicaer.BasicAerJob "qiskit.providers.basicaer.BasicAerJob") job objects returned from BasicAer backends are now synchronous instances of [`JobV1`](qiskit.providers.JobV1 "qiskit.providers.JobV1"). This means that calls to the [`run()`](qiskit.providers.basicaer.QasmSimulatorPy#run "qiskit.providers.basicaer.QasmSimulatorPy.run") will block until the simulation finishes executing. If you want to restore the previous async behavior you’ll need to wrap the [`run()`](qiskit.providers.basicaer.QasmSimulatorPy#run "qiskit.providers.basicaer.QasmSimulatorPy.run") with something that will run in a seperate thread or process like `futures.ThreadPoolExecutor` or `futures.ProcessPoolExecutor`.

*   The `allow_sample_measuring` option for the BasicAer simulator [`QasmSimulatorPy`](qiskit.providers.basicaer.QasmSimulatorPy "qiskit.providers.basicaer.QasmSimulatorPy") has changed from a default of `False` to `True`. This was done to better reflect the actual default behavior of the simulator, which would use sample measuring if the input circuit supported it (even if it was not enabled). If you are running a circuit that doesn’t support sample measurement (ie it has `Reset` operations or if there are operations after a measurement on a qubit) you should make sure to explicitly set this option to `False` when you call [`run()`](qiskit.providers.basicaer.QasmSimulatorPy#run "qiskit.providers.basicaer.QasmSimulatorPy.run").

*   The [`CommutativeCancellation`](qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation") transpiler pass is now aware of the target basis gates, which means it will only use gates in the specified basis. Previously, the pass would unconditionally replace consecutive gates which commute with [`ZGate`](qiskit.circuit.library.ZGate "qiskit.circuit.library.ZGate") with the [`U1Gate`](qiskit.circuit.library.U1Gate "qiskit.circuit.library.U1Gate"). However, now that the pass is basis aware and has a kwarg, `basis_gates`, for specifying the target basis there is a potential change in behavior if the kwarg is not set. When the `basis_gates` kwarg is not used and there are no variable z-rotation gates in the circuit then no commutative cancellation will occur.

*   [`Register`](qiskit.circuit.Register "qiskit.circuit.Register") (which is the parent class for [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") and [`Bit`](qiskit.circuit.Bit "qiskit.circuit.Bit") (which is the parent class for [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") and [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit")) objects are now immutable. In previous releases it was possible to adjust the value of a [`size`](qiskit.circuit.QuantumRegister#size "qiskit.circuit.QuantumRegister.size") or [`name`](qiskit.circuit.QuantumRegister#name "qiskit.circuit.QuantumRegister.name") attributes of a [`Register`](qiskit.circuit.Register "qiskit.circuit.Register") object and the [`index`](qiskit.circuit.Qubit#index "qiskit.circuit.Qubit.index") or [`register`](qiskit.circuit.Qubit#register "qiskit.circuit.Qubit.register") attributes of a [`Bit`](qiskit.circuit.Bit "qiskit.circuit.Bit") object after it was initially created. However this would lead to unsound behavior that would corrupt container structure that rely on a hash (such as a dict) since these attributes are treated as immutable properties of a register or bit (see [#4705](https://github.com/Qiskit/qiskit-terra/issues/4705) for more details). To avoid this unsound behavior this attributes of a [`Register`](qiskit.circuit.Register "qiskit.circuit.Register") and [`Bit`](qiskit.circuit.Bit "qiskit.circuit.Bit") are no longer settable after initial creation. If you were previously adjusting the objects at runtime you will now need to create a new `Register` or `Bit` object with the new values.

*   The `DAGCircuit.__eq__` method (which is used by the `==` operator), which is used to check structural equality of [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instances, will now include the [`global_phase`](qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") and [`calibrations`](qiskit.circuit.QuantumCircuit#calibrations "qiskit.circuit.QuantumCircuit.calibrations") attributes in the fields checked for equality. This means that circuits which would have evaluated as equal in prior releases may not anymore if the `global_phase` or `calibrations` differ between the circuits. For example, in previous releases this would return `True`:

    ```python
    import math

    from qiskit import QuantumCircuit

    qc1 = QuantumCircuit(1)
    qc1.x(0)

    qc2 = QuantumCircuit(1, global_phase=math.pi)
    qc2.x(0)

    print(qc2 == qc1)
    ```

    However, now because the `global_phase` attribute of the circuits differ this will now return `False`.

*   The previously deprecated `qubits()` and `clbits()` methods on the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class, which were deprecated in the 0.15.0 Terra release, have been removed. Instead you should use the `qubits` and `clbits` attributes of the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class. For example, if you were running:

    ```python
    from qiskit.dagcircuit import DAGCircuit

    dag = DAGCircuit()
    qubits = dag.qubits()
    ```

    That would be replaced by:

    ```python
    from qiskit.dagcircuit import DAGCircuit

    dag = DAGCircuit()
    qubits = dag.qubits
    ```

*   The [`PulseDefaults`](qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") returned by the fake pulse backends `qiskit.test.mock.FakeOpenPulse2Q` and `qiskit.test.mock.FakeOpenPulse3Q` have been updated to have more realistic pulse sequence definitions. If you are using these fake backend classes you may need to update your usage because of these changes.

*   The default synthesis method used by [`decompose_clifford()`](quantum_info#qiskit.quantum_info.decompose_clifford "qiskit.quantum_info.decompose_clifford") function in the [`quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module (which gets used internally by the [`qiskit.quantum_info.Clifford.to_circuit()`](qiskit.quantum_info.Clifford#to_circuit "qiskit.quantum_info.Clifford.to_circuit") method) for more than 3 qubits now uses a non-optimal greedy compilation routine for Clifford elements synthesis, by Bravyi et. al., which typically yields better CX cost compared to the old default. If you need to revert to the previous Aaronson-Gottesman method this can be done by setting `method='AG'`.

*   The previously deprecated module `qiskit.visualization.interactive`, which was deprecated in the 0.15.0 release, has now been removed. Instead you should use the matplotlib based visualizations:

    | Removed Interactive function | Equivalent matplotlib function                                                                                                               |
    | ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
    | `iplot_bloch_multivector`    | [`qiskit.visualization.plot_bloch_multivector()`](qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector") |
    | `iplot_state_city`           | [`qiskit.visualization.plot_state_city()`](qiskit.visualization.plot_state_city "qiskit.visualization.plot_state_city")                      |
    | `iplot_state_qsphere`        | [`qiskit.visualization.plot_state_qsphere()`](qiskit.visualization.plot_state_qsphere "qiskit.visualization.plot_state_qsphere")             |
    | `iplot_state_hinton`         | [`qiskit.visualization.plot_state_hinton()`](qiskit.visualization.plot_state_hinton "qiskit.visualization.plot_state_hinton")                |
    | `iplot_histogram`            | [`qiskit.visualization.plot_histogram()`](qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram")                         |
    | `iplot_state_paulivec`       | [`qiskit.visualization.plot_state_paulivec()`](qiskit.visualization.plot_state_paulivec "qiskit.visualization.plot_state_paulivec")          |

*   The `qiskit.Aer` and `qiskit.IBMQ` top level attributes are now lazy loaded. This means that the objects will now always exist and warnings will no longer be raised on import if `qiskit-aer` or `qiskit-ibmq-provider` are not installed (or can’t be found by Python). If you were checking for the presence of `qiskit-aer` or `qiskit-ibmq-provider` using these module attributes and explicitly comparing to `None` or looking for the absence of the attribute this no longer will work because they are always defined as an object now. In other words running something like:

    ```python
    try:
        from qiskit import Aer
    except ImportError:
        print("Aer not available")

    or::

    try:
        from qiskit import IBMQ
    except ImportError:
        print("IBMQ not available")
    ```

    will no longer work. Instead to determine if those providers are present you can either explicitly use `qiskit.providers.aer.Aer` and `qiskit.providers.ibmq.IBMQ`:

    ```python
    try:
        from qiskit.providers.aer import Aer
    except ImportError:
        print("Aer not available")

    try:
        from qiskit.providers.ibmq import IBMQ
    except ImportError:
        print("IBMQ not available")
    ```

    or check `bool(qiskit.Aer)` and `bool(qiskit.IBMQ)` instead, for example:

    ```python
    import qiskit

    if not qiskit.Aer:
        print("Aer not available")
    if not qiskit.IBMQ:
        print("IBMQ not available")
    ```

    This change was necessary to avoid potential import cycle issues between the qiskit packages and also to improve the import time when Aer or IBMQ are not being used.

*   The user config file option `suppress_packaging_warnings` option in the user config file and the `QISKIT_SUPPRESS_PACKAGING_WARNINGS` environment variable no longer has any effect and will be silently ignored. The warnings this option controlled have been removed and will no longer be emitted at import time from the `qiskit` module.

*   The previously deprecated `condition` kwarg for [`qiskit.dagcircuit.DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") constructor has been removed. It was deprecated in the 0.15.0 release. Instead you should now be setting the classical condition on the [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") object passed into the [`DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") constructor when creating a new `op` node.

*   When creating a new [`Register`](qiskit.circuit.Register "qiskit.circuit.Register") (which is the parent class for [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister")) or [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object with a number of bits (eg `QuantumCircuit(2)`), it is now required that number of bits are specified as an integer or another type which is castable to unambiguous integers(e.g. `2.0`). Non-integer values will now raise an error as the intent in those cases was unclear (you can’t have fractional bits). For more information on why this was changed refer to: [#4855](https://github.com/Qiskit/qiskit-terra/issues/4855)

*   [networkx](https://networkx.org/) is no longer a requirement for qiskit-terra. All the networkx usage inside qiskit-terra has been removed with the exception of 3 methods:

    *   `qiskit.dagcircuit.DAGCircuit.to_networkx`
    *   `qiskit.dagcircuit.DAGCircuit.from_networkx`
    *   `qiskit.dagcircuit.DAGDependency.to_networkx`

    If you are using any of these methods you will need to manually install networkx in your environment to continue using them.

*   By default on macOS with Python >=3.8 [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") will no longer run in multiple processes. This is a change from previous releases where the default behavior was that [`parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") would launch multiple processes. This change was made because with newer versions of macOS with Python 3.8 and 3.9 multiprocessing is either unreliable or adds significant overhead because of the change in Python 3.8 to launch new processes with `spawn` instead of `fork`. To re-enable parallel execution on macOS with Python >= 3.8 you can use the user config file `parallel` option or set the environment variable `QISKIT_PARALLEL` to `True`.

*   The previously deprecated kwarg `callback` on the constructor for the [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") class has been removed. This kwarg has been deprecated since the 0.13.0 release (April, 9th 2020). Instead you can pass the `callback` kwarg to the [`qiskit.transpiler.PassManager.run()`](qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") method directly. For example, if you were using:

    ```python
    from qiskit.circuit.random import random_circuit
    from qiskit.transpiler import PassManager

    qc = random_circuit(2, 2)

    def callback(**kwargs)
      print(kwargs['pass_'])

    pm = PassManager(callback=callback)
    pm.run(qc)
    ```

    this can be replaced with:

    ```python
    from qiskit.circuit.random import random_circuit
    from qiskit.transpiler import PassManager

    qc = random_circuit(2, 2)

    def callback(**kwargs)
      print(kwargs['pass_'])

    pm = PassManager()
    pm.run(qc, callback=callback)
    ```

*   It is now no longer possible to instantiate a base channel without a prefix, such as `qiskit.pulse.Channel` or `qiskit.pulse.PulseChannel`. These classes are designed to classify types of different user facing channel classes, such as `qiskit.pulse.DriveChannel`, but do not have a definition as a target resource. If you were previously directly instantiating either `qiskit.pulse.Channel` or `qiskit.pulse.PulseChannel`, this is no longer allowed. Please use the appropriate subclass.

*   When the `require_cp` and/or `require_tp` kwargs of [`qiskit.quantum_info.process_fidelity()`](quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity"), [`qiskit.quantum_info.average_gate_fidelity()`](quantum_info#qiskit.quantum_info.average_gate_fidelity "qiskit.quantum_info.average_gate_fidelity"), [`qiskit.quantum_info.gate_error()`](quantum_info#qiskit.quantum_info.gate_error "qiskit.quantum_info.gate_error") are `True`, they will now only log a warning rather than the previous behavior of raising a [`QiskitError`](exceptions#qiskit.exceptions.QiskitError "qiskit.exceptions.QiskitError") exception if the input channel is non-CP or non-TP respectively.

*   The [`QFT`](qiskit.circuit.library.QFT "qiskit.circuit.library.QFT") class in the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module now computes the Fourier transform using a little-endian representation of tensors, i.e. the state $|1\rangle$ maps to $|0\rangle - |1\rangle + |2\rangle - ..$ assuming the computational basis correspond to little-endian bit ordering of the integers. $|0\rangle = |000\rangle, |1\rangle = |001\rangle$, etc. This was done to make it more consistent with the rest of Qiskit, which uses a little-endian convention for bit order. If you were depending on the previous bit order you can use the `reverse_bits()` method to revert to the previous behavior. For example:

    ```python
    from qiskit.circuit.library import QFT

    qft = QFT(5).reverse_bits()
    ```

*   The `qiskit.__qiskit_version__` module attribute was previously a `dict` will now return a custom read-only `Mapping` object that checks the version of qiskit elements at runtime instead of at import time. This was done to speed up the import path of qiskit and eliminate a possible import cycle by only importing the element packages at runtime if the version is needed from the package. This should be fully compatible with the `dict` previously return and for most normal use cases there will be no difference. However, if some applications were relying on either mutating the contents or explicitly type checking it may require updates to adapt to this change.

*   The `qiskit.execute` module has been renamed to [`qiskit.execute_function`](execute#module-qiskit.execute_function "qiskit.execute_function"). This was necessary to avoid a potentical name conflict between the [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute") function which is re-exported as `qiskit.execute`. `qiskit.execute` the function in some situations could conflict with `qiskit.execute` the module which would lead to a cryptic error because Python was treating `qiskit.execute` as the module when the intent was to the function or vice versa. The module rename was necessary to avoid this conflict. If you’re importing `qiskit.execute` to get the module (typical usage was `from qiskit.execute import execute`) you will need to update this to use `qiskit.execute_function` instead. `qiskit.execute` will now always resolve to the function.

*   The `qiskit.compiler.transpile`, `qiskit.compiler.assemble`, `qiskit.compiler.schedule`, and `qiskit.compiler.sequence` modules have been renamed to `qiskit.compiler.transpiler`, `qiskit.compiler.assembler`, `qiskit.compiler.scheduler`, and `qiskit.compiler.sequence` respectively. This was necessary to avoid a potentical name conflict between the modules and the re-exported function paths [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), [`qiskit.compiler.assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"), [`qiskit.compiler.schedule()`](compiler#qiskit.compiler.schedule "qiskit.compiler.schedule"), and [`qiskit.compiler.sequence()`](compiler#qiskit.compiler.sequence "qiskit.compiler.sequence"). In some situations this name conflict between the module path and re-exported function path would lead to a cryptic error because Python was treating an import as the module when the intent was to use the function or vice versa. The module rename was necessary to avoid this conflict. If you were using the imports to get the modules before (typical usage would be like\`\`from qiskit.compiler.transpile import transpile\`\`) you will need to update this to use the new module paths. [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), [`qiskit.compiler.assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"), [`qiskit.compiler.schedule()`](compiler#qiskit.compiler.schedule "qiskit.compiler.schedule"), and [`qiskit.compiler.sequence()`](compiler#qiskit.compiler.sequence "qiskit.compiler.sequence") will now always resolve to the functions.

*   The [`qiskit.quantum_info.Quaternion`](qiskit.quantum_info.Quaternion "qiskit.quantum_info.Quaternion") class was moved from the `qiskit.quantum_info.operator` submodule to the `qiskit.quantum_info.synthesis` submodule to better reflect it’s purpose. No change is required if you were importing it from the root [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module, but if you were importing from `qiskit.quantum_info.operator` you will need to update your import path.

*   Removed the `QuantumCircuit.mcmt` method, which has been deprecated since the Qiskit Terra 0.14.0 release in April 2020. Instead of using the method, please use the [`MCMT`](qiskit.circuit.library.MCMT "qiskit.circuit.library.MCMT") class instead to construct a multi-control multi-target gate and use the [`qiskit.circuit.QuantumCircuit.append()`](qiskit.circuit.QuantumCircuit#append "qiskit.circuit.QuantumCircuit.append") or [`qiskit.circuit.QuantumCircuit.compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") to add it to a circuit.

    For example, you can replace:

    ```python
    circuit.mcmt(ZGate(), [0, 1, 2], [3, 4])
    ```

    with:

    ```python
    from qiskit.circuit.library import MCMT
    mcmt = MCMT(ZGate(), 3, 2)
    circuit.compose(mcmt, range(5))
    ```

*   Removed the `QuantumCircuit.diag_gate` method which has been deprecated since the Qiskit Terra 0.14.0 release in April 2020. Instead, use the [`diagonal()`](qiskit.circuit.QuantumCircuit#diagonal "qiskit.circuit.QuantumCircuit.diagonal") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").

*   Removed the `QuantumCircuit.ucy` method which has been deprecated since the Qiskit Terra 0.14.0 release in April 2020. Instead, use the [`ucry()`](qiskit.circuit.QuantumCircuit#ucry "qiskit.circuit.QuantumCircuit.ucry") method of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").

*   The previously deprecated `mirror()` method for [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") has been removed. It was deprecated in the 0.15.0 release. The [`qiskit.circuit.QuantumCircuit.reverse_ops()`](qiskit.circuit.QuantumCircuit#reverse_ops "qiskit.circuit.QuantumCircuit.reverse_ops") method should be used instead since mirroring could be confused with swapping the output qubits of the circuit. The `reverse_ops()` method only reverses the order of gates that are applied instead of mirroring.

*   The previously deprecated support passing a float (for the `scale` kwarg as the first positional argument to the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") has been removed. It was deprecated in the 0.12.0 release. The first positional argument to the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method is now the `output` kwarg which does not accept a float. Instead you should be using `scale` as a named kwarg instead of using it positionally.

    For example, if you were previously calling `draw` with:

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(2)
    qc.draw(0.75, output='mpl')
    ```

    this would now need to be:

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(2)
    qc.draw(output='mpl', scale=0.75)
    ```

    or:

    ```python
    qc.draw('mpl', scale=0.75)
    ```

*   Features of Qiskit Pulse ([`qiskit.pulse`](pulse#module-qiskit.pulse "qiskit.pulse")) which were deprecated in the 0.15.0 release (August, 2020) have been removed. The full set of changes are:

    | Module                 | Old                      | New                                                                                                                 |
    | ---------------------- | ------------------------ | ------------------------------------------------------------------------------------------------------------------- |
    | `qiskit.pulse.library` | `SamplePulse`            | [`Waveform`](qiskit.pulse.library.Waveform "qiskit.pulse.library.Waveform")                                         |
    | `qiskit.pulse.library` | `ConstantPulse`          | [`Constant`](qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant") |
    | (module rename)        | `pulse.pulse_lib` Module | [`qiskit.pulse.library`](pulse#module-qiskit.pulse.library "qiskit.pulse.library")                                  |

    | Class                                                                                                | Old method                           | New method                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
    | ---------------------------------------------------------------------------------------------------- | ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | [`ParametricPulse`](qiskit.pulse.library.ParametricPulse "qiskit.pulse.library.ParametricPulse")     | `get_sample_pulse`                   | [`get_waveform`](qiskit.pulse.library.ParametricPulse#get_waveform "qiskit.pulse.library.ParametricPulse.get_waveform")                                                                                                                                                                                                                                                                                                                                                   |
    | [`Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") | `command`                            | N/A. Commands and Instructions have been unified. Use `operands()` to get information about the instruction data.                                                                                                                                                                                                                                                                                                                                                         |
    | [`Acquire`](qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire")                   | `acquires`, `mem_slots`, `reg_slots` | [`acquire()`](qiskit.pulse.instructions.Acquire#acquire "qiskit.pulse.instructions.Acquire.acquire"), [`mem_slot()`](qiskit.pulse.instructions.Acquire#mem_slot "qiskit.pulse.instructions.Acquire.mem_slot"), [`reg_slot()`](qiskit.pulse.instructions.Acquire#reg_slot "qiskit.pulse.instructions.Acquire.reg_slot"). (The [`Acquire`](qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire") instruction no longer broadcasts across multiple qubits.) |

*   The dictionary previously held on [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") edges has been removed. Instead, edges now hold the [`Bit`](qiskit.circuit.Bit "qiskit.circuit.Bit") instance which had previously been included in the dictionary as its `'wire'` field. Note that the NetworkX graph returned by `to_networkx()` will still have a dictionary for its edge attributes, but the `'name'` field will no longer be populated.

*   The [`parameters`](qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") attribute of the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class no longer is returning a `set`. Instead it returns a `ParameterView` object which implements all the methods that `set` offers (albeit deprecated). This was done to support a model that preserves name-sorted parameters. It should be fully compatible with any previous usage of the `set` returned by the [`parameters`](qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") attribute, except for where explicit type checking of a set was done.

*   When running [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") on a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with [`delay()`](qiskit.circuit.QuantumCircuit#delay "qiskit.circuit.QuantumCircuit.delay") instructions, the units will be converted to dt if the value of dt (sample time) is known to [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), either explicitly via the `dt` kwarg or via the [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") for a `Backend` object passed in via the `backend` kwarg.

*   The interpretation of `meas_map` (which is an attribute of a [`PulseBackendConfiguration`](qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") object or as the corresponding `meas_map` kwarg on the [`schedule()`](compiler#qiskit.compiler.schedule "qiskit.compiler.schedule"), [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"), [`sequence()`](compiler#qiskit.compiler.sequence "qiskit.compiler.sequence"), or [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute") functions) has been updated to better match the true constraints of the hardware. The format of this data is a list of lists, where the items in the inner list are integers specifying qubit labels. For instance:

    ```python
    [[A, B, C], [D, E, F, G]]
    ```

    Previously, the `meas_map` constraint was interpreted such that if one qubit was acquired (e.g. A), then all other qubits sharing a subgroup with that qubit (B and C) would have to be acquired at the same time and for the same duration. This constraint has been relaxed. One acquisition does not require more acquisitions. (If A is acquired, B and C do **not** need to be acquired.) Instead, qubits in the same measurement group cannot be acquired in a partially overlapping way – think of the `meas_map` as specifying a shared acquisition resource (If we acquire A from `t=1000` to `t=2000`, we cannot acquire B starting from `1000<t<2000`). For example:

    ```python
    # Good
    meas_map = [[0, 1]]
    # Acquire a subset of [0, 1]
    sched = pulse.Schedule()
    sched = sched.append(pulse.Acquire(10, acq_q0))

    # Acquire 0 and 1 together (same start time, same duration)
    sched = pulse.Schedule()
    sched = sched.append(pulse.Acquire(10, acq_q0))
    sched = sched.append(pulse.Acquire(10, acq_q1))

    # Acquire 0 and 1 disjointly
    sched = pulse.Schedule()
    sched = sched.append(pulse.Acquire(10, acq_q0))
    sched = sched.append(pulse.Acquire(10, acq_q1)) << 10

    # Acquisitions overlap, but 0 and 1 aren't in the same measurement
    # grouping
    meas_map = [[0], [1]]
    sched = pulse.Schedule()
    sched = sched.append(pulse.Acquire(10, acq_q0))
    sched = sched.append(pulse.Acquire(10, acq_q1)) << 1

    # Bad: 0 and 1 are in the same grouping, but acquisitions
    # partially overlap
    meas_map = [[0, 1]]
    sched = pulse.Schedule()
    sched = sched.append(pulse.Acquire(10, acq_q0))
    sched = sched.append(pulse.Acquire(10, acq_q1)) << 1
    ```

<span id="release-notes-0-17-0-deprecation-notes" />

<span id="id305" />

#### Deprecation Notes

*   Two new arguments have been added to [`qiskit.dagcircuit.DAGNode.semantic_eq()`](qiskit.dagcircuit.DAGNode#semantic_eq "qiskit.dagcircuit.DAGNode.semantic_eq"), `bit_indices1` and `bit_indices2`, which are expected to map the [`Bit`](qiskit.circuit.Bit "qiskit.circuit.Bit") instances in each [`DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") to their index in `qubits` or `clbits` list of their respective [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit"). During the deprecation period, these arguments are optional and when **not** specified the mappings will be automatically constructed based on the `register` and `index` properties of each [`Bit`](qiskit.circuit.Bit "qiskit.circuit.Bit") instance. However, in a future release, they will be required arguments and the mapping will need to be supplied by the user.

*   The [`pulse`](pulse#module-qiskit.pulse "qiskit.pulse") builder functions:

    *   `qiskit.pulse.call_circuit()`
    *   `qiskit.pulse.call_schedule()`

    are deprecated and will be removed in a future release. These functions are unified into `qiskit.pulse.call()` which should be used instead.

*   The [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") method `qiskit.pulse.Schedule.flatten()` method is deprecated and will be removed in a future release. Instead you can use the [`qiskit.pulse.transforms.flatten()`](pulse#qiskit.pulse.transforms.flatten "qiskit.pulse.transforms.flatten") function which will perform the same operation.

*   The `assign_parameters()` for the following classes:

    > *   [`qiskit.pulse.channels.Channel`](pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel"),
    > *   `qiskit.pulse.library.Pulse`,
    > *   [`qiskit.pulse.instructions.Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction"),

    and all their subclasses is now deprecated and will be removed in a future release. This functionality has been subsumed [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") which is the future direction for constructing parameterized pulse programs.

*   The `parameters` attribute for the following clasess:

    > *   [`Channel`](pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel")
    > *   [`Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction").

    is deprecated and will be removed in a future release. This functionality has been subsumed [`ScheduleBlock`](qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") which is the future direction for constructing parameterized pulse programs.

*   Python 3.6 support has been deprecated and will be removed in a future release. When support is removed you will need to upgrade the Python version you’re using to Python 3.7 or above.

*   Two [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods `combine()` and `extend()` along with their corresponding Python operators `+` and `+=` are deprecated and will be removed in a future release. Instead the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") should be used. The [`compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") method allows more flexibility in composing two circuits that do not have matching registers. It does not, however, automatically add qubits/clbits unlike the deprecated methods. To add a circuit on new qubits/clbits, the [`qiskit.circuit.QuantumCircuit.tensor()`](qiskit.circuit.QuantumCircuit#tensor "qiskit.circuit.QuantumCircuit.tensor") method can be used. For example:

    ```python
    from qiskit.circuit import QuantumRegister, QuantumCircuit

    a = QuantumRegister(2, 'a')
    circuit_a = QuantumCircuit(a)
    circuit_a.cx(0, 1)

    b = QuantumRegister(2, 'b')
    circuit_b = QuantumCircuit(b)
    circuit_b.cz(0, 1)

    # same as circuit_a + circuit_b (or combine)
    added_with_different_regs = circuit_b.tensor(circuit_a)

    # same as circuit_a + circuit_a (or combine)
    added_with_same_regs = circuit_a.compose(circuit_a)

    # same as circuit_a += circuit_b (or extend)
    circuit_a = circuit_b.tensor(circuit_a)

    # same as circuit_a += circuit_a (or extend)
    circuit_a.compose(circuit_a, inplace=True)
    ```

*   Support for passing [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") instances to the `qubits` kwarg of the [`qiskit.transpiler.InstructionDurations.get()`](qiskit.transpiler.InstructionDurations#get "qiskit.transpiler.InstructionDurations.get") method has been deprecated and will be removed in a future release. Instead, you should call the [`get()`](qiskit.transpiler.InstructionDurations#get "qiskit.transpiler.InstructionDurations.get") method with the integer indices of the desired qubits.

*   Using `@` (`__matmul__`) for invoking the `compose` method of `BaseOperator` subclasses (eg [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator")) is deprecated and will be removed in a future release. The [`qiskit.quantum_info.Operator.compose()`](qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose") method can be used directly or also invoked using the `&` (`__and__`) operator.

*   Using `*` (`__mul__`) for calling the [`dot()`](qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot") method of `BaseOperator` subclasses (eg [`qiskit.quantum_info.Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator")) is deprecated and will be removed in a future release. Instead you can just call the [`dot()`](qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot") directly.

*   Using `@` (`__matmul__`) for invoking the [`evolve()`](qiskit.quantum_info.Statevector#evolve "qiskit.quantum_info.Statevector.evolve") method of the [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes is deprecated and will be removed in a future release.. The `evolve` method can be used directly or also invoked using the `&` (`__and__`) operator.

*   The `qiskit.pulse.schedule.ParameterizedSchedule` class has been deprecated and will be removed in a future release. Instead you can directly parameterize pulse [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") objects with a [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") object, for example:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.pulse import Schedule
    from qiskit.pulse import ShiftPhase, DriveChannel

    theta = Parameter('theta')
    target_schedule = Schedule()
    target_schedule.insert(0, ShiftPhase(theta, DriveChannel(0)), inplace=True)
    ```

*   The `qiskit.pulse.ScheduleComponent` class in the [`qiskit.pulse`](pulse#module-qiskit.pulse "qiskit.pulse") module has been deprecated and will be removed in a future release. Its usage should be replaced either using a [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") or `qiskit.pulse.Instruction` directly. Additionally, the primary purpose of the `ScheduleComponent` class was as a common base class for both [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") and `Instruction` for any place that was explicitly type checking or documenting accepting a `ScheduleComponent` input should be updated to accept `Instruction` or [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule").

*   The JSON Schema files and usage for the IBMQ API payloads are deprecated and will be removed in a future release. This includes everything under the `qiskit.schemas` module and the `qiskit.validation` module. This also includes the `validate` kwargs for [`qiskit.qobj.QasmQobj.to_dict()`](qiskit.qobj.QasmQobj#to_dict "qiskit.qobj.QasmQobj.to_dict") and [`qiskit.qobj.QasmQobj.to_dict()`](qiskit.qobj.QasmQobj#to_dict "qiskit.qobj.QasmQobj.to_dict") along with the module level fastjsonschema validators in [`qiskit.qobj`](qobj#module-qiskit.qobj "qiskit.qobj") (which do not raise a deprecation warning). The schema files have been moved to the [Qiskit/ibmq-schemas](https://github.com/Qiskit/ibmq-schemas) repository and those should be treated as the canonical versions of the API schemas. Moving forward only those schemas will recieve updates and will be used as the source of truth for the schemas. If you were relying on the schemas bundled in qiskit-terra you should update to use that repository instead.

*   The `qiskit.util` module has been deprecated and will be removed in a future release. It has been replaced by [`qiskit.utils`](utils#module-qiskit.utils "qiskit.utils") which provides the same functionality and will be expanded in the future. Note that no `DeprecationWarning` will be emitted regarding this deprecation since it was not feasible on Python 3.6.

*   The `CXDirection` transpiler pass in the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module has been deprecated and will be removed in a future release. Instead the `GateDirection` should be used. It behaves identically to the `CXDirection` except that it now also supports transforming a circuit with [`ECRGate`](qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate") gates in addition to [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") gates.

*   The `CheckCXDirection` transpiler pass in the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module has been deprecated and will be removed in a future release. Instead the `CheckGateDirection` pass should be used. It behaves identically to the `CheckCXDirection` except that it now also supports checking the direction of all 2-qubit gates, not just [`CXGate`](qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") gates.

*   The [`WeightedAdder`](qiskit.circuit.library.WeightedAdder "qiskit.circuit.library.WeightedAdder") method `num_ancilla_qubits()` is deprecated and will be removed in a future release. It has been replaced with the [`qiskit.circuit.library.WeightedAdder.num_ancillas`](qiskit.circuit.library.WeightedAdder#num_ancillas "qiskit.circuit.library.WeightedAdder.num_ancillas") attribute which is consistent with other circuit libraries’ APIs.

*   The following legacy methods of the [`qiskit.quantum_info.Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") class have been deprecated. See the method documentation for replacement use in the updated Pauli class.

    *   `from_label()`
    *   `sgn_prod()`
    *   `to_spmatrix()`
    *   `kron()`
    *   `update_z()`
    *   `update_x()`
    *   `insert_paulis()`
    *   `append_paulis()`
    *   `delete_qubits()`
    *   `pauli_single()`
    *   `random()`

*   Using a `list` or `numpy.ndarray` as the `channel` or `target` argument for the [`qiskit.quantum_info.process_fidelity()`](quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity"), [`qiskit.quantum_info.average_gate_fidelity()`](quantum_info#qiskit.quantum_info.average_gate_fidelity "qiskit.quantum_info.average_gate_fidelity"), [`qiskit.quantum_info.gate_error()`](quantum_info#qiskit.quantum_info.gate_error "qiskit.quantum_info.gate_error"), and [`qiskit.quantum_info.diamond_norm()`](quantum_info#qiskit.quantum_info.diamond_norm "qiskit.quantum_info.diamond_norm") functions has been deprecated and will not be supported in a future release. The inputs should instead be a [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") or a `BaseOperator` subclass object (eg. [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator"), [`Choi`](qiskit.quantum_info.Choi "qiskit.quantum_info.Choi"), etc.)

*   Accessing references from [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") and [`Clbit`](qiskit.circuit.Clbit "qiskit.circuit.Clbit") instances to their containing registers via the [`register`](qiskit.circuit.Qubit#register "qiskit.circuit.Qubit.register") or [`index`](qiskit.circuit.Qubit#index "qiskit.circuit.Qubit.index") properties has been deprecated and will be removed in a future release. Instead, [`Register`](qiskit.circuit.Register "qiskit.circuit.Register") objects can be queried to find the [`Bit`](qiskit.circuit.Bit "qiskit.circuit.Bit") objects they contain.

*   The current functionality of the [`qiskit.visualization.pulse_drawer()`](qiskit.visualization.pulse_drawer "qiskit.visualization.pulse_drawer") function is deprecated and will be replaced by `qiskit.visualization.pulse_drawer_v2()` (which is not backwards compatible) in a future release.

*   The use of methods inherited from the `set` type on the output of the [`parameters`](qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") attribute (which used to be a `set`) of the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class are deprecated and will be removed in a future release. This includes the methods from the `add()`, `difference()`, `difference_update()`, `discard()`, `intersection()`, `intersection_update()`, `issubset()`, `issuperset()`, `symmetric_difference()`, `symmetric_difference_update()`, `union()`, `update()`, `__isub__()` (which is the `-=` operator), and `__ixor__()` (which is the `^=` operator).

*   The name of the first (and only) positional argument for the [`qiskit.circuit.QuantumCircuit.bind_parameters()`](qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") method has changed from `value_dict` to `values`. The passing an argument in with the name `values_dict` is deprecated and will be removed in future release. For example, if you were previously calling [`bind_parameters()`](qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") with a call like: `bind_parameters(values_dict={})` this is deprecated and should be replaced by `bind_parameters(values={})` or even better just pass the argument positionally `bind_parameters({})`.

*   The name of the first (and only) positional argument for the [`qiskit.circuit.QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") method has changed from `param_dict` to `parameters`. Passing an argument in with the name `param_dict` is deprecated and will be removed in future release. For example, if you were previously calling [`assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") with a call like: `assign_parameters(param_dict={})` this is deprecated and should be replaced by `assign_parameters(values={})` or even better just pass the argument positionally `assign_parameters({})`.

<span id="release-notes-0-17-0-bug-fixes" />

<span id="id306" />

#### Bug Fixes

*   Fixed an issue where the [`execute()`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute") function would raise [`QiskitError`](exceptions#qiskit.exceptions.QiskitError "qiskit.exceptions.QiskitError") exception when a [`ParameterVector`](qiskit.circuit.ParameterVector "qiskit.circuit.ParameterVector") object was passed in for the `parameter_bind` kwarg. parameter. For example, it is now possible to call something like:

    ```python
    execute(circuit, backend, parameter_binds=[{pv1: [...], pv2: [...]}])
    ```

    where `pv1` and `pv2` are [`ParameterVector`](qiskit.circuit.ParameterVector "qiskit.circuit.ParameterVector") objects. Fixed [#5467](https://github.com/Qiskit/qiskit-terra/issues/5467)

*   Fixed an issue with the labels of parametric pulses in the [`PulseQobjInstruction`](qiskit.qobj.PulseQobjInstruction "qiskit.qobj.PulseQobjInstruction") class were not being properly set as they are with sampled pulses. This also means that pulse names that are imported from the [`PulseDefaults`](qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") returned by a [`Backend`](qiskit.providers.Backend "qiskit.providers.Backend"), such as `x90`, `x90m`, etc, will properly be set. Fixed [#5363](https://github.com/Qiskit/qiskit-terra/issues/5363)

*   Fixed an issue where unbound parameters only occurring in the [`global_phase`](qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") attribute of a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object would not show in the [`parameters`](qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") attribute and could not be bound. Fixed [#5806](https://github.com/Qiskit/qiskit-terra/issues/5806)

*   The [`calibrations`](qiskit.circuit.QuantumCircuit#calibrations "qiskit.circuit.QuantumCircuit.calibrations") attribute of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects are now preserved when the `+=` (ie the `extend()` method) and the `+` (ie the `combine()` method) are used. Fixed [#5930](https://github.com/Qiskit/qiskit-terra/pull/5930) and [#5908](https://github.com/Qiskit/qiskit-terra/issues/5908)

*   The [`name`](qiskit.circuit.Register#name "qiskit.circuit.Register.name") setter method of class [`Register`](qiskit.circuit.Register "qiskit.circuit.Register") (which is the parent class of [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister")) previously did not check if the assigned string was a valid register name as per the [OpenQASM specification](https://arxiv.org/pdf/1707.03429v2.pdf). This check was previously only performed when the name was specified in the constructor, this has now been fixed so that setting the `name` attribute directly with an invalid value will now also raise an exception. Fixed [#5461](https://github.com/Qiskit/qiskit-terra/issues/5461)

*   Fixed an issue with the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method when visualizing a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with a [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") that has a classical condition after a `Measure` that used the same [`ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister"), it was possible for the conditional [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") to be displayed to the left of the `Measure`. Fixed [#5387](https://github.com/Qiskit/qiskit-terra/issues/5387)

*   In the transpiler pass [`qiskit.transpiler.passes.CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") a bias towards lower numbered qubits could be observed. This undesireable bias has been fixed by shuffling the candidates to randomize the results. Furthermore, the usage of the [`CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") pass in the [`preset_passmanagers`](transpiler_preset#module-qiskit.transpiler.preset_passmanagers "qiskit.transpiler.preset_passmanagers") (for level 2 and 3) has been adjusted to use a configured seed if the `seed_transpiler` kwarg is set when [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") is called. Fixed [#5990](https://github.com/Qiskit/qiskit-terra/issues/5990)

*   Fixes a bug where the `channels` field for a [`PulseBackendConfiguration`](qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") object was not being included in the output of the [`qiskit.providers.models.PulseBackendConfiguration.to_dict`](qiskit.providers.models.PulseBackendConfiguration#to_dict "qiskit.providers.models.PulseBackendConfiguration.to_dict") method. Fixed [#5579](https://github.com/Qiskit/qiskit-terra/issues/5579)

*   Fixed the `'circular'` entanglement in the [`qiskit.circuit.library.NLocal`](qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") circuit class for the edge case where the circuit has the same size as the entanglement block (e.g. a two-qubit circuit and CZ entanglement gates). In this case there should only be one entanglement gate, but there was accidentially added a second one in the inverse direction as the first. Fixed [Qiskit/qiskit-aqua#1452](https://github.com/Qiskit/qiskit-aqua/issues/1452)

*   Fixed the handling of breakpoints in the [`PiecewisePolynomialPauliRotations`](qiskit.circuit.library.PiecewisePolynomialPauliRotations "qiskit.circuit.library.PiecewisePolynomialPauliRotations") class in the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library"). Now for `n` intervals, `n+1` breakpoints are allowed. This enables specifying another end interval other than $2^\text{num qubits}$. This is important because from the end of the last interval to $2^\text{num qubits}$ the function is the identity.

*   Fixed an issue in the [`qiskit.circuit.library.Permutation`](qiskit.circuit.library.Permutation "qiskit.circuit.library.Permutation") circuit class where some permutations would not be properly generated. This issue could also effect [`qiskit.circuit.library.QuantumVolume`](qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") if it were called with classical\_permutation=False\`. Fixed [#5812](https://github.com/Qiskit/qiskit-terra/issues/5812)

*   Fixed an issue where generating QASM output with the [`qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") method for a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object that has a [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") with an open control the output would be as if all controls were closed independent of the specified control state. This would result in a different circuit being created from [`from_qasm_str()`](qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") if parsing the generated QASM.

    This was fixed by updating the QASM output from [`qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") by defining a composite gate which uses `XGate` to implement the open controls. The composite gate is named like `<original_gate_name>_o<ctrl_state>` where `o` stands for open control and `ctrl_state` is the integer value of the control state. Fixed [#5443](https://github.com/Qiskit/qiskit-terra/issues/5443)

*   Fixed an issue where binding [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects in a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with the `parameter_binds` in the [`execute`](execute#qiskit.execute_function.execute "qiskit.execute_function.execute") function would cause all the bound [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects would have the same `name`, which meant the result names were also not unique. This fix causes the [`bind_parameters()`](qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") and [`assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") to assign a unique circuit name when `inplace=False` as:

    ```python
    <base name>-<class instance no.>[-<pid name>]
    ```

    where `<base name>` is the name supplied by the “name” kwarg, otherwise it defaults to “circuit”. The class instance number gets incremented every time an instance of the class is generated. `<pid name>` is appended if called outside the main process. Fixed [#5185](https://github.com/Qiskit/qiskit-terra/issues/5185)

*   Fixed an issue with the `scheduler()` function where it would raise an exception if an input circuit contained an unbound [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object. Fixed [#5304](https://github.com/Qiskit/qiskit-terra/issues/5304)

*   Fixed an issue in the [`qiskit.transpiler.passes.TemplateOptimization`](qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") transpiler passes where template circuits that contained unbound [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects would crash under some scenarios if the parameters could not be bound during the template matching. Now, if the [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects can not be bound templates with unbound [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") are discarded and ignored by the [`TemplateOptimization`](qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") pass. Fixed [#5533](https://github.com/Qiskit/qiskit-terra/issues/5533)

*   Fixed an issue with the [`qiskit.visualization.timeline_drawer()`](qiskit.visualization.timeline_drawer "qiskit.visualization.timeline_drawer") function where classical bits were inproperly handled. Fixed [#5361](https://github.com/Qiskit/qiskit-terra/issues/5361)

*   Fixed an issue in the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method where [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") instructions in a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object were not being correctly treated as idle time. So when the `idle_wires` kwarg was set to `False` the wires with the [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") objects would still be shown. This has been fixed so that the idle wires are removed from the visualization if there are only [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") objects on a wire.

*   Previously, when the option `layout_method` kwarg was provided to the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function and the `optimization_level` kwarg was set to >= 2 so that the pass [`qiskit.transpiler.passes.CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") would run, if [`CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") found a solution then the method in `layout_method` was not executed. This has been fixed so that if specified, the `layout_method` is always honored. Fixed [#5409](https://github.com/Qiskit/qiskit-terra/issues/5409)

*   When the argument `coupling_map=None` (either set explicitly, set implicitly as the default value, or via the `backend` kwarg), the transpiling process was not “embedding” the circuit. That is, even when an `initial_layout` was specified, the virtual qubits were not assigned to physical qubits. This has been fixed so that now, the [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function honors the `initial_layout` argument by embedding the circuit:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister
    from qiskit.compiler import transpile

    qr = QuantumRegister(2, name='qr')
    circ = QuantumCircuit(qr)
    circ.h(qr[0])
    circ.cx(qr[0], qr[1])

    transpile(circ, initial_layout=[1, 0]).draw(output='mpl')
    ```

    If the `initial_layout` refers to more qubits than in the circuit, the transpiling process will extended the circuit with ancillas.

    ```python
    from qiskit import QuantumCircuit, QuantumRegister
    from qiskit.compiler import transpile

    qr = QuantumRegister(2, name='qr')
    circ = QuantumCircuit(qr)
    circ.h(qr[0])
    circ.cx(qr[0], qr[1])

    transpile(circ, initial_layout=[4, 2], coupling_map=None).draw()
    ```

    Fixed [#5345](https://github.com/Qiskit/qiskit-terra/issues/5345)

*   A new kwarg, `user_cost_dict` has been added to the constructor for the [`qiskit.transpiler.passes.TemplateOptimization`](qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") transpiler pass. This enables users to provide a custom cost dictionary for the gates to the underlying template matching algorithm. For example:

    ```python
    from qiskit.transpiler.passes import TemplateOptimization

    cost_dict = {'id': 0, 'x': 1, 'y': 1, 'z': 1, 'h': 1, 't': 1}
    pass = TemplateOptimization(user_cost_dict=cost_dict)
    ```

*   An issue when passing the [`Counts`](qiskit.result.Counts "qiskit.result.Counts") object returned by [`get_counts()`](qiskit.result.Result#get_counts "qiskit.result.Result.get_counts") to [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") would produce an improperly formatted [`Counts`](qiskit.result.Counts "qiskit.result.Counts") object with certain inputs has been fixed. Fixes [#5424](https://github.com/Qiskit/qiskit-terra/issues/5424)

*   Improved the allocation of helper qubits in [`PolynomialPauliRotations`](qiskit.circuit.library.PolynomialPauliRotations "qiskit.circuit.library.PolynomialPauliRotations") and [`PiecewiseLinearPauliRotations`](qiskit.circuit.library.PiecewiseLinearPauliRotations "qiskit.circuit.library.PiecewiseLinearPauliRotations") which makes the implementation of these circuit more efficient. Fixed [#5320](https://github.com/Qiskit/qiskit-terra/issues/5320) and [#5322](https://github.com/Qiskit/qiskit-terra/issues/5322)

*   Fix the usage of the allocated helper qubits in the [`MCXGate`](qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate") in the [`WeightedAdder`](qiskit.circuit.library.WeightedAdder "qiskit.circuit.library.WeightedAdder") class. These were previously allocated but not used prior to this fix. Fixed [#5321](https://github.com/Qiskit/qiskit-terra/issues/5321)

*   In a number of cases, the `latex` output method for the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method did not display the gate name correctly, and in other cases, did not include gate parameters where they should be. Now the gate names will be displayed the same way as they are displayed with the `mpl` output method, and parameters will display for all the gates that have them. In addition, some of the gates did not display in the correct form, and these have been fixed. Fixes [#5605](https://github.com/Qiskit/qiskit-terra/issues/5605), [#4938](https://github.com/Qiskit/qiskit-terra/issues/4938), and [#3765](https://github.com/Qiskit/qiskit-terra/issues/3765)

*   Fixed an issue where, if the `qiskit.circuit.Instruction.to_instruction()` method was used on a subcircuit which contained classical registers and that [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") object was then added to a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object, then the output from the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method would in some instances display the subcircuit to the left of a measure when it should have been displayed to the right. Fixed [#5947](https://github.com/Qiskit/qiskit-terra/issues/5947)

*   Fixed an issue with [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") objects in a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") where [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") would not be convert the units of the [`Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") to the units of the [`Backend`](qiskit.providers.Backend "qiskit.providers.Backend"), if the `backend` kwarg is set on `transpile()`. This could result in the wrong behavior because of a unit mismatch, for example running:

    ```python
    from qiskit import transpile, execute
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(1)
    qc.delay(100, [0], unit='us')

    qc = transpile(qc, backend)
    job = execute(qc, backend)
    ```

    would previously have resulted in the backend delay for 100 timesteps (each of duration dt) rather than expected (100e-6 / dt) timesteps. This has been corrected so the [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function properly converts the units.

<span id="release-notes-0-17-0-other-notes" />

<span id="id307" />

#### Other Notes

*   The snapshots of all the fake/mock backends in `qiskit.test.mock` have been updated to reflect recent device changes. This includes a change in the [`basis_gates`](qiskit.providers.models.QasmBackendConfiguration#basis_gates "qiskit.providers.models.QasmBackendConfiguration.basis_gates") attribute for the [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") to `['cx', 'rz', 'sx', 'x', 'id']`, the addition of a `readout_length` property to the qubit properties in the [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties"), and updating the [`PulseDefaults`](qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") so that all the mock backends support parametric pulse based [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") instances.

<span id="aer-0-8-0" />

<span id="aer-release-notes-0-8-0" />

### Aer 0.8.0

<span id="aer-release-notes-0-8-0-prelude" />

<span id="id308" />

#### Prelude

The 0.8 release includes several new features and bug fixes. The highlights for this release are: the introduction of a unified `AerSimulator` backend for running circuit simulations using any of the supported simulation methods; a simulator instruction library (`qiskit.providers.aer.library`) which includes custom instructions for saving various kinds of simulator data; MPI support for running large simulations on a distributed computing environment.

<span id="aer-release-notes-0-8-0-new-features" />

<span id="id309" />

#### New Features

*   Python 3.9 support has been added in this release. You can now run Qiskit Aer using Python 3.9 without building from source.

*   Add the CMake flag `DISABLE_CONAN` (default=\`\`OFF\`\`)s. When installing from source, setting this to `ON` allows bypassing the Conan package manager to find libraries that are already installed on your system. This is also available as an environment variable `DISABLE_CONAN`, which takes precedence over the CMake flag. This is not the official procedure to build AER. Thus, the user is responsible of providing all needed libraries and corresponding files to make them findable to CMake.

*   This release includes support for building qiskit-aer with MPI support to run large simulations on a distributed computing environment. See the [contributing guide](https://github.com/Qiskit/qiskit-aer/blob/master/CONTRIBUTING.md#building-with-mpi-support) for instructions on building and running in an MPI environment.

*   It is now possible to build qiskit-aer with CUDA enabled in Windows. See the [contributing guide](https://github.com/Qiskit/qiskit-aer/blob/master/CONTRIBUTING.md#building-with-gpu-support) for instructions on building from source with GPU support.

*   When building the qiskit-aer Python extension from source several build dependencies need to be pre-installed to enable C++ compilation. As a user convenience when building the extension any of these build dependencies which were missing would be automatically installed using `pip` prior to the normal `setuptools` installation steps, however it was previously was not possible to avoid this automatic installation. To solve this issue a new environment variable `DISABLE_DEPENDENCY_INSTALL` has been added. If it is set to `1` or `ON` when building the python extension from source this will disable the automatic installation of these missing build dependencies.

*   Adds support for optimized N-qubit Pauli gate ( [`qiskit.circuit.library.PauliGate`](qiskit.circuit.library.PauliGate "qiskit.circuit.library.PauliGate")) to the `StatevectorSimulator`, `UnitarySimulator`, and the statevector and density matrix methods of the `QasmSimulator` and `AerSimulator`.

*   The `run()` method for the `AerSimulator`, `QasmSimulator`, `StatevectorSimulator`, and `UnitarySimulator` backends now takes a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") (or a list of [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects) as it’s input. The previous [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") object is still supported for now, but will be deprecated in a future release.

    For an example of how to use this see:

    ```python
    from qiskit import transpile, QuantumCircuit

    from qiskit.providers.aer import Aer

    backend = Aer.get_backend('aer_simulator')

    circuit = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    tqc = transpile(circuit, backend)
    result = backend.run(tqc, shots=4096).result()
    ```

*   The `run()` method for the `PulseSimulator` backend now takes a [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") (or a list of [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") objects) as it’s input. The previous [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") object is still supported for now, but will be deprecated in a future release.

*   Adds the new `AerSimulator` simulator backend supporting the following simulation methods

    > *   `automatic`
    > *   `statevector`
    > *   `stabilizer`
    > *   `density_matrix`
    > *   `matrix_product_state`
    > *   `unitary`
    > *   `superop`

    The default automatic method will automatically choose a simulation method separately for each run circuit based on the circuit instructions and noise model (if any). Initializing a simulator with a specific method can be done using the method option.

    GPU simulation for the statevector, density matrix and unitary methods can be enabled by setting the `device='GPU'` backend option.

    Note that the `unitary` and `superop` methods do not support measurement as they simulate the unitary matrix or superoperator matrix of the run circuit so one of the new `save_unitary()`, `save_superop()`, or `save_state()` instructions must be used to save the simulator state to the returned results. Similarly state of the other simulations methods can be saved using the appropriate instructions. See the `qiskit.providers.aer.library` API documents for more details.

    Note that the `AerSimulator` simulator superceds the `QasmSimulator`, `StatevectorSimulator`, and `UnitarySimulator` backends which will be deprecated in a future release.

*   Updates the `AerProvider` class to include multiple `AerSimulator` backends preconfigured for all available simulation methods and simulation devices. The new backends can be accessed through the provider interface using the names

    > *   `"aer_simulator"`
    > *   `"aer_simulator_statevector"`
    > *   `"aer_simulator_stabilizer"`
    > *   `"aer_simulator_density_matrix"`
    > *   `"aer_simulator_matrix_product_state"`
    > *   `"aer_simulator_extended_stabilizer"`
    > *   `"aer_simulator_unitary"`
    > *   `"aer_simulator_superop"`

    Additional if Aer was installed with GPU support on a compatible system the following GPU backends will also be available

    > *   `"aer_simulator_statevector_gpu"`
    > *   `"aer_simulator_density_matrix_gpu"`
    > *   `"aer_simulator_unitary_gpu"`

    For example:

    ```python
    from qiskit import Aer

    # Get the GPU statevector simulator backend
    backend = Aer.get_backend('aer_simulator_statevector_gpu')
    ```

*   Added a new `norm estimation` method for performing measurements when using the `"extended_stabilizer"` simulation method. This norm estimation method can be used by passing the following options to the `AerSimulator` and `QasmSimulator` backends

    ```python
    simulator = QasmSimulator(
        method='extended_stabilizer',
        extended_stabilizer_sampling_method='norm_estimation')
    ```

    The norm estimation method is slower than the alternative `metropolis` or `resampled_metropolis` options, but gives better performance on circuits with sparse output distributions. See the documentation of the `QasmSimulator` for more information.

*   Adds instructions for saving the state of the simulator in various formats. These instructions are

    *   `qiskit.providers.aer.library.SaveDensityMatrix`
    *   `qiskit.providers.aer.library.SaveMatrixProductState`
    *   `qiskit.providers.aer.library.SaveStabilizer`
    *   `qiskit.providers.aer.library.SaveState`
    *   `qiskit.providers.aer.library.SaveStatevector`
    *   `qiskit.providers.aer.library.SaveStatevectorDict`
    *   `qiskit.providers.aer.library.SaveUnitary`

    These instructions can be appended to a quantum circuit by using the `save_density_matrix`, `save_matrix_product_state`, `save_stabilizer`, `save_state`, `save_statevector`, `save_statevector_dict`, `save_unitary` circuit methods which are added to `QuantumCircuit` when importing Aer.

    See the `qiskit.providers.aer.library` API documentation for details on method compatibility for each instruction.

    Note that the snapshot instructions `SnapshotStatevector`, `SnapshotDensityMatrix`, `SnapshotStabilizer` are still supported but will be deprecated in a future release.

*   Adds `qiskit.providers.aer.library.SaveExpectationValue` and `qiskit.providers.aer.library.SaveExpectationValueVariance` quantum circuit instructions for saving the expectation value $\langle H\rangle = Tr[H\rho]$, or expectation value and variance $Var(H) = \langle H^2\rangle - \langle H\rangle^2$, of a Hermitian operator $H$ for the simulator state $\rho$. These instruction can be appended to a quantum circuit by using the `save_expectation_value` and `save_expectation_value_variance` circuit methods which is added to `QuantumCircuit` when importing Aer.

    Note that the snapshot instruction `SnapshotExpectationValue`, is still supported but will be deprecated in a future release.

*   Adds `qiskit.providers.aer.library.SaveProbabilities` and `qiskit.providers.aer.library.SaveProbabilitiesDict` quantum circuit instruction for saving all measurement outcome probabilities for Z-basis measurements of the simualtor state. These instruction can be appended to a quantum circuit by using the `save_probabilities` and `save_probabilities_dict` circuit methods which is added to `QuantumCircuit` when importing Aer.

    Note that the snapshot instruction `SnapshotProbabilities`, is still supported but will be deprecated in a future release.

*   Adds `qiskit.providers.aer.library.SaveAmplitudes` and `qiskit.providers.aer.library.SaveAmplitudesSquared` circuit instructions for saving select complex statevector amplitudes, or select probabilities (amplitudes squared) for supported simulation methods. These instructions can be appended to a quantum circuit by using the `save_amplitudes` and `save_amplitudes_squared` circuit methods which is added to `QuantumCircuit` when importing Aer.

*   Adds instructions for setting the state of the simulators. These instructions must be defined on the full number of qubits in the circuit. They can be applied at any point in a circuit and will override the simulator state with the one specified. Added instructions are

    *   `qiskit.providers.aer.library.SetDensityMatrix`
    *   `qiskit.providers.aer.library.SetStabilizer`
    *   `qiskit.providers.aer.library.SetStatevector`
    *   `qiskit.providers.aer.library.SetUnitary`

    These instruction can be appended to a quantum circuit by using the `set_density_matrix`, `set_stabilizer`, `set_statevector`, `set_unitary` circuit methods which are added to `QuantumCircuit` when importing Aer.

    See the `qiskit.providers.aer.library` API documentation for details on method compatibility for each instruction.

*   Added support for diagonal gates to the `"matrix_product_state"` simulation method.

*   Added support for the `initialize` instruction to the `"matrix_product_state"` simulation method.

<span id="aer-release-notes-0-8-0-known-issues" />

<span id="id310" />

#### Known Issues

*   There is a known issue where the simulation of certain circuits with a Kraus noise model using the `"matrix_product_state"` simulation method can cause the simulator to crash. Refer to [#306](https://github.com/Qiskit/qiskit-aer/issues/1184) for more information.

<span id="aer-release-notes-0-8-0-upgrade-notes" />

<span id="id311" />

#### Upgrade Notes

*   The minimum version of [Conan](https://conan.io/) has been increased to 1.31.2. This was necessary to fix a compatibility issue with newer versions of the [urllib3](https://pypi.org/project/urllib3/) (which is a dependency of Conan). It also adds native support for AppleClang 12 which is useful for users with new Apple computers.

*   `pybind11` minimum version required is 2.6 instead of 2.4. This is needed in order to support CUDA enabled compilation in Windows.

*   Cython has been removed as a build dependency.

*   Removed x90 gate decomposition from noise models that was deprecated in qiskit-aer 0.7. This decomposition is now done by using regular noise model basis gates and the qiskit transpiler.

*   The following options for the `"extended_stabilizer"` simulation method have changed.

    > *   `extended_stabilizer_measure_sampling`: This option has been replaced by the options `extended_stabilizer_sampling_method`, which controls how we simulate qubit measurement.
    > *   `extended_stabilizer_mixing_time`: This option has been renamed as `extended_stabilizer_metropolis_mixing_time` to clarify it only applies to the `metropolis` and `resampled_metropolis` sampling methods.
    > *   `extended_stabilizer_norm_estimation_samples`: This option has been renamed to `extended_stabilizer_norm_estimation_default_samples`.

    One additional option, `extended_stabilizer_norm_estimation_repetitions` has been added, whih controls part of the behaviour of the norm estimation sampling method.

<span id="aer-release-notes-0-8-0-deprecation-notes" />

<span id="id312" />

#### Deprecation Notes

*   Python 3.6 support has been deprecated and will be removed in a future release. When support is removed you will need to upgrade the Python version you’re using to Python 3.7 or above.

<span id="aer-release-notes-0-8-0-bug-fixes" />

<span id="id313" />

#### Bug Fixes

*   Fixes bug with `AerProvider` where options set on the returned backends using `set_options()` were stored in the provider and would persist for subsequent calls to `get_backend()` for the same named backend. Now every call to and `backends()` returns a new instance of the simulator backend that can be configured.
*   Fixes bug in the error message returned when a circuit contains unsupported simulator instructions. Previously some supported instructions were also being listed in the error message along with the unsupported instructions.
*   Fixes issue with setting `QasmSimulator` basis gates when using `"method"` and `"noise_model"` options together, and when using them with a simulator constructed using `from_backend()`. Now the listed basis gates will be the intersection of gates supported by the backend configuration, simulation method, and noise model basis gates. If the intersection of the noise model basis gates and simulator basis gates is empty a warning will be logged.
*   Fix bug where the `` "sx"` `` gate [`SXGate`](qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate") was not listed as a supported gate in the C++ code, in `StateOpSet` of `matrix_product_state.hp`.
*   Fix bug where `"csx"`, `"cu2"`, `"cu3"` were incorrectly listed as supported basis gates for the `"density_matrix"` method of the `QasmSimulator`.
*   Fix bug where parameters were passed incorrectly between functions in `matrix_product_state_internal.cpp`, causing wrong simulation, as well as reaching invalid states, which in turn caused an infinite loop.
*   Fixes a bug that resulted in `c_if` not working when the width of the conditional register was greater than 64. See [#1077](https://github.com/Qiskit/qiskit-aer/issues/1077).
*   Fixes a bug [#1153](https://github.com/Qiskit/qiskit-aer/issues/1153)) where noise on conditional gates was always being applied regardless of whether the conditional gate was actually applied based on the classical register value. Now noise on a conditional gate will only be applied in the case where the conditional gate is applied.
*   Fixes a bug with nested OpenMP flag was being set to true when it shouldn’t be.
*   Fixes a bug when applying truncation in the matrix product state method of the QasmSimulator.
*   Fixed issue [#1126](https://github.com/Qiskit/qiskit-aer/issues/1126): bug in reporting measurement of a single qubit. The bug occured when copying the measured value to the output data structure.
*   In MPS, apply\_kraus was operating directly on the input bits in the parameter qubits, instead of on the internal qubits. In the MPS algorithm, the qubits are constantly moving around so all operations should be applied to the internal qubits.
*   When invoking MPS::sample\_measure, we need to first sort the qubits to the default ordering because this is the assumption in qasm\_controller.This is done by invoking the method move\_all\_qubits\_to\_sorted\_ordering. It was correct in sample\_measure\_using\_apply\_measure, but missing in sample\_measure\_using\_probabilities.
*   Fixes bug with the `from_backend()` method of the `QasmSimulator` that would set the `local` attribute of the configuration to the backend value rather than always being set to `True`.
*   Fixes bug in `from_backend()` and `from_backend()` where `basis_gates` was set incorrectly for IBMQ devices with basis gate set `['id', 'rz', 'sx', 'x', 'cx']`. Now the noise model will always have the same basis gates as the backend basis gates regardless of whether those instructions have errors in the noise model or not.
*   Fixes an issue where the Extended “extended\_stabilizer” simulation method would give incorrect results on quantum circuits with sparse output distributions. Refer to [#306](https://github.com/Qiskit/qiskit-aer/issues/306) for more information and examples.

<span id="id314" />

### Ignis 0.6.0

<span id="ignis-release-notes-0-6-0-new-features" />

<span id="id315" />

#### New Features

*   The `qiskit.ignis.mitigation.expval_meas_mitigator_circuits()` function has been improved so that the number of circuits generated by the function used for calibration by the CTMP method are reduced from $O(n)$ to $O(\log{n})$ (where $n$ is the number of qubits).

<span id="ignis-release-notes-0-6-0-upgrade-notes" />

<span id="id316" />

#### Upgrade Notes

*   The `qiskit.ignis.verification.randomized_benchmarking_seq()` function is now using the upgraded CNOTDihedral class, `qiskit.ignis.verification.CNOTDihedral`, which enables performing CNOT-Dihedral Randomized Benchmarking on more than two qubits.
*   The python package `retworkx` is now a requirement for installing qiskit-ignis. It replaces the previous usage of `networkx` (which is no longer a requirement) to get better performance.
*   The `scikit-learn` dependency is no longer required and is now an optional requirement. If you’re using the IQ measurement discriminators (`IQDiscriminationFitter`, `LinearIQDiscriminationFitter`, `QuadraticIQDiscriminationFitter`, or `SklearnIQDiscriminator`) you will now need to manually install scikit-learn, either by running `pip install scikit-learn` or when you’re also installing qiskit-ignis with `pip install qiskit-ignis[iq]`.

<span id="ignis-release-notes-0-6-0-bug-fixes" />

<span id="id317" />

#### Bug Fixes

*   Fixed an issue in the expectation value method `expectation_value()`, for the error mitigation classes `TensoredExpvalMeasMitigator` and `CTMPExpvalMeasMitigator` if the `qubits` kwarg was not specified it would incorrectly use the total number of qubits of the mitigator, rather than the number of classical bits in the count dictionary leading to greatly reduced performance. Fixed [#561](https://github.com/Qiskit/qiskit-ignis/issues/561)
*   Fix the `"auto"` method of the `TomographyFitter`, `StateTomographyFitter`, and `ProcessTomographyFitter` to only use `"cvx"` if CVXPY is installed *and* a third-party SDP solver other than SCS is available. This is because the SCS solver has lower accuracy than other solver methods and often returns a density matrix or Choi-matrix that is not completely-positive and fails validation when used with the [`qiskit.quantum_info.state_fidelity()`](quantum_info#qiskit.quantum_info.state_fidelity "qiskit.quantum_info.state_fidelity") or [`qiskit.quantum_info.process_fidelity()`](quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity") functions.

<span id="aqua-0-9-0" />

### Aqua 0.9.0

This release officially deprecates the Qiskit Aqua project, in the future (no sooner than 3 months from this release) the Aqua project will have it’s final release and be archived. All the functionality that qiskit-aqua provides has been migrated to either new packages or to other qiskit packages. The application modules that are provided by qiskit-aqua have been split into several new packages: `qiskit-optimization`, `qiskit-nature`, `qiskit-machine-learning`, and `qiskit-finance`. These packages can be installed by themselves (via the standard pip install command, ie `pip install qiskit-nature`) or with the rest of the Qiskit metapackage as optional extras (ie, `pip install 'qiskit[finance,optimization]'` or `pip install 'qiskit[all]'`. The core building blocks for algorithms and the operator flow now exist as part of qiskit-terra at [`qiskit.algorithms`](algorithms#module-qiskit.algorithms "qiskit.algorithms") and [`qiskit.opflow`](opflow#module-qiskit.opflow "qiskit.opflow"). Depending on your existing usage of Aqua you should either use the application packages or the new modules in Qiskit Terra.

For more details on how to migrate from using Qiskit Aqua, you can refer to the [migration guide](https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide).

<span id="id319" />

### IBM Q Provider 0.12.2

No change

<span id="qiskit-0-24-1" />

## Qiskit 0.24.1

<span id="terra-0-16-4" />

### Terra 0.16.4

No change

<span id="aer-0-7-6" />

### Aer 0.7.6

No change

<span id="ignis-0-5-2" />

### Ignis 0.5.2

No change

<span id="aqua-0-8-2" />

### Aqua 0.8.2

No change

<span id="id320" />

### IBM Q Provider 0.12.2

<span id="release-notes-ibmq-0-12-2-new-features" />

<span id="id321" />

#### Upgrade Notes

*   `qiskit.providers.ibmq.IBMQBackend.defaults()` now returns the pulse defaults for the backend if the backend supports pulse. However, your provider may not support pulse even if the backend does. The `open_pulse` flag in backend configuration indicates whether the provider supports it.

<span id="qiskit-0-24-0" />

## Qiskit 0.24.0

<span id="id322" />

### Terra 0.16.4

No change

<span id="id323" />

### Aer 0.7.6

<span id="release-notes-aer-0-7-6-new-features" />

<span id="id324" />

#### New Features

*   This is the first release of qiskit-aer that publishes precompiled binaries to PyPI for Linux on aarch64 (arm64). From this release onwards Linux aarch64 packages will be published and supported.

<span id="release-notes-aer-0-7-6-bug-fixes" />

<span id="id325" />

#### Bug Fixes

*   Fixes a bug [#1153](https://github.com/Qiskit/qiskit-aer/issues/1153) where noise on conditional gates was always being applied regardless of whether the conditional gate was actually applied based on the classical register value. Now noise on a conditional gate will only be applied in the case where the conditional gate is applied.
*   Fixed issue [#1126](https://github.com/Qiskit/qiskit-aer/issues/1126): bug in reporting measurement of a single qubit. The bug occured when copying the measured value to the output data structure.
*   There was previously a mismatch between the default reported number of qubits the Aer backend objects would say were supported and the the maximum number of qubits the simulator would actually run. This was due to a mismatch between the Python code used for calculating the max number of qubits and the C++ code used for a runtime check for the max number of qubits based on the available memory. This has been correct so by default now Aer backends will allow running circuits that can fit in all the available system memory. Fixes [#1114](https://github.com/Qiskit/qiskit-aer/issues/1126)

No change

<span id="id326" />

### Ignis 0.5.2

No change

<span id="id327" />

### Aqua 0.8.2

No change

<span id="ibm-q-provider-0-12-0" />

### IBM Q Provider 0.12.0

<span id="release-notes-ibmq-0-12-0-prelude" />

<span id="id328" />

#### Prelude

*   `qiskit.providers.ibmq.IBMQBackend.run()` method now takes one or more [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") or [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule"). Use of [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") and [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") is now deprecated. Runtime configuration options, such as the number of shots, can be set via either the `run()` method, or the `qiskit.providers.ibmq.IBMQBackend.set_options()` method. The former is used as a one-time setting for the job, and the latter for all jobs sent to the backend. If an option is set in both places, the value set in `run()` takes precedence.
*   IBM Quantum credentials are now loaded only from sections of the `qiskitrc` file that start with ‘ibmq’.

<span id="release-notes-ibmq-0-12-0-new-features" />

<span id="id329" />

#### New Features

*   Python 3.9 support has been added in this release. You can now run Qiskit IBMQ provider using Python 3.9.

*   `qiskit.providers.ibmq.AccountProvider.backends()` now has a new parameter min\_num\_qubits that allows you to filter by the minimum number of qubits.

*   `qiskit.providers.ibmq.IBMQBackend.run()` method now takes one or more [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") or [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule"). Runtime configuration options, such as the number of shots, can be set via either the `run()` method, or the `qiskit.providers.ibmq.IBMQBackend.set_options()` method. The former is used as a one-time setting for the job, and the latter for all jobs sent to the backend. If an option is set in both places, the value set in `run()` takes precedence. For example:

    ```python
    from qiskit import IBMQ, transpile
    from qiskit.test.reference_circuits import ReferenceCircuits

    provider = IBMQ.load_account()
    backend = provider.get_backend('ibmq_vigo')
    circuits = transpile(ReferenceCircuits.bell(), backend=backend)
    default_shots = backend.options.shots  # Returns the backend default of 1024 shots.
    backend.set_options(shots=2048)        # All jobs will now have use 2048 shots.
    backend.run(circuits)                  # This runs with 2048 shots.
    backend.run(circuits, shots=8192)      # This runs with 8192 shots.
    backend.run(circuits)                  # This again runs with 2048 shots.
    ```

*   `qiskit.providers.ibmq.experiment.Experiment` now has three additional attributes, hub, group, and project, that identify the provider used to create the experiment.

*   You can now assign an `experiment_id` to a job when submitting it using `qiskit.providers.ibmq.IBMQBackend.run()`. You can use this new field to group together a collection of jobs that belong to the same experiment. The `qiskit.providers.ibmq.IBMQBackendService.jobs()` method was also updated to allow filtering by `experiment_id`.

*   `qiskit.providers.ibmq.experiment.Experiment` now has two additional attributes:

    *   share\_level: The level at which the experiment is shared which determines who can see it when listing experiments. This can be updated.
    *   owner: The ID of the user that uploaded the experiment. This is set by the server and cannot be updated.

*   The method `qiskit.providers.ibmq.experimentservice.ExperimentService.experiments()` now accepts `hub`, `group`, and `project` as filtering keywords.

*   Methods `qiskit.providers.ibmq.experiment.ExperimentService.experiments()` and `qiskit.providers.ibmq.experiment.ExperimentService.analysis_results()` now support a `limit` parameter that allows you to limit the number of experiments and analysis results returned.

*   The method `qiskit.providers.ibmq.experimentservice.ExperimentService.experiments()` now accepts `exclude_mine` and `mine_only` as filtering keywords.

*   The method `qiskit.providers.ibmq.experimentservice.ExperimentService.experiments()` now accepts `exclude_public` and `public_only` as filtering keywords.

*   `qiskit.providers.ibmq.managed.IBMQJobManager.run()` now accepts a single [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") or [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") in addition to a list of them.

*   The `least_busy()` function now skips backends that are operational but paused, meaning they are accepting but not processing jobs.

*   You can now pickle an `IBMQJob` instance, as long as it doesn’t contain custom data that is not picklable (e.g. in Qobj header).

*   You can now use the two new methods, `qiskit.providers.ibmq.AccountProvider.services()` and `qiskit.providers.ibmq.AccountProvider.service()` to find out what services are available to your account and get an instance of a particular service.

*   The `qiskit.providers.ibmq.IBMQBackend.reservations()` method now always returns the reservation scheduling modes even for reservations that you don’t own.

<span id="release-notes-ibmq-0-12-0-upgrade-notes" />

<span id="id330" />

#### Upgrade Notes

*   A number of previously deprecated methods and features have been removed, including:

    > *   `qiskit.providers.ibmq.job.IBMQJob.to_dict()`
    > *   `qiskit.providers.ibmq.job.IBMQJob.from_dict()`
    > *   Qconfig.py support
    > *   Use of proxy URLs that do not include protocols

*   A new parameter, `limit` is now the first parameter for both `qiskit.providers.ibmq.experiment.ExperimentService.experiments()` and `qiskit.providers.ibmq.experiment.ExperimentService.analysis_results()` methods. This `limit` has a default value of 10, meaning by deafult only 10 experiments and analysis results will be returned.

*   IBM Quantum credentials are now loaded only from sections of the `qiskitrc` file that start with ‘ibmq’. This allows the `qiskitrc` file to be used for other functionality.

<span id="release-notes-ibmq-0-12-0-deprecation-notes" />

<span id="id331" />

#### Deprecation Notes

*   Use of [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") and [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") in the `qiskit.providers.ibmq.IBMQBackend.run()` method is now deprecated. [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") should now be used instead.

*   The `backends` attribute of `qiskit.providers.ibmq.AccountProvider` has been renamed to `backend` (sigular). For backward compatibility, you can continue to use `backends`, but it is deprecated and will be removed in a future release. The `qiskit.providers.ibmq.AccountProvider.backends()` method remains unchanged. For example:

    ```python
    backend = provider.backend.ibmq_vigo   # This is the new syntax.
    backend = provider.backends.ibmq_vigo  # This is deprecated.
    backends = provider.backends()         # This continues to work as before.
    ```

*   Setting of the `IBMQJob` `client_version` attribute has been deprecated. You can, however, continue to read the value of attribute.

*   “The `validate_qobj` keyword in `qiskit.providers.ibmq.IBMQBackend.run()` is deprecated and will be removed in a future release. If you’re relying on this schema validation you should pull the schemas from the [Qiskit/ibmq-schemas](https://github.com/Qiskit/ibm-quantum-schemas) and directly validate your payloads with that.

<span id="release-notes-ibmq-0-12-0-bug-fixes" />

<span id="id332" />

#### Bug Fixes

*   Fixes the issue wherein a job could be left in the `CREATING` state if job submit fails half-way through.
*   Fixes the issue wherein using Jupyter backend widget would fail if the backend’s basis gates do not include the traditional u1, u2, and u3. Fixes [#844](https://github.com/Qiskit/qiskit-ibmq-provider/issues/844)
*   Fixes the infinite loop raised when passing an `IBMQRandomService` instance to a child process.
*   Fixes the issue wherein a `TypeError` is raised if the server returns an error code but the response data is not in the expected format.

<span id="qiskit-0-23-6" />

## Qiskit 0.23.6

<span id="id334" />

### Terra 0.16.4

No change

<span id="aer-0-7-5" />

### Aer 0.7.5

<span id="release-notes-aer-0-7-5-prelude" />

<span id="id335" />

#### Prelude

This release is a bugfix release that fixes compatibility in the precompiled binary wheel packages with numpy versions \< 1.20.0. The previous release 0.7.4 was building the binaries in a way that would require numpy 1.20.0 which has been resolved now, so the precompiled binary wheel packages will work with any numpy compatible version.

<span id="id336" />

### Ignis 0.5.2

No change

<span id="id337" />

### Aqua 0.8.2

No change

<span id="ibm-q-provider-0-11-1" />

### IBM Q Provider 0.11.1

No change

<span id="qiskit-0-23-5" />

## Qiskit 0.23.5

<span id="id338" />

### Terra 0.16.4

<span id="release-notes-0-16-4-prelude" />

<span id="id339" />

#### Prelude

This release is a bugfix release that primarily fixes compatibility with numpy 1.20.0. This numpy release deprecated their local aliases for Python’s numeric types (`np.int` -> `int`, `np.float` -> `float`, etc.) and the usage of these aliases in Qiskit resulted in a large number of deprecation warnings being emitted. This release fixes this so you can run Qiskit with numpy 1.20.0 without those deprecation warnings.

<span id="aer-0-7-4" />

### Aer 0.7.4

<span id="release-notes-aer-0-7-4-bug-fixes" />

<span id="id340" />

#### Bug Fixes

Fixes compatibility with numpy 1.20.0. This numpy release deprecated their local aliases for Python’s numeric types (`np.int` -> `int`, `np.float` -> `float`, etc.) and the usage of these aliases in Qiskit Aer resulted in a large number of deprecation warnings being emitted. This release fixes this so you can run Qiskit Aer with numpy 1.20.0 without those deprecation warnings.

<span id="id341" />

### Ignis 0.5.2

<span id="release-notes-ignis-0-5-2-prelude" />

<span id="id342" />

#### Prelude

This release is a bugfix release that primarily fixes compatibility with numpy 1.20.0. It is also the first release to include support for Python 3.9. Earlier releases (including 0.5.0 and 0.5.1) worked with Python 3.9 but did not indicate this in the package metadata, and there was no upstream testing for those releases. This release fixes that and was tested on Python 3.9 (in addition to 3.6, 3.7, and 3.8).

<span id="release-notes-ignis-0-5-2-bug-fixes" />

<span id="id343" />

#### Bug Fixes

*   [networkx](https://networkx.org/) is explicitly listed as a dependency now. It previously was an implicit dependency as it was required for the `qiskit.ignis.verification.topological_codes` module but was not correctly listed as a depdendency as qiskit-terra also requires networkx and is also a depdency of ignis so it would always be installed in practice. However, it is necessary to list it as a requirement for future releases of qiskit-terra that will not require networkx. It’s also important to correctly list the dependencies of ignis in case there were a future incompatibility between version requirements.

<span id="id344" />

### Aqua 0.8.2

<span id="id345" />

### IBM Q Provider 0.11.1

No change

<span id="qiskit-0-23-4" />

## Qiskit 0.23.4

<span id="terra-0-16-3" />

### Terra 0.16.3

<span id="release-notes-0-16-3-bug-fixes" />

<span id="id346" />

#### Bug Fixes

*   Fixed an issue introduced in 0.16.2 that would cause errors when running [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") on a circuit with a series of 1 qubit gates and a non-gate instruction that only operates on a qubit (e.g. `Reset`). Fixes [#5736](https://github.com/Qiskit/qiskit-terra/issues/5736)

<span id="aer-0-7-3" />

### Aer 0.7.3

No change

<span id="ignis-0-5-1" />

### Ignis 0.5.1

No change

<span id="aqua-0-8-1" />

### Aqua 0.8.1

No change

<span id="id347" />

### IBM Q Provider 0.11.1

No change

<span id="qiskit-0-23-3" />

## Qiskit 0.23.3

<span id="terra-0-16-2" />

### Terra 0.16.2

<span id="release-notes-0-16-2-new-features" />

<span id="id348" />

#### New Features

*   Python 3.9 support has been added in this release. You can now run Qiskit Terra using Python 3.9.

<span id="release-notes-0-16-2-upgrade-notes" />

<span id="id349" />

#### Upgrade Notes

*   The class `MCXGrayCode` will now create a `C3XGate` if `num_ctrl_qubits` is 3 and a `C4XGate` if `num_ctrl_qubits` is 4. This is in addition to the previous functionality where for any of the modes of the :class:’qiskit.library.standard\_gates.x.MCXGate\`, if `num_ctrl_bits` is 1, a `CXGate` is created, and if 2, a `CCXGate` is created.

<span id="release-notes-0-16-2-bug-fixes" />

<span id="id350" />

#### Bug Fixes

*   Pulse [`Delay`](qiskit.pulse.instructions.Delay "qiskit.pulse.instructions.Delay") instructions are now explicitly assembled as [`PulseQobjInstruction`](qiskit.qobj.PulseQobjInstruction "qiskit.qobj.PulseQobjInstruction") objects included in the [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") output from [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble").

    Previously, we could ignore [`Delay`](qiskit.pulse.instructions.Delay "qiskit.pulse.instructions.Delay") instructions in a [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") as part of [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") as the time was explicit in the [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") objects. But, now with pulse gates, there are situations where we can schedule ONLY a delay, and not including the delay itself would remove the delay.

*   Circuits with custom gate calibrations can now be scheduled with the transpiler without explicitly providing the durations of each circuit calibration.

*   The [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") and [`Unroller`](qiskit.transpiler.passes.Unroller "qiskit.transpiler.passes.Unroller") passes, in some cases, had not been preserving the global phase of the circuit under transpilation. This has been fixed.

*   A bug in [`qiskit.pulse.builder.frequency_offset()`](pulse#qiskit.pulse.builder.frequency_offset "qiskit.pulse.builder.frequency_offset") where when `compensate_phase` was set a factor of $2\pi$ was missing from the appended phase.

*   Fix the global phase of the output of the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`repeat()`](qiskit.circuit.QuantumCircuit#repeat "qiskit.circuit.QuantumCircuit.repeat"). If a circuit with global phase is appended to another circuit, the global phase is currently not propagated. Simulators rely on this, since the phase otherwise gets applied multiple times. This sets the global phase of [`repeat()`](qiskit.circuit.QuantumCircuit#repeat "qiskit.circuit.QuantumCircuit.repeat") to 0 before appending the repeated circuit instead of multiplying the existing phase times the number of repetitions.

*   Fixes bug in [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") where multiplying by a certain non Python builtin Numpy scalar types returned incorrect values. Fixes [#5408](https://github.com/Qiskit/qiskit-terra/issues/5408)

*   The definition of the Hellinger fidelity from has been corrected from the previous defition of $1-H(P,Q)$ to $[1-H(P,Q)^2]^2$ so that it is equal to the quantum state fidelity of P, Q as diagonal density matrices.

*   Reduce the number of CX gates in the decomposition of the 3-controlled X gate, [`C3XGate`](qiskit.circuit.library.C3XGate "qiskit.circuit.library.C3XGate"). Compiled and optimized in the U CX basis, now only 14 CX and 16 U gates are used instead of 20 and 22, respectively.

*   Fixes the issue wherein using Jupyter backend widget or [`qiskit.tools.backend_monitor()`](tools#qiskit.tools.backend_monitor "qiskit.tools.backend_monitor") would fail if the backend’s basis gates do not include the traditional u1, u2, and u3.

*   When running [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") on a list of circuits with a single element, the function used to return a circuit instead of a list. Now, when [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") is called with a list, it will return a list even if that list has a single element. See [#5260](https://github.com/Qiskit/qiskit-terra/issues/5260).

    ```python
    from qiskit import *

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    transpiled = transpile([qc])
    print(type(transpiled), len(transpiled))
    ```

    ```python
    <class 'list'> 1
    ```

<span id="id351" />

### Aer 0.7.3

<span id="release-notes-aer-0-7-3-new-features" />

<span id="id352" />

#### New Features

*   Python 3.9 support has been added in this release. You can now run Qiskit Aer using Python 3.9 without building from source.

<span id="release-notes-aer-0-7-3-bug-fixes" />

<span id="id353" />

#### Bug Fixes

*   Fixes issue with setting `QasmSimulator` basis gates when using `"method"` and `"noise_model"` options together, and when using them with a simulator constructed using `from_backend()`. Now the listed basis gates will be the intersection of gates supported by the backend configuration, simulation method, and noise model basis gates. If the intersection of the noise model basis gates and simulator basis gates is empty a warning will be logged.
*   Fixes a bug that resulted in c\_if not working when the width of the conditional register was greater than 64. See [#1077](https://github.com/Qiskit/qiskit-aer/issues/1077).
*   Fixes bug in `from_backend()` and `from_backend()` where `basis_gates` was set incorrectly for IBMQ devices with basis gate set `['id', 'rz', 'sx', 'x', 'cx']`. Now the noise model will always have the same basis gates as the backend basis gates regardless of whether those instructions have errors in the noise model or not.
*   Fixes a bug when applying truncation in the matrix product state method of the QasmSimulator.

<span id="id354" />

### Ignis 0.5.1

No change

<span id="id355" />

### Aqua 0.8.1

No change

<span id="id356" />

### IBM Q Provider 0.11.1

No change

<span id="qiskit-0-23-2" />

## Qiskit 0.23.2

<span id="terra-0-16-1" />

### Terra 0.16.1

No change

<span id="aer-0-7-2" />

### Aer 0.7.2

<span id="release-notes-0-7-2-new-features" />

<span id="id357" />

#### New Features

*   Add the CMake flag `DISABLE_CONAN` (default=\`\`OFF\`\`)s. When installing from source, setting this to `ON` allows bypassing the Conan package manager to find libraries that are already installed on your system. This is also available as an environment variable `DISABLE_CONAN`, which takes precedence over the CMake flag. This is not the official procedure to build AER. Thus, the user is responsible of providing all needed libraries and corresponding files to make them findable to CMake.

<span id="release-notes-0-7-2-bug-fixes" />

<span id="id358" />

#### Bug Fixes

*   Fixes a bug with nested OpenMP flag was being set to true when it shouldn’t be.

<span id="id359" />

### Ignis 0.5.1

No change

<span id="id360" />

### Aqua 0.8.1

No change

<span id="id361" />

### IBM Q Provider 0.11.1

No change

<span id="qiskit-0-23-1" />

## Qiskit 0.23.1

<span id="release-notes-0-16-1" />

<span id="id362" />

### Terra 0.16.1

<span id="release-notes-0-16-1-bug-fixes" />

<span id="id363" />

#### Bug Fixes

*   Fixed an issue where an error was thrown in execute for valid circuits built with delays.
*   The QASM definition of ‘c4x’ in qelib1.inc has been corrected to match the standard library definition for C4XGate.
*   Fixes a bug in subtraction for quantum channels $A - B$ where $B$ was an [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") object. Negation was being applied to the matrix in the Operator representation which is not equivalent to negation in the quantum channel representation.
*   Changes the way `_evolve_instruction()` access qubits to handle the case of an instruction with multiple registers.

<span id="aer-0-7-1" />

<span id="release-notes-aer-0-7-1" />

### Aer 0.7.1

<span id="release-notes-aer-0-7-1-upgrade-notes" />

<span id="id364" />

#### Upgrade Notes

*   The minimum cmake version to build qiskit-aer has increased from 3.6 to 3.8. This change was necessary to enable fixing GPU version builds that support running on x86\_64 CPUs lacking AVX2 instructions.

<span id="release-notes-aer-0-7-1-bug-fixes" />

<span id="id365" />

#### Bug Fixes

*   qiskit-aer with GPU support will now work on systems with x86\_64 CPUs lacking AVX2 instructions. Previously, the GPU package would only run if the AVX2 instructions were available. Fixes [#1023](https://github.com/Qiskit/qiskit-aer/issues/1023)
*   Fixes bug with `AerProvider` where options set on the returned backends using `set_options()` were stored in the provider and would persist for subsequent calls to `get_backend()` for the same named backend. Now every call to and `backends()` returns a new instance of the simulator backend that can be configured.
*   Fixes bug in the error message returned when a circuit contains unsupported simulator instructions. Previously some supported instructions were also being listed in the error message along with the unsupported instructions.
*   Fix bug where the “sx”\` gate [`SXGate`](qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate") was not listed as a supported gate in the C++ code, in StateOpSet of matrix\_product\_state.hp.
*   Fix bug where `"csx"`, `"cu2"`, `"cu3"` were incorrectly listed as supported basis gates for the `"density_matrix"` method of the `QasmSimulator`.
*   In MPS, apply\_kraus was operating directly on the input bits in the parameter qubits, instead of on the internal qubits. In the MPS algorithm, the qubits are constantly moving around so all operations should be applied to the internal qubits.
*   When invoking MPS::sample\_measure, we need to first sort the qubits to the default ordering because this is the assumption in qasm\_controller.This is done by invoking the method move\_all\_qubits\_to\_sorted\_ordering. It was correct in sample\_measure\_using\_apply\_measure, but missing in sample\_measure\_using\_probabilities.

<span id="release-notes-ignis-0-5-1" />

<span id="id366" />

### Ignis 0.5.1

<span id="release-notes-ignis-0-5-1-bug-fixes" />

<span id="id367" />

#### Bug Fixes

*   Fix the `"auto"` method of the `TomographyFitter`, `StateTomographyFitter`, and `ProcessTomographyFitter` to only use `"cvx"` if CVXPY is installed *and* a third-party SDP solver other than SCS is available. This is because the SCS solver has lower accuracy than other solver methods and often returns a density matrix or Choi-matrix that is not completely-positive and fails validation when used with the [`qiskit.quantum_info.state_fidelity()`](quantum_info#qiskit.quantum_info.state_fidelity "qiskit.quantum_info.state_fidelity") or [`qiskit.quantum_info.process_fidelity()`](quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity") functions.

<span id="release-notes-aqua-0-8-1" />

<span id="id368" />

### Aqua 0.8.1

<span id="id369" />

### 0.8.1

<span id="release-notes-aqua-0-8-1-new-features" />

<span id="id370" />

#### New Features

*   A new algorithm has been added: the Born Openheimer Potential Energy surface for the calculation of potential energy surface along different degrees of freedom of the molecule. The algorithm is called `BOPESSampler`. It further provides functionalities of fitting the potential energy surface to an analytic function of predefined potentials.some details.

<span id="release-notes-aqua-0-8-1-critical-issues" />

#### Critical Issues

*   Be aware that `initial_state` parameter in `QAOA` has now different implementation as a result of a bug fix. The previous implementation wrongly mixed the user provided `initial_state` with Hadamard gates. The issue is fixed now. No attention needed if your code does not make use of the user provided `initial_state` parameter.

<span id="release-notes-aqua-0-8-1-bug-fixes" />

<span id="id371" />

#### Bug Fixes

*   optimize\_svm method of qp\_solver would sometimes fail resulting in an error like this ValueError: cannot reshape array of size 1 into shape (200,1) This addresses the issue by adding an L2 norm parameter, lambda2, which defaults to 0.001 but can be changed via the QSVM algorithm, as needed, to facilitate convergence.
*   A method `one_letter_symbol` has been removed from the `VarType` in the latest build of DOCplex making Aqua incompatible with this version. So instead of using this method an explicit type check of variable types has been introduced in the Aqua optimization module.
*   :meth\`\~qiskit.aqua.operators.state\_fns.DictStateFn.sample()\` could only handle real amplitudes, but it is fixed to handle complex amplitudes. #1311 \<[https://github.com/Qiskit/qiskit-aqua/issues/1311](https://github.com/Qiskit/qiskit-aqua/issues/1311)> for more details.
*   Trotter class did not use the reps argument in constructor. #1317 \<[https://github.com/Qiskit/qiskit-aqua/issues/1317](https://github.com/Qiskit/qiskit-aqua/issues/1317)> for more details.
*   Raise an AquaError if :class\`qiskit.aqua.operators.converters.CircuitSampler\` samples an empty operator. #1321 \<[https://github.com/Qiskit/qiskit-aqua/issues/1321](https://github.com/Qiskit/qiskit-aqua/issues/1321)> for more details.
*   `to_opflow()` returns a correct operator when coefficients are complex numbers. #1381 \<[https://github.com/Qiskit/qiskit-aqua/issues/1381](https://github.com/Qiskit/qiskit-aqua/issues/1381)> for more details.
*   Let backend simulators validate NoiseModel support instead of restricting to Aer only in QuantumInstance.
*   Correctly handle PassManager on QuantumInstance `transpile` method by calling its `run` method if it exists.
*   A bug that mixes custom `initial_state` in `QAOA` with Hadamard gates has been fixed. This doesn’t change functionality of QAOA if no initial\_state is provided by the user. Attention should be taken if your implementation uses QAOA with cusom `initial_state` parameter as the optimization results might differ.
*   Previously, setting seed\_simulator=0 in the QuantumInstance did not set any seed. This was only affecting the value 0. This has been fixed.

>

<span id="release-notes-ibmq-0-11-1" />

<span id="id372" />

### IBM Q Provider 0.11.1

>

<span id="release-notes-ibmq-0-11-1-new-features" />

<span id="id373" />

#### New Features

*   `qiskit.providers.ibmq.experiment.Experiment` now has three additional attributes, hub, group, and project, that identify the provider used to create the experiment.
*   Methods `qiskit.providers.ibmq.experiment.ExperimentService.experiments()` and `qiskit.providers.ibmq.experiment.ExperimentService.analysis_results()` now support a `limit` parameter that allows you to limit the number of experiments and analysis results returned.

<span id="release-notes-ibmq-0-11-1-upgrade-notes" />

<span id="id374" />

#### Upgrade Notes

*   A new parameter, `limit` is now the first parameter for both `qiskit.providers.ibmq.experiment.ExperimentService.experiments()` and `qiskit.providers.ibmq.experiment.ExperimentService.analysis_results()` methods. This `limit` has a default value of 10, meaning by deafult only 10 experiments and analysis results will be returned.

<span id="release-notes-ibmq-0-11-1-bug-fixes" />

<span id="id375" />

#### Bug Fixes

*   Fixes the issue wherein a job could be left in the `CREATING` state if job submit fails half-way through.
*   Fixes the infinite loop raised when passing an `IBMQRandomService` instance to a child process.

<span id="qiskit-0-23-0" />

## Qiskit 0.23.0

<span id="terra-0-16-0" />

### Terra 0.16.0

<span id="release-notes-0-16-0-prelude" />

<span id="id376" />

#### Prelude

The 0.16.0 release includes several new features and bug fixes. The major features in this release are the following:

*   Introduction of scheduled circuits, where delays can be used to control the timing and alignment of operations in the circuit.
*   Compilation of quantum circuits from classical functions, such as oracles.
*   Ability to compile and optimize single qubit rotations over different Euler basis as well as the phase + square-root(X) basis (i.e. `['p', 'sx']`), which will replace the older IBM Quantum basis of `['u1', 'u2', 'u3']`.
*   Tracking of [`global_phase()`](qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") on the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class has been extended through the [`transpiler`](transpiler#module-qiskit.transpiler "qiskit.transpiler"), [`quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info"), and [`assembler`](assembler#module-qiskit.assembler "qiskit.assembler") modules, as well as the BasicAer and Aer simulators. Unitary and state vector simulations will now return global phase-correct unitary matrices and state vectors.

Also of particular importance for this release is that Python 3.5 is no longer supported. If you are using Qiskit Terra with Python 3.5, the 0.15.2 release is that last version which will work.

<span id="release-notes-0-16-0-new-features" />

<span id="id377" />

#### New Features

*   Global R gates have been added to [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library"). This includes the global R gate ([`GR`](qiskit.circuit.library.GR "qiskit.circuit.library.GR")), global Rx ([`GRX`](qiskit.circuit.library.GRX "qiskit.circuit.library.GRX")) and global Ry ([`GRY`](qiskit.circuit.library.GRY "qiskit.circuit.library.GRY")) gates which are derived from the [`GR`](qiskit.circuit.library.GR "qiskit.circuit.library.GR") gate, and global Rz ( [`GRZ`](qiskit.circuit.library.GRZ "qiskit.circuit.library.GRZ")) that is defined in a similar way to the [`GR`](qiskit.circuit.library.GR "qiskit.circuit.library.GR") gates. The global R gates are defined on a number of qubits simultaneously, and act as a direct sum of R gates on each qubit.

    For example:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister
    import numpy as np

    num_qubits = 3
    qr = QuantumRegister(num_qubits)
    qc = QuantumCircuit(qr)

    qc.compose(GR(num_qubits, theta=np.pi/3, phi=2*np.pi/3), inplace=True)
    ```

    will create a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") on a [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") of 3 qubits and perform a [`RGate`](qiskit.circuit.library.RGate "qiskit.circuit.library.RGate") of an angle $\theta = \frac{\pi}{3}$ about an axis in the xy-plane of the Bloch spheres that makes an angle of $\phi = \frac{2\pi}{3}$ with the x-axis on each qubit.

*   A new color scheme, `iqx`, has been added to the `mpl` backend for the circuit drawer [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw"). This uses the same color scheme as the Circuit Composer on the IBM Quantum Experience website. There are now 3 available color schemes - `default`, `iqx`, and `bw`.

    There are two ways to select a color scheme. The first is to use a user config file, by default in the `~/.qiskit` directory, in the file `settings.conf` under the `[Default]` heading, a user can enter `circuit_mpl_style = iqx` to select the `iqx` color scheme.

    The second way is to add `{'name': 'iqx'}` to the `style` kwarg to the `QuantumCircuit.draw` method or to the `circuit_drawer` function. The second way will override the setting in the settings.conf file. For example:

    ```python
    from qiskit.circuit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()
    circuit.draw('mpl', style={'name': 'iqx'})
    ```

*   In the `style` kwarg for the the circuit drawer [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") the `displaycolor` field with the `mpl` backend now allows for entering both the gate color and the text color for each gate type in the form `(gate_color, text_color)`. This allows the use of light and dark gate colors with contrasting text colors. Users can still set only the gate color, in which case the `gatetextcolor` field will be used. Gate colors can be set in the `style` dict for any number of gate types, from one to the entire `displaycolor` dict. For example:

    ```python
    from qiskit.circuit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.h(0)

    style_dict = {'displaycolor': {'h': ('#FA74A6', '#000000')}}
    circuit.draw('mpl', style=style_dict)
    ```

    or

    ```python
    style_dict = {'displaycolor': {'h': '#FA74A6'}}
    circuit.draw('mpl', style=style_dict)
    ```

*   Two alignment contexts are added to the pulse builder ([`qiskit.pulse.builder`](pulse#module-qiskit.pulse.builder "qiskit.pulse.builder")) to facilitate writing a repeated pulse sequence with delays.

    *   [`qiskit.pulse.builder.align_equispaced()`](pulse#qiskit.pulse.builder.align_equispaced "qiskit.pulse.builder.align_equispaced") inserts delays with equivalent length in between pulse schedules within the context.
    *   [`qiskit.pulse.builder.align_func()`](pulse#qiskit.pulse.builder.align_func "qiskit.pulse.builder.align_func") offers more advanced control of pulse position. This context takes a callable that calculates a fractional coordinate of i-th pulse and aligns pulses within the context. This makes coding of dynamical decoupling easy.

*   A `rep_delay` parameter has been added to the [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") class under the run configuration, [`QasmQobjConfig`](qiskit.qobj.QasmQobjConfig "qiskit.qobj.QasmQobjConfig"). This parameter is used to denote the time between program executions. It must be chosen from the backend range given by the [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") method `rep_delay_range()`. If a value is not provided a backend default, `qiskit.providers.models.BackendConfiguration.default_rep_delay`, will be used. `rep_delay` will only work on backends which allow for dynamic repetition time. This is can be checked with the [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") property `dynamic_reprate_enabled`.

*   The `qobj_schema.json` JSON Schema file in `qiskit.schemas` has been updated to include the `rep_delay` as an optional configuration property for QASM Qobjs.

*   The `backend_configuration_schema.json` JSON Schema file in `qiskit.schemas` has been updated to include `dynamic_reprate_enabled`, `rep_delay_range` and `default_rep_delay` as optional properties for a QASM backend configuration payload.

*   A new optimization pass, [`qiskit.transpiler.passes.TemplateOptimization`](qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") has been added to the transpiler. This pass applies a template matching algorithm described in [arXiv:1909.05270](https://arxiv.org/pdf/1909.05270.pdf) that replaces all compatible maximal matches in the circuit.

    To implement this new transpiler pass a new module, `template_circuits`, was added to the circuit library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library")). This new module contains all the Toffoli circuit templates used in the [`TemplateOptimization`](qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization").

    This new pass is **not** currently included in the preset pass managers ([`qiskit.transpiler.preset_passmanagers`](transpiler_preset#module-qiskit.transpiler.preset_passmanagers "qiskit.transpiler.preset_passmanagers")), to use it you will need to create a custom [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager").

*   A new version of the providers interface has been added. This new interface, which can be found in [`qiskit.providers`](providers#module-qiskit.providers "qiskit.providers"), provides a new versioning mechanism that will enable changes to the interface to happen in a compatible manner over time. The new interface should be simple to migrate existing providers, as it is mostly identical except for the explicit versioning.

    Besides having explicitly versioned abstract classes the key changes for the new interface are that the [`BackendV1`](qiskit.providers.BackendV1 "qiskit.providers.BackendV1") method [`run()`](qiskit.providers.BackendV1#run "qiskit.providers.BackendV1.run") can now take a `QuantumCircuit` or [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") object as inputs instead of `Qobj` objects. To go along with that options are now part of a backend class so that users can configure run time options when running with a circuit. The final change is that [`qiskit.providers.JobV1`](qiskit.providers.JobV1 "qiskit.providers.JobV1") can now be synchronous or asynchronous, the exact configuration and method for configuring this is up to the provider, but there are interface hook points to make it explicit which execution model a job is running under in the `JobV1` abstract class.

*   A new kwarg, `inplace`, has been added to the function [`qiskit.result.marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts"). This kwarg is used to control whether the contents are marginalized in place or a new copy is returned, for [`Result`](qiskit.result.Result "qiskit.result.Result") object input. This parameter does not have any effect for an input `dict` or [`Counts`](qiskit.result.Counts "qiskit.result.Counts") object.

*   An initial version of a classical function compiler, [`qiskit.circuit.classicalfunction`](classicalfunction#module-qiskit.circuit.classicalfunction "qiskit.circuit.classicalfunction"), has been added. This enables compiling typed python functions (operating only on bits of type `Int1` at the moment) into [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects. For example:

    ```python
    from qiskit.circuit import classical_function, Int1

    @classical_function
    def grover_oracle(a: Int1, b: Int1, c: Int1, d: Int1) -> Int1:
         x = not a and b
         y = d and not c
         z = not x or y
         return z

    quantum_circuit = grover_oracle.synth()
    quantum_circuit.draw()
    ```

    The parameter `registerless=False` in the [`qiskit.circuit.classicalfunction.ClassicalFunction`](qiskit.circuit.classicalfunction.ClassicalFunction "qiskit.circuit.classicalfunction.ClassicalFunction") method [`synth()`](qiskit.circuit.classicalfunction.ClassicalFunction#synth "qiskit.circuit.classicalfunction.ClassicalFunction.synth") creates a circuit with registers refering to the parameter names. For example:

    ```python
    quantum_circuit = grover_oracle.synth(registerless=False)
    quantum_circuit.draw()
    ```

    A decorated classical function can be used the same way as any other quantum gate when appending it to a circuit.

    ```python
    circuit = QuantumCircuit(5)
    circuit.append(grover_oracle, range(5))
    circuit.draw()
    ```

    The `GROVER_ORACLE` gate is synthesized when its decomposition is required.

    ```python
    circuit.decompose().draw()
    ```

    The feature requires `tweedledum`, a library for synthesizing quantum circuits, that can be installed via pip with `pip install tweedledum`.

*   A new class [`qiskit.circuit.Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") for representing a delay instruction in a circuit has been added. A new method [`delay()`](qiskit.circuit.QuantumCircuit#delay "qiskit.circuit.QuantumCircuit.delay") is now available for easily appending delays to circuits. This makes it possible to describe timing-sensitive experiments (e.g. T1/T2 experiment) in the circuit level.

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(1, 1)
    qc.delay(500, 0, unit='ns')
    qc.measure(0, 0)

    qc.draw()
    ```

*   A new argument `scheduling_method` for [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") has been added. It is required when transpiling circuits with delays. If `scheduling_method` is specified, the transpiler returns a scheduled circuit such that all idle times in it are padded with delays (i.e. start time of each instruction is uniquely determined). This makes it possible to see how scheduled instructions (gates) look in the circuit level.

    ```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.test.mock.backends import FakeAthens

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)

    scheduled_circuit = transpile(qc, backend=FakeAthens(), scheduling_method="alap")
    print("Duration in dt:", scheduled_circuit.duration)
    scheduled_circuit.draw(idle_wires=False)
    ```

    See also [`timeline_drawer()`](qiskit.visualization.timeline_drawer "qiskit.visualization.timeline_drawer") for the best visualization of scheduled circuits.

*   A new fuction [`qiskit.compiler.sequence()`](compiler#qiskit.compiler.sequence "qiskit.compiler.sequence") has been also added so that we can convert a scheduled circuit into a [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") to make it executable on a pulse-enabled backend.

    ```python
    from qiskit.compiler import sequence

    sched = sequence(scheduled_circuit, pulse_enabled_backend)
    ```

*   The [`schedule()`](compiler#qiskit.compiler.schedule "qiskit.compiler.schedule") has been updated so that it can schedule circuits with delays. Now there are two paths to schedule a circuit with delay:

    ```python
    qc = QuantumCircuit(1, 1)
    qc.h(0)
    qc.delay(500, 0, unit='ns')
    qc.h(0)
    qc.measure(0, 0)

    sched_path1 = schedule(qc.decompose(), backend)
    sched_path2 = sequence(transpile(qc, backend, scheduling_method='alap'), backend)
    assert pad(sched_path1) == sched_path2
    ```

    Refer to the release notes and documentation for [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`sequence()`](compiler#qiskit.compiler.sequence "qiskit.compiler.sequence") for the details on the other path.

*   Added the [`GroverOperator`](qiskit.circuit.library.GroverOperator "qiskit.circuit.library.GroverOperator") to the circuit library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library")) to construct the Grover operator used in Grover’s search algorithm and Quantum Amplitude Amplification/Estimation. Provided with an oracle in form of a circuit, `GroverOperator` creates the textbook Grover operator. To generalize this for amplitude amplification and use a generic operator instead of Hadamard gates as state preparation, the `state_in` argument can be used.

*   The [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") methods [`get()`](qiskit.pulse.InstructionScheduleMap#get "qiskit.pulse.InstructionScheduleMap.get") and [`pop()`](qiskit.pulse.InstructionScheduleMap#pop "qiskit.pulse.InstructionScheduleMap.pop") methods now take [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") instances in addition to numerical values for schedule generator parameters. If the generator is a function, expressions may be bound before or within the function call. If the generator is a `ParametrizedSchedule`, expressions must be bound before the schedule itself is bound/called.

*   A new class [`LinearAmplitudeFunction`](qiskit.circuit.library.LinearAmplitudeFunction "qiskit.circuit.library.LinearAmplitudeFunction") was added to the circuit library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library")) for mapping (piecewise) linear functions on qubit amplitudes,

    $$
    F|x\rangle |0\rangle = \sqrt{1 - f(x)}|x\rangle |0\rangle + \sqrt{f(x)}|x\rangle |1\rangle
    $$

    The mapping is based on a controlled Pauli Y-rotations and a Taylor approximation, as described in [https://arxiv.org/abs/1806.06893](https://arxiv.org/abs/1806.06893). This circuit can be used to compute expectation values of linear functions using the quantum amplitude estimation algorithm.

*   The new jupyter magic `monospaced_output` has been added to the [`qiskit.tools.jupyter`](tools_jupyter#module-qiskit.tools.jupyter "qiskit.tools.jupyter") module. This magic sets the Jupyter notebook output font to “Courier New”, when possible. When used this fonts returns text circuit drawings that are better aligned.

    ```python
    import qiskit.tools.jupyter
    %monospaced_output
    ```

*   A new transpiler pass, [`Optimize1qGatesDecomposition`](qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition"), has been added. This transpiler pass is an alternative to the existing [`Optimize1qGates`](qiskit.transpiler.passes.Optimize1qGates "qiskit.transpiler.passes.Optimize1qGates") that uses the [`OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") class to decompose and simplify a chain of single qubit gates. This method is compatible with any basis set, while [`Optimize1qGates`](qiskit.transpiler.passes.Optimize1qGates "qiskit.transpiler.passes.Optimize1qGates") only works for u1, u2, and u3. The default pass managers for `optimization_level` 1, 2, and 3 have been updated to use this new pass if the basis set doesn’t include u1, u2, or u3.

*   The [`OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") now supports two new basis, `'PSX'` and `'U'`. These can be specified with the `basis` kwarg on the constructor. This will decompose the matrix into a circuit using `PGate` and [`SXGate`](qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate") for `'PSX'`, and [`UGate`](qiskit.circuit.library.UGate "qiskit.circuit.library.UGate") for `'U'`.

*   A new method [`remove()`](qiskit.transpiler.PassManager#remove "qiskit.transpiler.PassManager.remove") has been added to the [`qiskit.transpiler.PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") class. This method enables removing a pass from a [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") instance. It works on indexes, similar to [`replace()`](qiskit.transpiler.PassManager#replace "qiskit.transpiler.PassManager.replace"). For example, to remove the [`RemoveResetInZeroState`](qiskit.transpiler.passes.RemoveResetInZeroState "qiskit.transpiler.passes.RemoveResetInZeroState") pass from the pass manager used at optimization level 1:

    ```python
    from qiskit.transpiler.preset_passmanagers import level_1_pass_manager
    from qiskit.transpiler.passmanager_config import PassManagerConfig

    pm = level_1_pass_manager(PassManagerConfig())
    pm.draw()
    ```

    ```python
    [0] FlowLinear: UnrollCustomDefinitions, BasisTranslator
    [1] FlowLinear: RemoveResetInZeroState
    [2] DoWhile: Depth, FixedPoint, Optimize1qGates, CXCancellation
    ```

    The stage `[1]` with `RemoveResetInZeroState` can be removed like this:

    ```python
    pass_manager.remove(1)
    pass_manager.draw()
    ```

    ```python
    [0] FlowLinear: UnrollCustomDefinitions, BasisTranslator
    [1] DoWhile: Depth, FixedPoint, Optimize1qGates, CXCancellation
    ```

*   Several classes to load probability distributions into qubit amplitudes; `UniformDistribution`, `NormalDistribution`, and `LogNormalDistribution` were added to the circuit library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library")). The normal and log-normal distribution support both univariate and multivariate distributions. These circuits are central to applications in finance where quantum amplitude estimation is used.

*   Support for pulse gates has been added to the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This enables a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") to override (for basis gates) or specify (for standard and custom gates) a definition of a [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") operation in terms of time-ordered signals across hardware channels. In other words, it enables the option to provide pulse-level custom gate calibrations.

    The circuits are built exactly as before. For example:

    ```python
    from qiskit import pulse
    from qiskit.circuit import QuantumCircuit, Gate

    class RxGate(Gate):
        def __init__(self, theta):
            super().__init__('rxtheta', 1, [theta])

    circ = QuantumCircuit(1)
    circ.h(0)
    circ.append(RxGate(3.14), [0])
    ```

    Then, the calibration for the gate can be registered using the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`add_calibration()`](qiskit.circuit.QuantumCircuit#add_calibration "qiskit.circuit.QuantumCircuit.add_calibration") which takes a [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") definition as well as the qubits and parameters that it is defined for:

    ```python
    # Define the gate implementation as a schedule
    with pulse.build() as custom_h_schedule:
        pulse.play(pulse.library.Drag(...), pulse.DriveChannel(0))

    with pulse.build() as q1_x180:
        pulse.play(pulse.library.Gaussian(...), pulse.DriveChannel(1))

    # Register the schedule to the gate
    circ.add_calibration('h', [0], custom_h_schedule)  # or gate.name string to register
    circ.add_calibration(RxGate(3.14), [0], q1_x180)   # Can accept gate
    ```

    Previously, this functionality could only be used through complete Pulse Schedules. Additionally, circuits can now be submitted to backends with your custom definitions (dependent on backend support).

    Circuits with pulse gates can still be lowered to a [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") by using the [`schedule()`](compiler#qiskit.compiler.schedule "qiskit.compiler.schedule") function.

    The calibrated gate can also be transpiled using the regular transpilation process:

    ```python
    transpiled_circuit = transpile(circ, backend)
    ```

    The transpiled circuit will leave the calibrated gates on the same qubit as the original circuit and will not unroll them to the basis gates.

*   Support for disassembly of [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") objects has been added to the [`qiskit.assembler.disassemble()`](assembler#qiskit.assembler.disassemble "qiskit.assembler.disassemble") function. For example:

    ```python
    from qiskit import pulse
    from qiskit.assembler.disassemble import disassemble
    from qiskit.compiler.assemble import assemble
    from qiskit.test.mock import FakeOpenPulse2Q

    backend = FakeOpenPulse2Q()

    d0 = pulse.DriveChannel(0)
    d1 = pulse.DriveChannel(1)
    with pulse.build(backend) as sched:
        with pulse.align_right():
            pulse.play(pulse.library.Constant(10, 1.0), d0)
            pulse.shift_phase(3.11, d0)
            pulse.measure_all()

    qobj = assemble(sched, backend=backend, shots=512)
    scheds, run_config, header = disassemble(qobj)
    ```

*   A new kwarg, `coord_type` has been added to [`qiskit.visualization.plot_bloch_vector()`](qiskit.visualization.plot_bloch_vector "qiskit.visualization.plot_bloch_vector"). This kwarg enables changing the coordinate system used for the input parameter that describes the positioning of the vector on the Bloch sphere in the generated visualization. There are 2 supported values for this new kwarg, `'cartesian'` (the default value) and `'spherical'`. If the `coord_type` kwarg is set to `'spherical'` the list of parameters taken in are of the form `[r, theta,  phi]` where `r` is the radius, `theta` is the inclination from +z direction, and `phi` is the azimuth from +x direction. For example:

    ```python
    from numpy import pi

    from qiskit.visualization import plot_bloch_vector

    x = 0
    y = 0
    z = 1
    r = 1
    theta = pi
    phi = 0


    # Cartesian coordinates, where (x,y,z) are cartesian coordinates
    # for bloch vector
    plot_bloch_vector([x,y,z])
    ```

    ```python
    plot_bloch_vector([x,y,z], coord_type="cartesian")  # Same as line above
    ```

    ```python
    # Spherical coordinates, where (r,theta,phi) are spherical coordinates
    # for bloch vector
    plot_bloch_vector([r, theta, phi], coord_type="spherical")
    ```

*   Pulse [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") objects now support using [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects for parameters.

    For example:

    ```python
    from qiskit.circuit import Parameter
    from qiskit import pulse

    alpha = Parameter('⍺')
    phi = Parameter('ϕ')
    qubit = Parameter('q')
    amp = Parameter('amp')

    schedule = pulse.Schedule()
    schedule += SetFrequency(alpha, DriveChannel(qubit))
    schedule += ShiftPhase(phi, DriveChannel(qubit))
    schedule += Play(Gaussian(duration=128, sigma=4, amp=amp),
                     DriveChannel(qubit))
    schedule += ShiftPhase(-phi, DriveChannel(qubit))
    ```

    Parameter assignment is done via the [`assign_parameters()`](qiskit.pulse.Schedule#assign_parameters "qiskit.pulse.Schedule.assign_parameters") method:

    ```python
    schedule.assign_parameters({alpha: 4.5e9, phi: 1.57,
                                qubit: 0, amp: 0.2})
    ```

    Expressions and partial assignment also work, such as:

    ```python
    beta = Parameter('b')
    schedule += SetFrequency(alpha + beta, DriveChannel(0))
    schedule.assign_parameters({alpha: 4.5e9})
    schedule.assign_parameters({beta: phi / 6.28})
    ```

*   A new visualization function [`timeline_drawer()`](qiskit.visualization.timeline_drawer "qiskit.visualization.timeline_drawer") was added to the [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization") module.

    For example:

    ```python
    from qiskit.visualization import timeline_drawer
    from qiskit import QuantumCircuit, transpile
    from qiskit.test.mock import FakeAthens

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0,1)
    timeline_drawer(transpile(qc, FakeAthens(), scheduling_method='alap'))
    ```

<span id="release-notes-0-16-0-upgrade-notes" />

<span id="id378" />

#### Upgrade Notes

*   Type checking for the `params` kwarg of the constructor for the [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") class and its subclasses has been changed. Previously all [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") parameters had to be in a set of allowed types defined in the [`Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") class. Now a new method, [`validate_parameter()`](qiskit.circuit.Gate#validate_parameter "qiskit.circuit.Gate.validate_parameter") is used to determine if a parameter type is valid or not. The definition of this method in a subclass will take priority over its parent. For example, `UnitaryGate` accepts a parameter of the type `numpy.ndarray` and defines a custom `validate_parameter()` method that returns the parameter if it’s an `numpy.ndarray`. This takes priority over the function defined in its parent class [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate"). If `UnitaryGate` were to be used as parent for a new class, this `validate_parameter` method would be used unless the new child class defines its own method.

*   The previously deprecated methods, arguments, and properties named `n_qubits` and `numberofqubits` have been removed. These were deprecated in the 0.13.0 release. The full set of changes are:

    | Class                                                                             | Old              | New                                                                                                 |
    | --------------------------------------------------------------------------------- | ---------------- | --------------------------------------------------------------------------------------------------- |
    | [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") | `n_qubits`       | [`num_qubits`](qiskit.circuit.QuantumCircuit#num_qubits "qiskit.circuit.QuantumCircuit.num_qubits") |
    | [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli")                  | `numberofqubits` | [`num_qubits`](qiskit.quantum_info.Pauli#num_qubits "qiskit.quantum_info.Pauli.num_qubits")         |

    | Function                                                                                                                        | Old Argument | New Argument |
    | ------------------------------------------------------------------------------------------------------------------------------- | ------------ | ------------ |
    | [`qiskit.circuit.random.random_circuit()`](circuit#qiskit.circuit.random.random_circuit "qiskit.circuit.random.random_circuit") | `n_qubits`   | `num_qubits` |
    | [`qiskit.circuit.library.MSGate`](qiskit.circuit.library.MSGate "qiskit.circuit.library.MSGate")                                | `n_qubits`   | `num_qubits` |

*   Inserting a parameterized [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") instance into a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") now creates a copy of that gate which is used in the circuit. If changes are made to the instance inserted into the circuit it will no longer be reflected in the gate in the circuit. This change was made to fix an issue when inserting a single parameterized [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") object into multiple circuits.

*   The function [`qiskit.result.marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") now, by default, does not modify the [`qiskit.result.Result`](qiskit.result.Result "qiskit.result.Result") instance parameter. Previously, the `Result` object was always modified in place. A new kwarg `inplace` has been added [`marginal_counts()`](result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") which enables using the previous behavior when `inplace=True` is set.

*   The [`U3Gate`](qiskit.circuit.library.U3Gate "qiskit.circuit.library.U3Gate") definition has been changed to be in terms of the [`UGate`](qiskit.circuit.library.UGate "qiskit.circuit.library.UGate") class. The [`UGate`](qiskit.circuit.library.UGate "qiskit.circuit.library.UGate") class has no definition. It is therefore not possible to unroll **every** circuit in terms of U3 and CX anymore. Instead, U and CX can be used for **every** circuit.

*   The deprecated support for running Qiskit Terra with Python 3.5 has been removed. To use Qiskit Terra from this release onward you will now need to use at least Python 3.6. If you are using Python 3.5 the last version which will work is Qiskit Terra 0.15.2.

*   In the [`PulseBackendConfiguration`](qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") in the `hamiltonian` attributes the `vars` field is now returned in a unit of Hz instead of the previously used GHz. This change was made to be consistent with the units used with the other attributes in the class.

*   The previously deprecated support for passing in a dictionary as the first positional argument to [`DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") constructor has been removed. Using a dictonary for the first positional argument was deprecated in the 0.13.0 release. To create a [`DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") object now you should directly pass the attributes as kwargs on the constructor.

*   The keyword arguments for the circuit gate methods (for example: [`qiskit.circuit.QuantumCircuit.cx`](qiskit.circuit.QuantumCircuit#cx "qiskit.circuit.QuantumCircuit.cx")) `q`, `ctl*`, and `tgt*`, which were deprecated in the 0.12.0 release, have been removed. Instead, only `qubit`, `control_qubit*` and `target_qubit*` can be used as named arguments for these methods.

*   The previously deprecated module `qiskit.extensions.standard` has been removed. This module has been deprecated since the 0.14.0 release. The [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") can be used instead. Additionally, all the gate classes previously in `qiskit.extensions.standard` are still importable from [`qiskit.extensions`](extensions#module-qiskit.extensions "qiskit.extensions").

*   The previously deprecated gates in the module `qiskit.extensions.quantum_initializer`: `DiagGate`, UCG\`, `UCPauliRotGate`, `UCRot`, `UCRXGate`, `UCX`, `UCRYGate`, `UCY`, `UCRZGate`, `UCZ` have been removed. These were all deprecated in the 0.14.0 release and have alternatives available in the circuit library ([`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library")).

*   The previously deprecated [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") gate method `iden()` has been removed. This was deprecated in the 0.13.0 release and [`i()`](qiskit.circuit.QuantumCircuit#i "qiskit.circuit.QuantumCircuit.i") or [`id()`](qiskit.circuit.QuantumCircuit#id "qiskit.circuit.QuantumCircuit.id") can be used instead.

<span id="id379" />

#### Deprecation Notes

*   The use of a `numpy.ndarray` for a parameter in the `params` kwarg for the constructor of the [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") class and subclasses has been deprecated and will be removed in future releases. This was done as part of the refactoring of how `parms` type checking is handled for the [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") class. If you have a custom gate class which is a subclass of [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") directly (or via a different parent in the hierarchy) that accepts an `ndarray` parameter, you should define a custom [`validate_parameter()`](qiskit.circuit.Gate#validate_parameter "qiskit.circuit.Gate.validate_parameter") method for your class that will return the allowed parameter type. For example:

    ```python
    def validate_parameter(self, parameter):
        """Custom gate parameter has to be an ndarray."""
        if isinstance(parameter, numpy.ndarray):
            return parameter
        else:
            raise CircuitError("invalid param type {0} in gate "
                               "{1}".format(type(parameter), self.name))
    ```

*   The [`num_ancilla_qubits`](qiskit.circuit.library.PiecewiseLinearPauliRotations#num_ancilla_qubits "qiskit.circuit.library.PiecewiseLinearPauliRotations.num_ancilla_qubits") property of the [`PiecewiseLinearPauliRotations`](qiskit.circuit.library.PiecewiseLinearPauliRotations "qiskit.circuit.library.PiecewiseLinearPauliRotations") and [`PolynomialPauliRotations`](qiskit.circuit.library.PolynomialPauliRotations "qiskit.circuit.library.PolynomialPauliRotations") classes has been deprecated and will be removed in a future release. Instead the property [`num_ancillas`](qiskit.circuit.library.PolynomialPauliRotations#num_ancillas "qiskit.circuit.library.PolynomialPauliRotations.num_ancillas") should be used instead. This was done to make it consistent with the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`num_ancillas()`](qiskit.circuit.QuantumCircuit#num_ancillas "qiskit.circuit.QuantumCircuit.num_ancillas").

*   The [`qiskit.circuit.library.MSGate`](qiskit.circuit.library.MSGate "qiskit.circuit.library.MSGate") class has been deprecated, but will remain in place to allow loading of old jobs. It has been replaced with the [`qiskit.circuit.library.GMS`](qiskit.circuit.library.GMS "qiskit.circuit.library.GMS") class which should be used instead.

*   The `MSBasisDecomposer` transpiler pass has been deprecated and will be removed in a future release. The [`qiskit.transpiler.passes.BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") pass can be used instead.

*   The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods `u1`, `u2` and `u3` are now deprecated. Instead the following replacements can be used.

    ```python
    u1(theta) = p(theta) = u(0, 0, theta)
    u2(phi, lam) = u(pi/2, phi, lam) = p(pi/2 + phi) sx p(pi/2 lam)
    u3(theta, phi, lam) = u(theta, phi, lam) = p(phi + pi) sx p(theta + pi) sx p(lam)
    ```

    The gate classes themselves, [`U1Gate`](qiskit.circuit.library.U1Gate "qiskit.circuit.library.U1Gate"), [`U2Gate`](qiskit.circuit.library.U2Gate "qiskit.circuit.library.U2Gate") and [`U3Gate`](qiskit.circuit.library.U3Gate "qiskit.circuit.library.U3Gate") remain, to allow loading of old jobs.

<span id="release-notes-0-16-0-bug-fixes" />

<span id="id380" />

#### Bug Fixes

*   The [`Result`](qiskit.result.Result "qiskit.result.Result") class’s methods [`data()`](qiskit.result.Result#data "qiskit.result.Result.data"), [`get_memory()`](qiskit.result.Result#get_memory "qiskit.result.Result.get_memory"), [`get_counts()`](qiskit.result.Result#get_counts "qiskit.result.Result.get_counts"), [`get_unitary()`](qiskit.result.Result#get_unitary "qiskit.result.Result.get_unitary"), and ```get_statevector ` will now emit a warning when the ``experiment`()``` kwarg is specified for attempting to fetch results using either a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") or [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") instance, when more than one entry matching the instance name is present in the `Result` object. Note that only the first entry matching this name will be returned. Fixes [#3207](https://github.com/Qiskit/qiskit-terra/issues/3207)
*   The [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`append()`](qiskit.circuit.QuantumCircuit#append "qiskit.circuit.QuantumCircuit.append") can now be used to insert one parameterized gate instance into multiple circuits. This fixes a previous issue where inserting a single parameterized [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") object into multiple circuits would cause failures when one circuit had a parameter assigned. Fixes [#4697](https://github.com/Qiskit/qiskit-terra/issues/4697)
*   Previously the `qiskit.execute.execute()` function would incorrectly disallow both the `backend` and `pass_manager` kwargs to be specified at the same time. This has been fixed so that both `backend` and `pass_manager` can be used together on calls to `execute()`. Fixes [#5037](https://github.com/Qiskit/qiskit-terra/issues/5037)
*   The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`unitary()`](qiskit.circuit.QuantumCircuit#unitary "qiskit.circuit.QuantumCircuit.unitary") method has been fixed to accept a single integer for the `qarg` argument (when adding a 1-qubit unitary). The allowed types for the `qargs` argument are now `int`, [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit"), or a list of integers. Fixes [#4944](https://github.com/Qiskit/qiskit-terra/issues/4944)
*   Previously, calling `inverse()` on a `BlueprintCircuit` object could fail if its internal data property was not yet populated. This has been fixed so that the calling `inverse()` will populate the internal data before generating the inverse of the circuit. Fixes [#5140](https://github.com/Qiskit/qiskit-terra/issues/5140)
*   Fixed an issue when creating a [`qiskit.result.Counts`](qiskit.result.Counts "qiskit.result.Counts") object from an empty data dictionary. Now this will create an empty [`Counts`](qiskit.result.Counts "qiskit.result.Counts") object. The [`most_frequent()`](qiskit.result.Counts#most_frequent "qiskit.result.Counts.most_frequent") method is also updated to raise a more descriptive exception when the object is empty. Fixes [#5017](https://github.com/Qiskit/qiskit-terra/issues/5017)
*   Fixes a bug where setting `ctrl_state` of a `UnitaryGate` would be applied twice; once in the creation of the matrix for the controlled unitary and again when calling the [`definition()`](qiskit.circuit.ControlledGate#definition "qiskit.circuit.ControlledGate.definition") method of the [`qiskit.circuit.ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") class. This would give the appearence that setting `ctrl_state` had no effect.
*   Previously the [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") method [`inverse()`](qiskit.circuit.ControlledGate#inverse "qiskit.circuit.ControlledGate.inverse") would not preserve the `ctrl_state` parameter in some cases. This has been fixed so that calling [`inverse()`](qiskit.circuit.ControlledGate#inverse "qiskit.circuit.ControlledGate.inverse") will preserve the value `ctrl_state` in its output.
*   Fixed a bug in the `mpl` output backend of the circuit drawer [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") that would cause the drawer to fail if the `style` kwarg was set to a string. The correct behavior would be to treat that string as a path to a JSON file containing the style sheet for the visualization. This has been fixed, and warnings are raised if the JSON file for the style sheet can’t be loaded.
*   Fixed an error where loading a QASM file via [`from_qasm_file()`](qiskit.circuit.QuantumCircuit#from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file") or [`from_qasm_str()`](qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") would fail if a `u`, `phase(p)`, `sx`, or `sxdg` gate were present in the QASM file. Fixes [#5156](https://github.com/Qiskit/qiskit-terra/issues/5151)
*   Fixed a bug that would potentially cause registers to be mismapped when unrolling/decomposing a gate defined with only one 2-qubit operation.

<span id="aer-0-7-0" />

### Aer 0.7.0

<span id="release-notes-aer-0-7-0-prelude" />

<span id="id381" />

#### Prelude

This 0.7.0 release includes numerous performance improvements and significant enhancements to the simulator interface, and drops support for Python 3.5. The main interface changes are configurable simulator backends, and constructing preconfigured simulators from IBMQ backends. Noise model an basis gate support has also been extended for most of the Qiskit circuit library standard gates, including new support for 1 and 2-qubit rotation gates. Performance improvements include adding SIMD support to the density matrix and unitary simulation methods, reducing the used memory and improving the performance of circuits using statevector and density matrix snapshots, and adding support for Kraus instructions to the gate fusion circuit optimization for greatly improving the performance of noisy statevector simulations.

<span id="release-notes-aer-0-7-0-new-features" />

<span id="id382" />

#### New Features

*   Adds basis gate support for the [`qiskit.circuit.Delay`](qiskit.circuit.Delay "qiskit.circuit.Delay") instruction to the `StatevectorSimulator`, `UnitarySimulator`, and `QasmSimulator`. Note that this gate is treated as an identity gate during simulation and the delay length parameter is ignored.

*   Adds basis gate support for the single-qubit gate [`qiskit.circuit.library.UGate`](qiskit.circuit.library.UGate "qiskit.circuit.library.UGate") to the `StatevectorSimulator`, `UnitarySimulator`, and the `"statevector"`, `"density_matrix"`, `"matrix_product_state"`, and `"extended_stabilizer"` methods of the `QasmSimulator`.

*   Adds basis gate support for the phase gate [`qiskit.circuit.library.PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate") to the `StatevectorSimulator`, `StatevectorSimulator`, `UnitarySimulator`, and the `"statevector"`, `"density_matrix"`, `"matrix_product_state"`, and `"extended_stabilizer"` methods of the `QasmSimulator`.

*   Adds basis gate support for the controlled-phase gate [`qiskit.circuit.library.CPhaseGate`](qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate") to the `StatevectorSimulator`, `StatevectorSimulator`, `UnitarySimulator`, and the `"statevector"`, `"density_matrix"`, and `"matrix_product_state"` methods of the `QasmSimulator`.

*   Adds support for the multi-controlled phase gate [`qiskit.circuit.library.MCPhaseGate`](qiskit.circuit.library.MCPhaseGate "qiskit.circuit.library.MCPhaseGate") to the `StatevectorSimulator`, `UnitarySimulator`, and the `"statevector"` method of the `QasmSimulator`.

*   Adds support for the $\sqrt(X)$ gate [`qiskit.circuit.library.SXGate`](qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate") to the `StatevectorSimulator`, `UnitarySimulator`, and `QasmSimulator`.

*   Adds support for 1 and 2-qubit Qiskit circuit library rotation gates [`RXGate`](qiskit.circuit.library.RXGate "qiskit.circuit.library.RXGate"), [`RYGate`](qiskit.circuit.library.RYGate "qiskit.circuit.library.RYGate"), [`RZGate`](qiskit.circuit.library.RZGate "qiskit.circuit.library.RZGate"), [`RGate`](qiskit.circuit.library.RGate "qiskit.circuit.library.RGate"), [`RXXGate`](qiskit.circuit.library.RXXGate "qiskit.circuit.library.RXXGate"), [`RYYGate`](qiskit.circuit.library.RYYGate "qiskit.circuit.library.RYYGate"), [`RZZGate`](qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate"), [`RZXGate`](qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate") to the `StatevectorSimulator`, `UnitarySimulator`, and the `"statevector"` and `"density_matrix"` methods of the `QasmSimulator`.

*   Adds support for multi-controlled rotation gates `"mcr"`, `"mcrx"`, `"mcry"`, `"mcrz"` to the `StatevectorSimulator`, `UnitarySimulator`, and the `"statevector"` method of the `QasmSimulator`.

*   Make simulator backends configurable. This allows setting persistant options such as simulation method and noise model for each simulator backend object.

    The `QasmSimulator` and `PulseSimulator` can also be configured from an `IBMQBackend` backend object using the :meth:\`\~qiskit.providers.aer.QasmSimulator.from\_backend method. For the `QasmSimulator` this will configure the coupling map, basis gates, and basic device noise model based on the backend configuration and properties. For the `PulseSimulator` the system model and defaults will be configured automatically from the backend configuration, properties and defaults.

    For example a noisy density matrix simulator backend can be constructed as `QasmSimulator(method='density_matrix', noise_model=noise_model)`, or an ideal matrix product state simulator as `QasmSimulator(method='matrix_product_state')`.

    A benefit is that a `PulseSimulator` instance configured from a backend better serves as a drop-in replacement to the original backend, making it easier to swap in and out a simulator and real backend, e.g. when testing code on a simulator before using a real backend. For example, in the following code-block, the `PulseSimulator` is instantiated from the `FakeArmonk()` backend. All configuration and default data is copied into the simulator instance, and so when it is passed as an argument to `assemble`, it behaves as if the original backend was supplied (e.g. defaults from `FakeArmonk` will be present and used by `assemble`).

    ```python
    armonk_sim = qiskit.providers.aer.PulseSimulator.from_backend(FakeArmonk())
    pulse_qobj = assemble(schedules, backend=armonk_sim)
    armonk_sim.run(pulse_qobj)
    ```

    While the above example is small, the demonstrated ‘drop-in replacement’ behavior should greatly improve the usability in more complicated work-flows, e.g. when calibration experiments are constructed using backend attributes.

*   Adds support for qobj global phase to the `StatevectorSimulator`, `UnitarySimulator`, and statevector methods of the `QasmSimulator`.

*   Improves general noisy statevector simulation performance by adding a Kraus method to the gate fusion circuit optimization that allows applying gate fusion to noisy statevector simulations with general Kraus noise.

*   Use move semantics for statevector and density matrix snapshots for the “statevector” and “density\_matrix” methods of the `QasmSimulator` if they are the final instruction in a circuit. This reduces the memory usage of the simulator improves the performance by avoiding copying a large array in the results.

*   Adds support for general Kraus `QauntumError` gate errors in the `NoiseModel` to the `"matrix_product_state"` method of the `QasmSimulator`.

*   Adds support for density matrix snapshot instruction `qiskit.providers.aer.extensions.SnapshotDensityMatrix` to the `"matrix_product_state"` method of the `QasmSimulator`.

*   Extends the SIMD vectorization of the statevector simulation method to the unitary matrix, superoperator matrix, and density matrix simulation methods. This gives roughtly a 2x performance increase general simulation using the `UnitarySimulator`, the `"density_matrix"` method of the `QasmSimulator`, gate fusion, and noise simulation.

*   Adds a custom vector class to C++ code that has better integration with Pybind11. This haves the memory requirement of the `StatevectorSimulator` by avoiding an memory copy during Python binding of the final simulator state.

<span id="release-notes-aer-0-7-0-upgrade-notes" />

<span id="id383" />

#### Upgrade Notes

*   AER now uses Lapack to perform some matrix related computations. It uses the Lapack library bundled with OpenBlas (already available in Linux and Macos typical OpenBlas dsitributions; Windows version distributed with AER) or with the accelerate framework in MacOS.

*   The deprecated support for running qiskit-aer with Python 3.5 has been removed. To use qiskit-aer >=0.7.0 you will now need at least Python 3.6. If you are using Python 3.5 the last version which will work is qiskit-aer 0.6.x.

*   Updates gate fusion default thresholds so that gate fusion will be applied to circuits with of more than 14 qubits for statevector simulations on the `StatevectorSimulator` and `QasmSimulator`.

    For the `"density_matrix"` method of the `QasmSimulator` and for the `UnitarySimulator` gate fusion will be applied to circuits with more than 7 qubits.

    Custom qubit threshold values can be set using the `fusion_threshold` backend option ie `backend.set_options(fusion_threshold=10)`

*   Changes `fusion_threshold` backend option to apply fusion when the number of qubits is above the threshold, not equal or above the threshold, to match the behavior of the OpenMP qubit threshold parameter.

<span id="release-notes-aer-0-7-0-deprecation-notes" />

<span id="id384" />

#### Deprecation Notes

*   `qiskit.providers.aer.noise.NoiseModel.set_x90_single_qubit_gates()` has been deprecated as unrolling to custom basis gates has been added to the qiskit transpiler. The correct way to use an X90 based noise model is to define noise on the Sqrt(X) `"sx"` or `"rx"` gate and one of the single-qubit phase gates `"u1"`, `"rx"`, or `"p"` in the noise model.
*   The `variance` kwarg of Snapshot instructions has been deprecated. This function computed the sample variance in the snapshot due to noise model sampling, not the variance due to measurement statistics so was often being used incorrectly. If noise modeling variance is required single shot snapshots should be used so variance can be computed manually in post-processing.

<span id="release-notes-aer-0-7-0-bug-fixes" />

<span id="id385" />

#### Bug Fixes

*   Fixes bug in the `StatevectorSimulator` that caused it to always run as CPU with double-precision without SIMD/AVX2 support even on systems with AVX2, or when single-precision or the GPU method was specified in the backend options.
*   Fixes some for-loops in C++ code that were iterating over copies rather than references of container elements.
*   Fixes a bug where snapshot data was always copied from C++ to Python rather than moved where possible. This will halve memory usage and improve simulation time when using large statevector or density matrix snapshots.
*   Fix State::snapshot\_pauli\_expval to return correct Y expectation value in stabilizer simulator. Refer to #895 \<[https://github.com/Qiskit/qiskit-aer/issues/895](https://github.com/Qiskit/qiskit-aer/issues/895)> for more details.
*   The controller\_execute wrappers have been adjusted to be functors (objects) rather than free functions. Among other things, this allows them to be used in multiprocessing.pool.map calls.
*   Add missing available memory checks for the `StatevectorSimulator` and `UnitarySimulator`. This throws an exception if the memory required to simulate the number of qubits in a circuit exceeds the available memory of the system.

<span id="ignis-0-5-0" />

<span id="release-notes-ignis-0-5-0" />

### Ignis 0.5.0

<span id="release-notes-ignis-0-5-0-prelude" />

<span id="id386" />

#### Prelude

This release includes a new module for expectation value measurement error mitigation, improved plotting functionality for quantum volume experiments, several bug fixes, and drops support for Python 3.5.

<span id="release-notes-ignis-0-5-0-new-features" />

<span id="id387" />

#### New Features

*   The `qiskit.ignis.verification.randomized_benchmarking.randomized_benchmarking_seq()` function allows an optional input of gate objects as interleaved\_elem. In addition, the CNOT-Dihedral class `qiskit.ignis.verification.randomized_benchmarking.CNOTDihedral` has a new method to\_instruction, and the existing from\_circuit method has an optional input of an Instruction (in addition to QuantumCircuit).

*   The `qiskit.ignis.verification.randomized_benchmarking.CNOTDihedral` now contains the following new features. Initialization from various types of objects: CNOTDihedral, ScalarOp, QuantumCircuit, Instruction and Pauli. Converting to a matrix using to\_matrix and to an operator using to\_operator. Tensor product methods tensor and expand. Calculation of the adjoint, conjugate and transpose using conjugate, adjoint and transpose methods. Verify that an element is CNOTDihedral using is\_cnotdihedral method. Decomposition method to\_circuit of a CNOTDihedral element into a circuit was extended to allow any number of qubits, based on the function decompose\_cnotdihedral\_general.

*   Adds expectation value measurement error mitigation to the mitigation module. This supports using *complete* N-qubit assignment matrix, single-qubit *tensored* assignment matrix, or *continuous time Markov process (CTMP)* \[1] measurement error mitigation when computing expectation values of diagonal operators from counts dictionaries. Expectation values are computed using the using the `qiskit.ignis.mitigation.expectation_value()` function.

    Calibration circuits for calibrating a measurement error mitigator are generated using the `qiskit.ignis.mitigation.expval_meas_mitigator_circuits()` function, and the result fitted using the `qiskit.ignis.mitigation.ExpvalMeasMitigatorFitter` class. The fitter returns a mitigator object can the be supplied as an argument to the `expectation_value()` function to apply mitigation.

    ## \[1] S Bravyi, S Sheldon, A Kandala, DC Mckay, JM Gambetta,

    *Mitigating measurement errors in multi-qubit experiments*, arXiv:2006.14044 \[quant-ph].

    Example:

    > The following example shows calibrating a 5-qubit expectation value measurement error mitigator using the `'tensored'` method.
    >
    > ```python
    > from qiskit import execute
    > from qiskit.test.mock import FakeVigo
    > import qiskit.ignis.mitigation as mit
    >
    > backend = FakeVigo()
    > num_qubits = backend.configuration().num_qubits
    >
    > # Generate calibration circuits
    > circuits, metadata = mit.expval_meas_mitigator_circuits(
    >     num_qubits, method='tensored')
    > result = execute(circuits, backend, shots=8192).result()
    >
    > # Fit mitigator
    > mitigator = mit.ExpvalMeasMitigatorFitter(result, metadata).fit()
    >
    > # Plot fitted N-qubit assignment matrix
    > mitigator.plot_assignment_matrix()
    > ```
    >
    > The following shows how to use the above mitigator to apply measurement error mitigation to expectation value computations
    >
    > ```python
    > from qiskit import QuantumCircuit
    >
    > # Test Circuit with expectation value -1.
    > qc = QuantumCircuit(num_qubits)
    > qc.x(range(num_qubits))
    > qc.measure_all()
    >
    > # Execute
    > shots = 8192
    > seed_simulator = 1999
    > result = execute(qc, backend, shots=8192, seed_simulator=1999).result()
    > counts = result.get_counts(0)
    >
    > # Expectation value of Z^N without mitigation
    > expval_nomit, error_nomit = mit.expectation_value(counts)
    > print('Expval (no mitigation): {:.2f} \u00B1 {:.2f}'.format(
    >     expval_nomit, error_nomit))
    >
    > # Expectation value of Z^N with mitigation
    > expval_mit, error_mit = mit.expectation_value(counts,
    >     meas_mitigator=mitigator)
    > print('Expval (with mitigation): {:.2f} \u00B1 {:.2f}'.format(
    >     expval_mit, error_mit))
    > ```

*   Adds Numba as an optional dependency. Numba is used to significantly increase the performance of the `qiskit.ignis.mitigation.CTMPExpvalMeasMitigator` class used for expectation value measurement error mitigation with the CTMP method.

*   Add two methods to `qiskit.ignis.verification.quantum_volume.QVFitter`.

    *   `qiskit.ignis.verification.quantum_volume.QVFitter.calc_z_value()` to calculate z value in standard normal distribution using mean and standard deviation sigma. If sigma = 0, it raises a warning and assigns a small value (1e-10) for sigma so that the code still runs.
    *   `qiskit.ignis.verification.quantum_volume.QVFitter.calc_confidence_level()` to calculate confidence level using z value.

*   Store confidence level even when hmean \< 2/3 in `qiskit.ignis.verification.quantum_volume.QVFitter.qv_success()`.

*   Add explanations for how to calculate statistics based on binomial distribution in `qiskit.ignis.verification.quantum_volume.QVFitter.calc_statistics()`.

*   The `qiskit.ignis.verification.QVFitter` method `plot_qv_data()` has been updated to return a `matplotlib.Figure` object. Previously, it would not return anything. By returning a figure this makes it easier to integrate the visualizations into a larger `matplotlib` workflow.

*   The error bars in the figure produced by the `qiskit.ignis.verification.QVFitter` method `qiskit.ignis.verification.QVFitter.plot_qv_data()` has been updated to represent two-sigma confidence intervals. Previously, the error bars represent one-sigma confidence intervals. The success criteria of Quantum Volume benchmarking requires heavy output probability > 2/3 with one-sided two-sigma confidence (\~97.7%). Changing error bars to represent two-sigma confidence intervals allows easily identification of success in the figure.

*   A new kwarg, `figsize` has been added to the `qiskit.ignis.verification.QVFitter` method `qiskit.ignis.verification.QVFitter.plot_qv_data()`. This kwarg takes in a tuple of the form `(x, y)` where `x` and `y` are the dimension in inches to make the generated plot.

*   The `qiskit.ignis.verification.quantum_volume.QVFitter.plot_hop_accumulative()` method has been added to plot heavy output probability (HOP) vs number of trials similar to Figure 2a of Quantum Volume 64 paper ([arXiv:2008.08571](https://arxiv.org/abs/2008.08571)). HOP of individual trials are plotted as scatters and cummulative HOP are plotted in red line. Two-sigma confidence intervals are plotted as shaded area and 2/3 success threshold is plotted as dashed line.

*   The `qiskit.ignis.verification.quantum_volume.QVFitter.plot_qv_trial()` method has been added to plot individual trials, leveraging on the [`qiskit.visualization.plot_histogram()`](qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram") method from Qiskit Terra. Bitstring counts are plotted as overlapping histograms for ideal (hollow) and experimental (filled) values. Experimental heavy output probability are shown on the legend. Median probability is plotted as red dashed line.

<span id="release-notes-ignis-0-5-0-upgrade-notes" />

<span id="id388" />

#### Upgrade Notes

*   The deprecated support for running qiskit-ignis with Python 3.5 has been removed. To use qiskit-ignis >=0.5.0 you will now need at least Python 3.6. If you are using Python 3.5 the last version which will work is qiskit-ignis 0.4.x.

<span id="release-notes-ignis-0-5-0-bug-fixes" />

<span id="id389" />

#### Bug Fixes

*   Fixing a bug in the class `qiskit.ignis.verification.randomized_benchmarking.CNOTDihedral` for elements with more than 5 quits.
*   Fix the confidence level threshold for `qiskit.ignis.verification.quantum_volume.QVFitter.qv_success()` to 0.977 corresponding to z = 2 as defined by the QV paper Algorithm 1.
*   Fix a bug at `qiskit.ignis.verification.randomized_benchmarking.randomized_benchmarking_seq()` which caused all the subsystems with the same size in the given rb\_pattern to have the same gates when a ‘rand\_seed’ parameter was given to the function.

<span id="aqua-0-8-0" />

### Aqua 0.8.0

<span id="release-notes-aqua-0-8-0-prelude" />

<span id="id390" />

#### Prelude

This release introduces an interface for running the available methods for Bosonic problems. In particular we introduced a full interface for running vibronic structure calculations.

This release introduces an interface for excited states calculations. It is now easier for the user to create a general excited states calculation. This calculation is based on a Driver which provides the relevant information about the molecule, a Transformation which provides the information about the mapping of the problem into a qubit Hamiltonian, and finally a Solver. The Solver is the specific way which the excited states calculation is done (the algorithm). This structure follows the one of the ground state calculations. The results are modified to take lists of expectation values instead of a single one. The QEOM and NumpyEigensolver are adapted to the new structure. A factory is introduced to run a numpy eigensolver with a specific filter (to target states of specific symmetries).

VQE expectation computation with Aer qasm\_simulator now defaults to a computation that has the expected shot noise behavior.

<span id="release-notes-aqua-0-8-0-new-features" />

<span id="id391" />

#### New Features

*   Introduced an option warm\_start that should be used when tuning other options does not help. When this option is enabled, a relaxed problem (all variables are continuous) is solved first and the solution is used to initialize the state of the optimizer before it starts the iterative process in the solve method.

*   The amplitude estimation algorithms now use `QuantumCircuit` objects as inputs to specify the A- and Q operators. This change goes along with the introduction of the `GroverOperator` in the circuit library, which allows an intuitive and fast construction of different Q operators. For example, a Bernoulli-experiment can now be constructed as

    ```python
    import numpy as np
    from qiskit import QuantumCircuit
    from qiskit.aqua.algorithms import AmplitudeEstimation

    probability = 0.5
    angle = 2 * np.sqrt(np.arcsin(probability))
    a_operator = QuantumCircuit(1)
    a_operator.ry(angle, 0)

    # construct directly
    q_operator = QuantumCircuit(1)
    q_operator.ry(2 * angle, 0)

    # construct via Grover operator
    from qiskit.circuit.library import GroverOperator
    oracle = QuantumCircuit(1)
    oracle.z(0)  # good state = the qubit is in state |1>
    q_operator = GroverOperator(oracle, state_preparation=a_operator)

    # use default construction in QAE
    q_operator = None

    ae = AmplitudeEstimation(a_operator, q_operator)
    ```

*   Add the possibility to compute Conditional Value at Risk (CVaR) expectation values.

    Given a diagonal observable H, often corresponding to the objective function of an optimization problem, we are often not as interested in minimizing the average energy of our observed measurements. In this context, we are satisfied if at least some of our measurements achieve low energy. (Note that this is emphatically not the case for chemistry problems).

    To this end, one might consider using the best observed sample as a cost function during variational optimization. The issue here, is that this can result in a non-smooth optimization surface. To resolve this issue, we can smooth the optimization surface by using not just the best observed sample, but instead average over some fraction of best observed samples. This is exactly what the CVaR estimator accomplishes \[1].

    Let $\alpha$ be a real number in $[0,1]$ which specifies the fraction of best observed samples which are used to compute the objective function. Observe that if $\alpha = 1$, CVaR is equivalent to a standard expectation value. Similarly, if $\alpha = 0$, then CVaR corresponds to using the best observed sample. Intermediate values of $\alpha$ interpolate between these two objective functions.

    The functionality to use CVaR is included into the operator flow through a new subclass of OperatorStateFn called CVaRMeasurement. This new StateFn object is instantied in the same way as an OperatorMeasurement with the exception that it also accepts an alpha parameter and that it automatically enforces the is\_measurement attribute to be True. Observe that it is unclear what a CVaRStateFn would represent were it not a measurement.

    Examples:

    ```python
    qc = QuantumCircuit(1)
    qc.h(0)
    op = CVaRMeasurement(Z, alpha=0.5) @ CircuitStateFn(primitive=qc, coeff=1.0)
    result = op.eval()
    ```

    Similarly, an operator corresponding to a standard expectation value can be converted into a CVaR expectation using the CVaRExpectation converter.

    Examples:

    ```python
    qc = QuantumCircuit(1)
    qc.h(0)
    op = ~StateFn(Z) @ CircuitStateFn(primitive=qc, coeff=1.0)
    cvar_expecation = CVaRExpectation(alpha=0.1).convert(op)
    result = cvar_expecation.eval()
    ```

    See \[1] for additional details regarding this technique and it’s empircal performance.

    References:

    > ## \[1]: Barkoutsos, P. K., Nannicini, G., Robert, A., Tavernelli, I., and Woerner, S.,
    >
    > “Improving Variational Quantum Optimization using CVaR” [arXiv:1907.04769](https://arxiv.org/abs/1907.04769)

*   New interface `Eigensolver` for Eigensolver algorithms.

*   An interface for excited states calculation has been added to the chemistry module. It is now easier for the user to create a general excited states calculation. This calculation is based on a `Driver` which provides the relevant information about the molecule, a `Transformation` which provides the information about the mapping of the problem into a qubit Hamiltonian, and finally a Solver. The Solver is the specific way which the excited states calculation is done (the algorithm). This structure follows the one of the ground state calculations. The results are modified to take lists of expectation values instead of a single one. The `QEOM` and `NumpyEigensolver` are adapted to the new structure. A factory is introduced to run a numpy eigensolver with a specific filter (to target states of specific symmetries).

*   In addition to the workflows for solving Fermionic problems, interfaces for calculating Bosonic ground and excited states have been added. In particular we introduced a full interface for running vibronic structure calculations.

*   The `OrbitalOptimizationVQE` has been added as new ground state solver in the chemistry module. This solver allows for the simulatneous optimization of the variational parameters and the orbitals of the molecule. The algorithm is introduced in Sokolov et al., The Journal of Chemical Physics 152 (12).

*   A new algorithm has been added: the Born Openheimer Potential Energy surface for the calculation of potential energy surface along different degrees of freedom of the molecule. The algorithm is called `BOPESSampler`. It further provides functionalities of fitting the potential energy surface to an analytic function of predefined potentials.

*   A feasibility check of the obtained solution has been added to all optimizers in the optimization stack. This has been implemented by adding two new methods to `QuadraticProgram`: \* `get_feasibility_info(self, x: Union[List[float], np.ndarray])` accepts an array and returns whether this solution is feasible and a list of violated variables(violated bounds) and a list of violated constraints. \* `is_feasible(self, x: Union[List[float], np.ndarray])` accepts an array and returns whether this solution is feasible or not.

*   Add circuit-based versions of `FixedIncomeExpectedValue`, `EuropeanCallDelta`, `GaussianConditionalIndependenceModel` and `EuropeanCallExpectedValue` to `qiskit.finance.applications`.

*   Gradient Framework. `qiskit.operators.gradients` Given an operator that represents either a quantum state resp. an expectation value, the gradient framework enables the evaluation of gradients, natural gradients, Hessians, as well as the Quantum Fisher Information.

    Suppose a parameterized quantum state |ψ(θ)〉 = V(θ)|ψ〉 with input state |ψ〉 and parametrized Ansatz V(θ), and an Operator O(ω).

    Gradients: We want to compute $d⟨ψ(θ)|O(ω)|ψ(θ)〉/ dω$ resp. $d⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθ$ resp. $d⟨ψ(θ)|i〉⟨i|ψ(θ)〉/ dθ$.

    The last case corresponds to the gradient w\.r.t. the sampling probabilities of |ψ(θ). These gradients can be computed with different methods, i.e. a parameter shift, a linear combination of unitaries and a finite difference method.

    Examples:

    ```python
    x = Parameter('x')
    ham = x * X
    a = Parameter('a')

    q = QuantumRegister(1)
    qc = QuantumCircuit(q)
    qc.h(q)
    qc.p(params[0], q[0])
    op = ~StateFn(ham) @ CircuitStateFn(primitive=qc, coeff=1.)

    value_dict = {x: 0.1, a: np.pi / 4}

    ham_grad = Gradient(grad_method='param_shift').convert(operator=op, params=[x])
    ham_grad.assign_parameters(value_dict).eval()

    state_grad = Gradient(grad_method='lin_comb').convert(operator=op, params=[a])
    state_grad.assign_parameters(value_dict).eval()

    prob_grad = Gradient(grad_method='fin_diff').convert(operator=CircuitStateFn(primitive=qc, coeff=1.),
                                                         params=[a])
    prob_grad.assign_parameters(value_dict).eval()
    ```

    Hessians: We want to compute $d^2⟨ψ(θ)|O(ω)|ψ(θ)〉/ dω^2$ resp. $d^2⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθ^2$ resp. $d^2⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθdω$ resp. $d^2⟨ψ(θ)|i〉⟨i|ψ(θ)〉/ dθ^2$.

    The last case corresponds to the Hessian w\.r.t. the sampling probabilities of |ψ(θ). Just as the first order gradients, the Hessians can be evaluated with different methods, i.e. a parameter shift, a linear combination of unitaries and a finite difference method. Given a tuple of parameters `Hessian().convert(op, param_tuple)` returns the value for the second order derivative. If a list of parameters is given `Hessian().convert(op, param_list)` returns the full Hessian for all the given parameters according to the given parameter order.

    QFI: The Quantum Fisher Information QFI is a metric tensor which is representative for the representation capacity of a parameterized quantum state |ψ(θ)〉 = V(θ)|ψ〉 generated by an input state |ψ〉 and a parametrized Ansatz V(θ). The entries of the QFI for a pure state read $[QFI]kl= Re[〈∂kψ|∂lψ〉−〈∂kψ|ψ〉〈ψ|∂lψ〉] * 4$.

    Just as for the previous derivative types, the QFI can be computed using different methods: a full representation based on a linear combination of unitaries implementation, a block-diagonal and a diagonal representation based on an overlap method.

    Examples:

    ```python
    q = QuantumRegister(1)
    qc = QuantumCircuit(q)
    qc.h(q)
    qc.p(params[0], q[0])
    op = ~StateFn(ham) @ CircuitStateFn(primitive=qc, coeff=1.)

    value_dict = {x: 0.1, a: np.pi / 4}
    qfi = QFI('lin_comb_full').convert(operator=CircuitStateFn(primitive=qc, coeff=1.), params=[a])
    qfi.assign_parameters(value_dict).eval()
    ```

    The combination of the QFI and the gradient lead to a special form of a gradient, namely

    NaturalGradients: The natural gradient is a special gradient method which rescales a gradient w\.r.t. a state parameter with the inverse of the corresponding Quantum Fisher Information (QFI) $QFI^-1 d⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθ$. Hereby, we can choose a gradient as well as a QFI method and a regularization method which is used together with a least square solver instead of exact invertion of the QFI:

    Examples:

    ```python
    op = ~StateFn(ham) @ CircuitStateFn(primitive=qc, coeff=1.)
    nat_grad = NaturalGradient(grad_method='lin_comb, qfi_method='lin_comb_full', \
                               regularization='ridge').convert(operator=op, params=params)
    ```

    The gradient framework is also compatible with the optimizers from qiskit.aqua.components.optimizers. The derivative classes come with a gradient\_wrapper() function which returns the corresponding callable.

*   Introduces `transformations` for the fermionic and bosonic transformation of a problem instance. Transforms the fermionic operator to qubit operator. Respective class for the transformation is `fermionic_transformation` Introduces in algorithms `ground_state_solvers` for the calculation of ground state properties. The calculation can be done either using an `MinimumEigensolver` or using `AdaptVQE` Introduces `chemistry/results` where the eigenstate\_result and the electronic\_structure\_result are also used for the algorithms. Introduces Minimum Eigensolver factories `minimum_eigensolver_factories` where chemistry specific minimum eigensolvers can be initialized Introduces orbital optimization vqe `oovqe` as a ground state solver for chemistry applications

*   New Algorithm result classes:

    `Grover` method `_run()` returns class `GroverResult`. `AmplitudeEstimation` method `_run()` returns class `AmplitudeEstimationResult`. `IterativeAmplitudeEstimation` method `_run()` returns class `IterativeAmplitudeEstimationResult`. `MaximumLikelihoodAmplitudeEstimation` method `_run()` returns class `MaximumLikelihoodAmplitudeEstimationResult`.

    All new result classes are backwards compatible with previous result dictionary.

*   New Linear Solver result classes:

    `HHL` method `_run()` returns class `HHLResult`. `NumPyLSsolver` method `_run()` returns class `NumPyLSsolverResult`.

    All new result classes are backwards compatible with previous result dictionary.

*   `MinimumEigenOptimizationResult` now exposes properties: `samples` and `eigensolver_result`. The latter is obtained from the underlying algorithm used by the optimizer and specific to the algorithm. `RecursiveMinimumEigenOptimizer` now returns an instance of the result class `RecursiveMinimumEigenOptimizationResult` which in turn may contains intermediate results obtained from the underlying algorithms. The dedicated result class exposes properties `replacements` and `history` that are specific to this optimizer. The depth of the history is managed by the `history` parameter of the optimizer.

*   `GroverOptimizer` now returns an instance of `GroverOptimizationResult` and this result class exposes properties `operation_counts`, `n_input_qubits`, and `n_output_qubits` directly. These properties are not available in the `raw_results` dictionary anymore.

*   `SlsqpOptimizer` now returns an instance of `SlsqpOptimizationResult` and this result class exposes additional properties specific to the SLSQP implementation.

*   Support passing `QuantumCircuit` objects as generator circuits into the `QuantumGenerator`.

*   Removes the restriction to real input vectors in CircuitStateFn.from\_vector. The method calls extensions.Initialize. The latter explicitly supports (in API and documentation) complex input vectors. So this restriction seems unnecessary.

*   Simplified AbelianGrouper using a graph coloring algorithm of retworkx. It is faster than the numpy-based coloring algorithm.

*   Allow calling `eval` on state function objects with no argument, which returns the `VectorStateFn` representation of the state function. This is consistent behavior with `OperatorBase.eval`, which returns the `MatrixOp` representation, if no argument is passed.

*   Adds `max_iterations` to the `VQEAdapt` class in order to allow limiting the maximum number of iterations performed by the algorithm.

*   VQE expectation computation with Aer qasm\_simulator now defaults to a computation that has the expected shot noise behavior. The special Aer snapshot based computation, that is much faster, with the ideal output similar to state vector simulator, may still be chosen but like before Aqua 0.7 it now no longer defaults to this but can be chosen.

<span id="release-notes-aqua-0-8-0-upgrade-notes" />

<span id="id392" />

#### Upgrade Notes

*   Extension of the previous Analytic Quantum Gradient Descent (AQGD) classical optimizer with the AQGD with Epochs. Now AQGD performs the gradient descent optimization with a momentum term, analytic gradients, and an added customized step length schedule for parametrized quantum gates. Gradients are computed “analytically” using the quantum circuit when evaluating the objective function.
*   The deprecated support for running qiskit-aqua with Python 3.5 has been removed. To use qiskit-aqua >=0.8.0 you will now need at least Python 3.6. If you are using Python 3.5 the last version which will work is qiskit-aqua 0.7.x.
*   Added retworkx as a new dependency.

<span id="release-notes-aqua-0-8-0-deprecation-notes" />

<span id="id393" />

#### Deprecation Notes

*   The `i_objective` argument of the amplitude estimation algorithms has been renamed to `objective_qubits`.

*   TransformationType

*   QubitMappingType

*   Deprecate the `CircuitFactory` and derived types. The `CircuitFactory` has been introduced as temporary class when the `QuantumCircuit` missed some features necessary for applications in Aqua. Now that the circuit has all required functionality, the circuit factory can be removed. The replacements are shown in the following table.

    ```python
    Circuit factory class               | Replacement
    ------------------------------------+-----------------------------------------------
    CircuitFactory                      | use QuantumCircuit
                                        |
    UncertaintyModel                    | -
    UnivariateDistribution              | -
    MultivariateDistribution            | -
    NormalDistribution                  | qiskit.circuit.library.NormalDistribution
    MultivariateNormalDistribution      | qiskit.circuit.library.NormalDistribution
    LogNormalDistribution               | qiskit.circuit.library.LogNormalDistribution
    MultivariateLogNormalDistribution   | qiskit.circuit.library.LogNormalDistribution
    UniformDistribution                 | qiskit.circuit.library.UniformDistribution
    MultivariateUniformDistribution     | qiskit.circuit.library.UniformDistribution
    UnivariateVariationalDistribution   | use parameterized QuantumCircuit
    MultivariateVariationalDistribution | use parameterized QuantumCircuit
                                        |
    UncertaintyProblem                  | -
    UnivariateProblem                   | -
    MultivariateProblem                 | -
    UnivariatePiecewiseLinearObjective  | qiskit.circuit.library.LinearAmplitudeFunction
    ```

*   The ising convert classes `qiskit.optimization.converters.QuadraticProgramToIsing` and `qiskit.optimization.converters.IsingToQuadraticProgram` have been deprecated and will be removed in a future release. Instead the `qiskit.optimization.QuadraticProgram` methods `to_ising()` and `from_ising()` should be used instead.

*   Deprecate the `WeightedSumOperator` which has been ported to the circuit library as `WeightedAdder` in `qiskit.circuit.library`.

*   `Core Hamiltonian` class is deprecated in favor of the `FermionicTransformation` `Chemistry Operator` class is deprecated in favor of the `tranformations` `minimum_eigen_solvers/vqe_adapt` is also deprecated and moved as an implementation of the ground\_state\_solver interface `applications/molecular_ground_state_energy` is deprecated in favor of `ground_state_solver`

*   `Optimizer.SupportLevel` nested enum is replaced by `OptimizerSupportLevel` and `Optimizer.SupportLevel` was removed. Use, for example, `OptimizerSupportLevel.required` instead of `Optimizer.SupportLevel.required`.

*   Deprecate the `UnivariateVariationalDistribution` and `MultivariateVariationalDistribution` as input to the `QuantumGenerator`. Instead, plain `QuantumCircuit` objects can be used.

*   Ignored fast and use\_nx options of AbelianGrouper.group\_subops to be removed in the future release.

*   GSLS optimizer class deprecated `__init__` parameter `max_iter` in favor of `maxiter`. SPSA optimizer class deprecated `__init__` parameter `max_trials` in favor of `maxiter`. optimize\_svm function deprecated `max_iters` parameter in favor of `maxiter`. ADMMParameters class deprecated `__init__` parameter `max_iter` in favor of `maxiter`.

<span id="release-notes-aqua-0-8-0-bug-fixes" />

<span id="id394" />

#### Bug Fixes

*   The UCCSD excitation list, comprising single and double excitations, was not being generated correctly when an active space was explicitly provided to UCSSD via the active\_(un)occupied parameters.
*   For the amplitude estimation algorithms, we define the number of oracle queries as number of times the Q operator/Grover operator is applied. This includes the number of shots. That factor has been included in MLAE and IQAE but was missing in the ‘standard’ QAE.
*   Fix CircuitSampler.convert, so that the `is_measurement` property is propagated to converted StateFns.
*   Fix double calculation of coefficients in :meth\`\~qiskit.aqua.operators.VectorStateFn.to\_circuit\_op\`.
*   Calling PauliTrotterEvolution.convert on an operator including a term that is a scalar multiple of the identity gave an incorrect circuit, one that ignored the scalar coefficient. This fix includes the effect of the coefficient in the global\_phase property of the circuit.
*   Make ListOp.num\_qubits check that all ops in list have the same num\_qubits Previously, the number of qubits in the first operator in the ListOp was returned. With this change, an additional check is made that all other operators also have the same number of qubits.
*   Make PauliOp.exp\_i() generate the correct matrix with the following changes. 1) There was previously an error in the phase of a factor of 2. 2) The global phase was ignored when converting the circuit to a matrix. We now use qiskit.quantum\_info.Operator, which is generally useful for converting a circuit to a unitary matrix, when possible.
*   Fixes the cyclicity detection as reported buggy in [https://github.com/Qiskit/qiskit-aqua/issues/1184](https://github.com/Qiskit/qiskit-aqua/issues/1184).

<span id="ibm-q-provider-0-11-0" />

### IBM Q Provider 0.11.0

<span id="release-notes-0-11-0-ibmq-upgrade-notes" />

<span id="id395" />

#### Upgrade Notes

*   The deprecated support for running qiskit-ibmq-provider with Python 3.5 has been removed. To use qiskit-ibmq-provider >=0.11.0 you will now need at least Python 3.6. If you are using Python 3.5 the last version which will work is qiskit-ibmq-provider 0.10.x.
*   Prior to this release, `websockets` 7.0 was used for Python 3.6. With this release, `websockets` 8.0 or above is required for all Python versions. The package requirements have been updated to reflect this.

<span id="qiskit-0-22-0" />

## Qiskit 0.22.0

<span id="terra-0-15-2" />

### Terra 0.15.2

No change

<span id="aer-0-6-1" />

### Aer 0.6.1

No change

<span id="ignis-0-4-0" />

### Ignis 0.4.0

No change

<span id="aqua-0-7-5" />

### Aqua 0.7.5

No change

<span id="ibm-q-provider-0-10-0" />

### IBM Q Provider 0.10.0

<span id="release-notes-ibmq-provider-0-10-0-new-features" />

<span id="id396" />

#### New Features

*   CQC randomness extractors can now be invoked asynchronously, using methods `run_async_ext1()` and `run_async_ext2()`. Each of these methods returns a `CQCExtractorJob` instance that allows you to check on the job status (using `status()`) and wait for its result (using `block_until_ready()`). The `qiskit.provider.ibmq.random.CQCExtractor.run()` method remains synchronous.
*   You can now use the new IBMQ experiment service to query, retrieve, and download experiment related data. Interface to this service is located in the new `qiskit.providers.ibmq.experiment` package. Note that this feature is still in beta, and not all accounts have access to it. It is also subject to heavy modification in both functionality and API without backward compatibility.
*   Two Jupyter magic functions, the IQX dashboard and the backend widget, are updated to display backend reservations. If a backend has reservations scheduled in the next 24 hours, time to the next one and its duration are displayed (e.g. `Reservation: in 6 hrs 30 min (60m)`). If there is a reservation and the backend is active, the backend status is displayed as `active [R]`.

<span id="release-notes-ibmq-provider-0-10-0-upgrade-notes" />

<span id="id397" />

#### Upgrade Notes

*   Starting from this release, the basis\_gates returned by `qiskit.providers.ibmq.IBMQBackend.configuration()` may differ for each backend. You should update your program if it relies on the basis gates being `['id','u1','u2','u3','cx']`. We recommend always using the `configuration()` method to find backend configuration values instead of hard coding them.
*   `qiskit-ibmq-provider` release 0.10 requires `qiskit-terra` release 0.15 or above. The package metadata has been updated to reflect the new dependency.

<span id="qiskit-0-21-0" />

## Qiskit 0.21.0

<span id="id398" />

### Terra 0.15.2

No change

<span id="id399" />

### Aer 0.6.1

No change

<span id="id400" />

### Ignis 0.4.0

No change

<span id="id401" />

### Aqua 0.7.5

No change

<span id="ibm-q-provider-0-9-0" />

### IBM Q Provider 0.9.0

<span id="release-notes-ibmq-provider-0-9-0-new-features" />

<span id="id402" />

#### New Features

*   You can now access the IBMQ random number services, such as the CQC randomness extractor, using the new package `qiskit.providers.ibmq.random`. Note that this feature is still in beta, and not all accounts have access to it. It is also subject to heavy modification in both functionality and API without backward compatibility.

<span id="release-notes-ibmq-provider-0-9-0-bug-fixes" />

<span id="id403" />

#### Bug Fixes

*   Fixes an issue that may raise a `ValueError` if `retrieve_job()` is used to retrieve a job submitted via the IBM Quantum Experience Composer.
*   `IBMQJobManager` has been updated so that if a time out happens while waiting for an old job to finish, the time out error doesn’t prevent a new job to be submitted. Fixes [#737](https://github.com/Qiskit/qiskit-ibmq-provider/issues/737)

<span id="qiskit-0-20-1" />

## Qiskit 0.20.1

<span id="id405" />

### Terra 0.15.2

<span id="release-notes-0-15-2-bug-fixes" />

<span id="id406" />

#### Bug Fixes

*   When accessing the `definition` attribute of a parameterized `Gate` instance, the generated `QuantumCircuit` had been generated with an invalid `ParameterTable`, such that reading from `QuantumCircuit.parameters` or calling `QuantumCircuit.bind_parameters` would incorrectly report the unbound parameters. This has been resolved.
*   `SXGate().inverse()` had previously returned an ‘sx\_dg’ gate with a correct `definition` but incorrect `to_matrix`. This has been updated such that `SXGate().inverse()` returns an `SXdgGate()` and vice versa.
*   `Instruction.inverse()`, when not overridden by a subclass, would in some cases return a `Gate` instance with an incorrect `to_matrix` method. The instances of incorrect `to_matrix` methods have been removed.
*   For `C3XGate` with a non-zero `angle`, inverting the gate via `C3XGate.inverse()` had previously generated an incorrect inverse gate. This has been corrected.
*   The `MCXGate` modes have been updated to return a gate of the same mode when calling `.inverse()`. This resolves an issue where in some cases, transpiling a circuit containing the inverse of an `MCXVChain` gate would raise an error.
*   Previously, when creating a multiply controlled phase gate via `PhaseGate.control`, an `MCU1Gate` gate had been returned. This has been had corrected so that an `MCPhaseGate` is returned.
*   Previously, attempting to decompose a circuit containing an `MCPhaseGate` would raise an error due to an inconsistency in the definition of the `MCPhaseGate`. This has been corrected.
*   `QuantumCircuit.compose` and `DAGCircuit.compose` had, in some cases, incorrectly translated conditional gates if the input circuit contained more than one `ClassicalRegister`. This has been resolved.
*   Fixed an issue when creating a [`qiskit.result.Counts`](qiskit.result.Counts "qiskit.result.Counts") object from an empty data dictionary. Now this will create an empty [`Counts`](qiskit.result.Counts "qiskit.result.Counts") object. The [`most_frequent()`](qiskit.result.Counts#most_frequent "qiskit.result.Counts.most_frequent") method is also updated to raise a more descriptive exception when the object is empty. Fixes [#5017](https://github.com/Qiskit/qiskit-terra/issues/5017)
*   Extending circuits with differing registers updated the `qregs` and `cregs` properties accordingly, but not the `qubits` and `clbits` lists. As these are no longer generated from the registers but are cached lists, this lead to a discrepancy of registers and bits. This has been fixed and the `extend` method explicitly updates the cached bit lists.
*   Fix bugs of the concrete implementations of meth:\~qiskit.circuit.ControlledGate.inverse method which do not preserve the `ctrl_state` parameter.
*   A bug was fixed that caused long pulse schedules to throw a recursion error.

<span id="id407" />

### Aer 0.6.1

No change

<span id="id408" />

### Ignis 0.4.0

No change

<span id="id409" />

### Aqua 0.7.5

No change

<span id="ibm-q-provider-0-8-0" />

### IBM Q Provider 0.8.0

No change

<span id="qiskit-0-20-0" />

## Qiskit 0.20.0

<span id="terra-0-15-1" />

### Terra 0.15.1

<span id="release-notes-0-15-0-prelude" />

<span id="id410" />

#### Prelude

The 0.15.0 release includes several new features and bug fixes. Some highlights for this release are:

This release includes the introduction of arbitrary basis translation to the transpiler. This includes support for directly targeting a broader range of device basis sets, e.g. backends implementing RZ, RY, RZ, CZ or iSwap gates.

The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class now tracks global phase. This means controlling a circuit which has global phase now correctly adds a relative phase, and gate matrix definitions are now exact rather than equal up to a global phase.

<span id="release-notes-0-15-0-new-features" />

<span id="id411" />

#### New Features

*   A new DAG class [`qiskit.dagcircuit.DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") for representing the dependency form of circuit, In this DAG, the nodes are operations (gates, measure, barrier, etc…) and the edges corresponds to non-commutation between two operations.

*   Four new functions are added to [`qiskit.converters`](converters#module-qiskit.converters "qiskit.converters") for converting back and forth to [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency"). These functions are:

    *   [`circuit_to_dagdependency()`](converters#qiskit.converters.circuit_to_dagdependency "qiskit.converters.circuit_to_dagdependency") to convert from a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object to a [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") object.
    *   [`dagdependency_to_circuit()`](converters#qiskit.converters.dagdependency_to_circuit "qiskit.converters.dagdependency_to_circuit") to convert from a [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") object to a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object.
    *   [`dag_to_dagdependency()`](converters#qiskit.converters.dag_to_dagdependency "qiskit.converters.dag_to_dagdependency") to convert from a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") object to a [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") object.
    *   [`dagdependency_to_dag()`](converters#qiskit.converters.dagdependency_to_dag "qiskit.converters.dagdependency_to_dag") to convert from a [`DAGDependency`](qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") object to a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") object.

    For example:

    ```python
    from qiskit.converters.dagdependency_to_circuit import dagdependency_to_circuit
    from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

    circuit_in = QuantumCircuit(2)
    circuit_in.h(qr[0])
    circuit_in.h(qr[1])

    dag_dependency = circuit_to_dagdependency(circuit_in)
    circuit_out = dagdepency_to_circuit(dag_dependency)
    ```

*   Two new transpiler passes have been added to [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") The first, [`UnrollCustomDefinitions`](qiskit.transpiler.passes.UnrollCustomDefinitions "qiskit.transpiler.passes.UnrollCustomDefinitions"), unrolls all instructions in the circuit according to their [`definition`](qiskit.circuit.Instruction#definition "qiskit.circuit.Instruction.definition") property, stopping when reaching either the specified `basis_gates` or a set of gates in the provided [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary"). The second, [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator"), uses the set of translations in the provided [`EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") to re-write circuit instructions in a specified basis.

*   A new `translation_method` keyword argument has been added to [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") to allow selection of the method to be used for translating circuits to the available device gates. For example, `transpile(circ, backend, translation_method='translator')`. Valid choices are:

    *   `'unroller'`: to use the [`Unroller`](qiskit.transpiler.passes.Unroller "qiskit.transpiler.passes.Unroller") pass
    *   `'translator'`: to use the [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") pass.
    *   `'synthesis'`: to use the [`UnitarySynthesis`](qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") pass.

    The default value is `'translator'`.

*   A new class for handling counts result data, [`qiskit.result.Counts`](qiskit.result.Counts "qiskit.result.Counts"), has been added. This class is a subclass of `dict` and can be interacted with like any other dictionary. But, it includes helper methods and attributes for dealing with counts results from experiments and also handles post processing and formatting of binary strings at object initialization. A [`Counts`](qiskit.result.Counts "qiskit.result.Counts") object can be created by passing a dictionary of counts with the keys being either integers, hexadecimal strings of the form `'0x4a'`, binary strings of the form `'0b1101'`, a bit string formatted across register and memory slots (ie `'00 10'`), or a dit string. For example:

    ```python
    from qiskit.result import Counts

    counts = Counts({"0x0': 1, '0x1', 3, '0x2': 1020})
    ```

*   A new method for constructing [`qiskit.dagcircuit.DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") objects has been added, `from_networkx()`. This method takes in a networkx `MultiDiGraph` object (in the format returned by `to_networkx()`) and will return a new [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") object. The intent behind this function is to enable transpiler pass authors to leverage networkx’s [graph algorithm library](https://networkx.github.io/documentation/stable/reference/algorithms/index.html) if a function is missing from the [retworkx API](https://retworkx.readthedocs.io/en/latest/api.html). Although, hopefully in such casses an issue will be opened with [retworkx issue tracker](https://github.com/Qiskit/retworkx/issues) (or even better a pull request submitted).

*   A new kwarg for `init_qubits` has been added to [`assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") and `execute()`. For backends that support this feature `init_qubits` can be used to control whether the backend executing the circuits inserts any initialization sequences at the start of each shot. By default this is set to `True` meaning that all qubits can assumed to be in the ground state at the start of each shot. However, when `init_qubits` is set to `False` qubits will be uninitialized at the start of each experiment and between shots. Note, that the backend running the circuits has to support this feature for this flag to have any effect.

*   A new kwarg `rep_delay` has been added to [`qiskit.compiler.assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"), `qiskit.execute.execute()`, and the constructor for `PulseQobjtConfig`.qiskit This new kwarg is used to denotes the time between program executions. It must be chosen from the list of valid values set as the `rep_delays` from a backend’s [`PulseBackendConfiguration`](qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") object which can be accessed as `backend.configuration().rep_delays`).

    The `rep_delay` kwarg will only work on backends which allow for dynamic repetition time. This will also be indicated in the [`PulseBackendConfiguration`](qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") object for a backend as the `dynamic_reprate_enabled` attribute. If `dynamic_reprate_enabled` is `False` then the `rep_time` value specified for [`qiskit.compiler.assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"), `qiskit.execute.execute()`, or the constructor for `PulseQobjtConfig` will be used rather than `rep_delay`. `rep_time` only allows users to specify the duration of a program, rather than the delay between programs.

*   The `qobj_schema.json` JSON Schema file in `qiskit.schemas` has been updated to include the `rep_delay` as an optional configuration property for pulse qobjs.

*   The `backend_configuration_schema.json` JSON Schema file in mod:qiskit.schemas has been updated to include `rep_delay_range` and `default_rep_delay` as optional properties for a pulse backend configuration.

*   A new attribute, [`global_phase`](qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase"), which is is used for tracking the global phase has been added to the [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. For example:

    ```python
    import math

    from qiskit import QuantumCircuit

    circ = QuantumCircuit(1, global_phase=math.pi)
    circ.u1(0)
    ```

    The global phase may also be changed or queried with `circ.global_phase` in the above example. In either case the setting is in radians. If the circuit is converted to an instruction or gate the global phase is represented by two single qubit rotations on the first qubit.

    This allows for other methods and functions which consume a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object to take global phase into account. For example. with the [`global_phase`](qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") attribute the [`to_matrix()`](qiskit.circuit.Gate#to_matrix "qiskit.circuit.Gate.to_matrix") method for a gate can now exactly correspond to its decompositions instead of just up to a global phase.

    The same attribute has also been added to the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class so that global phase can be tracked when converting between [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit").

*   Two new classes, [`AncillaRegister`](qiskit.circuit.AncillaRegister "qiskit.circuit.AncillaRegister") and [`AncillaQubit`](qiskit.circuit.AncillaQubit "qiskit.circuit.AncillaQubit") have been added to the [`qiskit.circuit`](circuit#module-qiskit.circuit "qiskit.circuit") module. These are subclasses of [`QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`Qubit`](qiskit.circuit.Qubit "qiskit.circuit.Qubit") respectively and enable marking qubits being ancillas. This will allow these qubits to be re-used in larger circuits and algorithms.

*   A new method, [`control()`](qiskit.circuit.QuantumCircuit#control "qiskit.circuit.QuantumCircuit.control"), has been added to the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). This method will return a controlled version of the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object, with both open and closed controls. This functionality had previously only been accessible via the [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") class.

*   A new method [`repeat()`](qiskit.circuit.QuantumCircuit#repeat "qiskit.circuit.QuantumCircuit.repeat") has been added to the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. It returns a new circuit object containing a specified number of repetitions of the original circuit. For example:

    ```python
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    repeated_qc = qc.repeat(3)
    repeated_qc.decompose().draw(output='mpl')
    ```

    The parameters are copied by reference, meaning that if you update the parameters in one instance of the circuit all repetitions will be updated.

*   A new method [`reverse_bits()`](qiskit.circuit.QuantumCircuit#reverse_bits "qiskit.circuit.QuantumCircuit.reverse_bits") has been added to the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This method will reverse the order of bits in a circuit (both quantum and classical bits). This can be used to switch a circuit from little-endian to big-endian and vice-versa.

*   A new method, [`combine_into_edge_map()`](qiskit.transpiler.Layout#combine_into_edge_map "qiskit.transpiler.Layout.combine_into_edge_map"), was added to the [`qiskit.transpiler.Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout") class. This method enables converting converting two [`Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout") objects into a qubit map for composing two circuits.

*   A new class, `ConfigurableFakeBackend`, has been added to the `qiskit.test.mock.utils` module. This new class enables the creation of configurable mock backends for use in testing. For example:

    ```python
    from qiskit.test.mock.utils import ConfigurableFakeBackend

    backend = ConfigurableFakeBackend("Tashkent",
                                      n_qubits=100,
                                      version="0.0.1",
                                      basis_gates=['u1'],
                                      qubit_t1=99.,
                                      qubit_t2=146.,
                                      qubit_frequency=5.,
                                      qubit_readout_error=0.01,
                                      single_qubit_gates=['u1'])
    ```

    will create a backend object with 100 qubits and all the other parameters specified in the constructor.

*   A new method [`draw()`](qiskit.circuit.EquivalenceLibrary#draw "qiskit.circuit.EquivalenceLibrary.draw") has been added to the [`qiskit.circuit.EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") class. This method can be used for drawing the contents of an equivalence library, which can be useful for debugging. For example:

    ```python
    from numpy import pi

    from qiskit.circuit import EquivalenceLibrary
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit import QuantumRegister
    from qiskit.circuit import Parameter
    from qiskit.circuit.library import HGate
    from qiskit.circuit.library import U2Gate
    from qiskit.circuit.library import U3Gate

    my_equiv_library = EquivalenceLibrary()

    q = QuantumRegister(1, 'q')
    def_h = QuantumCircuit(q)
    def_h.append(U2Gate(0, pi), [q[0]], [])
    my_equiv_library.add_equivalence(HGate(), def_h)

    theta = Parameter('theta')
    phi = Parameter('phi')
    lam = Parameter('lam')
    def_u2 = QuantumCircuit(q)
    def_u2.append(U3Gate(pi / 2, phi, lam), [q[0]], [])
    my_equiv_library.add_equivalence(U2Gate(phi, lam), def_u2)

    my_equiv_library.draw()
    ```

*   A new Phase instruction, `SetPhase`, has been added to [`qiskit.pulse`](pulse#module-qiskit.pulse "qiskit.pulse"). This instruction sets the phase of the subsequent pulses to the specified phase (in radians. For example:

    ```python
    import numpy as np

    from qiskit.pulse import DriveChannel
    from qiskit.pulse import Schedule
    from qiskit.pulse import SetPhase

    sched = Schedule()
    sched += SetPhase(np.pi, DriveChannel(0))
    ```

    In this example, the phase of the pulses applied to `DriveChannel(0)` after the `SetPhase` instruction will be set to $\pi$ radians.

*   A new pulse instruction `ShiftFrequency` has been added to [`qiskit.pulse.instructions`](pulse#module-qiskit.pulse.instructions "qiskit.pulse.instructions"). This instruction enables shifting the frequency of a channel from its set frequency. For example:

    ```python
    from qiskit.pulse import DriveChannel
    from qiskit.pulse import Schedule
    from qiskit.pulse import ShiftFrequency

    sched = Schedule()
    sched += ShiftFrequency(-340e6, DriveChannel(0))
    ```

    In this example all the pulses applied to `DriveChannel(0)` after the `ShiftFrequency` command will have the envelope a frequency decremented by 340MHz.

*   A new method [`conjugate()`](qiskit.circuit.ParameterExpression#conjugate "qiskit.circuit.ParameterExpression.conjugate") has been added to the [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") class. This enables calling `numpy.conj()` without raising an error. Since a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") object is real, it will return itself. This behaviour is analogous to Python floats/ints.

*   A new class [`PhaseEstimation`](qiskit.circuit.library.PhaseEstimation "qiskit.circuit.library.PhaseEstimation") has been added to [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library"). This circuit library class is the circuit used in the original formulation of the phase estimation algorithm in [arXiv:quant-ph/9511026](https://arxiv.org/pdf/quant-ph/9511026.pdf). Phase estimation is the task to to estimate the phase $\phi$ of an eigenvalue $e^{2\pi i\phi}$ of a unitary operator $U$, provided with the corresponding eigenstate $|psi\rangle$. That is

    $$
    U|\psi\rangle = e^{2\pi i\phi} |\psi\rangle
    $$

    This estimation (and thereby this circuit) is a central routine to several well-known algorithms, such as Shor’s algorithm or Quantum Amplitude Estimation.

*   The [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization") function [`plot_state_qsphere()`](qiskit.visualization.plot_state_qsphere "qiskit.visualization.plot_state_qsphere") has a new kwarg `show_state_labels` which is used to control whether each blob in the qsphere visualization is labeled. By default this kwarg is set to `True` and shows the basis states next to each blob by default. This feature can be disabled, reverting to the previous behavior, by setting the `show_state_labels` kwarg to `False`.

*   The [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization") function [`plot_state_qsphere()`](qiskit.visualization.plot_state_qsphere "qiskit.visualization.plot_state_qsphere") has a new kwarg `show_state_phases` which is set to `False` by default. When set to `True` it displays the phase of each basis state.

*   The [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization") function [`plot_state_qsphere()`](qiskit.visualization.plot_state_qsphere "qiskit.visualization.plot_state_qsphere") has a new kwarg `use_degrees` which is set to `False` by default. When set to `True` it displays the phase of each basis state in degrees, along with the phase circle at the bottom right.

*   A new class, [`QuadraticForm`](qiskit.circuit.library.QuadraticForm "qiskit.circuit.library.QuadraticForm") to the [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module for implementing a a quadratic form on binary variables. The circuit library element implements the operation

    $$
    |x\rangle |0\rangle \mapsto |x\rangle |Q(x) \mod 2^m\rangle
    $$

    for the quadratic form $Q$ and $m$ output qubits. The result is in the $m$ output qubits is encoded in two’s complement. If $m$ is not specified, the circuit will choose the minimal number of qubits required to represent the result without applying a modulo operation. The quadratic form is specified using a matrix for the quadratic terms, a vector for the linear terms and a constant offset. If all terms are integers, the circuit implements the quadratic form exactly, otherwise it is only an approximation.

    For example:

    ```python
    import numpy as np

    from qiskit.circuit.library import QuadraticForm

    A = np.array([[1, 2], [-1, 0]])
    b = np.array([3, -3])
    c = -2
    m = 4
    quad_form_circuit = QuadraticForm(m, A, b, c)
    ```

*   Add [`qiskit.quantum_info.Statevector.expectation_value()`](qiskit.quantum_info.Statevector#expectation_value "qiskit.quantum_info.Statevector.expectation_value") and [`qiskit.quantum_info.DensityMatrix.expectation_value()`](qiskit.quantum_info.DensityMatrix#expectation_value "qiskit.quantum_info.DensityMatrix.expectation_value") methods for computing the expectation value of an [`qiskit.quantum_info.Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator").

*   For the `seed` kwarg in the constructor for [`qiskit.circuit.library.QuantumVolume`](qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") [numpy random Generator objects](https://numpy.org/doc/stable/reference/random/generator.html) can now be used. Previously, only integers were a valid input. This is useful when integrating [`QuantumVolume`](qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") as part of a larger function with its own random number generation, e.g. generating a sequence of [`QuantumVolume`](qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") circuits.

*   The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") has a new kwarg `front` which can be used for prepending the other circuit before the origin circuit instead of appending. For example:

    ```python
    from qiskit.circuit import QuantumCircuit

    circ1 = QuantumCircuit(2)
    circ2 = QuantumCircuit(2)

    circ2.h(0)
    circ1.cx(0, 1)

    circ1.compose(circ2, front=True).draw(output='mpl')
    ```

*   Two new passes, [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") for layout and routing have been added to [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes"). These new passes are based on the algorithm presented in Li et al., “Tackling the Qubit Mapping Problem for NISQ-Era Quantum Devices”, ASPLOS 2019. They can also be selected when using the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function by setting the `layout_method` kwarg to `'sabre'` and/or the `routing_method` to `'sabre'` to use [`SabreLayout`](qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and [`SabreSwap`](qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") respectively.

*   Added the method [`replace()`](qiskit.pulse.Schedule#replace "qiskit.pulse.Schedule.replace") to the [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") class which allows a pulse instruction to be replaced with another. For example:

    ```python
    .. code-block:: python
    ```

    > from qiskit import pulse
    >
    > d0 = pulse.DriveChannel(0)
    >
    > sched = pulse.Schedule()
    >
    > old = pulse.Play(pulse.Constant(100, 1.0), d0) new = pulse.Play(pulse.Constant(100, 0.1), d0)
    >
    > sched += old
    >
    > sched = sched.replace(old, new)
    >
    > assert sched == pulse.Schedule(new)

*   Added new gate classes to [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") for the $\sqrt{X}$, its adjoint $\sqrt{X}^\dagger$, and controlled $\sqrt{X}$ gates as [`SXGate`](qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate"), [`SXdgGate`](qiskit.circuit.library.SXdgGate "qiskit.circuit.library.SXdgGate"), and [`CSXGate`](qiskit.circuit.library.CSXGate "qiskit.circuit.library.CSXGate"). They can also be added to a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object using the [`sx()`](qiskit.circuit.QuantumCircuit#sx "qiskit.circuit.QuantumCircuit.sx"), [`sxdg()`](qiskit.circuit.QuantumCircuit#sxdg "qiskit.circuit.QuantumCircuit.sxdg"), and [`csx()`](qiskit.circuit.QuantumCircuit#csx "qiskit.circuit.QuantumCircuit.csx") respectively.

*   Add support for `Reset` instructions to [`qiskit.quantum_info.Statevector.from_instruction()`](qiskit.quantum_info.Statevector#from_instruction "qiskit.quantum_info.Statevector.from_instruction"). Note that this involves RNG sampling in choosing the projection to the zero state in the case where the qubit is in a superposition state. The seed for sampling can be set using the [`seed()`](qiskit.quantum_info.Statevector#seed "qiskit.quantum_info.Statevector.seed") method.

*   The methods [`qiskit.circuit.ParameterExpression.subs()`](qiskit.circuit.ParameterExpression#subs "qiskit.circuit.ParameterExpression.subs") and [`qiskit.circuit.QuantumCircuit.assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") now accept [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") as the target value to be substituted.

    For example,

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter

    p = Parameter('p')
    source = QuantumCircuit(1)
    source.rz(p, 0)

    x = Parameter('x')
    source.assign_parameters({p: x*x})
    ```

    ```python
         ┌──────────┐
    q_0: ┤ Rz(x**2) ├
         └──────────┘
    ```

*   The [`QuantumCircuit()`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`to_gate()`](qiskit.circuit.QuantumCircuit#to_gate "qiskit.circuit.QuantumCircuit.to_gate") has a new kwarg `label` which can be used to set a label for for the output [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") object. For example:

    ```python
    from qiskit.circuit import QuantumCircuit

    circuit_gate = QuantumCircuit(2)
    circuit_gate.h(0)
    circuit_gate.cx(0, 1)
    custom_gate = circuit_gate.to_gate(label='My Special Bell')
    new_circ = QuantumCircuit(2)
    new_circ.append(custom_gate, [0, 1], [])
    new_circ.draw(output='mpl')
    ```

*   Added the [`UGate`](qiskit.circuit.library.UGate "qiskit.circuit.library.UGate"), [`CUGate`](qiskit.circuit.library.CUGate "qiskit.circuit.library.CUGate"), [`PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate"), and [`CPhaseGate`](qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate") with the corresponding [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods [`u()`](qiskit.circuit.QuantumCircuit#u "qiskit.circuit.QuantumCircuit.u"), [`cu()`](qiskit.circuit.QuantumCircuit#cu "qiskit.circuit.QuantumCircuit.cu"), [`p()`](qiskit.circuit.QuantumCircuit#p "qiskit.circuit.QuantumCircuit.p"), and [`cp()`](qiskit.circuit.QuantumCircuit#cp "qiskit.circuit.QuantumCircuit.cp"). The [`UGate`](qiskit.circuit.library.UGate "qiskit.circuit.library.UGate") gate is the generic single qubit rotation gate with 3 Euler angles and the [`CUGate`](qiskit.circuit.library.CUGate "qiskit.circuit.library.CUGate") gate its controlled version. [`CUGate`](qiskit.circuit.library.CUGate "qiskit.circuit.library.CUGate") has 4 parameters to account for a possible global phase of the U gate. The [`PhaseGate`](qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate") and [`CPhaseGate`](qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate") gates are the general Phase gate at an arbitrary angle and it’s controlled version.

*   A new kwarg, `cregbundle` has been added to the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw"). When set to `True` the cregs will be bundled into a single line in circuit visualizations for the `text` and `mpl` drawers. The default value is `True`. Addresses issue [#4290](https://github.com/Qiskit/qiskit-terra/issues/4290).

    For example:

    ```python
    from qiskit import QuantumCircuit
    circuit = QuantumCircuit(2)
    circuit.measure_all()
    circuit.draw(output='mpl', cregbundle=True)
    ```

*   A new kwarg, `initial_state` has been added to the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw"). When set to `True` the initial state will now be included in circuit visualizations for all drawers. Addresses issue [#4293](https://github.com/Qiskit/qiskit-terra/issues/4293).

    For example:

    ```python
    from qiskit import QuantumCircuit
    circuit = QuantumCircuit(2)
    circuit.measure_all()
    circuit.draw(output='mpl', initial_state=True)
    ```

*   Labels will now be displayed when using the ‘mpl’ drawer. There are 2 types of labels - gate labels and control labels. Gate labels will replace the gate name in the display. Control labels will display above or below the controls for a gate. Fixes issues #3766, #4580 Addresses issues [#3766](https://github.com/Qiskit/qiskit-terra/issues/3766) and [#4580](https://github.com/Qiskit/qiskit-terra/issues/4580).

    For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.circuit.library.standard_gates import YGate
    circuit = QuantumCircuit(2)
    circuit.append(YGate(label='A Y Gate').control(label='Y Control'), [0, 1])
    circuit.draw(output='mpl')
    ```

<span id="release-notes-0-15-0-upgrade-notes" />

<span id="id416" />

#### Upgrade Notes

*   Implementations of the multi-controlled X Gate ( [`MCXGrayCode`](qiskit.circuit.library.MCXGrayCode "qiskit.circuit.library.MCXGrayCode"), [`MCXRecursive`](qiskit.circuit.library.MCXRecursive "qiskit.circuit.library.MCXRecursive"), and [`MCXVChain`](qiskit.circuit.library.MCXVChain "qiskit.circuit.library.MCXVChain")) have had their `name` properties changed to more accurately describe their implementation: `mcx_gray`, `mcx_recursive`, and `mcx_vchain` respectively. Previously, these gates shared the name `mcx` with [`MCXGate`](qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate"), which caused these gates to be incorrectly transpiled and simulated.

*   By default the preset passmanagers in [`qiskit.transpiler.preset_passmanagers`](transpiler_preset#module-qiskit.transpiler.preset_passmanagers "qiskit.transpiler.preset_passmanagers") are using [`UnrollCustomDefinitions`](qiskit.transpiler.passes.UnrollCustomDefinitions "qiskit.transpiler.passes.UnrollCustomDefinitions") and [`BasisTranslator`](qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") to handle basis changing instead of the previous default [`Unroller`](qiskit.transpiler.passes.Unroller "qiskit.transpiler.passes.Unroller"). This was done because the new passes are more flexible and allow targeting any basis set, however the output may differ. To use the previous default you can set the `translation_method` kwarg on [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") to `'unroller'`.

*   The [`qiskit.converters.circuit_to_gate()`](converters#qiskit.converters.circuit_to_gate "qiskit.converters.circuit_to_gate") and :func\`qiskit.converters.circuit\_to\_instruction\` converter functions had previously automatically included the generated gate or instruction in the active `SessionEquivalenceLibrary`. These converters now accept an optional `equivalence_library` keyword argument to specify if and where the converted instances should be registered. The default behavior has changed to not register the converted instance.

*   The default value of the `cregbundle` kwarg for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function has been changed to `True`. This means that by default the classical bits in the circuit diagram will now be bundled by default, for example:

    ```python
    from qiskit.circuit import QuantumCircuit

    circ = QuantumCircuit(4)
    circ.x(0)
    circ.h(1)
    circ.measure_all()
    circ.draw(output='mpl')
    ```

    If you want to have your circuit drawing retain the previous behavior and show each classical bit in the diagram you can set the `cregbundle` kwarg to `False`. For example:

    ```python
    from qiskit.circuit import QuantumCircuit

    circ = QuantumCircuit(4)
    circ.x(0)
    circ.h(1)
    circ.measure_all()
    circ.draw(output='mpl', cregbundle=False)
    ```

*   [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") plotting with [`qiskit.pulse.Schedule.draw()`](qiskit.pulse.Schedule#draw "qiskit.pulse.Schedule.draw") and [`qiskit.visualization.pulse_drawer()`](qiskit.visualization.pulse_drawer "qiskit.visualization.pulse_drawer") will no longer display the event table by default. This can be reenabled by setting the `table` kwarg to `True`.

*   The pass [`RemoveResetInZeroState`](qiskit.transpiler.passes.RemoveResetInZeroState "qiskit.transpiler.passes.RemoveResetInZeroState") was previously included in the preset pass manager [`level_0_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_0_pass_manager "qiskit.transpiler.preset_passmanagers.level_0_pass_manager") which was used with the `optimization_level=0` for [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and `execute()` functions. However, [`RemoveResetInZeroState`](qiskit.transpiler.passes.RemoveResetInZeroState "qiskit.transpiler.passes.RemoveResetInZeroState") is an optimization pass and should not have been included in optimization level 0 and was removed. If you need to run [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") with [`RemoveResetInZeroState`](qiskit.transpiler.passes.RemoveResetInZeroState "qiskit.transpiler.passes.RemoveResetInZeroState") either use a custom pass manager or `optimization_level` 1, 2, or 3.

*   The deprecated kwarg `line_length` for the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method has been removed. It had been deprecated since the 0.10.0 release. Instead you can use the `fold` kwarg to adjust the width of the circuit diagram.

*   The `'mpl'` output mode for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") now requires the [pylatexenc](https://pylatexenc.readthedocs.io/en/latest/latexencode/) library to be installed. This was already an optional dependency for visualization, but was only required for the `'latex'` output mode before. It is now also required for the matplotlib drawer because it is needed to handle correctly sizing gates with matplotlib’s [mathtext](https://matplotlib.org/3.2.2/tutorials/text/mathtext.html) labels for gates.

*   The deprecated `get_tokens` methods for the [`qiskit.qasm.Qasm`](qasm#qiskit.qasm.Qasm "qiskit.qasm.Qasm") and `qiskit.qasm.QasmParser` has been removed. These methods have been deprecated since the 0.9.0 release. The `qiskit.qasm.Qasm.generate_tokens()` and `qiskit.qasm.QasmParser.generate_tokens()` methods should be used instead.

*   The deprecated kwarg `channels_to_plot` for [`qiskit.pulse.Schedule.draw()`](qiskit.pulse.Schedule#draw "qiskit.pulse.Schedule.draw"), `qiskit.pulse.Instruction.draw()`, `qiskit.visualization.pulse.matplotlib.ScheduleDrawer.draw` and [`pulse_drawer()`](qiskit.visualization.pulse_drawer "qiskit.visualization.pulse_drawer") has been removed. The kwarg has been deprecated since the 0.11.0 release and was replaced by the `channels` kwarg, which functions identically and should be used instead.

*   The deprecated `circuit_instruction_map` attribute of the [`qiskit.providers.models.PulseDefaults`](qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") class has been removed. This attribute has been deprecated since the 0.12.0 release and was replaced by the `instruction_schedule_map` attribute which can be used instead.

*   The `union` method of [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") and `Instruction` have been deprecated since the 0.12.0 release and have now been removed. Use [`qiskit.pulse.Schedule.insert()`](qiskit.pulse.Schedule#insert "qiskit.pulse.Schedule.insert") and `qiskit.pulse.Instruction.meth()` methods instead with the kwarg\`\`time=0\`\`.

*   The deprecated `scaling` argument to the `draw` method of [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") and `Instruction` has been replaced with `scale` since the 0.12.0 release and now has been removed. Use the `scale` kwarg instead.

*   The deprecated `period` argument to [`qiskit.pulse.library`](pulse#module-qiskit.pulse.library "qiskit.pulse.library") functions have been replaced by `freq` since the 0.13.0 release and now removed. Use the `freq` kwarg instead of `period`.

*   The `qiskit.pulse.commands` module containing `Commands` classes was deprecated in the 0.13.0 release and has now been removed. You will have to upgrade your Pulse code if you were still using commands. For example:

    | Old                                  | New                          |
    | ------------------------------------ | ---------------------------- |
    | `Command(args)(channel)`             | `Instruction(args, channel)` |
    | \`\`\`python                         |                              |
    | Acquire(duration)(AcquireChannel(0)) |                              |
    | \`\`\`                               | \`\`\`python                 |
    | Acquire(duration, AcquireChannel(0)) |                              |

    ````|
    | ```python
    Delay(duration)(channel) 
    ```             | ```python
    Delay(duration, channel) 
    ```                                          |
    | ```python
    FrameChange(angle)(DriveChannel(0)) 
    ```  | ```python
    # FrameChange was also renamed ShiftPhase(angle, DriveChannel(0)) 
    ``` |
    | ```python
    Gaussian(...)(DriveChannel(0)) 
    ```       | ```python
    # Pulses need to be `Play`d Play(Gaussian(...), DriveChannel(0)) 
    ```  |

    ````

*   All classes and function in the `qiskit.tool.qi` module were deprecated in the 0.12.0 release and have now been removed. Instead use the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module and the new methods and classes that it has for working with quantum states and operators.

*   The `qiskit.quantum_info.basis_state` and `qiskit.quantum_info.projector` functions are deprecated as of Qiskit Terra 0.12.0 as are now removed. Use the `qiskit.quantum_info.QuantumState` and its derivatives [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") to work with states.

*   The interactive plotting functions from [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization"), `iplot_bloch_multivector`, `iplot_state_city`, `iplot_state_qsphere`, `iplot_state_hinton`, `iplot_histogram`, `iplot_state_paulivec` now are just deprecated aliases for the matplotlib based equivalents and are no longer interactive. The hosted static JS code that these functions relied on has been removed and they no longer could work. A normal deprecation wasn’t possible because the site they depended on no longer exists.

*   The validation components using marshmallow from `qiskit.validation` have been removed from terra. Since they are no longer used to build any objects in terra.

*   The marshmallow schema classes in [`qiskit.result`](result#module-qiskit.result "qiskit.result") have been removed since they are no longer used by the [`qiskit.result.Result`](qiskit.result.Result "qiskit.result.Result") class.

*   The output of the [`to_dict()`](qiskit.result.Result#to_dict "qiskit.result.Result.to_dict") method for the [`qiskit.result.Result`](qiskit.result.Result "qiskit.result.Result") class is no longer in a format for direct JSON serialization. Depending on the content contained in instances of these classes there may be types that the default JSON encoder doesn’t know how to handle, for example complex numbers or numpy arrays. If you’re JSON serializing the output of the `to_dict()` method directly you should ensure that your JSON encoder can handle these types.

*   The option to acquire multiple qubits at once was deprecated in the 0.12.0 release and is now removed. Specifically, the init args `mem_slots` and `reg_slots` have been removed from [`qiskit.pulse.instructions.Acquire`](qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire"), and `channel`, `mem_slot` and `reg_slot` will raise an error if a list is provided as input.

*   Support for the use of the `USE_RETWORKX` environment variable which was introduced in the 0.13.0 release to provide an optional fallback to the legacy [networkx](https://networkx.github.io/) based [`qiskit.dagcircuit.DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") implementation has been removed. This flag was only intended as provide a relief valve for any users that encountered a problem with the new implementation for one release during the transition to retworkx.

*   The module within [`qiskit.pulse`](pulse#module-qiskit.pulse "qiskit.pulse") responsible for schedule->schedule transformations has been renamed from `reschedule.py` to `transforms.py`. The previous import path has been deprecated. To upgrade your code:

    ```python
    from qiskit.pulse.rescheduler import <X>
    ```

    should be replaced by:

    ```python
    from qiskit.pulse.transforms import <X>
    ```

*   In previous releases a [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") did not allow `TransformationPass` classes to modify the `PropertySet`. This restriction has been lifted so a `TransformationPass` class now has read and write access to both the `PropertySet` and `DAGCircuit` during [`run()`](qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run"). This change was made to more efficiently facilitate `TransformationPass` classes that have an internal state which may be necessary for later passes in the [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager"). Without this change a second redundant `AnalysisPass` would have been necessary to recreate the internal state, which could add significant overhead.

<span id="release-notes-0-15-0-deprecation-notes" />

<span id="id417" />

#### Deprecation Notes

*   The name of the first positional parameter for the [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization") functions [`plot_state_hinton()`](qiskit.visualization.plot_state_hinton "qiskit.visualization.plot_state_hinton"), [`plot_bloch_multivector()`](qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector"), [`plot_state_city()`](qiskit.visualization.plot_state_city "qiskit.visualization.plot_state_city"), [`plot_state_paulivec()`](qiskit.visualization.plot_state_paulivec "qiskit.visualization.plot_state_paulivec"), and [`plot_state_qsphere()`](qiskit.visualization.plot_state_qsphere "qiskit.visualization.plot_state_qsphere") has been renamed from `rho` to `state`. Passing in the value by name to `rho` is deprecated and will be removed in a future release. Instead you should either pass the argument positionally or use the new parameter name `state`.

*   The `qiskit.pulse.pulse_lib` module has been deprecated and will be removed in a future release. It has been renamed to [`qiskit.pulse.library`](pulse#module-qiskit.pulse.library "qiskit.pulse.library") which should be used instead.

*   The [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method `mirror()` has been deprecated and will be removed in a future release. The method [`qiskit.circuit.QuantumCircuit.reverse_ops()`](qiskit.circuit.QuantumCircuit#reverse_ops "qiskit.circuit.QuantumCircuit.reverse_ops") should be used instead, since mirroring could be confused with swapping the output qubits of the circuit. The [`reverse_ops()`](qiskit.circuit.QuantumCircuit#reverse_ops "qiskit.circuit.QuantumCircuit.reverse_ops") method only reverses the order of gates that are applied instead of mirroring.

*   The `qubits()` and `clbits()` methods of [`qiskit.dagcircuit.DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") have been deprecated and will be removed in a future release. They have been replaced with properties of the same name, `qiskit.dagcircuit.DAGCircuit.qubits` and `qiskit.dagcircuit.DAGCircuit.clbits`, and are cached so accessing them is much faster.

*   The `get_sample_pulse` method for `qiskit.pulse.library.ParametricPulse` derived classes (for example [`GaussianSquare`](qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare")) has been deprecated and will be removed in a future release. It has been replaced by the `get_waveform` method (for example `get_waveform()`) which should behave identically.

*   The use of the optional `condition` argument on [`qiskit.dagcircuit.DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode"), [`qiskit.dagcircuit.DAGCircuit.apply_operation_back()`](qiskit.dagcircuit.DAGCircuit#apply_operation_back "qiskit.dagcircuit.DAGCircuit.apply_operation_back"), and [`qiskit.dagcircuit.DAGCircuit.apply_operation_front()`](qiskit.dagcircuit.DAGCircuit#apply_operation_front "qiskit.dagcircuit.DAGCircuit.apply_operation_front") has been deprecated and will be removed in a future release. Instead the `control` set in [`qiskit.circuit.Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") instances being added to a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") should be used.

*   The `set_atol` and `set_rtol` class methods of the `qiskit.quantum_info.BaseOperator` and `qiskit.quantum_info.QuantumState` classes (and their subclasses such as [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix")) are deprecated and will be removed in a future release. Instead the value for the attributes `.atol` and `.rtol` should be set on the class instead. For example:

    ```python
    from qiskit.quantum_info import ScalarOp

    ScalarOp.atol = 3e-5
    op = ScalarOp(2)
    ```

*   The interactive plotting functions from [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization"), `iplot_bloch_multivector`, `iplot_state_city`, `iplot_state_qsphere`, `iplot_state_hinton`, `iplot_histogram`, `iplot_state_paulivec` have been deprecated and will be removed in a future release. The matplotlib based equivalent functions from [`qiskit.visualization`](visualization#module-qiskit.visualization "qiskit.visualization"), [`plot_bloch_multivector()`](qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector"), [`plot_state_city()`](qiskit.visualization.plot_state_city "qiskit.visualization.plot_state_city"), [`plot_state_qsphere()`](qiskit.visualization.plot_state_qsphere "qiskit.visualization.plot_state_qsphere"), [`plot_state_hinton()`](qiskit.visualization.plot_state_hinton "qiskit.visualization.plot_state_hinton"), `plot_state_histogram()`, and [`plot_state_paulivec()`](qiskit.visualization.plot_state_paulivec "qiskit.visualization.plot_state_paulivec") should be used instead.

*   The properties `acquires`, `mem_slots`, and `reg_slots` of the [`qiskit.pulse.instructions.Acquire`](qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire") pulse instruction have been deprecated and will be removed in a future release. They are just duplicates of [`channel`](qiskit.pulse.instructions.Acquire#channel "qiskit.pulse.instructions.Acquire.channel"), [`mem_slot`](qiskit.pulse.instructions.Acquire#mem_slot "qiskit.pulse.instructions.Acquire.mem_slot"), and [`reg_slot`](qiskit.pulse.instructions.Acquire#reg_slot "qiskit.pulse.instructions.Acquire.reg_slot") respectively now that previously deprecated support for using multiple qubits in a single [`Acquire`](qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire") instruction has been removed.

*   The `SamplePulse` class from [`qiskit.pulse`](pulse#module-qiskit.pulse "qiskit.pulse") has been renamed to [`Waveform`](qiskit.pulse.library.Waveform "qiskit.pulse.library.Waveform"). `SamplePulse` is deprecated and will be removed in a future release.

*   The style dictionary key `cregbundle` has been deprecated and will be removed in a future release. This has been replaced by the kwarg `cregbundle` added to the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw").

<span id="release-notes-0-15-0-bug-fixes" />

<span id="id418" />

#### Bug Fixes

*   The [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`num_nonlocal_gates`](qiskit.circuit.QuantumCircuit#num_nonlocal_gates "qiskit.circuit.QuantumCircuit.num_nonlocal_gates") previously included multi-qubit [`qiskit.circuit.Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") objects (for example, [`Barrier`](qiskit.circuit.library.Barrier "qiskit.circuit.library.Barrier")) in its count of non-local gates. This has been corrected so that only non-local [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") objects are counted. Fixes [#4500](https://github.com/Qiskit/qiskit-terra/issues/4500)

*   [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") instances with a set `ctrl_state` were in some cases not being evaluated as equal, even if the compared gates were equivalent. This has been resolved so that Fixes [#4573](https://github.com/Qiskit/qiskit-terra/issues/4573)

*   When accessing a bit from a [`qiskit.circuit.QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") or [`qiskit.circuit.ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") by index when using numpy integer types \<[https://numpy.org/doc/stable/user/basics.types.html](https://numpy.org/doc/stable/user/basics.types.html)>\`\_\_ would previously raise a `CircuitError` exception. This has been resolved so numpy types can be used in addition to Python’s built-in `int` type. Fixes [#3929](https://github.com/Qiskit/qiskit-terra/issues/3929).

*   A bug was fixed where only the first `qiskit.pulse.configuration.Kernel` or `qiskit.pulse.configuration.Discriminator` for an `qiskit.pulse.Acquire` was used when there were multiple Acquires at the same time in a [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule").

*   The SI unit use for constructing `qiskit.pulse.SetFrequency` objects is in Hz, but when a [`PulseQobjInstruction`](qiskit.qobj.PulseQobjInstruction "qiskit.qobj.PulseQobjInstruction") object is created from a `SetFrequency` instance it needs to be converted to GHz. This conversion was missing from previous releases and has been fixed.

*   Previously it was possible to set the number of control qubits to zero in which case the the original, potentially non-controlled, operation would be returned. This could cause an `AttributeError` to be raised if the caller attempted to access an attribute which only [`ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") object have. This has been fixed by adding a getter and setter for [`num_ctrl_qubits`](qiskit.circuit.ControlledGate#num_ctrl_qubits "qiskit.circuit.ControlledGate.num_ctrl_qubits") to validate that a valid value is being used. Fixes [#4576](https://github.com/Qiskit/qiskit-terra/issues/4576)

*   Open controls were implemented by modifying a [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") objects [`definition`](qiskit.circuit.Gate#definition "qiskit.circuit.Gate.definition"). However, when the gate already exists in the basis set, this definition was not used, which resulted in incorrect circuits being sent to a backend after transpilation. This has been fixed by modifying the `Unroller` pass to use the definition if it encounters a controlled gate with open controls. Fixes [#4437](https://github.com/Qiskit/qiskit-terra/issues/4437)

*   The `insert_barriers` keyword argument in the [`ZZFeatureMap`](qiskit.circuit.library.ZZFeatureMap "qiskit.circuit.library.ZZFeatureMap") class didn’t actually insert barriers in between the Hadamard layers and evolution layers. This has been fixed so that barriers are now properly inserted.

*   Fixed issue where some gates with three or more qubits would fail to compile in certain instances. Refer to #4577 \<[https://github.com/Qiskit/qiskit-terra/issues/4577](https://github.com/Qiskit/qiskit-terra/issues/4577) for more detail.

*   The matplotlib (`'mpl'`) output backend for the [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") and the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function was not properly scaling when the kwarg `scale` was set. Fonts and line widths did not scale with the rest of the image. This has been fixed and all elements of the circuit diagram now scale properly. For example:

    ```python
    from qiskit import QuantumCircuit
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.draw(output='mpl', scale=0.5)
    ```

    Fixes [#4179](https://github.com/Qiskit/qiskit-terra/issues/4179).

*   Fixes issue where initializing or evolving [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes by circuits by circuit containing `Barrier` instructions would raise an exception. Fixes [#4461](https://github.com/Qiskit/qiskit-terra/issues/4461)

*   Previously when a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") contained a [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") with a classical condition the transpiler would sometimes fail when using `optimization_level=3` on [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or `execute()` raising an `UnboundLocalError`. This has been fixed by updating the [`ConsolidateBlocks`](qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") pass to account for the classical condition. Fixes [#4672](https://github.com/Qiskit/qiskit-terra/issues/4672).

*   In some situations long gate and register names would overflow, or leave excessive empty space around them when using the `'mpl'` output backend for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function. This has been fixed by using correct text widths for a proportional font. Fixes [#4611](https://github.com/Qiskit/qiskit-terra/issues/4611), [#4605](https://github.com/Qiskit/qiskit-terra/issues/4605), [#4545](https://github.com/Qiskit/qiskit-terra/issues/4545), [#4497](https://github.com/Qiskit/qiskit-terra/issues/4497), [#4449](https://github.com/Qiskit/qiskit-terra/issues/4449), and [#3641](https://github.com/Qiskit/qiskit-terra/issues/3641).

*   When using the ```style` kwarg on the :meth:`qiskit.circuit.QuantumCircuit.draw` or :func:`qiskit.visualization.circuit_drawer` with the ``'mpl'``` output backend the dictionary key `'showindex'` set to `True`, the index numbers at the top of the column did not line up properly. This has been fixed.

*   When using `cregbunde=True` with the `'mpl'` output backend for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and measuring onto a second fold, the measure arrow would overwrite the creg count. The count was moved to the left to prevent this. Fixes [#4148](https://github.com/Qiskit/qiskit-terra/issues/4148).

*   When using the `'mpl'` output backend for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function [`CSwapGate`](qiskit.circuit.library.CSwapGate "qiskit.circuit.library.CSwapGate") gates and a controlled [`RZZGate`](qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate") gates now display with their appropriate symbols instead of in a box.

*   When using the `'mpl'` output backend for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function controlled gates created using the [`to_gate()`](qiskit.circuit.QuantumCircuit#to_gate "qiskit.circuit.QuantumCircuit.to_gate") method were not properly spaced and could overlap with other gates in the circuit diagram. This issue has been fixed.

*   When using the `'mpl'` output backend for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function gates with arrays as parameters, such as `HamiltonianGate`, no longer display with excessive space around them. Fixes [#4352](https://github.com/Qiskit/qiskit-terra/issues/4352).

*   When using the `'mpl'` output backend for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function generic gates created by directly instantiating [`qiskit.circuit.Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") method now display the proper background color for the gate. Fixes [#4496](https://github.com/Qiskit/qiskit-terra/issues/4496).

*   When using the `'mpl'` output backend for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function an `AttributeError` that occurred when using `Isometry` or `Initialize` has been fixed. Fixes [#4439](https://github.com/Qiskit/qiskit-terra/issues/4439).

*   When using the `'mpl'` output backend for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function some open-controlled gates did not properly display the open controls. This has been corrected so that open controls are properly displayed as open circles. Fixes [#4248](https://github.com/Qiskit/qiskit-terra/issues/4248).

*   When using the `'mpl'` output backend for the [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function setting the `fold` kwarg to -1 will now properly display the circuit without folding. Fixes [#4506](https://github.com/Qiskit/qiskit-terra/issues/4506).

*   Parametric pulses from `qiskit.pulse.library.discrete` now have zero ends of parametric pulses by default. The endpoints are defined such that for a function $f(x)$ then $f(-1) = f(duration + 1) = 0$. Fixes [#4317](https://github.com/Qiskit/qiskit-terra/issues/4317)

<span id="release-notes-0-15-0-other-notes" />

<span id="id421" />

#### Other Notes

*   The [`qiskit.result.Result`](qiskit.result.Result "qiskit.result.Result") class which was previously constructed using the marshmallow library has been refactored to not depend on marshmallow anymore. This new implementation should be a seamless transition but some specific behavior that was previously inherited from marshmallow may not work. Please file issues for any incompatibilities found.

<span id="id422" />

### Aer 0.6.1

<span id="release-notes-0-6-0-prelude" />

<span id="id423" />

#### Prelude

This 0.6.0 release includes numerous performance improvements for all simulators in the Aer provider and significant changes to the build system when building from source. The main changes are support for SIMD vectorization, approximation in the matrix product state method via bond-dimension truncation, more efficient Pauli expectation value computation, and greatly improved efficiency in Python conversion of C++ result objects. The build system was upgraded to use the [Conan](https://conan.io/) to manage common C++ dependencies when building from source.

<span id="release-notes-0-6-0-new-features" />

<span id="id424" />

#### New Features

*   Add density matrix snapshot support to “statevector” and “statevector\_gpu” methods of the QasmSimulator.

*   Allow density matrix snapshots on specific qubits, not just all qubits. This computes the partial trace of the state over the remaining qubits.

*   Adds Pauli expectation value snapshot support to the “density\_matrix” simulation method of the `qiskit.providers.aer.QasmSimulator`. Add snapshots to circuits using the `qiskit.providers.aer.extensions.SnapshotExpectationValue` extension.

*   Greatly improves performance of the Pauli expectation value snapshot algorithm for the “statevector”, “statevector\_gpu, “density\_matrix”, and “density\_matrix\_gpu” simulation methods of the `qiskit.providers.aer.QasmSimulator`.

*   Enable the gate-fusion circuit optimization from the `qiskit.providers.aer.QasmSimulator` in both the `qiskit.providers.aer.StatevectorSimulator` and `qiskit.providers.aer.UnitarySimulator` backends.

*   Improve the performance of average snapshot data in simulator results. This effects probability, Pauli expectation value, and density matrix snapshots using the following extensions:

    *   `qiskit.providers.aer.extensions.SnapshotExpectationValue`
    *   `qiskit.providers.aer.extensions.SnapshotProbabilities`
    *   `qiskit.providers.aer.extensions.SnapshotDensityMatrix`

*   Add move constructor and improve memory usage of the C++ matrix class to minimize copies of matrices when moving output of simulators into results.

*   Improve performance of unitary simulator.

*   Add approximation to the “matrix\_product\_state” simulation method of the `QasmSimulator` to limit the bond-dimension of the MPS.

    There are two modes of approximation. Both discard the smallest Schmidt coefficients following the SVD algorithm. There are two parameters that control the degree of approximation: `"matrix_product_state_max_bond_dimension"` (int): Sets a limit on the number of Schmidt coefficients retained at the end of the svd algorithm. Coefficients beyond this limit will be discarded. (Default: None, i.e., no limit on the bond dimension). `"matrix_product_state_truncation_threshold"` (double): Discard the smallest coefficients for which the sum of their squares is smaller than this threshold. (Default: 1e-16).

*   Improve the performance of measure sampling when using the “matrix\_product\_state” `QasmSimulator` simulation method.

*   Add support for `Delay`, `Phase` and `SetPhase` pulse instructions to the `qiskit.providers.aer.PulseSimulator`.

*   Improve the performance of the `qiskit.providers.aer.PulseSimulator` by caching calls to RHS function

*   Introduce alternate DE solving methods, specifiable through `backend_options` in the `qiskit.providers.aer.PulseSimulator`.

*   Improve performance of simulator result classes by using move semantics and removing unnecessary copies that were happening when combining results from separate experiments into the final result object.

*   Greatly improve performance of pybind11 conversion of simulator results by using move semantics where possible, and by moving vector and matrix results to Numpy arrays without copies.

*   Change the RNG engine for simulators from 32-bit Mersenne twister to 64-bit Mersenne twister engine.

*   Improves the performance of the “statevector” simulation method of the `qiskit.providers.aer.QasmSimulator` and `qiskit.providers.aer.StatevectorSimulator` by using SIMD intrinsics on systems that support the AVX2 instruction set. AVX2 support is automatically detected and enabled at runtime.

<span id="release-notes-0-6-0-upgrade-notes" />

<span id="id425" />

#### Upgrade Notes

*   Changes the build system to use the [Conan package manager](https://conan.io/). This tool will handle most of the dependencies needed by the C++ source code. Internet connection may be needed for the first build or when dependencies are added or updated, in order to download the required packages if they are not in your Conan local repository.

    When building the standalone version of qiskit-aer you must install conan first with:

    ```python
    pip install conan
    ```

*   Changes how transpilation passes are handled in the C++ Controller classes so that each pass must be explicitly called. This allows for greater customization on when each pass should be called, and with what parameters. In particular this enables setting different parameters for the gate fusion optimization pass depending on the QasmController simulation method.

*   Add `gate_length_units` kwarg to `qiskit.providers.aer.noise.NoiseModel.from_device()` for specifying custom `gate_lengths` in the device noise model function to handle unit conversions for internal code.

*   Add Controlled-Y (“cy”) gate to the Stabilizer simulator methods supported gateset.

*   For Aer’s backend the jsonschema validation of input qobj objects from terra is now opt-in instead of being enabled by default. If you want to enable jsonschema validation of qobj set the `validate` kwarg on the `qiskit.providers.aer.QasmSimualtor.run()` method for the backend object to `True`.

*   Adds an OpSet object to the base simulator State class to allow easier validation of instructions, gates, and snapshots supported by simulators.

*   Refactor OpSet class. Moved OpSet to separate header file and add `contains` and `difference` methods based on `std::set::contains` and `std::algorithm::set_difference`. These replace the removed invalid and validate instructions from OpSet, but with the order reversed. It returns a list of other ops not in current opset rather than opset instructions not in the other.

*   Improves how measurement sampling optimization is checked. The expensive part of this operation is now done once during circuit construction where rather than multiple times during simulation for when checking memory requirements, simulation method, and final execution.

<span id="release-notes-0-6-0-bug-fixes" />

<span id="id426" />

#### Bug Fixes

*   Remove “extended\_stabilizer” from the automatically selected simulation methods. This is needed as the extended stabilizer method is not exact and may give incorrect results for certain circuits unless the user knows how to optimize its configuration parameters.

    The automatic method now only selects from “stabilizer”, “density\_matrix”, and “statevector” methods. If a non-Clifford circuit that is too large for the statevector method is executed an exception will be raised suggesting you could try explicitly using the “extended\_stabilizer” or “matrix\_product\_state” methods instead.

*   Disables gate fusion for the matrix product state simulation method as this was causing issues with incorrect results being returned in some cases.

*   Fixes a bug causing incorrect channel evaluation in the `qiskit.providers.aer.PulseSimulator`.

*   Fixes several minor bugs for Hamiltonian parsing edge cases in the `qiskit.providers.aer.pulse.system_models.hamiltonian_model.HamiltonianModel` class.

<span id="id427" />

### Ignis 0.4.0

<span id="release-notes-0-4-0-prelude" />

<span id="id428" />

#### Prelude

The main change made in this release is a refactor of the Randomized Benchmarking code to integrate the updated Clifford class [`qiskit.quantum_info.Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") from Terra and to improve the CNOT-Dihedral class.

<span id="release-notes-0-4-0-new-features" />

<span id="id429" />

#### New Features

*   The `qiskit.ignis.verification.randomized_benchmarking.randomized_benchmarking_seq()` function was refactored to use the updated Clifford class [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford"), to allow efficient Randomized Benchmarking (RB) on Clifford sequences with more than 2 qubits. In addition, the code of the CNOT-Dihedral class `qiskit.ignis.verification.randomized_benchmarking.CNOTDihedral` was refactored to make it more efficient, by using numpy arrays, as well not using pre-generated pickle files storing all the 2-qubit group elements. The `qiskit.ignis.verification.randomized_benchmarking.randomized_benchmarking_seq()` function has a new kwarg `rand_seed` which can be used to specify a seed for the random number generator used to generate the RB circuits. This can be useful for having a reproducible circuit.
*   The `qiskit.ignis.verification.qv_circuits()` function has a new kwarg `seed` which can be used to specify a seed for the random number generator used to generate the Quantum Volume circuits. This can be useful for having a reproducible circuit.

<span id="release-notes-0-4-0-upgrade-notes" />

<span id="id430" />

#### Upgrade Notes

*   The `qiskit.ignis.verification.randomized_benchmarking.randomized_benchmarking_seq()` function is now using the updated Clifford class [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") and the updated CNOT-Dihedral class `qiskit.ignis.verification.randomized_benchmarking.CNOTDihedral` to construct its output instead of using pre-generated group tables for the Clifford and CNOT-Dihedral group elements, which were stored in pickle files. This may result in subtle differences from the output from the previous version.
*   A new requirement [scikit-learn](https://scikit-learn.org/stable/) has been added to the requirements list. This dependency was added in the 0.3.0 release but wasn’t properly exposed as a dependency in that release. This would lead to an `ImportError` if the `qiskit.ignis.measurement.discriminator.iq_discriminators` module was imported. This is now correctly listed as a dependency so that `scikit-learn` will be installed with qiskit-ignis.
*   The `qiskit.ignis.verification.qv_circuits()` function is now using the circuit library class [`QuantumVolume`](qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") to construct its output instead of building the circuit from scratch. This may result in subtle differences from the output from the previous version.
*   Tomography fitters can now also get list of Result objects instead of a single Result as requested in [issue #320](https://github.com/Qiskit/qiskit-ignis/issues/320/).

<span id="release-notes-0-4-0-deprecation-notes" />

<span id="id431" />

#### Deprecation Notes

*   The kwarg `interleaved_gates` for the `qiskit.ignis.verification.randomized_benchmarking.randomized_benchmarking_seq()` function has been deprecated and will be removed in a future release. It is superseded by `interleaved_elem`. The helper functions `qiskit.ignis.verification.randomized_benchmarking.BasicUtils`, `qiskit.ignis.verification.randomized_benchmarking.CliffordUtils` and `qiskit.ignis.verification.randomized_benchmarking.DihedralUtils` were deprecated. These classes are superseded by `qiskit.ignis.verification.randomized_benchmarking.RBgroup` that handles the group operations needed for RB. The class `qiskit.ignis.verification.randomized_benchmarking.Clifford` is superseded by [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford").

*   The kwargs `qr` and `cr` for the `qiskit.ignis.verification.qv_circuits()` function have been deprecated and will be removed in a future release. These kwargs were documented as being used for specifying a [`qiskit.circuit.QuantumRegister`](qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`qiskit.circuit.ClassicalRegister`](qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") to use in the generated Quantum Volume circuits instead of creating new ones. However, the parameters were never actually respected and a new Register would always be created regardless of whether they were set or not. This behavior is unchanged and these kwargs still do not have any effect, but are being deprecated prior to removal to avoid a breaking change for users who may have been setting either.

*   Support for passing in subsets of qubits as a list in the `qubit_lists` parameter for the `qiskit.ignis.verification.qv_circuits()` function has been deprecated and will removed in a future release. In the past this was used to specify a layout to run the circuit on a device. In other words if you had a 5 qubit device and wanted to run a 2 qubit QV circuit on qubits 1, 3, and 4 of that device. You would pass in `[1, 3, 4]` as one of the lists in `qubit_lists`, which would generate a 5 qubit virtual circuit and have qv applied to qubits 1, 3, and 4 in that virtual circuit. However, this functionality is not necessary and overlaps with the concept of `initial_layout` in the transpiler and whether a circuit has been embedded with a layout set. Moving forward instead you should just run [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or `execute()` with initial layout set to do this. For example, running the above example would become:

    ```python
    from qiskit import execute
    from qiskit.ignis.verification import qv_circuits

    initial_layout = [1, 3, 4]
    qv_circs, _ = qv_circuits([list(range3)])
    execute(qv_circuits, initial_layout=initial_layout)
    ```

<span id="release-notes-0-4-0-bug-fixes" />

<span id="id432" />

#### Bug Fixes

*   Fix a bug of the position of measurement pulses inserted by py:func:qiskit.ignis.characterization.calibrations.pulse\_schedules.drag\_schedules. Fixes [#465](https://github.com/Qiskit/qiskit-ignis/issues/465)

<span id="id433" />

### Aqua 0.7.5

<span id="release-notes-0-7-5-new-features" />

<span id="id434" />

#### New Features

*   Removed soft dependency on CPLEX in ADMMOptimizer. Now default optimizers used by ADMMOptimizer are MinimumEigenOptimizer for QUBO problems and SlsqpOptimizer as a continuous optimizer. You can still use CplexOptimizer as an optimizer for ADMMOptimizer, but it should be set explicitly.
*   New Yahoo! finance provider created.
*   Introduced `QuadraticProgramConverter` which is an abstract class for converters. Added `convert`/`interpret` methods for converters instead of `encode`/`decode`. Added `to_ising` and `from_ising` to `QuadraticProgram` class. Moved all parameters from `convert` to constructor except `name`. Created setter/getter for converter parameters. Added `auto_define_penalty` and `interpret` for\`\`LinearEqualityToPenalty\`\`. Now error messages of converters are more informative.
*   Added an SLSQP optimizer `qiskit.optimization.algorithms.SlsqpOptimizer` as a wrapper of the corresponding SciPy optimization method. This is a classical optimizer, does not depend on quantum algorithms and may be used as a replacement for `CobylaOptimizer`.
*   Cobyla optimizer has been modified to accommodate a multi start feature introduced in the SLSQP optimizer. By default, the optimizer does not run in the multi start mode.
*   The `SummedOp` does a mathematically more correct check for equality, where expressions such as `X + X == 2*X` and `X + Z == Z + X` evaluate to `True`.

<span id="release-notes-0-7-5-deprecation-notes" />

<span id="id435" />

#### Deprecation Notes

*   GSLS optimizer class deprecated `__init__` parameter `max_iter` in favor of `maxiter`. SPSA optimizer class deprecated `__init__` parameter `max_trials` in favor of `maxiter`. optimize\_svm function deprecated `max_iters` parameter in favor of `maxiter`. ADMMParameters class deprecated `__init__` parameter `max_iter` in favor of `maxiter`.
*   The ising convert classes `qiskit.optimization.converters.QuadraticProgramToIsing` and `qiskit.optimization.converters.IsingToQuadraticProgram` have been deprecated and will be removed in a future release. Instead the `qiskit.optimization.QuadraticProgram` methods `to_ising()` and `from_ising()` should be used instead.
*   The `pprint_as_string` method for `qiskit.optimization.QuadraticProgram` has been deprecated and will be removed in a future release. Instead you should just run `.pprint_as_string()` on the output from `to_docplex()`
*   The `prettyprint` method for `qiskit.optimization.QuadraticProgram` has been deprecated and will be removed in a future release. Instead you should just run `.prettyprint()` on the output from `to_docplex()`

<span id="release-notes-0-7-5-bug-fixes" />

<span id="id436" />

#### Bug Fixes

*   Changed in python version 3.8: On macOS, the spawn start method is now the default. The fork start method should be considered unsafe as it can lead to crashes in subprocesses. However P\_BFGS doesn’t support spawn, so we revert to single process. Refer to #1109 \<[https://github.com/Qiskit/qiskit-aqua/issues/1109](https://github.com/Qiskit/qiskit-aqua/issues/1109)> for more details.
*   Binding parameters in the `CircuitStateFn` did not copy the value of `is_measurement` and always set `is_measurement=False`. This has been fixed.
*   Previously, SummedOp.to\_matrix\_op built a list MatrixOp’s (with numpy matrices) and then summed them, returning a single MatrixOp. Some algorithms (for example vqe) require summing thousands of matrices, which exhausts memory when building the list of matrices. With this change, no list is constructed. Rather, each operand in the sum is converted to a matrix, added to an accumulator, and discarded.
*   Changing backends in VQE from statevector to qasm\_simulator or real device was causing an error due to CircuitSampler incompatible reuse. VQE was changed to always create a new CircuitSampler and create a new expectation in case not entered by user. Refer to #1153 \<[https://github.com/Qiskit/qiskit-aqua/issues/1153](https://github.com/Qiskit/qiskit-aqua/issues/1153)> for more details.
*   Exchange and Wikipedia finance providers were fixed to correctly handle Quandl data. Refer to #775 \<[https://github.com/Qiskit/qiskit-aqua/issues/775](https://github.com/Qiskit/qiskit-aqua/issues/775)> for more details. Fixes a divide by 0 error on finance providers mean vector and covariance matrix calculations. Refer to #781 \<[https://github.com/Qiskit/qiskit-aqua/issues/781](https://github.com/Qiskit/qiskit-aqua/issues/781)> for more details.
*   The `ListOp.combo_fn` property has been lost in several transformations, such as converting to another operator type, traversing, reducing or multiplication. Now this attribute is propagated to the resulting operator.
*   The evaluation of some operator expressions, such as of `SummedOp``s and evaluations with the ``CircuitSampler` did not treat coefficients correctly or ignored them completely. E.g. evaluating `~StateFn(0 * (I + Z)) @ Plus` did not yield 0 or the normalization of `~StateFn(I) @ ((Plus + Minus) / sqrt(2))` missed a factor of `sqrt(2)`. This has been fixed.
*   `OptimizationResult` included some public setters and class variables were `Optional`. This fix makes all class variables read-only so that mypy and pylint can check types more effectively. `MinimumEigenOptimizer.solve` generated bitstrings in a result as `str`. This fix changed the result into `List[float]` as the other algorithms do. Some public classes related to optimization algorithms were missing in the documentation of `qiskit.optimization.algorithms`. This fix added all such classes to the docstring. #1131 \<[https://github.com/Qiskit/qiskit-aqua/issues/1131](https://github.com/Qiskit/qiskit-aqua/issues/1131)> for more details.
*   `OptimizationResult.__init__` did not check whether the sizes of `x` and `variables` match or not (they should match). This fix added the check to raise an error if they do not match and fixes bugs detected by the check. This fix also adds missing unit tests related to `OptimizationResult.variable_names` and `OptimizationResult.variables_dict` in `test_converters`. #1167 \<[https://github.com/Qiskit/qiskit-aqua/issues/1167](https://github.com/Qiskit/qiskit-aqua/issues/1167)> for more details.
*   Fix parameter binding in the `OperatorStateFn`, which did not bind parameters of the underlying primitive but just the coefficients.
*   `op.eval(other)`, where `op` is of type `OperatorBase`, sometimes silently returns a nonsensical value when the number of qubits in `op` and `other` are not equal. This fix results in correct behavior, which is to throw an error rather than return a value, because the input in this case is invalid.
*   The `construct_circuit` method of `VQE` previously returned the expectation value to be evaluated as type `OperatorBase`. This functionality has been moved into `construct_expectation` and `construct_circuit` returns a list of the circuits that are evaluated to compute the expectation value.

<span id="id437" />

### IBM Q Provider 0.8.0

<span id="release-notes-0-8-0-new-features" />

<span id="id438" />

#### New Features

*   `IBMQBackend` now has a new `reservations()` method that returns reservation information for the backend, with optional filtering. In addition, you can now use `provider.backends.my_reservations()` to query for your own reservations.
*   `qiskit.providers.ibmq.job.IBMQJob.result()` raises an `IBMQJobFailureError` exception if the job has failed. The exception message now contains the reason the job failed, if the entire job failed for a single reason.
*   A new attribute `client_version` was added to `IBMQJob` and [`qiskit.result.Result`](qiskit.result.Result "qiskit.result.Result") object retrieved via `qiskit.providers.ibmq.job.IBMQJob.result()`. `client_version` is a dictionary with the key being the name and the value being the version of the client used to submit the job, such as Qiskit.
*   The `least_busy()` function now takes a new, optional parameter `reservation_lookahead`. If specified or defaulted to, a backend is considered unavailable if it has reservations in the next `n` minutes, where `n` is the value of `reservation_lookahead`. For example, if the default value of 60 is used, then any backends that have reservations in the next 60 minutes are considered unavailable.
*   `ManagedResults` now has a new `combine_results()` method that combines results from all managed jobs and returns a single [`Result`](qiskit.result.Result "qiskit.result.Result") object. This `Result` object can be used, for example, in `qiskit-ignis` fitter methods.

<span id="release-notes-0-8-0-upgrade-notes" />

<span id="id439" />

#### Upgrade Notes

*   Timestamps in the following fields are now in local time instead of UTC:

    *   Backend properties returned by `qiskit.providers.ibmq.IBMQBackend.properties()`.
    *   Backend properties returned by `qiskit.providers.ibmq.job.IBMQJob.properties()`.
    *   `estimated_start_time` and `estimated_complete_time` in `QueueInfo`, returned by `qiskit.providers.ibmq.job.IBMQJob.queue_info()`.
    *   `date` in [`Result`](qiskit.result.Result "qiskit.result.Result"), returned by `qiskit.providers.ibmq.job.IBMQJob.result()`.

    In addition, the `datetime` parameter for `qiskit.providers.ibmq.IBMQBackend.properties()` is also expected to be in local time unless it has UTC timezone information.

*   `websockets` 8.0 or above is now required if Python 3.7 or above is used. `websockets` 7.0 will continue to be used for Python 3.6 or below.

*   On Windows, the event loop policy is set to `WindowsSelectorEventLoopPolicy` instead of using the default `WindowsProactorEventLoopPolicy`. This fixes the issue that the `qiskit.providers.ibmq.job.IBMQJob.result()` method could hang on Windows. Fixes [#691](https://github.com/Qiskit/qiskit-ibmq-provider/issues/691)

<span id="release-notes-0-8-0-deprecation-notes" />

<span id="id441" />

#### Deprecation Notes

*   Use of `Qconfig.py` to save IBM Quantum Experience credentials is deprecated and will be removed in the next release. You should use `qiskitrc` (the default) instead.

<span id="release-notes-0-8-0-bug-fixes" />

<span id="id442" />

#### Bug Fixes

*   Fixes an issue wherein a call to `qiskit.providers.ibmq.IBMQBackend.jobs()` can hang if the number of jobs being returned is large. Fixes [#674](https://github.com/Qiskit/qiskit-ibmq-provider/issues/674)
*   Fixes an issue which would raise a `ValueError` when building error maps in Jupyter for backends that are offline. Fixes [#706](https://github.com/Qiskit/qiskit-ibmq-provider/issues/706)
*   `qiskit.providers.ibmq.IBMQBackend.jobs()` will now return the correct list of `IBMQJob` objects when the `status` kwarg is set to `'RUNNING'`.
*   The package metadata has been updated to properly reflect the dependency on `qiskit-terra` >= 0.14.0. This dependency was implicitly added as part of the 0.7.0 release but was not reflected in the package requirements so it was previously possible to install `qiskit-ibmq-provider` with a version of `qiskit-terra` which was too old. Fixes [#677](https://github.com/Qiskit/qiskit-ibmq-provider/issues/677)

<span id="qiskit-0-19-6" />

## Qiskit 0.19.6

<span id="terra-0-14-2" />

### Terra 0.14.2

No Change

<span id="aer-0-5-2" />

### Aer 0.5.2

No Change

<span id="ignis-0-3-3" />

### Ignis 0.3.3

<span id="release-notes-0-3-3-upgrade-notes" />

<span id="id446" />

#### Upgrade Notes

*   A new requirement [scikit-learn](https://scikit-learn.org/stable/) has been added to the requirements list. This dependency was added in the 0.3.0 release but wasn’t properly exposed as a dependency in that release. This would lead to an `ImportError` if the `qiskit.ignis.measurement.discriminator.iq_discriminators` module was imported. This is now correctly listed as a dependency so that `scikit-learn` will be installed with qiskit-ignis.

<span id="release-notes-0-3-3-bug-fixes" />

<span id="id447" />

#### Bug Fixes

*   Fixes an issue in qiskit-ignis 0.3.2 which would raise an `ImportError` when `qiskit.ignis.verification.tomography.fitters.process_fitter` was imported without `cvxpy` being installed.

<span id="aqua-0-7-3" />

### Aqua 0.7.3

No Change

<span id="ibm-q-provider-0-7-2" />

### IBM Q Provider 0.7.2

No Change

<span id="qiskit-0-19-5" />

## Qiskit 0.19.5

<span id="id448" />

### Terra 0.14.2

No Change

<span id="id449" />

### Aer 0.5.2

No Change

<span id="ignis-0-3-2" />

### Ignis 0.3.2

<span id="id450" />

#### Bug Fixes

*   The `qiskit.ignis.verification.TomographyFitter.fit()` method has improved detection logic for the default fitter. Previously, the `cvx` fitter method was used whenever [cvxpy](https://www.cvxpy.org/) was installed. However, it was possible to install cvxpy without an SDP solver that would work for the `cvx` fitter method. This logic has been reworked so that the `cvx` fitter method is only used if `cvxpy` is installed and an SDP solver is present that can be used. Otherwise, the `lstsq` fitter is used.
*   Fixes an edge case in `qiskit.ignis.mitigation.measurement.fitters.MeasurementFitter.apply()` for input that has invalid or incorrect state labels that don’t match the calibration circuit. Previously, this would not error and just return an empty result. Instead now this case is correctly caught and a `QiskitError` exception is raised when using incorrect labels.

<span id="id451" />

### Aqua 0.7.3

<span id="release-notes-0-7-3-upgrade-notes" />

<span id="id452" />

#### Upgrade Notes

*   The [cvxpy](https://www.cvxpy.org/) dependency which is required for the svm classifier has been removed from the requirements list and made an optional dependency. This is because installing cvxpy is not seamless in every environment and often requires a compiler be installed to run. To use the svm classifier now you’ll need to install cvxpy by either running `pip install cvxpy<1.1.0` or to install it with aqua running `pip install qiskit-aqua[cvx]`.

<span id="release-notes-0-7-3-bug-fixes" />

<span id="id453" />

#### Bug Fixes

*   The `compose` method of the `CircuitOp` used `QuantumCircuit.combine` which has been changed to use `QuantumCircuit.compose`. Using combine leads to the problem that composing an operator with a `CircuitOp` based on a named register does not chain the operators but stacks them. E.g. composing `Z ^ 2` with a circuit based on a 2-qubit named register yielded a 4-qubit operator instead of a 2-qubit operator.
*   The `MatrixOp.to_instruction` method previously returned an operator and not an instruction. This method has been updated to return an Instruction. Note that this only works if the operator primitive is unitary, otherwise an error is raised upon the construction of the instruction.
*   The `__hash__` method of the `PauliOp` class used the `id()` method which prevents set comparisons to work as expected since they rely on hash tables and identical objects used to not have identical hashes. Now, the implementation uses a hash of the string representation inline with the implementation in the `Pauli` class.

<span id="id454" />

### IBM Q Provider 0.7.2

No Change

<span id="qiskit-0-19-4" />

## Qiskit 0.19.4

<span id="id455" />

### Terra 0.14.2

<span id="release-notes-0-14-2-upgrade-notes" />

<span id="id456" />

#### Upgrade Notes

*   The `circuit_to_gate` and `circuit_to_instruction` converters had previously automatically included the generated gate or instruction in the active `SessionEquivalenceLibrary`. These converters now accept an optional `equivalence_library` keyword argument to specify if and where the converted instances should be registered. The default behavior is not to register the converted instance.

<span id="release-notes-0-14-2-bug-fixes" />

<span id="id457" />

#### Bug Fixes

*   Implementations of the multi-controlled X Gate (`MCXGrayCode`, `MCXRecursive` and `MCXVChain`) have had their `name` properties changed to more accurately describe their implementation (`mcx_gray`, `mcx_recursive`, and `mcx_vchain` respectively.) Previously, these gates shared the name ```mcx` with ``MCXGate```, which caused these gates to be incorrectly transpiled and simulated.
*   `ControlledGate` instances with a set `ctrl_state` were in some cases not being evaluated as equal, even if the compared gates were equivalent. This has been resolved.
*   Fixed the SI unit conversion for `qiskit.pulse.SetFrequency`. The `SetFrequency` instruction should be in Hz on the frontend and has to be converted to GHz when `SetFrequency` is converted to `PulseQobjInstruction`.
*   Open controls were implemented by modifying a gate's definition. However, when the gate already exists in the basis, this definition is not used, which yields incorrect circuits sent to a backend. This modifies the unroller to output the definition if it encounters a controlled gate with open controls.

<span id="id458" />

### Aer 0.5.2

No Change

<span id="ignis-0-3-0" />

### Ignis 0.3.0

No Change

<span id="aqua-0-7-2" />

### Aqua 0.7.2

<span id="id459" />

#### Prelude

VQE expectation computation with Aer qasm\_simulator now defaults to a computation that has the expected shot noise behavior.

<span id="id460" />

#### Upgrade Notes

*   [cvxpy](https://github.com/cvxgrp/cvxpy/) is now in the requirements list as a dependency for qiskit-aqua. It is used for the quadratic program solver which is used as part of the `qiskit.aqua.algorithms.QSVM`. Previously `cvxopt` was an optional dependency that needed to be installed to use this functionality. This is no longer required as cvxpy will be installed with qiskit-aqua.
*   For state tomography run as part of `qiskit.aqua.algorithms.HHL` with a QASM backend the tomography fitter function `qiskit.ignis.verification.StateTomographyFitter.fit()` now gets called explicitly with the method set to `lstsq` to always use the least-squares fitting. Previously it would opportunistically try to use the `cvx` fitter if `cvxpy` were installed. But, the `cvx` fitter depends on a specifically configured `cvxpy` installation with an SDP solver installed as part of `cvxpy` which is not always present in an environment with `cvxpy` installed.
*   The VQE expectation computation using qiskit-aer’s `qiskit.providers.aer.extensions.SnapshotExpectationValue` instruction is not enabled by default anymore. This was changed to be the default in 0.7.0 because it is significantly faster, but it led to unexpected ideal results without shot noise (see [#1013](https://github.com/Qiskit/qiskit-aqua/issues/1013) for more details). The default has now changed back to match user expectations. Using the faster expectation computation is now opt-in by setting the new `include_custom` kwarg to `True` on the `qiskit.aqua.algorithms.VQE` constructor.

<span id="id462" />

#### New Features

*   A new kwarg `include_custom` has been added to the constructor for `qiskit.aqua.algorithms.VQE` and it’s subclasses (mainly `qiskit.aqua.algorithms.QAOA`). When set to true and the `expectation` kwarg is set to `None` (the default) this will enable the use of VQE expectation computation with Aer’s `qasm_simulator` `qiskit.providers.aer.extensions.SnapshotExpectationValue` instruction. The special Aer snapshot based computation is much faster but with the ideal output similar to state vector simulator.

<span id="id463" />

### IBM Q Provider 0.7.2

No Change

<span id="qiskit-0-19-3" />

## Qiskit 0.19.3

<span id="terra-0-14-1" />

### Terra 0.14.1

No Change

<span id="id464" />

### Aer 0.5.2

<span id="id465" />

#### Bug Fixes

*   Fixed bug with statevector and unitary simulators running a number of (parallel) shots equal to the number of CPU threads instead of only running a single shot.
*   Fixes the “diagonal” qobj gate instructions being applied incorrectly in the density matrix Qasm Simulator method.
*   Fixes bug where conditional gates were not being applied correctly on the density matrix simulation method.
*   Fix bug in CZ gate and Z gate for “density\_matrix\_gpu” and “density\_matrix\_thrust” QasmSimulator methods.
*   Fixes issue where memory requirements of simulation were not being checked on the QasmSimulator when using a non-automatic simulation method.
*   Fixed a memory leak that effected the GPU simulator methods

<span id="id466" />

### Ignis 0.3.0

No Change

<span id="aqua-0-7-1" />

### Aqua 0.7.1

No Change

<span id="id467" />

### IBM Q Provider 0.7.2

<span id="id468" />

#### Bug Fixes

*   `qiskit.provider.ibmq.IBMQBackend.jobs()` will now return the correct list of `IBMQJob` objects when the `status` kwarg is set to `'RUNNING'`. Fixes [#523](https://github.com/Qiskit/qiskit-ibmq-provider/issues/523)
*   The package metadata has been updated to properly reflect the dependency on `qiskit-terra` >= 0.14.0. This dependency was implicitly added as part of the 0.7.0 release but was not reflected in the package requirements so it was previously possible to install `qiskit-ibmq-provider` with a version of `qiskit-terra` which was too old. Fixes [#677](https://github.com/Qiskit/qiskit-ibmq-provider/issues/677)

<span id="qiskit-0-19-0" />

## Qiskit 0.19.0

<span id="terra-0-14-0" />

### Terra 0.14.0

<span id="release-notes-0-14-0-prelude" />

<span id="id471" />

#### Prelude

The 0.14.0 release includes several new features and bug fixes. The biggest change for this release is the introduction of a quantum circuit library in [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library"), containing some circuit families of interest.

The circuit library gives users access to a rich set of well-studied circuit families, instances of which can be used as benchmarks, as building blocks in building more complex circuits, or as a tool to explore quantum computational advantage over classical. The contents of this library will continue to grow and mature.

The initial release of the circuit library contains:

*   `standard_gates`: these are fixed-width gates commonly used as primitive building blocks, consisting of 1, 2, and 3 qubit gates. For example the [`XGate`](qiskit.circuit.library.XGate "qiskit.circuit.library.XGate"), [`RZZGate`](qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate") and `CSWAPGate`. The old location of these gates under `qiskit.extensions.standard` is deprecated.
*   `generalized_gates`: these are families that can generalize to arbitrarily many qubits, for example a [`Permutation`](qiskit.circuit.library.Permutation "qiskit.circuit.library.Permutation") or [`GMS`](qiskit.circuit.library.GMS "qiskit.circuit.library.GMS") (Global Molmer-Sorensen gate).
*   `boolean_logic`: circuits that transform basis states according to simple Boolean logic functions, such as `ADD` or [`XOR`](qiskit.circuit.library.XOR "qiskit.circuit.library.XOR").
*   `arithmetic`: a set of circuits for doing classical arithmetic such as [`WeightedAdder`](qiskit.circuit.library.WeightedAdder "qiskit.circuit.library.WeightedAdder") and [`IntegerComparator`](qiskit.circuit.library.IntegerComparator "qiskit.circuit.library.IntegerComparator").
*   `basis_changes`: circuits such as the quantum Fourier transform, [`QFT`](qiskit.circuit.library.QFT "qiskit.circuit.library.QFT"), that mathematically apply basis changes.
*   `n_local`: patterns to easily create large circuits with rotation and entanglement layers, such as [`TwoLocal`](qiskit.circuit.library.TwoLocal "qiskit.circuit.library.TwoLocal") which uses single-qubit rotations and two-qubit entanglements.
*   `data_preparation`: circuits that take classical input data and encode it in a quantum state that is difficult to simulate, e.g. [`PauliFeatureMap`](qiskit.circuit.library.PauliFeatureMap "qiskit.circuit.library.PauliFeatureMap") or [`ZZFeatureMap`](qiskit.circuit.library.ZZFeatureMap "qiskit.circuit.library.ZZFeatureMap").
*   Other circuits that have proven interesting in the literature, such as [`QuantumVolume`](qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume"), [`GraphState`](qiskit.circuit.library.GraphState "qiskit.circuit.library.GraphState"), or [`IQP`](qiskit.circuit.library.IQP "qiskit.circuit.library.IQP").

To allow easier use of these circuits as building blocks, we have introduced a [`compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") method of [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") for composition of circuits either with other circuits (by welding them at the ends and optionally permuting wires) or with other simpler gates:

```python
>>> lhs.compose(rhs, qubits=[3, 2], inplace=True)
```

```python
            ┌───┐                   ┌─────┐                ┌───┐
lqr_1_0: ───┤ H ├───    rqr_0: ──■──┤ Tdg ├    lqr_1_0: ───┤ H ├───────────────
            ├───┤              ┌─┴─┐└─────┘                ├───┤
lqr_1_1: ───┤ X ├───    rqr_1: ┤ X ├───────    lqr_1_1: ───┤ X ├───────────────
         ┌──┴───┴──┐           └───┘                    ┌──┴───┴──┐┌───┐
lqr_1_2: ┤ U1(0.1) ├  +                     =  lqr_1_2: ┤ U1(0.1) ├┤ X ├───────
         └─────────┘                                    └─────────┘└─┬─┘┌─────┐
lqr_2_0: ─────■─────                           lqr_2_0: ─────■───────■──┤ Tdg ├
            ┌─┴─┐                                          ┌─┴─┐        └─────┘
lqr_2_1: ───┤ X ├───                           lqr_2_1: ───┤ X ├───────────────
            └───┘                                          └───┘
lcr_0: 0 ═══════════                           lcr_0: 0 ═══════════════════════
lcr_1: 0 ═══════════                           lcr_1: 0 ═══════════════════════
```

With this, Qiskit’s circuits no longer assume an implicit initial state of $|0\rangle$, and will not be drawn with this initial state. The all-zero initial state is still assumed on a backend when a circuit is executed.

<span id="release-notes-0-14-0-new-features" />

<span id="id472" />

#### New Features

*   A new method, [`has_entry()`](qiskit.circuit.EquivalenceLibrary#has_entry "qiskit.circuit.EquivalenceLibrary.has_entry"), has been added to the [`qiskit.circuit.EquivalenceLibrary`](qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") class to quickly check if a given gate has any known decompositions in the library.

*   A new class [`IQP`](qiskit.circuit.library.IQP "qiskit.circuit.library.IQP"), to construct an instantaneous quantum polynomial circuit, has been added to the circuit library module [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library").

*   A new [`compose()`](qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") method has been added to [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). It allows composition of two quantum circuits without having to turn one into a gate or instruction. It also allows permutations of qubits/clbits at the point of composition, as well as optional inplace modification. It can also be used in place of [`append()`](qiskit.circuit.QuantumCircuit#append "qiskit.circuit.QuantumCircuit.append"), as it allows composing instructions and operators onto the circuit as well.

*   [`qiskit.circuit.library.Diagonal`](qiskit.circuit.library.Diagonal "qiskit.circuit.library.Diagonal") circuits have been added to the circuit library. These circuits implement diagonal quantum operators (consisting of non-zero elements only on the diagonal). They are more efficiently simulated by the Aer simulator than dense matrices.

*   Add [`from_label()`](qiskit.quantum_info.Clifford#from_label "qiskit.quantum_info.Clifford.from_label") method to the [`qiskit.quantum_info.Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") class for initializing as the tensor product of single-qubit I, X, Y, Z, H, or S gates.

*   Schedule transformer `qiskit.pulse.reschedule.compress_pulses()` performs an optimization pass to reduce the usage of waveform memory in hardware by replacing multiple identical instances of a pulse in a pulse schedule with a single pulse. For example:

    ```python
    from qiskit.pulse import reschedule

    schedules = []
    for _ in range(2):
        schedule = Schedule()
        drive_channel = DriveChannel(0)
        schedule += Play(SamplePulse([0.0, 0.1]), drive_channel)
        schedule += Play(SamplePulse([0.0, 0.1]), drive_channel)
        schedules.append(schedule)

    compressed_schedules = reschedule.compress_pulses(schedules)
    ```

*   The [`qiskit.transpiler.Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout") has a new method [`reorder_bits()`](qiskit.transpiler.Layout#reorder_bits "qiskit.transpiler.Layout.reorder_bits") that is used to reorder a list of virtual qubits based on the layout object.

*   Two new methods have been added to the [`qiskit.providers.models.PulseBackendConfiguration`](qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") for interacting with channels.

    *   [`get_channel_qubits()`](qiskit.providers.models.PulseBackendConfiguration#get_channel_qubits "qiskit.providers.models.PulseBackendConfiguration.get_channel_qubits") to get a list of all qubits operated by the given channel and
    *   `get_qubit_channel()` to get a list of channels operating on the given qubit.

*   New `qiskit.extensions.HamiltonianGate` and [`qiskit.circuit.QuantumCircuit.hamiltonian()`](qiskit.circuit.QuantumCircuit#hamiltonian "qiskit.circuit.QuantumCircuit.hamiltonian") methods are introduced, representing Hamiltonian evolution of the circuit wavefunction by a user-specified Hermitian Operator and evolution time. The evolution time can be a [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter"), allowing the creation of parameterized UCCSD or QAOA-style circuits which compile to `UnitaryGate` objects if `time` parameters are provided. The Unitary of a `HamiltonianGate` with Hamiltonian Operator `H` and time parameter `t` is $e^{-iHt}$.

*   The circuit library module [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") now provides a new boolean logic AND circuit, [`qiskit.circuit.library.AND`](qiskit.circuit.library.AND "qiskit.circuit.library.AND"), and OR circuit, [`qiskit.circuit.library.OR`](qiskit.circuit.library.OR "qiskit.circuit.library.OR"), which implement the respective operations on a variable number of provided qubits.

*   New fake backends are added under `qiskit.test.mock`. These include mocked versions of `ibmq_armonk`, `ibmq_essex`, `ibmq_london`, `ibmq_valencia`, `ibmq_cambridge`, `ibmq_paris`, `ibmq_rome`, and `ibmq_athens`. As with other fake backends, these include snapshots of calibration data (i.e. `backend.defaults()`) and error data (i.e. `backend.properties()`) taken from the real system, and can be used for local testing, compilation and simulation.

*   The `last_update_date` parameter for [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") can now also be passed in as a `datetime` object. Previously only a string in ISO8601 format was accepted.

*   Adds [`qiskit.quantum_info.Statevector.from_int()`](qiskit.quantum_info.Statevector#from_int "qiskit.quantum_info.Statevector.from_int") and [`qiskit.quantum_info.DensityMatrix.from_int()`](qiskit.quantum_info.DensityMatrix#from_int "qiskit.quantum_info.DensityMatrix.from_int") methods that allow constructing a computational basis state for specified system dimensions.

*   The methods on the [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class for adding gates (for example [`h()`](qiskit.circuit.QuantumCircuit#h "qiskit.circuit.QuantumCircuit.h")) which were previously added dynamically at run time to the class definition have been refactored to be statically defined methods of the class. This means that static analyzer (such as IDEs) can now read these methods.

<span id="release-notes-0-14-0-upgrade-notes" />

<span id="id473" />

#### Upgrade Notes

*   A new package, [python-dateutil](https://pypi.org/project/python-dateutil/), is now required and has been added to the requirements list. It is being used to parse datetime strings received from external providers in [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") objects.

*   The marshmallow schema classes in [`qiskit.providers.models`](providers_models#module-qiskit.providers.models "qiskit.providers.models") have been removed since they are no longer used by the BackendObjects.

*   The output of the `to_dict()` method for the classes in [`qiskit.providers.models`](providers_models#module-qiskit.providers.models "qiskit.providers.models") is no longer in a format for direct JSON serialization. Depending on the content contained in instances of these class there may be numpy arrays and/or complex numbers in the fields of the dict. If you’re JSON serializing the output of the to\_dict methods you should ensure your JSON encoder can handle numpy arrays and complex numbers. This includes:

    *   [`qiskit.providers.models.BackendConfiguration.to_dict()`](qiskit.providers.models.BackendConfiguration#to_dict "qiskit.providers.models.BackendConfiguration.to_dict")
    *   [`qiskit.providers.models.BackendProperties.to_dict()`](qiskit.providers.models.BackendProperties#to_dict "qiskit.providers.models.BackendProperties.to_dict")
    *   [`qiskit.providers.models.BackendStatus.to_dict()`](qiskit.providers.models.BackendStatus#to_dict "qiskit.providers.models.BackendStatus.to_dict")
    *   [`qiskit.providers.models.QasmBackendConfiguration.to_dict()`](qiskit.providers.models.QasmBackendConfiguration#to_dict "qiskit.providers.models.QasmBackendConfiguration.to_dict")
    *   [`qiskit.providers.models.PulseBackendConfiguration.to_dict()`](qiskit.providers.models.PulseBackendConfiguration#to_dict "qiskit.providers.models.PulseBackendConfiguration.to_dict")
    *   [`qiskit.providers.models.UchannelLO.to_dict()`](qiskit.providers.models.UchannelLO#to_dict "qiskit.providers.models.UchannelLO.to_dict")
    *   [`qiskit.providers.models.GateConfig.to_dict()`](qiskit.providers.models.GateConfig#to_dict "qiskit.providers.models.GateConfig.to_dict")
    *   [`qiskit.providers.models.PulseDefaults.to_dict()`](qiskit.providers.models.PulseDefaults#to_dict "qiskit.providers.models.PulseDefaults.to_dict")
    *   [`qiskit.providers.models.Command.to_dict()`](qiskit.providers.models.Command#to_dict "qiskit.providers.models.Command.to_dict")
    *   [`qiskit.providers.models.JobStatus.to_dict()`](qiskit.providers.models.JobStatus#to_dict "qiskit.providers.models.JobStatus.to_dict")
    *   [`qiskit.providers.models.Nduv.to_dict()`](qiskit.providers.models.Nduv#to_dict "qiskit.providers.models.Nduv.to_dict")
    *   `qiskit.providers.models.Gate.to_dict()`

<span id="release-notes-0-14-0-deprecation-notes" />

<span id="id474" />

#### Deprecation Notes

*   The [`qiskit.dagcircuit.DAGCircuit.compose()`](qiskit.dagcircuit.DAGCircuit#compose "qiskit.dagcircuit.DAGCircuit.compose") method now takes a list of qubits/clbits that specify the positional order of bits to compose onto. The dictionary-based method of mapping using the `edge_map` argument is deprecated and will be removed in a future release.

*   The `combine_into_edge_map()` method for the [`qiskit.transpiler.Layout`](qiskit.transpiler.Layout "qiskit.transpiler.Layout") class has been deprecated and will be removed in a future release. Instead, the new method [`reorder_bits()`](qiskit.transpiler.Layout#reorder_bits "qiskit.transpiler.Layout.reorder_bits") should be used to reorder a list of virtual qubits according to the layout object.

*   Passing a `qiskit.pulse.ControlChannel` object in via the parameter `channel` for the [`qiskit.providers.models.PulseBackendConfiguration`](qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") method [`control()`](qiskit.providers.models.PulseBackendConfiguration#control "qiskit.providers.models.PulseBackendConfiguration.control") has been deprecated and will be removed in a future release. The `ControlChannel` objects are now generated from the backend configuration `channels` attribute which has the information of all channels and the qubits they operate on. Now, the method [`control()`](qiskit.providers.models.PulseBackendConfiguration#control "qiskit.providers.models.PulseBackendConfiguration.control") is expected to take the parameter `qubits` of the form `(control_qubit, target_qubit)` and type `list` or `tuple`, and returns a list of control channels.

*   The `AND` and `OR` methods of [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") are deprecated and will be removed in a future release. Instead you should use the circuit library boolean logic classes [`qiskit.circuit.library.AND`](qiskit.circuit.library.AND "qiskit.circuit.library.AND") amd [`qiskit.circuit.library.OR`](qiskit.circuit.library.OR "qiskit.circuit.library.OR") and then append those objects to your class. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.circuit.library import AND

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)

    qc_and = AND(2)

    qc.compose(qc_and, inplace=True)
    ```

*   The `qiskit.extensions.standard` module is deprecated and will be removed in a future release. The gate classes in that module have been moved to `qiskit.circuit.library.standard_gates`.

<span id="release-notes-0-14-0-bug-fixes" />

<span id="id475" />

#### Bug Fixes

*   The [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods [`inverse()`](qiskit.circuit.QuantumCircuit#inverse "qiskit.circuit.QuantumCircuit.inverse"), `mirror()` methods, as well as the `QuantumCircuit.data` setter would generate an invalid circuit when used on a parameterized circuit instance. This has been resolved and these methods should now work with a parameterized circuit. Fixes [#4235](https://github.com/Qiskit/qiskit-terra/issues/4235)

*   Previously when creating a controlled version of a standard qiskit gate if a `ctrl_state` was specified a generic `ControlledGate` object would be returned whereas without it a standard qiskit controlled gate would be returned if it was defined. This PR allows standard qiskit controlled gates to understand `ctrl_state`.

    Additionally, this PR fixes what might be considered a bug where setting the `ctrl_state` of an already controlled gate would assume the specified state applied to the full control width instead of the control qubits being added. For instance,:

    ```python
    circ = QuantumCircuit(2)
    circ.h(0)
    circ.x(1)
    gate = circ.to_gate()
    cgate = gate.control(1)
    c3gate = cgate.control(2, ctrl_state=0)
    ```

    would apply `ctrl_state` to all three control qubits instead of just the two control qubits being added.

*   Fixed a bug in [`random_clifford()`](quantum_info#qiskit.quantum_info.random_clifford "qiskit.quantum_info.random_clifford") that stopped it from sampling the full Clifford group. Fixes [#4271](https://github.com/Qiskit/qiskit-terra/issues/4271)

*   The [`qiskit.circuit.Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") method [`qiskit.circuit.Instruction.is_parameterized()`](qiskit.circuit.Instruction#is_parameterized "qiskit.circuit.Instruction.is_parameterized") method had previously returned `True` for any `Instruction` instance which had a [`qiskit.circuit.Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") in any element of its `params` array, even if that `Parameter` had been fully bound. This has been corrected so that `.is_parameterized` will return `False` when the instruction is fully bound.

*   [`qiskit.circuit.ParameterExpression.subs()`](qiskit.circuit.ParameterExpression#subs "qiskit.circuit.ParameterExpression.subs") had not correctly detected some cases where substituting parameters would result in a two distinct `Parameters` objects in an expression with the same name. This has been corrected so a `CircuitError` will be raised in these cases.

*   Improve performance of [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") for low-qubit circuit simulations by optimizing the class `__init__` methods. Fixes [#4281](https://github.com/Qiskit/qiskit-terra/issues/4281)

*   The function [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") now correctly handles when the parameter `basis_gates` is set to `None`. This will allow any gate in the output tranpiled circuit, including gates added by the transpilation process. Note that using this parameter may have some unintended consequences during optimization. Some transpiler passes depend on having a `basis_gates` set. For example, [`qiskit.transpiler.passes.Optimize1qGates`](qiskit.transpiler.passes.Optimize1qGates "qiskit.transpiler.passes.Optimize1qGates") only optimizes the chains of u1, u2, and u3 gates and without `basis_gates` it is unable to unroll gates that otherwise could be optimized:

    ```python
    from qiskit import *

    q = QuantumRegister(1, name='q')
    circuit = QuantumCircuit(q)
    circuit.h(q[0])
    circuit.u1(0.1, q[0])
    circuit.u2(0.1, 0.2, q[0])
    circuit.h(q[0])
    circuit.u3(0.1, 0.2, 0.3, q[0])

    result = transpile(circuit, basis_gates=None, optimization_level=3)
    result.draw()
    ```

    ```python
         ┌───┐┌─────────────┐┌───┐┌─────────────────┐
    q_0: ┤ H ├┤ U2(0.1,0.3) ├┤ H ├┤ U3(0.1,0.2,0.3) ├
         └───┘└─────────────┘└───┘└─────────────────┘
    ```

    Fixes [#3017](https://github.com/Qiskit/qiskit-terra/issues/3017)

<span id="release-notes-0-14-0-other-notes" />

<span id="id480" />

#### Other Notes

*   The objects in [`qiskit.providers.models`](providers_models#module-qiskit.providers.models "qiskit.providers.models") which were previously constructed using the marshmallow library have been refactored to not depend on marshmallow. This includes:

    *   [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration")
    *   [`BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties")
    *   [`BackendStatus`](qiskit.providers.models.BackendStatus "qiskit.providers.models.BackendStatus")
    *   [`QasmBackendConfiguration`](qiskit.providers.models.QasmBackendConfiguration "qiskit.providers.models.QasmBackendConfiguration")
    *   [`PulseBackendConfiguration`](qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration")
    *   [`UchannelLO`](qiskit.providers.models.UchannelLO "qiskit.providers.models.UchannelLO")
    *   [`GateConfig`](qiskit.providers.models.GateConfig "qiskit.providers.models.GateConfig")
    *   [`PulseDefaults`](qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults")
    *   [`Command`](qiskit.providers.models.Command "qiskit.providers.models.Command")
    *   [`JobStatus`](qiskit.providers.models.JobStatus "qiskit.providers.models.JobStatus")
    *   [`Nduv`](qiskit.providers.models.Nduv "qiskit.providers.models.Nduv")
    *   `Gate`

    These should be drop-in replacements without any noticeable change but specifics inherited from marshmallow may not work. Please file issues for any incompatibilities found.

<span id="aer-0-5-1" />

### Aer 0.5.1

No Change

<span id="id481" />

### Ignis 0.3.0

No Change

<span id="aqua-0-7-0" />

### Aqua 0.7.0

<span id="id482" />

#### Prelude

The Qiskit Aqua 0.7.0 release introduces a lot of new functionality along with an improved integration with [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects. The central contributions are the Qiskit’s optimization module, a complete refactor on Operators, using circuits as native input for the algorithms and removal of the declarative JSON API.

##### Optimization module

The `` qiskit.optimization` `` module now offers functionality for modeling and solving quadratic programs. It provides various near-term quantum and conventional algorithms, such as the `MinimumEigenOptimizer` (covering e.g. `VQE` or `QAOA`) or `CplexOptimizer`, as well as a set of converters to translate between different problem representations, such as `QuadraticProgramToQubo`. See the [changelog](https://github.com/Qiskit/qiskit-aqua/#migration-guide) for a list of the added features.

##### Operator flow

The operator logic provided in `` qiskit.aqua.operators` `` was completely refactored and is now a full set of tools for constructing physically-intuitive quantum computations. It contains state functions, operators and measurements and internally relies on Terra’s Operator objects. Computing expectation values and evolutions was heavily simplified and objects like the `ExpectationFactory` produce the suitable, most efficient expectation algorithm based on the Operator input type. See the [changelog](https://github.com/Qiskit/qiskit-aqua/#migration-guide) for a overview of the added functionality.

##### Native circuits

Algorithms commonly use parameterized circuits as input, for example the VQE, VQC or QSVM. Previously, these inputs had to be of type `VariationalForm` or `FeatureMap` which were wrapping the circuit object. Now circuits are natively supported in these algorithms, which means any individually constructed `QuantumCircuit` can be passed to these algorithms. In combination with the release of the circuit library which offers a wide collection of circuit families, it is now easy to construct elaborate circuits as algorithm input.

##### Declarative JSON API

The ability of running algorithms using dictionaries as parameters as well as using the Aqua interfaces GUI has been removed.

<span id="ibm-q-provider-0-7-0" />

### IBM Q Provider 0.7.0

<span id="release-notes-0-7-0-new-features" />

<span id="id484" />

#### New Features

*   A new exception, `qiskit.providers.ibmq.IBMQBackendJobLimitError`, is now raised if a job could not be submitted because the limit on active jobs has been reached.
*   `qiskit.providers.ibmq.job.IBMQJob` and `qiskit.providers.ibmq.managed.ManagedJobSet` each has two new methods `update_name` and `update_tags`. They are used to change the name and tags of a job or a job set, respectively.
*   `qiskit.providers.ibmq.IBMQFactory.save_account()` and `qiskit.providers.ibmq.IBMQFactory.enable_account()` now accept optional parameters `hub`, `group`, and `project`, which allow specifying a default provider to save to disk or use, respectively.

<span id="release-notes-0-7-0-upgrade-notes" />

<span id="id485" />

#### Upgrade Notes

*   The `qiskit.providers.ibmq.job.IBMQJob` methods `creation_date` and `time_per_step` now return date time information as a `datetime` object in local time instead of UTC. Similarly, the parameters `start_datetime` and `end_datetime`, of `qiskit.providers.ibmq.IBMQBackendService.jobs()` and `qiskit.providers.ibmq.IBMQBackend.jobs()` can now be specified in local time.
*   The `qiskit.providers.ibmq.job.QueueInfo.format()` method now uses a custom `datetime` to string formatter, and the package [arrow](https://pypi.org/project/arrow/) is no longer required and has been removed from the requirements list.

<span id="release-notes-0-7-0-deprecation-notes" />

<span id="id486" />

#### Deprecation Notes

*   The `from_dict()` and `to_dict()` methods of `qiskit.providers.ibmq.job.IBMQJob` are deprecated and will be removed in the next release.

<span id="release-notes-0-7-0-bug-fixes" />

<span id="id487" />

#### Bug Fixes

*   Fixed an issue where `nest_asyncio.apply()` may raise an exception if there is no asyncio loop due to threading.

<span id="qiskit-0-18-3" />

## Qiskit 0.18.3

<span id="terra-0-13-0" />

### Terra 0.13.0

No Change

<span id="id488" />

### Aer 0.5.1

<span id="release-notes-0-5-1-upgrade-notes" />

<span id="id489" />

#### Upgrade Notes

*   Changes how transpilation passes are handled in the C++ Controller classes so that each pass must be explicitly called. This allows for greater customization on when each pass should be called, and with what parameters. In particular this enables setting different parameters for the gate fusion optimization pass depending on the QasmController simulation method.
*   Add `gate_length_units` kwarg to `qiskit.providers.aer.noise.NoiseModel.from_device()` for specifying custom `gate_lengths` in the device noise model function to handle unit conversions for internal code.
*   Add Controlled-Y (“cy”) gate to the Stabilizer simulator methods supported gateset.
*   For Aer’s backend the jsonschema validation of input qobj objects from terra is now opt-in instead of being enabled by default. If you want to enable jsonschema validation of qobj set the `validate` kwarg on the `qiskit.providers.aer.QasmSimualtor.run()` method for the backend object to `True`.

<span id="release-notes-0-5-1-bug-fixes" />

<span id="id490" />

#### Bug Fixes

*   Remove “extended\_stabilizer” from the automatically selected simulation methods. This is needed as the extended stabilizer method is not exact and may give incorrect results for certain circuits unless the user knows how to optimize its configuration parameters.

    The automatic method now only selects from “stabilizer”, “density\_matrix”, and “statevector” methods. If a non-Clifford circuit that is too large for the statevector method is executed an exception will be raised suggesting you could try explicitly using the “extended\_stabilizer” or “matrix\_product\_state” methods instead.

*   Fixes Controller classes so that the ReduceBarrier transpilation pass is applied first. This prevents barrier instructions from preventing truncation of unused qubits if the only instruction defined on them was a barrier.

*   Disables gate fusion for the matrix product state simulation method as this was causing issues with incorrect results being returned in some cases.

*   Fix error in gate time unit conversion for device noise model with thermal relaxation errors and gate errors. The error probability the depolarizing error was being calculated with gate time in microseconds, while for thermal relaxation it was being calculated in nanoseconds. This resulted in no depolarizing error being applied as the incorrect units would make the device seem to be coherence limited.

*   Fix bug in incorrect composition of QuantumErrors when the qubits of composed instructions differ.

*   Fix issue where the “diagonal” gate is checked to be unitary with too high a tolerance. This was causing diagonals generated from Numpy functions to often fail the test.

*   Fix remove-barrier circuit optimization pass to be applied before qubit trucation. This fixes an issue where barriers inserted by the Terra transpiler across otherwise inactive qubits would prevent them from being truncated.

<span id="id491" />

### Ignis 0.3.0

No Change

<span id="aqua-0-6-6" />

### Aqua 0.6.6

No Change

<span id="ibm-q-provider-0-6-1" />

### IBM Q Provider 0.6.1

No Change

<span id="qiskit-0-18-0" />

## Qiskit 0.18.0

<span id="release-notes-0-13-0" />

<span id="id492" />

### Terra 0.13.0

<span id="release-notes-0-13-0-prelude" />

<span id="id493" />

#### Prelude

The 0.13.0 release includes many big changes. Some highlights for this release are:

For the transpiler we have switched the graph library used to build the [`qiskit.dagcircuit.DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class which is the underlying data structure behind all operations to be based on [retworkx](https://pypi.org/project/retworkx/) for greatly improved performance. Circuit transpilation speed in the 0.13.0 release should be significanlty faster than in previous releases.

There has been a significant simplification to the style in which Pulse instructions are built. Now, `Command` s are deprecated and a unified set of [`Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") s are supported.

The [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module includes several new functions for generating random operators (such as Cliffords and quantum channels) and for computing the diamond norm of quantum channels; upgrades to the [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes to support computing measurement probabilities and sampling measurements; and several new classes are based on the symplectic representation of Pauli matrices. These new classes include Clifford operators ([`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford")), N-qubit matrices that are sparse in the Pauli basis ([`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp")), lists of Pauli’s (`PauliTable`), and lists of stabilizers (`StabilizerTable`).

This release also has vastly improved documentation across Qiskit, including improved documentation for the [`qiskit.circuit`](circuit#module-qiskit.circuit "qiskit.circuit"), [`qiskit.pulse`](pulse#module-qiskit.pulse "qiskit.pulse") and [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") modules.

Additionally, the naming of gate objects and [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods have been updated to be more consistent. This has resulted in several classes and methods being deprecated as things move to a more consistent naming scheme.

For full details on all the changes made in this release see the detailed release notes below.

<span id="release-notes-0-13-0-new-features" />

<span id="id495" />

#### New Features

*   Added a new circuit library module [`qiskit.circuit.library`](circuit_library#module-qiskit.circuit.library "qiskit.circuit.library"). This will be a place for constructors of commonly used circuits that can be used as building blocks for larger circuits or applications.

*   The `qiskit.providers.BaseJob` class has four new methods:

    *   `done()`
    *   `running()`
    *   `cancelled()`
    *   `in_final_state()`

    These methods are used to check wheter a job is in a given job status.

*   Add ability to specify control conditioned on a qubit being in the ground state. The state of the control qubits is represented by an integer. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.extensions.standard import XGate

    qc = QuantumCircuit(4)
    cgate = XGate().control(3, ctrl_state=6)
    qc.append(cgate, [0, 1, 2, 3])
    ```

    Creates a four qubit gate where the fourth qubit gets flipped if the first qubit is in the ground state and the second and third qubits are in the excited state. If `ctrl_state` is `None`, the default, control is conditioned on all control qubits being excited.

*   A new jupyter widget, `%circuit_library_info` has been added to [`qiskit.tools.jupyter`](tools_jupyter#module-qiskit.tools.jupyter "qiskit.tools.jupyter"). This widget is used for visualizing details about circuits built from the circuit library. For example

    ```python
    from qiskit.circuit.library import XOR
    import qiskit.tools.jupyter
    circuit = XOR(5, seed=42)
    %circuit_library_info circuit
    ```

*   A new kwarg option, `formatted` , has been added to [`qiskit.circuit.QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") . When set to `True` the method will print a syntax highlighted version (using pygments) to stdout and return `None` (which differs from the normal behavior of returning the QASM code as a string).

*   A new kwarg option, `filename` , has been added to [`qiskit.circuit.QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm"). When set to a path the method will write the QASM code to that file. It will then continue to output as normal.

*   A new instruction `SetFrequency` which allows users to change the frequency of the `PulseChannel`. This is done in the following way:

    ```python
    from qiskit.pulse import Schedule
    from qiskit.pulse import SetFrequency

    sched = pulse.Schedule()
    sched += SetFrequency(5.5e9, DriveChannel(0))
    ```

    In this example, the frequency of all pulses before the `SetFrequency` command will be the default frequency and all pulses applied to drive channel zero after the `SetFrequency` command will be at 5.5 GHz. Users of `SetFrequency` should keep in mind any hardware limitations.

*   A new method, [`assign_parameters()`](qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") has been added to the [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This method accepts a parameter dictionary with both floats and Parameters objects in a single dictionary. In other words this new method allows you to bind floats, Parameters or both in a single dictionary.

    Also, by using the `inplace` kwarg it can be specified you can optionally modify the original circuit in place. By default this is set to `False` and a copy of the original circuit will be returned from the method.

*   A new method [`num_nonlocal_gates()`](qiskit.circuit.QuantumCircuit#num_nonlocal_gates "qiskit.circuit.QuantumCircuit.num_nonlocal_gates") has been added to the [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This method will return the number of gates in a circuit that involve 2 or or more qubits. These gates are more costly in terms of time and error to implement.

*   The [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`iso()`](qiskit.circuit.QuantumCircuit#iso "qiskit.circuit.QuantumCircuit.iso") for adding an `Isometry` gate to the circuit has a new alias. You can now call [`qiskit.circuit.QuantumCircuit.isometry()`](qiskit.circuit.QuantumCircuit#isometry "qiskit.circuit.QuantumCircuit.isometry") in addition to calling `iso`.

*   A `description` attribute has been added to the [`CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") class for storing a short description for different coupling maps (e.g. full, grid, line, etc.).

*   A new method [`compose()`](qiskit.dagcircuit.DAGCircuit#compose "qiskit.dagcircuit.DAGCircuit.compose") has been added to the [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class for composing two circuits via their DAGs.

    ```python
    dag_left.compose(dag_right, edge_map={right_qubit0: self.left_qubit1,
                                      right_qubit1: self.left_qubit4,
                                      right_clbit0: self.left_clbit1,
                                      right_clbit1: self.left_clbit0})
    ```

    ```python
                ┌───┐                    ┌─────┐┌─┐
    lqr_1_0: ───┤ H ├───     rqr_0: ──■──┤ Tdg ├┤M├
                ├───┤               ┌─┴─┐└─┬─┬─┘└╥┘
    lqr_1_1: ───┤ X ├───     rqr_1: ┤ X ├──┤M├───╫─
             ┌──┴───┴──┐            └───┘  └╥┘   ║
    lqr_1_2: ┤ U1(0.1) ├  +  rcr_0: ════════╬════╩═  =
             └─────────┘                    ║
    lqr_2_0: ─────■─────     rcr_1: ════════╩══════
                ┌─┴─┐
    lqr_2_1: ───┤ X ├───
                └───┘
    lcr_0:   ═══════════

    lcr_1:   ═══════════

                ┌───┐
    lqr_1_0: ───┤ H ├──────────────────
                ├───┤        ┌─────┐┌─┐
    lqr_1_1: ───┤ X ├─────■──┤ Tdg ├┤M├
             ┌──┴───┴──┐  │  └─────┘└╥┘
    lqr_1_2: ┤ U1(0.1) ├──┼──────────╫─
             └─────────┘  │          ║
    lqr_2_0: ─────■───────┼──────────╫─
                ┌─┴─┐   ┌─┴─┐  ┌─┐   ║
    lqr_2_1: ───┤ X ├───┤ X ├──┤M├───╫─
                └───┘   └───┘  └╥┘   ║
    lcr_0:   ═══════════════════╩════╬═
                                     ║
    lcr_1:   ════════════════════════╩═
    ```

*   The mock backends in `qiskit.test.mock` now have a functional `run()` method that will return results similar to the real devices. If `qiskit-aer` is installed a simulation will be run with a noise model built from the device snapshot in the fake backend. Otherwise, [`qiskit.providers.basicaer.QasmSimulatorPy`](qiskit.providers.basicaer.QasmSimulatorPy "qiskit.providers.basicaer.QasmSimulatorPy") will be used to run an ideal simulation. Additionally, if a pulse experiment is passed to `run` and qiskit-aer is installed the `PulseSimulator` will be used to simulate the pulse schedules.

*   The [`qiskit.result.Result()`](qiskit.result.Result "qiskit.result.Result") method [`get_counts()`](qiskit.result.Result#get_counts "qiskit.result.Result.get_counts") will now return a list of all the counts available when there are multiple circuits in a job. This works when `get_counts()` is called with no arguments.

    The main consideration for this feature was for drawing all the results from multiple circuits in the same histogram. For example it is now possible to do something like:

    ```python
    from qiskit import execute
    from qiskit import QuantumCircuit
    from qiskit.providers.basicaer import BasicAer
    from qiskit.visualization import plot_histogram

    sim = BasicAer.get_backend('qasm_simulator')

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()
    result = execute([qc, qc, qc], sim).result()

    plot_histogram(result.get_counts())
    ```

*   A new kwarg, `initial_state` has been added to the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw"). When set to `True` the initial state will be included in circuit visualizations for all backends. For example:

    ```python
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.measure_all()
    circuit.draw(output='mpl', initial_state=True)
    ```

*   It is now possible to insert a callable into a [`qiskit.pulse.InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") which returns a new [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") when it is called with parameters. For example:

    ```python
    def test_func(x):
       sched = Schedule()
       sched += pulse_lib.constant(int(x), amp_test)(DriveChannel(0))
       return sched

    inst_map = InstructionScheduleMap()
    inst_map.add('f', (0,), test_func)
    output_sched = inst_map.get('f', (0,), 10)
    assert output_sched.duration == 10
    ```

*   Two new gate classes, `qiskit.extensions.iSwapGate` and `qiskit.extensions.DCXGate`, along with their [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods [`iswap()`](qiskit.circuit.QuantumCircuit#iswap "qiskit.circuit.QuantumCircuit.iswap") and [`dcx()`](qiskit.circuit.QuantumCircuit#dcx "qiskit.circuit.QuantumCircuit.dcx") have been added to the standard extensions. These gates, which are locally equivalent to each other, can be used to enact particular XY interactions. A brief motivation for these gates can be found in: [arxiv.org/abs/quant-ph/0209035](https://arxiv.org/abs/quant-ph/0209035)

*   The `qiskit.providers.BaseJob` class now has a new method `wait_for_final_state()` that polls for the job status until the job reaches a final state (such as `DONE` or `ERROR`). This method also takes an optional `callback` kwarg which takes a Python callable that will be called during each iteration of the poll loop.

*   The `search_width` and `search_depth` attributes of the [`qiskit.transpiler.passes.LookaheadSwap`](qiskit.transpiler.passes.LookaheadSwap "qiskit.transpiler.passes.LookaheadSwap") pass are now settable when initializing the pass. A larger search space can often lead to more optimized circuits, at the cost of longer run time.

*   The number of qubits in [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") can now be accessed via the property [`num_qubits`](qiskit.providers.models.BackendConfiguration#num_qubits "qiskit.providers.models.BackendConfiguration.num_qubits"). It was previously only accessible via the `n_qubits` attribute.

*   Two new methods, [`angles()`](qiskit.quantum_info.OneQubitEulerDecomposer#angles "qiskit.quantum_info.OneQubitEulerDecomposer.angles") and [`angles_and_phase()`](qiskit.quantum_info.OneQubitEulerDecomposer#angles_and_phase "qiskit.quantum_info.OneQubitEulerDecomposer.angles_and_phase"), have been added to the [`qiskit.quantum_info.OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") class. These methods will return the relevant parameters without validation, and calling the `OneQubitEulerDecomposer` object will perform the full synthesis with validation.

*   An `RR` decomposition basis has been added to the [`qiskit.quantum_info.OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") for decomposing an arbitrary 2x2 unitary into a two `RGate` circuit.

*   Adds the ability to set `qargs` to objects which are subclasses of the abstract `BaseOperator` class. This is done by calling the object `op(qargs)` (where `op` is an operator class) and will return a shallow copy of the original object with a qargs property set. When such an object is used with the [`compose()`](qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose") or [`dot()`](qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot") methods the internal value for qargs will be used when the `qargs` method kwarg is not used. This allows for subsystem composition using binary operators, for example:

    ```python
    from qiskit.quantum_info import Operator

    init = Operator.from_label('III')
    x = Operator.from_label('X')
    h = Operator.from_label('H')
    init @ x([0]) @ h([1])
    ```

*   Adds [`qiskit.quantum_info.Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") operator class to the quantum\_info module. This operator is an efficient symplectic representation an N-qubit unitary operator from the Clifford group. This class includes a [`to_circuit()`](qiskit.quantum_info.Clifford#to_circuit "qiskit.quantum_info.Clifford.to_circuit") method for compilation into a `QuantumCircuit` of Clifford gates with a minimal number of CX gates for up to 3-qubits. It also providers general compilation for N > 3 qubits but this method is not optimal in the number of two-qubit gates.

*   Adds [`qiskit.quantum_info.SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") operator class. This is an efficient representaiton of an N-qubit matrix that is sparse in the Pauli basis and uses a `qiskit.quantum_info.PauliTable` and vector of complex coefficients for its data structure.

    This class supports much of the same functionality of the [`qiskit.quantum_info.Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") class so [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") objects can be tensored, composed, scalar multiplied, added and subtracted.

    Numpy arrays or [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") objects can be converted to a [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") using the :class:\`\~qiskit.quantum\_info.SparsePauliOp.from\_operator method. [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") can be convered to a sparse csr\_matrix or dense Numpy array using the [`to_matrix`](qiskit.quantum_info.SparsePauliOp#to_matrix "qiskit.quantum_info.SparsePauliOp.to_matrix") method, or to an [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") object using the [`to_operator`](qiskit.quantum_info.SparsePauliOp#to_operator "qiskit.quantum_info.SparsePauliOp.to_operator") method.

    A [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") can be iterated over in terms of its `PauliTable` components and coefficients, its coefficients and Pauli string labels using the [`label_iter()`](qiskit.quantum_info.SparsePauliOp#label_iter "qiskit.quantum_info.SparsePauliOp.label_iter") method, and the (dense or sparse) matrix components using the [`matrix_iter()`](qiskit.quantum_info.SparsePauliOp#matrix_iter "qiskit.quantum_info.SparsePauliOp.matrix_iter") method.

*   Add [`qiskit.quantum_info.diamond_norm()`](quantum_info#qiskit.quantum_info.diamond_norm "qiskit.quantum_info.diamond_norm") function for computing the diamond norm (completely-bounded trace-norm) of a quantum channel. This can be used to compute the distance between two quantum channels using `diamond_norm(chan1 - chan2)`.

*   A new class `qiskit.quantum_info.PauliTable` has been added. This is an efficient symplectic representation of a list of N-qubit Pauli operators. Some features of this class are:

    > *   `PauliTable` objects may be composed, and tensored which will return a `PauliTable` object with the combination of the operation ( `compose()`, `dot()`, `expand()`, `tensor()`) between each element of the first table, with each element of the second table.
    > *   Addition of two tables acts as list concatination of the terms in each table (`+`).
    > *   Pauli tables can be sorted by lexicographic (tensor product) order or by Pauli weights (`sort()`).
    > *   Duplicate elements can be counted and deleted (`unique()`).
    > *   The PauliTable may be iterated over in either its native symplectic boolean array representation, as Pauli string labels (`label_iter()`), or as dense Numpy array or sparse CSR matrices (`matrix_iter()`).
    > *   Checking commutation between elements of the Pauli table and another Pauli (`commutes()`) or Pauli table (`commutes_with_all()`)

    See the `qiskit.quantum_info.PauliTable` class API documentation for additional details.

*   Adds `qiskit.quantum_info.StabilizerTable` class. This is a subclass of the `qiskit.quantum_info.PauliTable` class which includes a boolean phase vector along with the Pauli table array. This represents a list of Stabilizer operators which are real-Pauli operators with +1 or -1 coefficient. Because the stabilizer matrices are real the `"Y"` label matrix is defined as `[[0, 1], [-1, 0]]`. See the API documentation for additional information.

*   Adds [`qiskit.quantum_info.pauli_basis()`](qiskit.quantum_info.pauli_basis "qiskit.quantum_info.pauli_basis") function which returns an N-qubit Pauli basis as a `qiskit.quantum_info.PauliTable` object. The ordering of this basis can either be by standard lexicographic (tensor product) order, or by the number of non-identity Pauli terms (weight).

*   Adds [`qiskit.quantum_info.ScalarOp`](qiskit.quantum_info.ScalarOp "qiskit.quantum_info.ScalarOp") operator class that represents a scalar multiple of an identity operator. This can be used to initialize an identity on arbitrary dimension subsystems and it will be implicitly converted to other `BaseOperator` subclasses (such as an [`qiskit.quantum_info.Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") or [`qiskit.quantum_info.SuperOp`](qiskit.quantum_info.SuperOp "qiskit.quantum_info.SuperOp")) when it is composed with, or added to, them.

    Example: Identity operator

    ```python
    from qiskit.quantum_info import ScalarOp, Operator

    X = Operator.from_label('X')
    Z = Operator.from_label('Z')

    init = ScalarOp(2 ** 3)  # 3-qubit identity
    op = init @ X([0]) @ Z([1]) @ X([2])  # Op XZX
    ```

*   A new method, [`reshape()`](qiskit.quantum_info.Operator#reshape "qiskit.quantum_info.Operator.reshape"), has been added to the `qiskit.quantum_innfo.Operator` class that returns a shallow copy of an operator subclass with reshaped subsystem input or output dimensions. The combined dimensions of all subsystems must be the same as the original operator or an exception will be raised.

*   Adds [`qiskit.quantum_info.random_clifford()`](quantum_info#qiskit.quantum_info.random_clifford "qiskit.quantum_info.random_clifford") for generating a random [`qiskit.quantum_info.Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") operator.

*   Add [`qiskit.quantum_info.random_quantum_channel()`](quantum_info#qiskit.quantum_info.random_quantum_channel "qiskit.quantum_info.random_quantum_channel") function for generating a random quantum channel with fixed [`Choi`](qiskit.quantum_info.Choi "qiskit.quantum_info.Choi")-rank in the [`Stinespring`](qiskit.quantum_info.Stinespring "qiskit.quantum_info.Stinespring") representation.

*   Add [`qiskit.quantum_info.random_hermitian()`](quantum_info#qiskit.quantum_info.random_hermitian "qiskit.quantum_info.random_hermitian") for generating a random Hermitian [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator").

*   Add [`qiskit.quantum_info.random_statevector()`](quantum_info#qiskit.quantum_info.random_statevector "qiskit.quantum_info.random_statevector") for generating a random [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector").

*   Adds `qiskit.quantum_info.random_pauli_table()` for generating a random `qiskit.quantum_info.PauliTable`.

*   Adds `qiskit.quantum_info.random_stabilizer_table()` for generating a random `qiskit.quantum_info.StabilizerTable`.

*   Add a `num_qubits` attribute to `qiskit.quantum_info.StateVector` and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes. This returns the number of qubits for N-qubit states and returns `None` for non-qubit states.

*   Adds [`to_dict()`](qiskit.quantum_info.Statevector#to_dict "qiskit.quantum_info.Statevector.to_dict") and [`to_dict()`](qiskit.quantum_info.DensityMatrix#to_dict "qiskit.quantum_info.DensityMatrix.to_dict") methods to convert [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") objects into Bra-Ket notation dictionary.

    Example

    ```python
    from qiskit.quantum_info import Statevector

    state = Statevector.from_label('+0')
    print(state.to_dict())
    ```

    ```python
    from qiskit.quantum_info import DensityMatrix

    state = DensityMatrix.from_label('+0')
    print(state.to_dict())
    ```

*   Adds [`probabilities()`](qiskit.quantum_info.Statevector#probabilities "qiskit.quantum_info.Statevector.probabilities") and [`probabilities()`](qiskit.quantum_info.DensityMatrix#probabilities "qiskit.quantum_info.DensityMatrix.probabilities") to [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes which return an array of measurement outcome probabilities in the computational basis for the specified subsystems.

    Example

    ```python
    from qiskit.quantum_info import Statevector

    state = Statevector.from_label('+0')
    print(state.probabilities())
    ```

    ```python
    from qiskit.quantum_info import DensityMatrix

    state = DensityMatrix.from_label('+0')
    print(state.probabilities())
    ```

*   Adds [`probabilities_dict()`](qiskit.quantum_info.Statevector#probabilities_dict "qiskit.quantum_info.Statevector.probabilities_dict") and [`probabilities_dict()`](qiskit.quantum_info.DensityMatrix#probabilities_dict "qiskit.quantum_info.DensityMatrix.probabilities_dict") to [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes which return a count-style dictionary array of measurement outcome probabilities in the computational basis for the specified subsystems.

    ```python
    from qiskit.quantum_info import Statevector

    state = Statevector.from_label('+0')
    print(state.probabilities_dict())
    ```

    ```python
    from qiskit.quantum_info import DensityMatrix

    state = DensityMatrix.from_label('+0')
    print(state.probabilities_dict())
    ```

*   Add [`sample_counts()`](qiskit.quantum_info.Statevector#sample_counts "qiskit.quantum_info.Statevector.sample_counts") and [`sample_memory()`](qiskit.quantum_info.Statevector#sample_memory "qiskit.quantum_info.Statevector.sample_memory") methods to the [`Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes for sampling measurement outcomes on subsystems.

    Example:

    > Generate a counts dictionary by sampling from a statevector
    >
    > ```python
    > from qiskit.quantum_info import Statevector
    >
    > psi = Statevector.from_label('+0')
    > shots = 1024
    >
    > # Sample counts dictionary
    > counts = psi.sample_counts(shots)
    > print('Measure both:', counts)
    >
    > # Qubit-0
    > counts0 = psi.sample_counts(shots, [0])
    > print('Measure Qubit-0:', counts0)
    >
    > # Qubit-1
    > counts1 = psi.sample_counts(shots, [1])
    > print('Measure Qubit-1:', counts1)
    > ```
    >
    > Return the array of measurement outcomes for each sample
    >
    > ```python
    > from qiskit.quantum_info import Statevector
    >
    > psi = Statevector.from_label('-1')
    > shots = 10
    >
    > # Sample memory
    > mem = psi.sample_memory(shots)
    > print('Measure both:', mem)
    >
    > # Qubit-0
    > mem0 = psi.sample_memory(shots, [0])
    > print('Measure Qubit-0:', mem0)
    >
    > # Qubit-1
    > mem1 = psi.sample_memory(shots, [1])
    > print('Measure Qubit-1:', mem1)
    > ```

*   Adds a [`measure()`](qiskit.quantum_info.Statevector#measure "qiskit.quantum_info.Statevector.measure") method to the [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") quantum state classes. This allows sampling a single measurement outcome from the specified subsystems and collapsing the statevector to the post-measurement computational basis state. For example

    ```python
    from qiskit.quantum_info import Statevector

    psi = Statevector.from_label('+1')

    # Measure both qubits
    outcome, psi_meas = psi.measure()
    print("measure([0, 1]) outcome:", outcome, "Post-measurement state:")
    print(psi_meas)

    # Measure qubit-1 only
    outcome, psi_meas = psi.measure([1])
    print("measure([1]) outcome:", outcome, "Post-measurement state:")
    print(psi_meas)
    ```

*   Adds a [`reset()`](qiskit.quantum_info.Statevector#reset "qiskit.quantum_info.Statevector.reset") method to the [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") quantum state classes. This allows reseting some or all subsystems to the $|0\rangle$ state. For example

    ```python
    from qiskit.quantum_info import Statevector

    psi = Statevector.from_label('+1')

    # Reset both qubits
    psi_reset = psi.reset()
    print("Post reset state: ")
    print(psi_reset)

    # Reset qubit-1 only
    psi_reset = psi.reset([1])
    print("Post reset([1]) state: ")
    print(psi_reset)
    ```

*   A new visualization function [`qiskit.visualization.visualize_transition()`](qiskit.visualization.visualize_transition "qiskit.visualization.visualize_transition") for visualizing single qubit gate transitions has been added. It takes in a single qubit circuit and returns an animation of qubit state transitions on a Bloch sphere. To use this function you must have installed the dependencies for and configured globally a matplotlib animtion writer. You can refer to the [matplotlib documentation](https://matplotlib.org/api/animation_api.html#writer-classes) for more details on this. However, in the default case simply ensuring that [FFmpeg](https://www.ffmpeg.org/) is installed is sufficient to use this function.

    It supports circuits with the following gates:

    *   `HGate`
    *   `XGate`
    *   `YGate`
    *   `ZGate`
    *   `RXGate`
    *   `RYGate`
    *   `RZGate`
    *   `SGate`
    *   `SdgGate`
    *   `TGate`
    *   `TdgGate`
    *   `U1Gate`

    For example:

    ```python
    from qiskit.visualization import visualize_transition
    from qiskit import *

    qc = QuantumCircuit(1)
    qc.h(0)
    qc.ry(70,0)
    qc.rx(90,0)
    qc.rz(120,0)

    visualize_transition(qc, fpg=20, spg=1, trace=True)
    ```

*   `execute()` has a new kwarg `schedule_circuit`. By setting `schedule_circuit=True` this enables scheduling of the circuit into a [`Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule"). This allows users building [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects to make use of custom scheduler methods, such as the `as_late_as_possible` and `as_soon_as_possible` methods. For example:

    ```python
    job = execute(qc, backend, schedule_circuit=True,
                  scheduling_method="as_late_as_possible")
    ```

*   A new environment variable `QISKIT_SUPPRESS_PACKAGING_WARNINGS` can be set to `Y` or `y` which will suppress the warnings about `qiskit-aer` and `qiskit-ibmq-provider` not being installed at import time. This is useful for users who are only running qiskit-terra (or just not qiskit-aer and/or qiskit-ibmq-provider) and the warnings are not an indication of a potential packaging problem. You can set the environment variable to `N` or `n` to ensure that warnings are always enabled even if the user config file is set to disable them.

*   A new user config file option, `suppress_packaging_warnings` has been added. When set to `true` in your user config file like:

    ```python
    [default]
    suppress_packaging_warnings = true
    ```

    it will suppress the warnings about `qiskit-aer` and `qiskit-ibmq-provider` not being installed at import time. This is useful for users who are only running qiskit-terra (or just not qiskit-aer and/or qiskit-ibmq-provider) and the warnings are not an indication of a potential packaging problem. If the user config file is set to disable the warnings this can be overridden by setting the `QISKIT_SUPPRESS_PACKAGING_WARNINGS` to `N` or `n`

*   [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") has two new kwargs, `layout_method` and `routing_method`. These allow you to select a particular method for placement and routing of circuits on constrained architectures. For, example:

    ```python
    transpile(circ, backend, layout_method='dense',
              routing_method='lookahead')
    ```

    will run [`DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") layout pass and [`LookaheadSwap`](qiskit.transpiler.passes.LookaheadSwap "qiskit.transpiler.passes.LookaheadSwap") routing pass.

*   There has been a significant simplification to the style in which Pulse instructions are built.

    With the previous style, `Command` s were called with channels to make an [`Instruction`](pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction"). The usage of both commands and instructions was a point of confusion. This was the previous style:

    ```python
    sched += Delay(5)(DriveChannel(0))
    sched += ShiftPhase(np.pi)(DriveChannel(0))
    sched += SamplePulse([1.0, ...])(DriveChannel(0))
    sched += Acquire(100)(AcquireChannel(0), MemorySlot(0))
    ```

    or, equivalently (though less used):

    ```python
    sched += DelayInstruction(Delay(5), DriveChannel(0))
    sched += ShiftPhaseInstruction(ShiftPhase(np.pi), DriveChannel(0))
    sched += PulseInstruction(SamplePulse([1.0, ...]), DriveChannel(0))
    sched += AcquireInstruction(Acquire(100), AcquireChannel(0),
                                MemorySlot(0))
    ```

    Now, rather than build a command *and* an instruction, each command has been migrated into an instruction:

    ```python
    sched += Delay(5, DriveChannel(0))
    sched += ShiftPhase(np.pi, DriveChannel(0))
    sched += Play(SamplePulse([1.0, ...]), DriveChannel(0))
    sched += SetFrequency(5.5, DriveChannel(0))  # New instruction!
    sched += Acquire(100, AcquireChannel(0), MemorySlot(0))
    ```

*   There is now a [`Play`](qiskit.pulse.instructions.Play "qiskit.pulse.instructions.Play") instruction which takes a description of a pulse envelope and a channel. There is a new `Pulse` class in the `pulse_lib` from which the pulse envelope description should subclass.

    For example:

    ```python
    Play(SamplePulse([0.1]*10), DriveChannel(0))
    Play(ConstantPulse(duration=10, amp=0.1), DriveChannel(0))
    ```

<span id="release-notes-0-13-0-upgrade-notes" />

<span id="id496" />

#### Upgrade Notes

*   The [`qiskit.dagcircuit.DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") method `pop` which was deprecated in the 0.9.0 release has been removed. If you were using this method you can leverage Python’s `del` statement or `delattr()` function to perform the same task.

*   A new optional visualization requirement, [pygments](https://pygments.org/) , has been added. It is used for providing syntax highlighting of OpenQASM 2.0 code in Jupyter widgets and optionally for the [`qiskit.circuit.QuantumCircuit.qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") method. It must be installed (either with `pip install pygments` or `pip install qiskit-terra[visualization]`) prior to using the `%circuit_library_info` widget in [`qiskit.tools.jupyter`](tools_jupyter#module-qiskit.tools.jupyter "qiskit.tools.jupyter") or the `formatted` kwarg on the [`qasm()`](qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") method.

*   The pulse `buffer` option found in `qiskit.pulse.Channel` and [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") was deprecated in Terra 0.11.0 and has now been removed. To add a delay on a channel or in a schedule, specify it explicitly in your Schedule with a Delay:

    ```python
    sched = Schedule()
    sched += Delay(5)(DriveChannel(0))
    ```

*   `PulseChannelSpec`, which was deprecated in Terra 0.11.0, has now been removed. Use BackendConfiguration instead:

    ```python
    config = backend.configuration()
    drive_chan_0 = config.drives(0)
    acq_chan_0 = config.acquires(0)
    ```

    or, simply reference the channel directly, such as `DriveChannel(index)`.

*   An import path was deprecated in Terra 0.10.0 and has now been removed: for `PulseChannel`, `DriveChannel`, `MeasureChannel`, and `ControlChannel`, use `from qiskit.pulse.channels import X` in place of `from qiskit.pulse.channels.pulse_channels import X`.

*   The pass [`qiskit.transpiler.passes.CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") (which was introduced in the 0.11.0 release) has been added to the preset pass manager for optimization levels 2 and 3. For level 2, there is a call limit of 1,000 and a timeout of 10 seconds. For level 3, the call limit is 10,000 and the timeout is 1 minute.

    Now that the pass is included in the preset pass managers the [python-constraint](https://pypi.org/project/python-constraint/) package is not longer an optional dependency and has been added to the requirements list.

*   The `TranspileConfig` class which was previously used to set run time configuration for a [`qiskit.transpiler.PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") has been removed and replaced by a new class `qiskit.transpile.PassManagerConfig`. This new class has been structured to include only the information needed to construct a [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager"). The attributes of this class are:

    *   `initial_layout`
    *   `basis_gates`
    *   `coupling_map`
    *   `backend_properties`
    *   `seed_transpiler`

*   The function `transpile_circuit` in [`qiskit.transpiler`](transpiler#module-qiskit.transpiler "qiskit.transpiler") has been removed. To transpile a circuit with a custom [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") now you should use the [`run()`](qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") method of the :class:\~qiskit.transpiler.PassManager\` object.

*   The [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function will no longer include the initial state included in visualizations by default. If you would like to retain the initial state in the output visualization you need to set the `initial_state` kwarg to `True`. For example, running:

    ```python
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.measure_all()
    circuit.draw(output='text')
    ```

    This no longer includes the initial state. If you’d like to retain it you can run:

    ```python
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(2)
    circuit.measure_all()
    circuit.draw(output='text', initial_state=True)
    ```

*   [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") (and `qiskit.execute.execute()`, which uses `transpile` internally) will now raise an error when the `pass_manager` kwarg is set and a value is set for other kwargs that are already set in an instantiated [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") object. Previously, these conflicting kwargs would just be silently ignored and the values in the `PassManager` instance would be used. For example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler.pass_manager_config import PassManagerConfig
    from qiskit.transpiler import preset_passmanagers
    from qiskit.compiler import transpile

    qc = QuantumCircuit(5)

    config = PassManagerConfig(basis_gates=['u3', 'cx'])
    pm = preset_passmanagers.level_0_pass_manager(config)
    transpile(qc, optimization_level=3, pass_manager=pm)
    ```

    will now raise an error while prior to this release the value in `pm` would just silently be used and the value for the `optimization_level` kwarg would be ignored. The `transpile` kwargs this applies to are:

    *   `optimization_level`
    *   `basis_gates`
    *   `coupling_map`
    *   `seed_transpiler`
    *   `backend_properties`
    *   `initial_layout`
    *   `layout_method`
    *   `routing_method`
    *   `backend`

*   The [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator"), [`Clifford`](qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford"), [`SparsePauliOp`](qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp"), `PauliTable`, `StabilizerTable`, operator classes have an added `call` method that allows them to assign a qargs to the operator for use with the [`compose()`](qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose"), [`dot()`](qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot"), [`evolve()`](qiskit.quantum_info.Statevector#evolve "qiskit.quantum_info.Statevector.evolve"),\`\`+\`\`, and `-` operations.

*   The addition method of the [`qiskit.quantum_info.Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator"), class now accepts a `qarg` kwarg to allow adding a smaller operator to a larger one assuming identities on the other subsystems (same as for `qargs` on [`compose()`](qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose") and [`dot()`](qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot") methods). This allows subsystem addition using the call method as with composition. This support is added to all BaseOperator subclasses ([`ScalarOp`](qiskit.quantum_info.ScalarOp "qiskit.quantum_info.ScalarOp"), [`Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator"), `QuantumChannel`).

    For example:

    ```python
    from qiskit.quantum_info import Operator, ScalarOp

    ZZ = Operator.from_label('ZZ')

    # Initialize empty Hamiltonian
    n_qubits = 10
    ham = ScalarOp(2 ** n_qubits, coeff=0)

    # Add 2-body nearest neighbour terms
    for j in range(n_qubits - 1):
        ham = ham + ZZ([j, j+1])
    ```

*   The `BaseOperator` class has been updated so that addition, subtraction and scalar multiplication are no longer abstract methods. This means that they are no longer required to be implemented in subclasses if they are not supported. The base class will raise a `NotImplementedError` when the methods are not defined.

*   The [`qiskit.quantum_info.random_density_matrix()`](quantum_info#qiskit.quantum_info.random_density_matrix "qiskit.quantum_info.random_density_matrix") function will now return a random [`DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") object. In previous releases it returned a numpy array.

*   The [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes no longer copy the input array if it is already the correct dtype.

*   [fastjsonschema](https://pypi.org/project/fastjsonschema/) is added as a dependency. This is used for much faster validation of qobj dictionaries against the JSON schema when the `to_dict()` method is called on qobj objects with the `validate` keyword argument set to `True`.

*   The qobj construction classes in [`qiskit.qobj`](qobj#module-qiskit.qobj "qiskit.qobj") will no longer validate against the qobj jsonschema by default. These include the following classes:

    *   [`qiskit.qobj.QasmQobjInstruction`](qiskit.qobj.QasmQobjInstruction "qiskit.qobj.QasmQobjInstruction")
    *   [`qiskit.qobj.QobjExperimentHeader`](qiskit.qobj.QobjExperimentHeader "qiskit.qobj.QobjExperimentHeader")
    *   [`qiskit.qobj.QasmQobjExperimentConfig`](qiskit.qobj.QasmQobjExperimentConfig "qiskit.qobj.QasmQobjExperimentConfig")
    *   [`qiskit.qobj.QasmQobjExperiment`](qiskit.qobj.QasmQobjExperiment "qiskit.qobj.QasmQobjExperiment")
    *   [`qiskit.qobj.QasmQobjConfig`](qiskit.qobj.QasmQobjConfig "qiskit.qobj.QasmQobjConfig")
    *   [`qiskit.qobj.QobjHeader`](qiskit.qobj.QobjHeader "qiskit.qobj.QobjHeader")
    *   [`qiskit.qobj.PulseQobjInstruction`](qiskit.qobj.PulseQobjInstruction "qiskit.qobj.PulseQobjInstruction")
    *   [`qiskit.qobj.PulseQobjExperimentConfig`](qiskit.qobj.PulseQobjExperimentConfig "qiskit.qobj.PulseQobjExperimentConfig")
    *   [`qiskit.qobj.PulseQobjExperiment`](qiskit.qobj.PulseQobjExperiment "qiskit.qobj.PulseQobjExperiment")
    *   [`qiskit.qobj.PulseQobjConfig`](qiskit.qobj.PulseQobjConfig "qiskit.qobj.PulseQobjConfig")
    *   [`qiskit.qobj.QobjMeasurementOption`](qiskit.qobj.QobjMeasurementOption "qiskit.qobj.QobjMeasurementOption")
    *   [`qiskit.qobj.PulseLibraryItem`](qiskit.qobj.PulseLibraryItem "qiskit.qobj.PulseLibraryItem")
    *   [`qiskit.qobj.QasmQobjInstruction`](qiskit.qobj.QasmQobjInstruction "qiskit.qobj.QasmQobjInstruction")
    *   [`qiskit.qobj.QasmQobjExperimentConfig`](qiskit.qobj.QasmQobjExperimentConfig "qiskit.qobj.QasmQobjExperimentConfig")
    *   [`qiskit.qobj.QasmQobjExperiment`](qiskit.qobj.QasmQobjExperiment "qiskit.qobj.QasmQobjExperiment")
    *   [`qiskit.qobj.QasmQobjConfig`](qiskit.qobj.QasmQobjConfig "qiskit.qobj.QasmQobjConfig")
    *   [`qiskit.qobj.QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj")
    *   [`qiskit.qobj.PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj")

    If you were relying on this validation or would like to validate them against the qobj schema this can be done by setting the `validate` kwarg to `True` on [`to_dict()`](qiskit.qobj.QasmQobj#to_dict "qiskit.qobj.QasmQobj.to_dict") method from either of the top level Qobj classes [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") or [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj"). For example:

    which will validate the output dictionary against the Qobj jsonschema.

*   The output dictionary from [`qiskit.qobj.QasmQobj.to_dict()`](qiskit.qobj.QasmQobj#to_dict "qiskit.qobj.QasmQobj.to_dict") and [`qiskit.qobj.PulseQobj.to_dict()`](qiskit.qobj.PulseQobj#to_dict "qiskit.qobj.PulseQobj.to_dict") is no longer in a format for direct json serialization as expected by IBMQ’s API. These Qobj objects are the current format we use for passing experiments to providers/backends and while having a dictionary format that could just be passed to the IBMQ API directly was moderately useful for `qiskit-ibmq-provider`, it made things more difficult for other providers. Especially for providers that wrap local simulators. Moving forward the definitions of what is passed between providers and the IBMQ API request format will be further decoupled (in a backwards compatible manner) which should ease the burden of writing providers and backends.

    In practice, the only functional difference between the output of these methods now and previous releases is that complex numbers are represented with the `complex` type and numpy arrays are not silently converted to list anymore. If you were previously calling `json.dumps()` directly on the output of `to_dict()` after this release a custom json encoder will be needed to handle these cases. For example:

    ```python
    import json

    from qiskit.circuit import ParameterExpression
    from qiskit import qobj

    my_qasm = qobj.QasmQobj(
        qobj_id='12345',
        header=qobj.QobjHeader(),
        config=qobj.QasmQobjConfig(shots=1024, memory_slots=2,
                                   max_credits=10),
        experiments=[
            qobj.QasmQobjExperiment(instructions=[
                qobj.QasmQobjInstruction(name='u1', qubits=[1],
                                         params=[0.4]),
                qobj.QasmQobjInstruction(name='u2', qubits=[1],
                                         params=[0.4, 0.2])
            ])
        ]
    )
    qasm_dict = my_qasm.to_dict()

    class QobjEncoder(json.JSONEncoder):
        """A json encoder for pulse qobj"""
        def default(self, obj):
            # Convert numpy arrays:
            if hasattr(obj, 'tolist'):
                return obj.tolist()
            # Use Qobj complex json format:
            if isinstance(obj, complex):
                return (obj.real, obj.imag)
            if isinstance(obj, ParameterExpression):
                return float(obj)
            return json.JSONEncoder.default(self, obj)

    json_str = json.dumps(qasm_dict, cls=QobjEncoder)
    ```

    will generate a json string in the same exact manner that `json.dumps(my_qasm.to_dict())` did in previous releases.

*   `CmdDef` has been deprecated since Terra 0.11.0 and has been removed. Please continue to use [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") instead.

*   The methods `cmds` and `cmd_qubits` in [`InstructionScheduleMap`](qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") have been deprecated since Terra 0.11.0 and have been removed. Please use `instructions` and `qubits_with_instruction` instead.

*   PulseDefaults have reported `qubit_freq_est` and `meas_freq_est` in Hz rather than GHz since Terra release 0.11.0. A warning which notified of this change has been removed.

*   The previously deprecated (in the 0.11.0 release) support for passsing in [`qiskit.circuit.Instruction`](qiskit.circuit.Instruction "qiskit.circuit.Instruction") parameters of types `sympy.Basic`, `sympy.Expr`, `qiskit.qasm.node.node.Node` (QASM AST node) and `sympy.Matrix` has been removed. The supported types for instruction parameters are:

    *   `int`
    *   `float`
    *   `complex`
    *   `str`
    *   `list`
    *   `np.ndarray`
    *   [`qiskit.circuit.ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")

*   The following properties of [`BackendConfiguration`](qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration"):

    *   `dt`
    *   `dtm`
    *   `rep_time`

    all have units of seconds. Prior to release 0.11.0, `dt` and `dtm` had units of nanoseconds. Prior to release 0.12.0, `rep_time` had units of microseconds. The warnings alerting users of these changes have now been removed from `BackendConfiguration`.

*   A new requirement has been added to the requirements list, [retworkx](https://pypi.org/project/retworkx/). It is an Apache 2.0 licensed graph library that has a similar API to networkx and is being used to significantly speed up the [`qiskit.dagcircuit.DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") operations as part of the transpiler. There are binaries published on PyPI for all the platforms supported by Qiskit Terra but if you’re using a platform where there aren’t precompiled binaries published refer to the [retworkx documentation](https://retworkx.readthedocs.io/en/stable/README.html#installing-retworkx) for instructions on pip installing from sdist.

    If you encounter any issues with the transpiler or DAGCircuit class as part of the transition you can switch back to the previous networkx implementation by setting the environment variable `USE_RETWORKX` to `N`. This option will be removed in the 0.14.0 release.

<span id="release-notes-0-13-0-deprecation-notes" />

<span id="id498" />

#### Deprecation Notes

*   Passing in the data to the constructor for [`qiskit.dagcircuit.DAGNode`](qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") as a dictionary arg `data_dict` is deprecated and will be removed in a future release. Instead you should now pass the fields in as kwargs to the constructor. For example the previous behavior of:

    ```python
    from qiskit.dagcircuit import DAGNode

    data_dict = {
        'type': 'in',
        'name': 'q_0',
    }
    node = DAGNode(data_dict)
    ```

    should now be:

    ```python
    from qiskit.dagcircuit import DAGNode

    node = DAGNode(type='in', name='q_0')
    ```

*   The naming of gate objects and methods have been updated to be more consistent. The following changes have been made:

    *   The Pauli gates all have one uppercase letter only (`I`, `X`, `Y`, `Z`)
    *   The parameterized Pauli gates (i.e. rotations) prepend the uppercase letter `R` (`RX`, `RY`, `RZ`)
    *   A controlled version prepends the uppercase letter `C` (`CX`, `CRX`, `CCX`)
    *   Gates are named according to their action, not their alternative names (`CCX`, not `Toffoli`)

    The old names have been deprecated and will be removed in a future release. This is a list of the changes showing the old and new class, name attribute, and methods. If a new column is blank then there is no change for that.

    | Old Class     | New Class        | Old Name Attribute | New Name Attribute | Old [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method                                                                             | New [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method                                                                          |
    | ------------- | ---------------- | ------------------ | ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | `ToffoliGate` | `CCXGate`        | `ccx`              |                    | [`ccx()`](qiskit.circuit.QuantumCircuit#ccx "qiskit.circuit.QuantumCircuit.ccx") and [`toffoli()`](qiskit.circuit.QuantumCircuit#toffoli "qiskit.circuit.QuantumCircuit.toffoli")       |                                                                                                                                                                                      |
    | `CrxGate`     | `CRXGate`        | `crx`              |                    | [`crx()`](qiskit.circuit.QuantumCircuit#crx "qiskit.circuit.QuantumCircuit.crx")                                                                                                        |                                                                                                                                                                                      |
    | `CryGate`     | `CRYGate`        | `cry`              |                    | [`cry()`](qiskit.circuit.QuantumCircuit#cry "qiskit.circuit.QuantumCircuit.cry")                                                                                                        |                                                                                                                                                                                      |
    | `CrzGate`     | `CRZGate`        | `crz`              |                    | [`crz()`](qiskit.circuit.QuantumCircuit#crz "qiskit.circuit.QuantumCircuit.crz")                                                                                                        |                                                                                                                                                                                      |
    | `FredkinGate` | `CSwapGate`      | `cswap`            |                    | [`cswap()`](qiskit.circuit.QuantumCircuit#cswap "qiskit.circuit.QuantumCircuit.cswap") and [`fredkin()`](qiskit.circuit.QuantumCircuit#fredkin "qiskit.circuit.QuantumCircuit.fredkin") |                                                                                                                                                                                      |
    | `Cu1Gate`     | `CU1Gate`        | `cu1`              |                    | `cu1()`                                                                                                                                                                                 |                                                                                                                                                                                      |
    | `Cu3Gate`     | `CU3Gate`        | `cu3`              |                    | `cu3()`                                                                                                                                                                                 |                                                                                                                                                                                      |
    | `CnotGate`    | `CXGate`         | `cx`               |                    | [`cx()`](qiskit.circuit.QuantumCircuit#cx "qiskit.circuit.QuantumCircuit.cx") and [`cnot()`](qiskit.circuit.QuantumCircuit#cnot "qiskit.circuit.QuantumCircuit.cnot")                   |                                                                                                                                                                                      |
    | `CyGate`      | `CYGate`         | `cy`               |                    | [`cy()`](qiskit.circuit.QuantumCircuit#cy "qiskit.circuit.QuantumCircuit.cy")                                                                                                           |                                                                                                                                                                                      |
    | `CzGate`      | `CZGate`         | `cz`               |                    | [`cz()`](qiskit.circuit.QuantumCircuit#cz "qiskit.circuit.QuantumCircuit.cz")                                                                                                           |                                                                                                                                                                                      |
    | `DiagGate`    | `DiagonalGate`   | `diag`             | `diagonal`         | `diag_gate`                                                                                                                                                                             | [`diagonal()`](qiskit.circuit.QuantumCircuit#diagonal "qiskit.circuit.QuantumCircuit.diagonal")                                                                                      |
    | `IdGate`      | `IGate`          | `id`               |                    | `iden`                                                                                                                                                                                  | [`i()`](qiskit.circuit.QuantumCircuit#i "qiskit.circuit.QuantumCircuit.i") and [`id()`](qiskit.circuit.QuantumCircuit#id "qiskit.circuit.QuantumCircuit.id")                         |
    | `Isometry`    |                  | `iso`              | `isometry`         | [`iso()`](qiskit.circuit.QuantumCircuit#iso "qiskit.circuit.QuantumCircuit.iso")                                                                                                        | [`isometry()`](qiskit.circuit.QuantumCircuit#isometry "qiskit.circuit.QuantumCircuit.isometry") and [`iso()`](qiskit.circuit.QuantumCircuit#iso "qiskit.circuit.QuantumCircuit.iso") |
    | `UCG`         | `UCGate`         | `multiplexer`      |                    | `ucg`                                                                                                                                                                                   | [`uc()`](qiskit.circuit.QuantumCircuit#uc "qiskit.circuit.QuantumCircuit.uc")                                                                                                        |
    | `UCRot`       | `UCPauliRotGate` |                    |                    |                                                                                                                                                                                         |                                                                                                                                                                                      |
    | `UCX`         | `UCRXGate`       | `ucrotX`           | `ucrx`             | `ucx`                                                                                                                                                                                   | [`ucrx()`](qiskit.circuit.QuantumCircuit#ucrx "qiskit.circuit.QuantumCircuit.ucrx")                                                                                                  |
    | `UCY`         | `UCRYGate`       | `ucroty`           | `ucry`             | `ucy`                                                                                                                                                                                   | [`ucry()`](qiskit.circuit.QuantumCircuit#ucry "qiskit.circuit.QuantumCircuit.ucry")                                                                                                  |
    | `UCZ`         | `UCRZGate`       | `ucrotz`           | `ucrz`             | `ucz`                                                                                                                                                                                   | [`ucrz()`](qiskit.circuit.QuantumCircuit#ucrz "qiskit.circuit.QuantumCircuit.ucrz")                                                                                                  |

*   The kwarg `period` for the function `square()`, `sawtooth()`, and `triangle()` in `qiskit.pulse.pulse_lib` is now deprecated and will be removed in a future release. Instead you should now use the `freq` kwarg to set the frequency.

*   The `DAGCircuit.compose_back()` and `DAGCircuit.extend_back()` methods are deprecated and will be removed in a future release. Instead you should use the [`qiskit.dagcircuit.DAGCircuit.compose()`](qiskit.dagcircuit.DAGCircuit#compose "qiskit.dagcircuit.DAGCircuit.compose") method, which is a more general and more flexible method that provides the same functionality.

*   The `callback` kwarg of the [`qiskit.transpiler.PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") class’s constructor has been deprecated and will be removed in a future release. Instead of setting it at the object level during creation it should now be set as a kwarg parameter on the [`qiskit.transpiler.PassManager.run()`](qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") method.

*   The `n_qubits` and `numberofqubits` keywords are deprecated throughout Terra and replaced by `num_qubits`. The old names will be removed in a future release. The objects affected by this change are listed below:

    | Class                                                                             | Old Method       | New Method                                                                                            |
    | --------------------------------------------------------------------------------- | ---------------- | ----------------------------------------------------------------------------------------------------- |
    | [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") | `n_qubits`       | [`num_qubits()`](qiskit.circuit.QuantumCircuit#num_qubits "qiskit.circuit.QuantumCircuit.num_qubits") |
    | [`Pauli`](qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli")                  | `numberofqubits` | [`num_qubits()`](qiskit.quantum_info.Pauli#num_qubits "qiskit.quantum_info.Pauli.num_qubits")         |

    | Function                                                                                                  | Old Argument | New Argument |
    | --------------------------------------------------------------------------------------------------------- | ------------ | ------------ |
    | [`random_circuit()`](circuit#qiskit.circuit.random.random_circuit "qiskit.circuit.random.random_circuit") | `n_qubits`   | `num_qubits` |
    | `MSGate`                                                                                                  | `n_qubit`    | `num_qubits` |

*   The function `qiskit.quantum_info.synthesis.euler_angles_1q` is now deprecated. It has been superseded by the [`qiskit.quantum_info.OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.OneQubitEulerDecomposer") class which provides the same functionality through:

    ```python
    OneQubitEulerDecomposer().angles(mat)
    ```

*   The `pass_manager` kwarg for the [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") has been deprecated and will be removed in a future release. Moving forward the preferred way to transpile a circuit with a custom [`PassManager`](qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") object is to use the [`run()`](qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") method of the `PassManager` object.

*   The `qiskit.quantum_info.random_state()` function has been deprecated and will be removed in a future release. Instead you should use the [`qiskit.quantum_info.random_statevector()`](quantum_info#qiskit.quantum_info.random_statevector "qiskit.quantum_info.random_statevector") function.

*   The `add`, `subtract`, and `multiply` methods of the [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes are deprecated and will be removed in a future release. Instead you shoulde use `+`, `-`, `*` binary operators instead.

*   Deprecates `qiskit.quantum_info.Statevector.to_counts()`, `qiskit.quantum_info.DensityMatrix.to_counts()`, and `qiskit.quantum_info.counts.state_to_counts()`. These functions are superseded by the class methods [`qiskit.quantum_info.Statevector.probabilities_dict()`](qiskit.quantum_info.Statevector#probabilities_dict "qiskit.quantum_info.Statevector.probabilities_dict") and [`qiskit.quantum_info.DensityMatrix.probabilities_dict()`](qiskit.quantum_info.DensityMatrix#probabilities_dict "qiskit.quantum_info.DensityMatrix.probabilities_dict").

*   `SamplePulse` and `ParametricPulse` s (e.g. `Gaussian`) now subclass from `Pulse` and have been moved to the `qiskit.pulse.pulse_lib`. The previous path via `pulse.commands` is deprecated and will be removed in a future release.

*   `DelayInstruction` has been deprecated and replaced by `Delay`. This new instruction has been taken over the previous `Command` `Delay`. The migration pattern is:

    ```python
    Delay(<duration>)(<channel>) -> Delay(<duration>, <channel>)
    DelayInstruction(Delay(<duration>), <channel>)
        -> Delay(<duration>, <channel>)
    ```

    Until the deprecation period is over, the previous `Delay` syntax of calling a command on a channel will also be supported:

    ```python
    Delay(<phase>)(<channel>)
    ```

    The new `Delay` instruction does not support a `command` attribute.

*   `FrameChange` and `FrameChangeInstruction` have been deprecated and replaced by [`ShiftPhase`](qiskit.pulse.instructions.ShiftPhase "qiskit.pulse.instructions.ShiftPhase"). The changes are:

    ```python
    FrameChange(<phase>)(<channel>) -> ShiftPhase(<phase>, <channel>)
    FrameChangeInstruction(FrameChange(<phase>), <channel>)
        -> ShiftPhase(<phase>, <channel>)
    ```

    Until the deprecation period is over, the previous FrameChange syntax of calling a command on a channel will be supported:

    ```python
    ShiftPhase(<phase>)(<channel>)
    ```

*   The `call` method of `SamplePulse` and `ParametricPulse` s have been deprecated. The migration is as follows:

    ```python
    Pulse(<*args>)(<channel>) -> Play(Pulse(*args), <channel>)
    ```

*   `AcquireInstruction` has been deprecated and replaced by [`Acquire`](qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire"). The changes are:

    ```python
    Acquire(<duration>)(<**channels>) -> Acquire(<duration>, <**channels>)
    AcquireInstruction(Acquire(<duration>), <**channels>)
        -> Acquire(<duration>, <**channels>)
    ```

    Until the deprecation period is over, the previous Acquire syntax of calling the command on a channel will be supported:

    ```python
    Acquire(<duration>)(<**channels>)
    ```

<span id="release-notes-0-13-0-bug-fixes" />

<span id="id499" />

#### Bug Fixes

*   The [`BarrierBeforeFinalMeasurements`](qiskit.transpiler.passes.BarrierBeforeFinalMeasurements "qiskit.transpiler.passes.BarrierBeforeFinalMeasurements") transpiler pass, included in the preset transpiler levels when targeting a physical device, previously inserted a barrier across only measured qubits. In some cases, this allowed the transpiler to insert a swap after a measure operation, rendering the circuit invalid for current devices. The pass has been updated so that the inserted barrier will span all qubits on the device. Fixes [#3937](https://github.com/Qiskit/qiskit-terra/issues/3937)

*   When extending a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instance (extendee) with another circuit (extension), the circuit is taken via reference. If a circuit is extended with itself that leads to an infinite loop as extendee and extension are the same. This bug has been resolved by copying the extension if it is the same object as the extendee. Fixes [#3811](https://github.com/Qiskit/qiskit-terra/issues/3811)

*   Fixes a case in [`qiskit.result.Result.get_counts()`](qiskit.result.Result#get_counts "qiskit.result.Result.get_counts"), where the results for an expirement could not be referenced if the experiment was initialized as a Schedule without a name. Fixes [#2753](https://github.com/Qiskit/qiskit-terra/issues/2753)

*   Previously, replacing [`Parameter`](qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects in a circuit with new Parameter objects prior to decomposing a circuit would result in the substituted values not correctly being substituted into the decomposed gates. This has been resolved such that binding and decomposition may occur in any order.

*   The matplotlib output backend for the [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method drawer has been fixed to render `CU1Gate` gates correctly. Fixes [#3684](https://github.com/Qiskit/qiskit-terra/issues/3684)

*   A bug in [`qiskit.circuit.QuantumCircuit.from_qasm_str()`](qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") and [`qiskit.circuit.QuantumCircuit.from_qasm_file()`](qiskit.circuit.QuantumCircuit#from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file") when loading QASM with custom gates defined has been fixed. Now, loading this QASM:

    ```python
    OPENQASM 2.0;
    include "qelib1.inc";
    gate rinv q {sdg q; h q; sdg q; h q; }
    qreg q[1];
    rinv q[0];
    ```

    is equivalent to the following circuit:

    ```python
    rinv_q = QuantumRegister(1, name='q')
    rinv_gate = QuantumCircuit(rinv_q, name='rinv')
    rinv_gate.sdg(rinv_q)
    rinv_gate.h(rinv_q)
    rinv_gate.sdg(rinv_q)
    rinv_gate.h(rinv_q)
    rinv = rinv_gate.to_instruction()
    qr = QuantumRegister(1, name='q')
    expected = QuantumCircuit(qr, name='circuit')
    expected.append(rinv, [qr[0]])
    ```

    Fixes [#1566](https://github.com/Qiskit/qiskit-terra/issues/1566)

*   Allow quantum circuit Instructions to have list parameter values. This is used in Aer for expectation value snapshot parameters for example `params = [[1.0, 'I'], [1.0, 'X']]]` for $\langle I + X\rangle$.

*   Previously, for circuits containing composite gates (those created via [`qiskit.circuit.QuantumCircuit.to_gate()`](qiskit.circuit.QuantumCircuit#to_gate "qiskit.circuit.QuantumCircuit.to_gate") or [`qiskit.circuit.QuantumCircuit.to_instruction()`](qiskit.circuit.QuantumCircuit#to_instruction "qiskit.circuit.QuantumCircuit.to_instruction") or their corresponding converters), attempting to bind the circuit more than once would result in only the first bind value being applied to all circuits when transpiled. This has been resolved so that the values provided for subsequent binds are correctly respected.

<span id="release-notes-0-13-0-other-notes" />

<span id="id505" />

#### Other Notes

*   The qasm and pulse qobj classes:

    *   [`QasmQobjInstruction`](qiskit.qobj.QasmQobjInstruction "qiskit.qobj.QasmQobjInstruction")
    *   [`QobjExperimentHeader`](qiskit.qobj.QobjExperimentHeader "qiskit.qobj.QobjExperimentHeader")
    *   [`QasmQobjExperimentConfig`](qiskit.qobj.QasmQobjExperimentConfig "qiskit.qobj.QasmQobjExperimentConfig")
    *   [`QasmQobjExperiment`](qiskit.qobj.QasmQobjExperiment "qiskit.qobj.QasmQobjExperiment")
    *   [`QasmQobjConfig`](qiskit.qobj.QasmQobjConfig "qiskit.qobj.QasmQobjConfig")
    *   [`QobjHeader`](qiskit.qobj.QobjHeader "qiskit.qobj.QobjHeader")
    *   [`PulseQobjInstruction`](qiskit.qobj.PulseQobjInstruction "qiskit.qobj.PulseQobjInstruction")
    *   [`PulseQobjExperimentConfig`](qiskit.qobj.PulseQobjExperimentConfig "qiskit.qobj.PulseQobjExperimentConfig")
    *   [`PulseQobjExperiment`](qiskit.qobj.PulseQobjExperiment "qiskit.qobj.PulseQobjExperiment")
    *   [`PulseQobjConfig`](qiskit.qobj.PulseQobjConfig "qiskit.qobj.PulseQobjConfig")
    *   [`QobjMeasurementOption`](qiskit.qobj.QobjMeasurementOption "qiskit.qobj.QobjMeasurementOption")
    *   [`PulseLibraryItem`](qiskit.qobj.PulseLibraryItem "qiskit.qobj.PulseLibraryItem")
    *   [`QasmQobjInstruction`](qiskit.qobj.QasmQobjInstruction "qiskit.qobj.QasmQobjInstruction")
    *   [`QasmQobjExperimentConfig`](qiskit.qobj.QasmQobjExperimentConfig "qiskit.qobj.QasmQobjExperimentConfig")
    *   [`QasmQobjExperiment`](qiskit.qobj.QasmQobjExperiment "qiskit.qobj.QasmQobjExperiment")
    *   [`QasmQobjConfig`](qiskit.qobj.QasmQobjConfig "qiskit.qobj.QasmQobjConfig")
    *   [`QasmQobj`](qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj")
    *   [`PulseQobj`](qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj")

    from [`qiskit.qobj`](qobj#module-qiskit.qobj "qiskit.qobj") have all been reimplemented without using the marsmallow library. These new implementations are designed to be drop-in replacement (except for as noted in the upgrade release notes) but specifics inherited from marshmallow may not work. Please file issues for any incompatibilities found.

<span id="aer-0-5-0" />

### Aer 0.5.0

#### Added

> *   Add support for terra diagonal gate
> *   Add support for parameterized qobj

#### Fixed

> *   Added postfix for linux on Raspberry Pi
> *   Handle numpy array inputs from qobj

<span id="id506" />

### Ignis 0.3.0

<span id="id507" />

#### Added

*   API documentation
*   CNOT-Dihedral randomized benchmarking
*   Accreditation module for output accrediation of noisy devices
*   Pulse calibrations for single qubits
*   Pulse Discriminator
*   Entanglement verification circuits
*   Gateset tomography for single-qubit gate sets
*   Adds randomized benchmarking utility functions `calculate_1q_epg`, `calculate_2q_epg` functions to calculate 1 and 2-qubit error per gate from error per Clifford
*   Adds randomized benchmarking utility functions `calculate_1q_epc`, `calculate_2q_epc` for calculating 1 and 2-qubit error per Clifford from error per gate

#### Changed

*   Support integer labels for qubits in tomography
*   Support integer labels for measurement error mitigation

#### Deprecated

*   Deprecates `twoQ_clifford_error` function. Use `calculate_2q_epc` instead.
*   Python 3.5 support in qiskit-ignis is deprecated. Support will be removed on the upstream python community’s end of life date for the version, which is 09/13/2020.

<span id="aqua-0-6-5" />

### Aqua 0.6.5

No Change

<span id="ibm-q-provider-0-6-0" />

### IBM Q Provider 0.6.0

No Change

<span id="qiskit-0-17-0" />

## Qiskit 0.17.0

<span id="terra-0-12-0" />

### Terra 0.12.0

No Change

<span id="aer-0-4-1" />

### Aer 0.4.1

No Change

<span id="ignis-0-2-0" />

### Ignis 0.2.0

No Change

<span id="id508" />

### Aqua 0.6.5

No Change

<span id="id509" />

### IBM Q Provider 0.6.0

<span id="id510" />

#### New Features

*   There are three new exceptions: `VisualizationError`, `VisualizationValueError`, and `VisualizationTypeError`. These are now used in the visualization modules when an exception is raised.
*   You can now set the logging level and specify a log file using the environment variables `QSIKIT_IBMQ_PROVIDER_LOG_LEVEL` and `QISKIT_IBMQ_PROVIDER_LOG_FILE`, respectively. Note that the name of the logger is `qiskit.providers.ibmq`.
*   `qiskit.providers.ibmq.job.IBMQJob` now has a new method `scheduling_mode()` that returns the scheduling mode the job is in.
*   IQX-related tutorials that used to be in `qiskit-iqx-tutorials` are now in `qiskit-ibmq-provider`.

<span id="id511" />

#### Changed

*   `qiskit.providers.ibmq.IBMQBackend.jobs()` now accepts a new boolean parameter `descending`, which can be used to indicate whether the jobs should be returned in descending or ascending order.
*   `qiskit.providers.ibmq.managed.IBMQJobManager` now looks at the job limit and waits for old jobs to finish before submitting new ones if the limit has been reached.
*   `qiskit.providers.ibmq.IBMQBackend.status()` now raises a `qiskit.providers.ibmq.IBMQBackendApiProtocolError` exception if there was an issue with validating the status.

<span id="qiskit-0-16-0" />

## Qiskit 0.16.0

<span id="id512" />

### Terra 0.12.0

No Change

<span id="aer-0-4-0" />

### Aer 0.4.0

No Change

<span id="id513" />

### Ignis 0.2.0

No Change

<span id="aqua-0-6-4" />

### Aqua 0.6.4

No Change

<span id="ibm-q-provider-0-5-0" />

### IBM Q Provider 0.5.0

<span id="id514" />

#### New Features

*   Some of the visualization and Jupyter tools, including gate/error map and backend information, have been moved from `qiskit-terra` to `qiskit-ibmq-provider`. They are now under the `qiskit.providers.ibmq.jupyter` and `qiskit.providers.ibmq.visualization`. In addition, you can now use `%iqx_dashboard` to get a dashboard that provides both job and backend information.

<span id="id515" />

#### Changed

*   JSON schema validation is no longer run by default on Qobj objects passed to `qiskit.providers.ibmq.IBMQBackend.run()`. This significantly speeds up the execution of the run() method. Qobj objects are still validated on the server side, and invalid Qobjs will continue to raise exceptions. To force local validation, set `validate_qobj=True` when you invoke `run()`.

<span id="qiskit-0-15-0" />

## Qiskit 0.15.0

<span id="id516" />

### Terra 0.12.0

<span id="id517" />

#### Prelude

The 0.12.0 release includes several new features and bug fixes. The biggest change for this release is the addition of support for parametric pulses to OpenPulse. These are Pulse commands which take parameters rather than sample points to describe a pulse. 0.12.0 is also the first release to include support for Python 3.8. It also marks the beginning of the deprecation for Python 3.5 support, which will be removed when the upstream community stops supporting it.

<span id="release-notes-0-12-0-new-features" />

<span id="id518" />

#### New Features

*   The pass [`qiskit.transpiler.passes.CSPLayout`](qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") was extended with two new parameters: `call_limit` and `time_limit`. These options allow limiting how long the pass will run. The option `call_limit` limits the number of times that the recursive function in the backtracking solver may be called. Similarly, `time_limit` limits how long (in seconds) the solver will be allowed to run. The defaults are `1000` calls and `10` seconds respectively.

*   `qiskit.pulse.Acquire` can now be applied to a single qubit. This makes pulse programming more consistent and easier to reason about, as now all operations apply to a single channel. For example:

    ```python
    acquire = Acquire(duration=10)
    schedule = Schedule()
    schedule.insert(60, acquire(AcquireChannel(0), MemorySlot(0), RegisterSlot(0)))
    schedule.insert(60, acquire(AcquireChannel(1), MemorySlot(1), RegisterSlot(1)))
    ```

*   A new method [`qiskit.transpiler.CouplingMap.draw()`](qiskit.transpiler.CouplingMap#draw "qiskit.transpiler.CouplingMap.draw") was added to [`qiskit.transpiler.CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") to generate a graphviz image from the coupling map graph. For example:

    ```python
    from qiskit.transpiler import CouplingMap

    coupling_map = CouplingMap(
        [[0, 1], [1, 0], [1, 2], [1, 3], [2, 1], [3, 1], [3, 4], [4, 3]])
    coupling_map.draw()
    ```

*   Parametric pulses have been added to OpenPulse. These are pulse commands which are parameterized and understood by the backend. Arbitrary pulse shapes are still supported by the SamplePulse Command. The new supported pulse classes are:

    > *   `qiskit.pulse.ConstantPulse`
    > *   `qiskit.pulse.Drag`
    > *   `qiskit.pulse.Gaussian`
    > *   `qiskit.pulse.GaussianSquare`

    They can be used like any other Pulse command. An example:

    ```python
    from qiskit.pulse import (Schedule, Gaussian, Drag, ConstantPulse,
                              GaussianSquare)

    sched = Schedule(name='parametric_demo')
    sched += Gaussian(duration=25, sigma=4, amp=0.5j)(DriveChannel(0))
    sched += Drag(duration=25, amp=0.1, sigma=5, beta=4)(DriveChannel(1))
    sched += ConstantPulse(duration=25, amp=0.3+0.1j)(DriveChannel(1))
    sched += GaussianSquare(duration=1500, amp=0.2, sigma=8,
                            width=140)(MeasureChannel(0)) << sched.duration
    ```

    The resulting schedule will be similar to a SamplePulse schedule built using `qiskit.pulse.pulse_lib`, however, waveform sampling will be performed by the backend. The method [`qiskit.pulse.Schedule.draw()`](qiskit.pulse.Schedule#draw "qiskit.pulse.Schedule.draw") can still be used as usual. However, the command will be converted to a `SamplePulse` with the `qiskit.pulse.ParametricPulse.get_sample_pulse()` method, so the pulse shown may not sample the continuous function the same way that the backend will.

    This feature can be used to construct Pulse programs for any backend, but the pulses will be converted to `SamplePulse` objects if the backend does not support parametric pulses. Backends which support them will have the following new attribute:

    ```python
    backend.configuration().parametric_pulses: List[str]
    # e.g. ['gaussian', 'drag', 'constant']
    ```

    Note that the backend does not need to support all of the parametric pulses defined in Qiskit.

    When the backend supports parametric pulses, and the Pulse schedule is built with them, the assembled Qobj is significantly smaller. The size of a PulseQobj built entirely with parametric pulses is dependent only on the number of instructions, whereas the size of a PulseQobj built otherwise will grow with the duration of the instructions (since every sample must be specified with a value).

*   Added utility functions, `qiskit.scheduler.measure()` and `qiskit.scheduler.measure_all()` to qiskit.scheduler module. These functions return a [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") object which measures qubits using OpenPulse. For example:

    ```python
    from qiskit.scheduler import measure, measure_all

    measure_q0_schedule = measure(qubits=[0], backend=backend)
    measure_all_schedule = measure_all(backend)
    measure_custom_schedule = measure(qubits=[0],
                                      inst_map=backend.defaults().instruction_schedule_map,
                                      meas_map=[[0]],
                                      qubit_mem_slots={0: 1})
    ```

*   Pulse [`qiskit.pulse.Schedule`](qiskit.pulse.Schedule "qiskit.pulse.Schedule") objects now have better representations that for simple schedules should be valid Python expressions.

*   The [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods [`qiskit.circuit.QuantumCircuit.measure_active()`](qiskit.circuit.QuantumCircuit#measure_active "qiskit.circuit.QuantumCircuit.measure_active"), [`qiskit.circuit.QuantumCircuit.measure_all()`](qiskit.circuit.QuantumCircuit#measure_all "qiskit.circuit.QuantumCircuit.measure_all"), and [`qiskit.circuit.QuantumCircuit.remove_final_measurements()`](qiskit.circuit.QuantumCircuit#remove_final_measurements "qiskit.circuit.QuantumCircuit.remove_final_measurements") now have an addition kwarg `inplace`. When `inplace` is set to `False` the function will return a modified **copy** of the circuit. This is different from the default behavior which will modify the circuit object in-place and return nothing.

*   Several new constructor methods were added to the [`qiskit.transpiler.CouplingMap`](qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") class for building objects with basic qubit coupling graphs. The new constructor methods are:

    > *   [`qiskit.transpiler.CouplingMap.from_full()`](qiskit.transpiler.CouplingMap#from_full "qiskit.transpiler.CouplingMap.from_full")
    > *   [`qiskit.transpiler.CouplingMap.from_line()`](qiskit.transpiler.CouplingMap#from_line "qiskit.transpiler.CouplingMap.from_line")
    > *   [`qiskit.transpiler.CouplingMap.from_ring()`](qiskit.transpiler.CouplingMap#from_ring "qiskit.transpiler.CouplingMap.from_ring")
    > *   [`qiskit.transpiler.CouplingMap.from_grid()`](qiskit.transpiler.CouplingMap#from_grid "qiskit.transpiler.CouplingMap.from_grid")

    For example, to use the new constructors to get a coupling map of 5 qubits connected in a linear chain you can now run:

    ```python
    from qiskit.transpiler import CouplingMap

    coupling_map = CouplingMap.from_line(5)
    coupling_map.draw()
    ```

*   Introduced a new pass [`qiskit.transpiler.passes.CrosstalkAdaptiveSchedule`](qiskit.transpiler.passes.CrosstalkAdaptiveSchedule "qiskit.transpiler.passes.CrosstalkAdaptiveSchedule"). This pass aims to reduce the impact of crosstalk noise on a program. It uses crosstalk characterization data from the backend to schedule gates. When a pair of gates has high crosstalk, they get serialized using a barrier. Naive serialization is harmful because it incurs decoherence errors. Hence, this pass uses a SMT optimization approach to compute a schedule which minimizes the impact of crosstalk as well as decoherence errors.

    The pass takes as input a circuit which is already transpiled onto the backend i.e., the circuit is expressed in terms of physical qubits and swap gates have been inserted and decomposed into CNOTs if required. Using this circuit and crosstalk characterization data, a [Z3 optimization](https://github.com/Z3Prover/z3) is used to construct a new scheduled circuit as output.

    To use the pass on a circuit circ:

    ```python
    dag = circuit_to_dag(circ)
    pass_ = CrosstalkAdaptiveSchedule(backend_prop, crosstalk_prop)
    scheduled_dag = pass_.run(dag)
    scheduled_circ = dag_to_circuit(scheduled_dag)
    ```

    `backend_prop` is a [`qiskit.providers.models.BackendProperties`](qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") object for the target backend. `crosstalk_prop` is a dict which specifies conditional error rates. For two gates `g1` and `g2`, `crosstalk_prop[g1][g2]` specifies the conditional error rate of `g1` when `g1` and `g2` are executed simultaneously. A method for generating `crosstalk_prop` will be added in a future release of qiskit-ignis. Until then you’ll either have to already know the crosstalk properties of your device, or manually write your own device characterization experiments.

*   In the preset pass manager for optimization level 1, [`qiskit.transpiler.preset_passmanagers.level_1_pass_manager()`](transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager") if [`qiskit.transpiler.passes.TrivialLayout`](qiskit.transpiler.passes.TrivialLayout "qiskit.transpiler.passes.TrivialLayout") layout pass is not a perfect match for a particular circuit, then [`qiskit.transpiler.passes.DenseLayout`](qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") layout pass is used instead.

*   Added a new abstract method [`qiskit.quantum_info.Operator.dot()`](qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot") to the abstract `BaseOperator` class, so it is included for all implementations of that abstract class, including [`qiskit.quantum_info.Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") and `QuantumChannel` (e.g., [`qiskit.quantum_info.Choi`](qiskit.quantum_info.Choi "qiskit.quantum_info.Choi")) objects. This method returns the right operator multiplication `a.dot(b)` $= a \cdot b$. This is equivalent to calling the operator [`qiskit.quantum_info.Operator.compose()`](qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose") method with the kwarg `front` set to `True`.

*   Added [`qiskit.quantum_info.average_gate_fidelity()`](quantum_info#qiskit.quantum_info.average_gate_fidelity "qiskit.quantum_info.average_gate_fidelity") and [`qiskit.quantum_info.gate_error()`](quantum_info#qiskit.quantum_info.gate_error "qiskit.quantum_info.gate_error") functions to the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module for working with [`qiskit.quantum_info.Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") and `QuantumChannel` (e.g., [`qiskit.quantum_info.Choi`](qiskit.quantum_info.Choi "qiskit.quantum_info.Choi")) objects.

*   Added the [`qiskit.quantum_info.partial_trace()`](quantum_info#qiskit.quantum_info.partial_trace "qiskit.quantum_info.partial_trace") function to the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") that works with [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") quantum state classes. For example:

    ```python
    from qiskit.quantum_info.states import Statevector
    from qiskit.quantum_info.states import DensityMatrix
    from qiskit.quantum_info.states import partial_trace

    psi = Statevector.from_label('10+')
    partial_trace(psi, [0, 1])
    rho = DensityMatrix.from_label('10+')
    partial_trace(rho, [0, 1])
    ```

*   When [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") or [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") is called with the `with_layout` kwarg set True (the default) the output visualization will now display the physical qubits as integers to clearly distinguish them from the virtual qubits.

    For Example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit import transpile
    from qiskit.test.mock import FakeVigo

    qc = QuantumCircuit(3)
    qc.h(0)
    qc.cx(0, 1)
    qc.cx(0, 2)
    transpiled_qc = transpile(qc, FakeVigo())
    transpiled_qc.draw(output='mpl')
    ```

*   Added new state measure functions to the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module: [`qiskit.quantum_info.entropy()`](quantum_info#qiskit.quantum_info.entropy "qiskit.quantum_info.entropy"), [`qiskit.quantum_info.mutual_information()`](quantum_info#qiskit.quantum_info.mutual_information "qiskit.quantum_info.mutual_information"), [`qiskit.quantum_info.concurrence()`](quantum_info#qiskit.quantum_info.concurrence "qiskit.quantum_info.concurrence"), and [`qiskit.quantum_info.entanglement_of_formation()`](quantum_info#qiskit.quantum_info.entanglement_of_formation "qiskit.quantum_info.entanglement_of_formation"). These functions work with the [`qiskit.quantum_info.Statevector`](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes.

*   The decomposition methods for single-qubit gates in [`qiskit.quantum_info.synthesis.one_qubit_decompose.OneQubitEulerDecomposer`](qiskit.quantum_info.OneQubitEulerDecomposer "qiskit.quantum_info.synthesis.one_qubit_decompose.OneQubitEulerDecomposer") have been expanded to now also include the `'ZXZ'` basis, characterized by three rotations about the Z,X,Z axis. This now means that a general 2x2 Operator can be decomposed into following bases: `U3`, `U1X`, `ZYZ`, `ZXZ`, `XYX`, `ZXZ`.

<span id="release-notes-0-12-0-known-issues" />

<span id="id519" />

#### Known Issues

*   Running functions that use [`qiskit.tools.parallel_map()`](tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") (for example `qiskit.execute.execute()`, [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), and [`qiskit.transpiler.PassManager.run()`](qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run")) may not work when called from a script running outside of a `if __name__ == '__main__':` block when using Python 3.8 on MacOS. Other environments are unaffected by this issue. This is due to changes in how parallel processes are launched by Python 3.8 on MacOS. If `RuntimeError` or `AttributeError` are raised by scripts that are directly calling `parallel_map()` or when calling a function that uses it internally with Python 3.8 on MacOS embedding the script calls inside `if __name__ == '__main__':` should workaround the issue. For example:

    ```python
    from qiskit import QuantumCircuit, QiskitError
    from qiskit import execute, BasicAer

    qc1 = QuantumCircuit(2, 2)
    qc1.h(0)
    qc1.cx(0, 1)
    qc1.measure([0,1], [0,1])
    # making another circuit: superpositions
    qc2 = QuantumCircuit(2, 2)
    qc2.h([0,1])
    qc2.measure([0,1], [0,1])
    execute([qc1, qc2], BasicAer.get_backend('qasm_simulator'))
    ```

    should be changed to:

    ```python
    from qiskit import QuantumCircuit, QiskitError
    from qiskit import execute, BasicAer

    def main():
        qc1 = QuantumCircuit(2, 2)
        qc1.h(0)
        qc1.cx(0, 1)
        qc1.measure([0,1], [0,1])
        # making another circuit: superpositions
        qc2 = QuantumCircuit(2, 2)
        qc2.h([0,1])
        qc2.measure([0,1], [0,1])
        execute([qc1, qc2], BasicAer.get_backend('qasm_simulator'))

    if __name__ == '__main__':
        main()
    ```

    if errors are encountered with Python 3.8 on MacOS.

<span id="release-notes-0-12-0-upgrade-notes" />

<span id="id520" />

#### Upgrade Notes

*   The value of the `rep_time` parameter for Pulse backend’s configuration object is now in units of seconds, not microseconds. The first time a `PulseBackendConfiguration` object is initialized it will raise a single warning to the user to indicate this.

*   The `rep_time` argument for [`qiskit.compiler.assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") now takes in a value in units of seconds, not microseconds. This was done to make the units with everything else in pulse. If you were passing in a value for `rep_time` ensure that you update the value to account for this change.

*   The value of the `base_gate` property of [`qiskit.circuit.ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") objects has been changed from the class of the base gate to an instance of the class of the base gate.

*   The `base_gate_name` property of [`qiskit.circuit.ControlledGate`](qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") has been removed; you can get the name of the base gate by accessing `base_gate.name` on the object. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.extensions import HGate

    qc = QuantumCircuit(3)
    cch_gate = HGate().control(2)
    base_gate_name = cch_gate.base_gate.name
    ```

*   Changed [`qiskit.quantum_info.Operator`](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") magic methods so that `__mul__` (which gets executed by python’s multiplication operation, if the left hand side of the operation has it defined) implements right matrix multiplication (i.e. [`qiskit.quantum_info.Operator.dot()`](qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot")), and `__rmul__` (which gets executed by python’s multiplication operation from the right hand side of the operation if the left does not have `__mul__` defined) implements scalar multiplication (i.e. `qiskit.quantum_info.Operator.multiply()`). Previously both methods implemented scalar multiplciation.

*   The second argument of the [`qiskit.quantum_info.process_fidelity()`](quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity") function, `target`, is now optional. If a target unitary is not specified, then process fidelity of the input channel with the identity operator will be returned.

*   [`qiskit.compiler.assemble()`](compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") will now respect the configured `max_shots` value for a backend. If a value for the `shots` kwarg is specified that exceed the max shots set in the backend configuration the function will now raise a `QiskitError` exception. Additionally, if no shots argument is provided the default value is either 1024 (the previous behavior) or `max_shots` from the backend, whichever is lower.

<span id="release-notes-0-12-0-deprecation-notes" />

<span id="id521" />

#### Deprecation Notes

*   Methods for adding gates to a [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with abbreviated keyword arguments (e.g. `ctl`, `tgt`) have had their keyword arguments renamed to be more descriptive (e.g. `control_qubit`, `target_qubit`). The old names have been deprecated. A table including the old and new calling signatures for the `QuantumCircuit` methods is included below.

    | Instruction Type                | Former Signature                    | New Signature                                           |
    | ------------------------------- | ----------------------------------- | ------------------------------------------------------- |
    | `qiskit.extensions.HGate`       | `qc.h(q)`                           | `qc.h(qubit)`                                           |
    | `qiskit.extensions.CHGate`      | `qc.ch(ctl, tgt)`                   | `qc.ch((control_qubit, target_qubit))`                  |
    | `qiskit.extensions.IdGate`      | `qc.iden(q)`                        | `qc.iden(qubit)`                                        |
    | `qiskit.extensions.RGate`       | `qc.iden(q)`                        | `qc.iden(qubit)`                                        |
    | `qiskit.extensions.RGate`       | `qc.r(theta, phi, q)`               | `qc.r(theta, phi, qubit)`                               |
    | `qiskit.extensions.RXGate`      | `qc.rx(theta, q)`                   | `qc.rx(theta, qubit)`                                   |
    | `qiskit.extensions.CrxGate`     | `qc.crx(theta, ctl, tgt)`           | `qc.crx(theta, control_qubit, target_qubit)`            |
    | `qiskit.extensions.RYGate`      | `qc.ry(theta, q)`                   | `qc.ry(theta, qubit)`                                   |
    | `qiskit.extensions.CryGate`     | `qc.cry(theta, ctl, tgt)`           | `qc.cry(theta, control_qubit, target_qubit)`            |
    | `qiskit.extensions.RZGate`      | `qc.rz(phi, q)`                     | `qc.rz(phi, qubit)`                                     |
    | `qiskit.extensions.CrzGate`     | `qc.crz(theta, ctl, tgt)`           | `qc.crz(theta, control_qubit, target_qubit)`            |
    | `qiskit.extensions.SGate`       | `qc.s(q)`                           | `qc.s(qubit)`                                           |
    | `qiskit.extensions.SdgGate`     | `qc.sdg(q)`                         | `qc.sdg(qubit)`                                         |
    | `qiskit.extensions.FredkinGate` | `qc.cswap(ctl, tgt1, tgt2)`         | `qc.cswap(control_qubit, target_qubit1, target_qubit2)` |
    | `qiskit.extensions.TGate`       | `qc.t(q)`                           | `qc.t(qubit)`                                           |
    | `qiskit.extensions.TdgGate`     | `qc.tdg(q)`                         | `qc.tdg(qubit)`                                         |
    | `qiskit.extensions.U1Gate`      | `qc.u1(theta, q)`                   | `qc.u1(theta, qubit)`                                   |
    | `qiskit.extensions.Cu1Gate`     | `qc.cu1(theta, ctl, tgt)`           | `qc.cu1(theta, control_qubit, target_qubit)`            |
    | `qiskit.extensions.U2Gate`      | `qc.u2(phi, lam, q)`                | `qc.u2(phi, lam, qubit)`                                |
    | `qiskit.extensions.U3Gate`      | `qc.u3(theta, phi, lam, q)`         | `qc.u3(theta, phi, lam, qubit)`                         |
    | `qiskit.extensions.Cu3Gate`     | `qc.cu3(theta, phi, lam, ctl, tgt)` | `qc.cu3(theta, phi, lam, control_qubit, target_qubit)`  |
    | `qiskit.extensions.XGate`       | `qc.x(q)`                           | `qc.x(qubit)`                                           |
    | `qiskit.extensions.CnotGate`    | `qc.cx(ctl, tgt)`                   | `qc.cx(control_qubit, target_qubit)`                    |
    | `qiskit.extensions.ToffoliGate` | `qc.ccx(ctl1, ctl2, tgt)`           | `qc.ccx(control_qubit1, control_qubit2, target_qubit)`  |
    | `qiskit.extensions.YGate`       | `qc.y(q)`                           | `qc.y(qubit)`                                           |
    | `qiskit.extensions.CyGate`      | `qc.cy(ctl, tgt)`                   | `qc.cy(control_qubit, target_qubit)`                    |
    | `qiskit.extensions.ZGate`       | `qc.z(q)`                           | `qc.z(qubit)`                                           |
    | `qiskit.extensions.CzGate`      | `qc.cz(ctl, tgt)`                   | `qc.cz(control_qubit, target_qubit)`                    |

*   Running `qiskit.pulse.Acquire` on multiple qubits has been deprecated and will be removed in a future release. Additionally, the `qiskit.pulse.AcquireInstruction` parameters `mem_slots` and `reg_slots` have been deprecated. Instead `reg_slot` and `mem_slot` should be used instead.

*   The attribute of the [`qiskit.providers.models.PulseDefaults`](qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") class `circuit_instruction_map` has been deprecated and will be removed in a future release. Instead you should use the new attribute `instruction_schedule_map`. This was done to match the type of the value of the attribute, which is an `InstructionScheduleMap`.

*   The `qiskit.pulse.PersistentValue` command is deprecated and will be removed in a future release. Similar functionality can be achieved with the `qiskit.pulse.ConstantPulse` command (one of the new parametric pulses). Compare the following:

    ```python
    from qiskit.pulse import Schedule, PersistentValue, ConstantPulse, \
                             DriveChannel

    # deprecated implementation
    sched_w_pv = Schedule()
    sched_w_pv += PersistentValue(value=0.5)(DriveChannel(0))
    sched_w_pv += PersistentValue(value=0)(DriveChannel(0)) << 10

    # preferred implementation
    sched_w_const = Schedule()
    sched_w_const += ConstantPulse(duration=10, amp=0.5)(DriveChannel(0))
    ```

*   Python 3.5 support in qiskit-terra is deprecated. Support will be removed in the first release after the upstream Python community’s end of life date for the version, which is 09/13/2020.

*   The `require_cptp` kwarg of the [`qiskit.quantum_info.process_fidelity()`](quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity") function has been deprecated and will be removed in a future release. It is superseded by two separate kwargs `require_cp` and `require_tp`.

*   Setting the `scale` parameter for [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") as the first positional argument is deprecated and will be removed in a future release. Instead you should use `scale` as keyword argument.

*   The `qiskit.tools.qi.qi` module is deprecated and will be removed in a future release. The legacy functions in the module have all been superseded by functions and classes in the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module. A table of the deprecated functions and their replacement are below:

    | Deprecated                                 | Replacement                                                                                                                                                     |
    | ------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `qiskit.tools.partial_trace()`             | [`qiskit.quantum_info.partial_trace()`](quantum_info#qiskit.quantum_info.partial_trace "qiskit.quantum_info.partial_trace")                                     |
    | `qiskit.tools.choi_to_pauli()`             | [`qiskit.quantum_info.Choi`](qiskit.quantum_info.Choi "qiskit.quantum_info.Choi") and `quantum_info.PTM`                                                        |
    | `qiskit.tools.chop()`                      | `numpy.round`                                                                                                                                                   |
    | `qiskit.tools.qi.qi.outer`                 | `numpy.outer`                                                                                                                                                   |
    | `qiskit.tools.concurrence()`               | [`qiskit.quantum_info.concurrence()`](quantum_info#qiskit.quantum_info.concurrence "qiskit.quantum_info.concurrence")                                           |
    | `qiskit.tools.shannon_entropy()`           | [`qiskit.quantum_info.shannon_entropy()`](quantum_info#qiskit.quantum_info.shannon_entropy "qiskit.quantum_info.shannon_entropy")                               |
    | `qiskit.tools.entropy()`                   | [`qiskit.quantum_info.entropy()`](quantum_info#qiskit.quantum_info.entropy "qiskit.quantum_info.entropy")                                                       |
    | `qiskit.tools.mutual_information()`        | [`qiskit.quantum_info.mutual_information()`](quantum_info#qiskit.quantum_info.mutual_information "qiskit.quantum_info.mutual_information")                      |
    | `qiskit.tools.entanglement_of_formation()` | [`qiskit.quantum_info.entanglement_of_formation()`](quantum_info#qiskit.quantum_info.entanglement_of_formation "qiskit.quantum_info.entanglement_of_formation") |
    | `qiskit.tools.is_pos_def()`                | `quantum_info.operators.predicates.is_positive_semidefinite_matrix`                                                                                             |

*   The `qiskit.quantum_info.states.states` module is deprecated and will be removed in a future release. The legacy functions in the module have all been superseded by functions and classes in the [`qiskit.quantum_info`](quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module.

    | Deprecated                                      | Replacement                                                                                                                               |
    | ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
    | `qiskit.quantum_info.states.states.basis_state` | [`qiskit.quantum_info.Statevector.from_label()`](qiskit.quantum_info.Statevector#from_label "qiskit.quantum_info.Statevector.from_label") |
    | `qiskit.quantum_info.states.states.projector`   | [`qiskit.quantum_info.DensityMatrix`](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix")                              |

*   The `scaling` parameter of the `draw()` method for the `Schedule` and `Pulse` objects was deprecated and will be removed in a future release. Instead the new `scale` parameter should be used. This was done to have a consistent argument between pulse and circuit drawings. For example:

    ```python
    #The consistency in parameters is seen below
    #For circuits
    circuit = QuantumCircuit()
    circuit.draw(scale=0.2)
    #For pulses
    pulse = SamplePulse()
    pulse.draw(scale=0.2)
    #For schedules
    schedule = Schedule()
    schedule.draw(scale=0.2)
    ```

<span id="release-notes-0-12-0-bug-fixes" />

<span id="id522" />

#### Bug Fixes

*   Previously, calling [`qiskit.circuit.QuantumCircuit.bind_parameters()`](qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") prior to decomposing a circuit would result in the bound values not being correctly substituted into the decomposed gates. This has been resolved such that binding and decomposition may occur in any order. Fixes [issue #2482](https://github.com/Qiskit/qiskit-terra/issues/2482) and [issue #3509](https://github.com/Qiskit/qiskit-terra/issues/3509)
*   The `Collect2qBlocks` pass had previously not considered classical conditions when determining whether to include a gate within an existing block. In some cases, this resulted in classical conditions being lost when transpiling with `optimization_level=3`. This has been resolved so that classically conditioned gates are never included in a block. Fixes [issue #3215](https://github.com/Qiskit/qiskit-terra/issues/3215)
*   All the output types for the circuit drawers in [`qiskit.circuit.QuantumCircuit.draw()`](qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") and [`qiskit.visualization.circuit_drawer()`](qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") have fixed and/or improved support for drawing controlled custom gates. Fixes [issue #3546](https://github.com/Qiskit/qiskit-terra/issues/3546), [issue #3763](https://github.com/Qiskit/qiskit-terra/issues/3763), and [issue #3764](https://github.com/Qiskit/qiskit-terra/issues/3764)
*   Explanation and examples have been added to documentation for the [`qiskit.circuit.QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods for adding gates: [`qiskit.circuit.QuantumCircuit.ccx()`](qiskit.circuit.QuantumCircuit#ccx "qiskit.circuit.QuantumCircuit.ccx"), [`qiskit.circuit.QuantumCircuit.ch()`](qiskit.circuit.QuantumCircuit#ch "qiskit.circuit.QuantumCircuit.ch"), [`qiskit.circuit.QuantumCircuit.crz()`](qiskit.circuit.QuantumCircuit#crz "qiskit.circuit.QuantumCircuit.crz"), [`qiskit.circuit.QuantumCircuit.cswap()`](qiskit.circuit.QuantumCircuit#cswap "qiskit.circuit.QuantumCircuit.cswap"), `qiskit.circuit.QuantumCircuit.cu1()`, `qiskit.circuit.QuantumCircuit.cu3()`, [`qiskit.circuit.QuantumCircuit.cx()`](qiskit.circuit.QuantumCircuit#cx "qiskit.circuit.QuantumCircuit.cx"), [`qiskit.circuit.QuantumCircuit.cy()`](qiskit.circuit.QuantumCircuit#cy "qiskit.circuit.QuantumCircuit.cy"), [`qiskit.circuit.QuantumCircuit.cz()`](qiskit.circuit.QuantumCircuit#cz "qiskit.circuit.QuantumCircuit.cz"), [`qiskit.circuit.QuantumCircuit.h()`](qiskit.circuit.QuantumCircuit#h "qiskit.circuit.QuantumCircuit.h"), `qiskit.circuit.QuantumCircuit.iden()`, [`qiskit.circuit.QuantumCircuit.rx()`](qiskit.circuit.QuantumCircuit#rx "qiskit.circuit.QuantumCircuit.rx"), [`qiskit.circuit.QuantumCircuit.ry()`](qiskit.circuit.QuantumCircuit#ry "qiskit.circuit.QuantumCircuit.ry"), [`qiskit.circuit.QuantumCircuit.rz()`](qiskit.circuit.QuantumCircuit#rz "qiskit.circuit.QuantumCircuit.rz"), [`qiskit.circuit.QuantumCircuit.s()`](qiskit.circuit.QuantumCircuit#s "qiskit.circuit.QuantumCircuit.s"), [`qiskit.circuit.QuantumCircuit.sdg()`](qiskit.circuit.QuantumCircuit#sdg "qiskit.circuit.QuantumCircuit.sdg"), [`qiskit.circuit.QuantumCircuit.swap()`](qiskit.circuit.QuantumCircuit#swap "qiskit.circuit.QuantumCircuit.swap"), [`qiskit.circuit.QuantumCircuit.t()`](qiskit.circuit.QuantumCircuit#t "qiskit.circuit.QuantumCircuit.t"), [`qiskit.circuit.QuantumCircuit.tdg()`](qiskit.circuit.QuantumCircuit#tdg "qiskit.circuit.QuantumCircuit.tdg"), `qiskit.circuit.QuantumCircuit.u1()`, `qiskit.circuit.QuantumCircuit.u2()`, `qiskit.circuit.QuantumCircuit.u3()`, [`qiskit.circuit.QuantumCircuit.x()`](qiskit.circuit.QuantumCircuit#x "qiskit.circuit.QuantumCircuit.x"), [`qiskit.circuit.QuantumCircuit.y()`](qiskit.circuit.QuantumCircuit#y "qiskit.circuit.QuantumCircuit.y"), [`qiskit.circuit.QuantumCircuit.z()`](qiskit.circuit.QuantumCircuit#z "qiskit.circuit.QuantumCircuit.z"). Fixes [issue #3400](https://github.com/Qiskit/qiskit-terra/issues/3400)
*   Fixes for handling of complex number parameter in circuit visualization. Fixes [issue #3640](https://github.com/Qiskit/qiskit-terra/issues/3640)

<span id="release-notes-0-12-0-other-notes" />

<span id="id523" />

#### Other Notes

*   The transpiler passes in the [`qiskit.transpiler.passes`](transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") directory have been organized into subdirectories to better categorize them by functionality. They are still all accessible under the `qiskit.transpiler.passes` namespace.

<span id="id524" />

### Aer 0.4.0

<span id="id525" />

#### Added

> *   Added `NoiseModel.from_backend` for building a basic device noise model for an IBMQ backend (#569)
> *   Added multi-GPU enabled simulation methods to the `QasmSimulator`, `StatevectorSimulator`, and `UnitarySimulator`. The qasm simulator has gpu version of the density matrix and statevector methods and can be accessed using `"method": "density_matrix_gpu"` or `"method": "statevector_gpu"` in `backend_options`. The statevector simulator gpu method can be accessed using `"method": "statevector_gpu"`. The unitary simulator GPU method can be accessed using `"method": "unitary_gpu"`. These backends use CUDA and require an NVidia GPU.(#544)
> *   Added `PulseSimulator` backend (#542)
> *   Added `PulseSystemModel` and `HamiltonianModel` classes to represent models to be used in `PulseSimulator` (#496, #493)
> *   Added `duffing_model_generators` to generate `PulseSystemModel` objects from a list of parameters (#516)
> *   Migrated ODE function solver to C++ (#442, #350)
> *   Added high level pulse simulator tests (#379)
> *   CMake BLAS\_LIB\_PATH flag to set path to look for BLAS lib (#543)

<span id="id526" />

#### Changed

> *   Changed the structure of the `src` directory to organise simulator source code. Simulator controller headers were moved to `src/controllers` and simulator method State headers are in `src/simulators` (#544)
> *   Moved the location of several functions (#568): \* Moved contents of `qiskit.provider.aer.noise.errors` into the `qiskit.providers.noise` module \* Moved contents of `qiskit.provider.aer.noise.utils` into the `qiskit.provider.aer.utils` module.
> *   Enabled optimization to aggregate consecutive gates in a circuit (fusion) by default (#579).

<span id="id527" />

#### Deprecated

> *   Deprecated `utils.qobj_utils` functions (#568)
> *   Deprecated `qiskit.providers.aer.noise.device.basic_device_noise_model`. It is superseded by the `NoiseModel.from_backend` method (#569)

#### Removed

> *   Removed `NoiseModel.as_dict`, `QuantumError.as_dict`, `ReadoutError.as_dict`, and `QuantumError.kron` methods that were deprecated in 0.3 (#568).

<span id="ignis-0-2" />

### Ignis 0.2

No Change

<span id="aqua-0-6" />

### Aqua 0.6

No Change

<span id="ibm-q-provider-0-4-6" />

### IBM Q Provider 0.4.6

<span id="id528" />

#### Added

*   Several new methods were added to `IBMQBackend`:

    > *   `wait_for_final_state()` blocks until the job finishes. It takes a callback function that it will invoke after every query to provide feedback.
    > *   `active_jobs()` returns the jobs submitted to a backend that are currently in an unfinished status.
    > *   `job_limit()` returns the job limit for a backend.
    > *   `remaining_jobs_count()` returns the number of jobs that you can submit to the backend before job limit is reached.

*   `QueueInfo` now has a new `format()` method that returns a formatted string of the queue information.

*   `IBMQJob` now has three new methods: `done()`, `running()`, and `cancelled()` that are used to indicate job status.

*   `qiskit.providers.ibmq.ibmqbackend.IBMQBackend.run()` now accepts an optional job\_tags parameter. If specified, the job\_tags are assigned to the job, which can later be used as a filter in `qiskit.providers.ibmq.ibmqbackend.IBMQBackend.jobs()`.

*   `IBMQJobManager` now has a new method `retrieve_job_set()` that allows you to retrieve a previously submitted job set using the job set ID.

<span id="id529" />

#### Changed

*   The `Exception` hierarchy has been refined with more specialized classes. You can, however, continue to catch their parent exceptions (such as `IBMQAccountError`). Also, the exception class `IBMQApiUrlError` has been replaced by `IBMQAccountCredentialsInvalidUrl` and `IBMQAccountCredentialsInvalidToken`.

<span id="id530" />

#### Deprecated

*   The use of proxy urls without a protocol (e.g. `http://`) is deprecated due to recent Python changes.

<span id="qiskit-0-14-0" />

## Qiskit 0.14.0

<span id="terra-0-11-0" />

### Terra 0.11.0

<span id="release-notes-0-11-0-prelude" />

<span id="id531" />

#### Prelude

The 0.11.0 release includes several new features and bug fixes. The biggest change for this release is the addition of the pulse scheduler. This allows users to define their quantum program as a `QuantumCircuit` and then map it to the underlying pulse instructions that will control the quantum hardware to implement the circuit.

<span id="release-notes-0-11-0-new-features" />

<span id="id532" />

#### New Features

*   Added 5 new commands to easily retrieve user-specific data from `BackendProperties`: `gate_property`, `gate_error`, `gate_length`, `qubit_property`, `t1`, `t2`, `readout_error` and `frequency`. They return the specific values of backend properties. For example:

    ```python
    from qiskit.test.mock import FakeOurense
    backend = FakeOurense()
    properties = backend.properties()

    gate_property = properties.gate_property('u1')
    gate_error = properties.gate_error('u1', 0)
    gate_length = properties.gate_length('u1', 0)
    qubit_0_property = properties.qubit_property(0)
    t1_time_0 = properties.t1(0)
    t2_time_0 = properties.t2(0)
    readout_error_0 = properties.readout_error(0)
    frequency_0 = properties.frequency(0)
    ```

*   Added method `Instruction.is_parameterized()` to check if an instruction object is parameterized. This method returns `True` if and only if instruction has a `ParameterExpression` or `Parameter` object for one of its params.

*   Added a new analysis pass `Layout2qDistance`. This pass allows to “score” a layout selection, once `property_set['layout']` is set. The score will be the sum of distances for each two-qubit gate in the circuit, when they are not directly connected. This scoring does not consider direction in the coupling map. The lower the number, the better the layout selection is.

    For example, consider a linear coupling map `[0]--[2]--[1]` and the following circuit:

    ```python
    qr = QuantumRegister(2, 'qr')
    circuit = QuantumCircuit(qr)
    circuit.cx(qr[0], qr[1])
    ```

    If the layout is `{qr[0]:0, qr[1]:1}`, `Layout2qDistance` will set `property_set['layout_score'] = 1`. If the layout is `{qr[0]:0, qr[1]:2}`, then the result is `property_set['layout_score'] = 0`. The lower the score, the better.

*   Added `qiskit.QuantumCircuit.cnot` as an alias for the `cx` method of `QuantumCircuit`. The names `cnot` and `cx` are often used interchangeably now the cx method can be called with either name.

*   Added `qiskit.QuantumCircuit.toffoli` as an alias for the `ccx` method of `QuantumCircuit`. The names `toffoli` and `ccx` are often used interchangeably now the ccx method can be called with either name.

*   Added `qiskit.QuantumCircuit.fredkin` as an alias for the `cswap` method of `QuantumCircuit`. The names `fredkin` and `cswap` are often used interchangeably now the cswap method can be called with either name.

*   The `latex` output mode for `qiskit.visualization.circuit_drawer()` and the `qiskit.circuit.QuantumCircuit.draw()` method now has a mode to passthrough raw latex from gate labels and parameters. The syntax for doing this mirrors matplotlib’s [mathtext mode](https://matplotlib.org/tutorials/text/mathtext.html) syntax. Any portion of a label string between a pair of ‘\$’ characters will be treated as raw latex and passed directly into the generated output latex. This can be leveraged to add more advanced formatting to circuit diagrams generated with the latex drawer.

    Prior to this release all gate labels were run through a utf8 -> latex conversion to make sure that the output latex would compile the string as expected. This is still what happens for all portions of a label outside the ‘\$’ pair. Also if you want to use a dollar sign in your label make sure you escape it in the label string (ie `'\$'`).

    You can mix and match this passthrough with the utf8 -> latex conversion to create the exact label you want, for example:

    ```python
    from qiskit import circuit
    circ = circuit.QuantumCircuit(2)
    circ.h([0, 1])
    circ.append(circuit.Gate(name='α_gate', num_qubits=1, params=[0]), [0])
    circ.append(circuit.Gate(name='α_gate$_2$', num_qubits=1, params=[0]), [1])
    circ.append(circuit.Gate(name='\$α\$_gate', num_qubits=1, params=[0]), [1])
    circ.draw(output='latex')
    ```

    will now render the first custom gate’s label as `α_gate`, the second will be `α_gate` with a 2 subscript, and the last custom gate’s label will be `$α$_gate`.

*   Add `ControlledGate` class for representing controlled gates. Controlled gate instances are created with the `control(n)` method of `Gate` objects where `n` represents the number of controls. The control qubits come before the controlled qubits in the new gate. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.extensions import HGate
    hgate = HGate()
    circ = QuantumCircuit(4)
    circ.append(hgate.control(3), [0, 1, 2, 3])
    print(circ)
    ```

    generates:

    ```python
    q_0: |0>──■──
              │
    q_1: |0>──■──
              │
    q_2: |0>──■──
            ┌─┴─┐
    q_3: |0>┤ H ├
            └───┘
    ```

*   Allowed values of `meas_level` parameters and fields can now be a member from the IntEnum class `qiskit.qobj.utils.MeasLevel`. This can be used when calling `execute` (or anywhere else `meas_level` is specified) with a pulse experiment. For example:

    ```python
    from qiskit import QuantumCircuit, transpile, schedule, execute
    from qiskit.test.mock import FakeOpenPulse2Q
    from qiskit.qobj.utils import MeasLevel, MeasReturnType

    backend = FakeOpenPulse2Q()
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0,1)
    qc_transpiled = transpile(qc, backend)
    sched = schedule(qc_transpiled, backend)
    execute(sched, backend, meas_level=MeasLevel.CLASSIFIED)
    ```

    In this above example, `meas_level=MeasLevel.CLASSIFIED` and `meas_level=2` can be used interchangably now.

*   A new layout selector based on constraint solving is included. CSPLayout models the problem of finding a layout as a constraint problem and uses recursive backtracking to solve it.

    ```python
    cmap16 = CouplingMap(FakeRueschlikon().configuration().coupling_map)

    qr = QuantumRegister(5, 'q')
    circuit = QuantumCircuit(qr)
    circuit.cx(qr[0], qr[1])
    circuit.cx(qr[0], qr[2])
    circuit.cx(qr[0], qr[3])

    pm = PassManager(CSPLayout(cmap16))
    circuit_after = pm.run(circuit)
    print(pm.property_set['layout'])
    ```

    ```python
    Layout({
    1: Qubit(QuantumRegister(5, 'q'), 1),
    2: Qubit(QuantumRegister(5, 'q'), 0),
    3: Qubit(QuantumRegister(5, 'q'), 3),
    4: Qubit(QuantumRegister(5, 'q'), 4),
    15: Qubit(QuantumRegister(5, 'q'), 2)
    })
    ```

    The parameter `CSPLayout(...,strict_direction=True)` is more restrictive but it will guarantee there is no need of running `CXDirection` after.

    ```python
    pm = PassManager(CSPLayout(cmap16, strict_direction=True))
    circuit_after = pm.run(circuit)
    print(pm.property_set['layout'])
    ```

    ```python
    Layout({
    8: Qubit(QuantumRegister(5, 'q'), 4),
    11: Qubit(QuantumRegister(5, 'q'), 3),
    5: Qubit(QuantumRegister(5, 'q'), 1),
    6: Qubit(QuantumRegister(5, 'q'), 0),
    7: Qubit(QuantumRegister(5, 'q'), 2)
    })
    ```

    If the constraint system is not solvable, the layout property is not set.

    ```python
    circuit.cx(qr[0], qr[4])
    pm = PassManager(CSPLayout(cmap16))
    circuit_after = pm.run(circuit)
    print(pm.property_set['layout'])
    ```

    ```python
    None
    ```

*   PulseBackendConfiguration (accessed normally as backend.configuration()) has been extended with useful methods to explore its data and the functionality that exists in PulseChannelSpec. PulseChannelSpec will be deprecated in the future. For example:

    ```python
    backend = provider.get_backend(backend_name)
    config = backend.configuration()
    q0_drive = config.drive(0)  # or, DriveChannel(0)
    q0_meas = config.measure(0)  # MeasureChannel(0)
    q0_acquire = config.acquire(0)  # AcquireChannel(0)
    config.hamiltonian  # Returns a dictionary with hamiltonian info
    config.sample_rate()  # New method which returns 1 / dt
    ```

*   `PulseDefaults` (accessed normally as `backend.defaults()`) has an attribute, `circuit_instruction_map` which has the methods of CmdDef. The new circuit\_instruction\_map is an `InstructionScheduleMap` object with three new functions beyond what CmdDef had:

    > *   qubit\_instructions(qubits) returns the operations defined for the qubits
    > *   assert\_has(instruction, qubits) raises an error if the op isn’t defined
    > *   remove(instruction, qubits) like pop, but doesn’t require parameters

    There are some differences from the CmdDef:

    > *   `__init__` takes no arguments
    > *   `cmds` and `cmd_qubits` are deprecated and replaced with `instructions` and `qubits_with_instruction`

    Example:

    ```python
    backend = provider.get_backend(backend_name)
    inst_map = backend.defaults().circuit_instruction_map
    qubit = inst_map.qubits_with_instruction('u3')[0]
    x_gate = inst_map.get('u3', qubit, P0=np.pi, P1=0, P2=np.pi)
    pulse_schedule = x_gate(DriveChannel(qubit))
    ```

*   A new kwarg parameter, `show_framechange_channels` to optionally disable displaying channels with only framechange instructions in pulse visualizations was added to the `qiskit.visualization.pulse_drawer()` function and `qiskit.pulse.Schedule.draw()` method. When this new kwarg is set to `False` the output pulse schedule visualization will not include any channels that only include frame changes.

    For example:

    ```python
    from qiskit.pulse import *
    from qiskit.pulse import library as pulse_lib

    gp0 = pulse_lib.gaussian(duration=20, amp=1.0, sigma=1.0)
    sched = Schedule()
    channel_a = DriveChannel(0)
    channel_b = DriveChannel(1)
    sched += Play(gp0, channel_a)
    sched = sched.insert(60, ShiftPhase(-1.57, channel_a))
    sched = sched.insert(30, ShiftPhase(-1.50, channel_b))
    sched = sched.insert(70, ShiftPhase(1.50, channel_b))

    sched.draw(show_framechange_channels=False)
    ```

*   A new utility function `qiskit.result.marginal_counts()` is added which allows marginalization of the counts over some indices of interest. This is useful when more qubits are measured than needed, and one wishes to get the observation counts for some subset of them only.

*   When `passmanager.run(...)` is invoked with more than one circuit, the transpilation of these circuits will run in parallel.

*   PassManagers can now be sliced to create a new PassManager containing a subset of passes using the square bracket operator. This allow running or drawing a portion of the PassManager for easier testing and visualization. For example let’s try to draw the first 3 passes of a PassManager pm, or run just the second pass on our circuit:

    ```python
    pm[0:4].draw()
    circuit2 = pm[1].run(circuit)
    ```

    Also now, PassManagers can be created by adding two PassManagers or by directly adding a pass/list of passes to a PassManager.

    ```python
    pm = pm1[0] + pm2[1:3]
    pm += [setLayout, unroller]
    ```

*   A basic `scheduler` module has now been added to Qiskit. The scheduler schedules an input transpiled `QuantumCircuit` into a pulse `Schedule`. The scheduler accepts as input a `Schedule` and either a pulse `Backend`, or a `CmdDef` which relates circuit `Instruction` objects on specific qubits to pulse Schedules and a `meas_map` which determines which measurements must occur together.

    Scheduling example:

    ```python
    from qiskit import QuantumCircuit, transpile, schedule
    from qiskit.test.mock import FakeOpenPulse2Q

    backend = FakeOpenPulse2Q()
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0,1)
    qc_transpiled = transpile(qc, backend)
    schedule(qc_transpiled, backend)
    ```

    The scheduler currently supports two scheduling policies, as\_late\_as\_possible (`alap`) and as\_soon\_as\_possible (`asap`), which respectively schedule pulse instructions to occur as late as possible or as soon as possible across qubits in a circuit. The scheduling policy may be selected with the input argument `method`, for example:

    ```python
    schedule(qc_transpiled, backend, method='alap')
    ```

    It is easy to use a pulse `Schedule` within a `QuantumCircuit` by mapping it to a custom circuit instruction such as a gate which may be used in a `QuantumCircuit`. To do this, first, define the custom gate and then add an entry into the `CmdDef` for the gate, for each qubit that the gate will be applied to. The gate can then be used in the `QuantumCircuit`. At scheduling time the gate will be mapped to the underlying pulse schedule. Using this technique allows easy integration with preexisting qiskit modules such as Ignis.

    For example:

    ```python
    from qiskit import pulse, circuit, schedule
    from qiskit.pulse import pulse_lib

    custom_cmd_def = pulse.CmdDef()

    # create custom gate
    custom_gate = circuit.Gate(name='custom_gate', num_qubits=1, params=[])

    # define schedule for custom gate
    custom_schedule = pulse.Schedule()
    custom_schedule += pulse_lib.gaussian(20, 1.0, 10)(pulse.DriveChannel)

    # add schedule to custom gate with same name
    custom_cmd_def.add('custom_gate', (0,), custom_schedule)

    # use custom gate in a circuit
    custom_qc = circuit.QuantumCircuit(1)
    custom_qc.append(custom_gate, qargs=[0])

    # schedule the custom gate
    schedule(custom_qc, cmd_def=custom_cmd_def, meas_map=[[0]])
    ```

<span id="release-notes-0-11-0-known-issues" />

<span id="id533" />

#### Known Issues

*   The feature for transpiling in parallel when `passmanager.run(...)` is invoked with more than one circuit is not supported under Windows. See [#2988](https://github.com/Qiskit/qiskit-terra/issues/2988) for more details.

<span id="release-notes-0-11-0-upgrade-notes" />

<span id="id534" />

#### Upgrade Notes

*   The `qiskit.pulse.channels.SystemTopology` class was used as a helper class for `PulseChannelSpec`. It has been removed since with the deprecation of `PulseChannelSpec` and changes to `BackendConfiguration` make it unnecessary.
*   The previously deprecated representation of qubits and classical bits as tuple, which was deprecated in the 0.9 release, has been removed. The use of `Qubit` and `Clbit` objects is the new way to represent qubits and classical bits.
*   The previously deprecated representation of the basis set as single string has been removed. A list of strings is the new preferred way.
*   The method `BaseModel.as_dict`, which was deprecated in the 0.9 release, has been removed in favor of the method `BaseModel.to_dict`.
*   In PulseDefaults (accessed normally as backend.defaults()), `qubit_freq_est` and `meas_freq_est` are now returned in Hz rather than GHz. This means the new return values are 1e9 \* their previous value.
*   [dill](https://pypi.org/project/dill/) was added as a requirement. This is needed to enable running `passmanager.run()` in parallel for more than one circuit.
*   The previously deprecated gate `UBase`, which was deprecated in the 0.9 release, has been removed. The gate `U3Gate` should be used instead.
*   The previously deprecated gate `CXBase`, which was deprecated in the 0.9 release, has been removed. The gate `CnotGate` should be used instead.
*   The instruction `snapshot` used to implicitly convert the `label` parameter to string. That conversion has been removed and an error is raised if a string is not provided.
*   The previously deprecated gate `U0Gate`, which was deprecated in the 0.9 release, has been removed. The gate `IdGate` should be used instead to insert delays.

<span id="release-notes-0-11-0-deprecation-notes" />

<span id="id535" />

#### Deprecation Notes

*   The `qiskit.pulse.CmdDef` class has been deprecated. Instead you should use the `qiskit.pulse.InstructionScheduleMap`. The `InstructionScheduleMap` object for a pulse enabled system can be accessed at `backend.defaults().instruction_schedules`.

*   `PulseChannelSpec` is being deprecated. Use `BackendConfiguration` instead. The backend configuration is accessed normally as `backend.configuration()`. The config has been extended with most of the functionality of PulseChannelSpec, with some modifications as follows, where 0 is an exemplary qubit index:

    ```python
    pulse_spec.drives[0]   -> config.drive(0)
    pulse_spec.measures[0] -> config.measure(0)
    pulse_spec.acquires[0] -> config.acquire(0)
    pulse_spec.controls[0] -> config.control(0)
    ```

    Now, if there is an attempt to get a channel for a qubit which does not exist for the device, a `BackendConfigurationError` will be raised with a helpful explanation.

    The methods `memoryslots` and `registerslots` of the PulseChannelSpec have not been migrated to the backend configuration. These classical resources are not restrained by the physical configuration of a backend system. Please instantiate them directly:

    ```python
    pulse_spec.memoryslots[0] -> MemorySlot(0)
    pulse_spec.registerslots[0] -> RegisterSlot(0)
    ```

    The `qubits` method is not migrated to backend configuration. The result of `qubits` can be built as such:

    ```python
    [q for q in range(backend.configuration().n_qubits)]
    ```

*   `Qubit` within `pulse.channels` has been deprecated. They should not be used. It is possible to obtain channel \<=> qubit mappings through the BackendConfiguration (or backend.configuration()).

*   The function `qiskit.visualization.circuit_drawer.qx_color_scheme()` has been deprecated. This function is no longer used internally and doesn’t reflect the current IBM QX style. If you were using this function to generate a style dict locally you must save the output from it and use that dictionary directly.

*   The Exception `TranspilerAccessError` has been deprecated. An alternative function `TranspilerError` can be used instead to provide the same functionality. This alternative function provides the exact same functionality but with greater generality.

*   Buffers in Pulse are deprecated. If a nonzero buffer is supplied, a warning will be issued with a reminder to use a Delay instead. Other options would include adding samples to a pulse instruction which are (0.+0.j) or setting the start time of the next pulse to `schedule.duration + buffer`.

*   Passing in `sympy.Basic`, `sympy.Expr` and `sympy.Matrix` types as instruction parameters are deprecated and will be removed in a future release. You’ll need to convert the input to one of the supported types which are:

    > *   `int`
    > *   `float`
    > *   `complex`
    > *   `str`
    > *   `np.ndarray`

<span id="release-notes-0-11-0-bug-fixes" />

<span id="id536" />

#### Bug Fixes

*   The Collect2qBlocks and CommutationAnalysis passes in the transpiler had been unable to process circuits containing Parameterized gates, preventing Parameterized circuits from being transpiled at optimization\_level 2 or above. These passes have been corrected to treat Parameterized gates as opaque.
*   The align\_measures function had an issue where Measure stimulus pulses weren’t properly aligned with Acquire pulses, resulting in an error. This has been fixed.
*   Uses of `numpy.random.seed` have been removed so that calls of qiskit functions do not affect results of future calls to `numpy.random`
*   Fixed race condition occurring in the job monitor when `job.queue_position()` returns `None`. `None` is a valid return from `job.queue_position()`.
*   Backend support for `memory=True` now checked when that kwarg is passed. `QiskitError` results if not supported.
*   When transpiling without a coupling map, there were no check in the amount of qubits of the circuit to transpile. Now the transpile process checks that the backend has enough qubits to allocate the circuit.

<span id="release-notes-0-11-0-other-notes" />

<span id="id537" />

#### Other Notes

*   The `qiskit.result.marginal_counts()` function replaces a similar utility function in qiskit-ignis `qiskit.ignis.verification.tomography.marginal_counts()`, which will be deprecated in a future qiskit-ignis release.
*   All sympy parameter output type support have been been removed (or deprecated as noted) from qiskit-terra. This includes sympy type parameters in `QuantumCircuit` objects, qasm ast nodes, or `Qobj` objects.

<span id="aer-0-3" />

### Aer 0.3

No Change

<span id="id538" />

### Ignis 0.2

No Change

<span id="id539" />

### Aqua 0.6

No Change

<span id="ibm-q-provider-0-4" />

### IBM Q Provider 0.4

<span id="id540" />

#### Prelude

The 0.4.0 release is the first release that makes use of all the features of the new IBM Q API. In particular, the `IBMQJob` class has been revamped in order to be able to retrieve more information from IBM Q, and a Job Manager class has been added for allowing a higher-level and more seamless usage of large or complex jobs. If you have not upgraded from the legacy IBM Q Experience or QConsole yet, please ensure to revisit the release notes for IBM Q Provider 0.3 (Qiskit 0.11) for more details on how to make the transition. The legacy accounts will no longer be supported as of this release.

<span id="id541" />

#### New Features

##### Job modifications

The `IBMQJob` class has been revised, and now mimics more closely to the contents of a remote job along with new features:

*   You can now assign a name to a job, by specifying `IBMQBackend.run(..., job_name='...')` when submitting a job. This name can be retrieved via `IBMQJob.name()` and can be used for filtering.
*   Jobs can now be shared with other users at different levels (global, per hub, group or project) via an optional `job_share_level` parameter when submitting the job.
*   `IBMQJob` instances now have more attributes, reflecting the contents of the remote IBM Q jobs. This implies that new attributes introduced by the IBM Q API will automatically and immediately be available for use (for example, `job.new_api_attribute`). The new attributes will be promoted to methods when they are considered stable (for example, `job.name()`).
*   `.error_message()` returns more information on why a job failed.
*   `.queue_position()` accepts a `refresh` parameter for forcing an update.
*   `.result()` accepts an optional `partial` parameter, for returning partial results, if any, of jobs that failed. Be aware that `Result` methods, such as `get_counts()` will raise an exception if applied on experiments that failed.

Please note that the changes include some low-level modifications of the class. If you were creating the instances manually, note that:

*   the signature of the constructor has changed to account for the new features.
*   the `.submit()` method can no longer be called directly, and jobs are expected to be submitted either via the synchronous `IBMQBackend.run()` or via the Job Manager.

##### Job Manager

A new Job Manager (`IBMQJobManager`) has been introduced, as a higher-level mechanism for handling jobs composed of multiple circuits or pulse schedules. The Job Manager aims to provide a transparent interface, intelligently splitting the input into efficient units of work and taking full advantage of the different components. It will be expanded on upcoming versions, and become the recommended entry point for job submission.

Its `.run()` method receives a list of circuits or pulse schedules, and returns a `ManagedJobSet instance`, which can then be used to track the statuses and results of these jobs. For example:

```python
from qiskit.providers.ibmq.managed import IBMQJobManager
from qiskit.circuit.random import random_circuit
from qiskit import IBMQ
from qiskit.compiler import transpile

provider = IBMQ.load_account()
backend = provider.backends.ibmq_ourense

circs = []
for _ in range(1000000):
    circs.append(random_circuit(2, 2))
transpile(circs, backend=backend)

# Farm out the jobs.
jm = IBMQJobManager()
job_set = jm.run(circs, backend=backend, name='foo')

job_set.statuses()    # Gives a list of job statuses
job_set.report()    # Prints detailed job information
results = job_set.results()
counts = results.get_counts(5)   # Returns data for experiment 5
```

<span id="provider-backends-modifications" />

##### provider.backends modifications

The `provider.backends` member, which was previously a function that returned a list of backends, has been promoted to a service. This implies that it can be used both in the previous way, as a `.backends()` method, and also as a `.backends` attribute with expanded capabilities:

*   it contains the existing backends from that provider as attributes, which can be used for autocompletion. For example:

    ```python
    my_backend = provider.get_backend('ibmq_qasm_simulator')
    ```

    is equivalent to:

    ```python
    my_backend = provider.backends.ibmq_qasm_simulator
    ```

*   the `provider.backends.jobs()` and `provider.backends.retrieve_job()` methods can be used for retrieving provider-wide jobs.

##### Other changes

*   The `backend.properties()` function now accepts an optional `datetime` parameter. If specified, the function returns the backend properties closest to, but older than, the specified datetime filter.
*   Some `warnings` have been toned down to `logger.warning` messages.

<span id="qiskit-0-13-0" />

## Qiskit 0.13.0

<span id="terra-0-10-0" />

### Terra 0.10.0

<span id="release-notes-0-10-0-prelude" />

<span id="id542" />

#### Prelude

The 0.10.0 release includes several new features and bug fixes. The biggest change for this release is the addition of initial support for using Qiskit with trapped ion trap backends.

<span id="release-notes-0-10-0-new-features" />

<span id="id543" />

#### New Features

*   Introduced new methods in `QuantumCircuit` which allows the seamless adding or removing of measurements at the end of a circuit.

    ## `measure_all()`

    Adds a `barrier` followed by a `measure` operation to all qubits in the circuit. Creates a `ClassicalRegister` of size equal to the number of qubits in the circuit, which store the measurements.

    ## `measure_active()`

    Adds a `barrier` followed by a `measure` operation to all active qubits in the circuit. A qubit is active if it has at least one other operation acting upon it. Creates a `ClassicalRegister` of size equal to the number of active qubits in the circuit, which store the measurements.

    ## `remove_final_measurements()`

    Removes all final measurements and preceeding `barrier` from a circuit. A measurement is considered “final” if it is not followed by any other operation, excluding barriers and other measurements. After the measurements are removed, if all of the classical bits in the `ClassicalRegister` are idle (have no operations attached to them), then the `ClassicalRegister` is removed.

    Examples:

    ```python
    # Using measure_all()
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.measure_all()
    circuit.draw()

    # A ClassicalRegister with prefix measure was created.
    # It has 2 clbits because there are 2 qubits to measure

                 ┌───┐ ░ ┌─┐
         q_0: |0>┤ H ├─░─┤M├───
                 └───┘ ░ └╥┘┌─┐
         q_1: |0>──────░──╫─┤M├
                       ░  ║ └╥┘
    measure_0: 0 ═════════╩══╬═
                             ║
    measure_1: 0 ════════════╩═


    # Using measure_active()
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.measure_active()
    circuit.draw()

    # This ClassicalRegister only has 1 clbit because only 1 qubit is active

                 ┌───┐ ░ ┌─┐
         q_0: |0>┤ H ├─░─┤M├
                 └───┘ ░ └╥┘
         q_1: |0>──────░──╫─
                       ░  ║
    measure_0: 0 ═════════╩═


    # Using remove_final_measurements()
    # Assuming circuit_all and circuit_active are the circuits from the measure_all and
    # measure_active examples above respectively

    circuit_all.remove_final_measurements()
    circuit_all.draw()
    # The ClassicalRegister is removed because, after the measurements were removed,
    # all of its clbits were idle

            ┌───┐
    q_0: |0>┤ H ├
            └───┘
    q_1: |0>─────


    circuit_active.remove_final_measurements()
    circuit_active.draw()
    # This will result in the same circuit

            ┌───┐
    q_0: |0>┤ H ├
            └───┘
    q_1: |0>─────
    ```

*   Initial support for executing experiments on ion trap backends has been added.

*   An Rxx gate (rxx) and a global Mølmer–Sørensen gate (ms) have been added to the standard gate set.

*   A Cnot to Rxx/Rx/Ry decomposer `cnot_rxx_decompose` and a single qubit Euler angle decomposer `OneQubitEulerDecomposer` have been added to the `quantum_info.synthesis` module.

*   A transpiler pass `MSBasisDecomposer` has been added to unroll circuits defined over U3 and Cnot gates into a circuit defined over Rxx,Ry and Rx. This pass will be included in preset pass managers for backends which include the ‘rxx’ gate in their supported basis gates.

*   The backends in `qiskit.test.mock` now contain a snapshot of real device calibration data. This is accessible via the `properties()` method for each backend. This can be used to test any code that depends on backend properties, such as noise-adaptive transpiler passes or device noise models for simulation. This will create a faster testing and development cycle without the need to go to live backends.

*   Allows the Result class to return partial results. If a valid result schema is loaded that contains some experiments which succeeded and some which failed, this allows accessing the data from experiments that succeeded, while raising an exception for experiments that failed and displaying the appropriate error message for the failed results.

*   An `ax` kwarg has been added to the following visualization functions:

    > *   `qiskit.visualization.plot_histogram`
    > *   `qiskit.visualization.plot_state_paulivec`
    > *   `qiskit.visualization.plot_state_qsphere`
    > *   `qiskit.visualization.circuit_drawer` (`mpl` backend only)
    > *   `qiskit.QuantumCircuit.draw` (`mpl` backend only)

    This kwarg is used to pass in a `matplotlib.axes.Axes` object to the visualization functions. This enables integrating these visualization functions into a larger visualization workflow. Also, if an ax kwarg is specified then there is no return from the visualization functions.

*   An `ax_real` and `ax_imag` kwarg has been added to the following visualization functions:

    > *   `qiskit.visualization.plot_state_hinton`
    > *   `qiskit.visualization.plot_state_city`

    These new kargs work the same as the newly added `ax` kwargs for other visualization functions. However because these plots use two axes (one for the real component, the other for the imaginary component). Having two kwargs also provides the flexibility to only generate a visualization for one of the components instead of always doing both. For example:

    ```python
    from matplotlib import pyplot as plt
    from qiskit.visualization import plot_state_hinton

    ax = plt.gca()

    plot_state_hinton(psi, ax_real=ax)
    ```

    will only generate a plot of the real component.

*   A given pass manager now can be edited with the new method replace. This method allows to replace a particular stage in a pass manager, which can be handy when dealing with preset pass managers. For example, let’s edit the layout selector of the pass manager used at optimization level 0:

    ```python
    from qiskit.transpiler.preset_passmanagers.level0 import level_0_pass_manager
    from qiskit.transpiler.transpile_config import TranspileConfig

    pass_manager = level_0_pass_manager(TranspileConfig(coupling_map=CouplingMap([[0,1]])))

    pass_manager.draw()
    ```

    ```python
    [0] FlowLinear: SetLayout
    [1] Conditional: TrivialLayout
    [2] FlowLinear: FullAncillaAllocation, EnlargeWithAncilla, ApplyLayout
    [3] FlowLinear: Unroller
    ```

    The layout selection is set in the stage \[1]. Let’s replace it with DenseLayout:

    ```python
    from qiskit.transpiler.passes import DenseLayout

    pass_manager.replace(1, DenseLayout(coupling_map), condition=lambda property_set: not property_set['layout'])
    pass_manager.draw()
    ```

    ```python
    [0] FlowLinear: SetLayout
    [1] Conditional: DenseLayout
    [2] FlowLinear: FullAncillaAllocation, EnlargeWithAncilla, ApplyLayout
    [3] FlowLinear: Unroller
    ```

    If you want to replace it without any condition, you can use set-item shortcut:

    ```python
    pass_manager[1] = DenseLayout(coupling_map)
    pass_manager.draw()
    ```

    ```python
    [0] FlowLinear: SetLayout
    [1] FlowLinear: DenseLayout
    [2] FlowLinear: FullAncillaAllocation, EnlargeWithAncilla, ApplyLayout
    [3] FlowLinear: Unroller
    ```

*   Introduced a new pulse command `Delay` which may be inserted into a pulse `Schedule`. This command accepts a `duration` and may be added to any `Channel`. Other commands may not be scheduled on a channel during a delay.

    The delay can be added just like any other pulse command. For example:

    ```python
    from qiskit import pulse
    from qiskit.pulse.utils import pad

    dc0 = pulse.DriveChannel(0)

    delay = pulse.Delay(1)
    test_pulse = pulse.SamplePulse([1.0])

    sched = pulse.Schedule()
    sched += test_pulse(dc0).shift(1)

    # build padded schedule by hand
    ref_sched = delay(dc0) | sched

    # pad schedule
    padded_sched = pad(sched)

    assert padded_sched == ref_sched
    ```

    One may also pass additional channels to be padded and a time to pad until, for example:

    ```python
    from qiskit import pulse
    from qiskit.pulse.utils import pad

    dc0 = pulse.DriveChannel(0)
    dc1 = pulse.DriveChannel(1)

    delay = pulse.Delay(1)
    test_pulse = pulse.SamplePulse([1.0])

    sched = pulse.Schedule()
    sched += test_pulse(dc0).shift(1)

    # build padded schedule by hand
    ref_sched = delay(dc0) | delay(dc1) |  sched

    # pad schedule across both channels until up until the first time step
    padded_sched = pad(sched, channels=[dc0, dc1], until=1)

    assert padded_sched == ref_sched
    ```

<span id="release-notes-0-10-0-upgrade-notes" />

<span id="id544" />

#### Upgrade Notes

*   Assignments and modifications to the `data` attribute of `qiskit.QuantumCircuit` objects are now validated following the same rules used throughout the `QuantumCircuit` API. This was done to improve the performance of the circuits API since we can now assume the `data` attribute is in a known format. If you were manually modifying the `data` attribute of a circuit object before this may no longer work if your modifications resulted in a data structure other than the list of instructions with context in the format `[(instruction, qargs, cargs)]`

*   The transpiler default passmanager for optimization level 2 now uses the `DenseLayout` layout selection mechanism by default instead of `NoiseAdaptiveLayout`. The `Denselayout` pass has also been modified to be made noise-aware.

*   The deprecated `DeviceSpecification` class has been removed. Instead you should use the `PulseChannelSpec`. For example, you can run something like:

    ```python
    device = pulse.PulseChannelSpec.from_backend(backend)
    device.drives[0]    # for DeviceSpecification, this was device.q[0].drive
    device.memoryslots  # this was device.mem
    ```

*   The deprecated module `qiskit.pulse.ops` has been removed. Use `Schedule` and `Instruction` methods directly. For example, rather than:

    ```python
    ops.union(schedule_0, schedule_1)
    ops.union(instruction, schedule)  # etc
    ```

    Instead please use:

    ```python
    schedule_0.union(schedule_1)
    instruction.union(schedule)
    ```

    This same pattern applies to other `ops` functions: `insert`, `shift`, `append`, and `flatten`.

<span id="release-notes-0-10-0-deprecation-notes" />

<span id="id545" />

#### Deprecation Notes

*   Using the `control` property of `qiskit.circuit.Instruction` for classical control is now deprecated. In the future this property will be used for quantum control. Classically conditioned operations will instead be handled by the `condition` property of `qiskit.circuit.Instruction`.
*   Support for setting `qiskit.circuit.Instruction` parameters with an object of type `qiskit.qasm.node.Node` has been deprecated. `Node` objects that were previously used as parameters should be converted to a supported type prior to initializing a new `Instruction` object or calling the `Instruction.params` setter. Supported types are `int`, `float`, `complex`, `str`, `qiskit.circuit.ParameterExpression`, or `numpy.ndarray`.
*   In the qiskit 0.9.0 release the representation of bits (both qubits and classical bits) changed from tuples of the form `(register, index)` to be instances of the classes `qiskit.circuit.Qubit` and `qiskit.circuit.Clbit`. For backwards compatibility comparing the equality between a legacy tuple and the bit classes was supported as everything transitioned from tuples to being objects. This support is now deprecated and will be removed in the future. Everything should use the bit classes instead of tuples moving forward.
*   When the `mpl` output is used for either `qiskit.QuantumCircuit.draw()` or `qiskit.visualization.circuit_drawer()` and the `style` kwarg is used, passing in unsupported dictionary keys as part of the `` style` `` dictionary is now deprecated. Where these unknown arguments were previously silently ignored, in the future, unsupported keys will raise an exception.
*   The `line length` kwarg for the `qiskit.QuantumCircuit.draw()` method and the `qiskit.visualization.circuit_drawer()` function with the text output mode is deprecated. It has been replaced by the `fold` kwarg which will behave identically for the text output mode (but also now supports the mpl output mode too). `line_length` will be removed in a future release so calls should be updated to use `fold` instead.
*   The `fold` field in the `style` dict kwarg for the `qiskit.QuantumCircuit.draw()` method and the `qiskit.visualization.circuit_drawer()` function has been deprecated. It has been replaced by the `fold` kwarg on both functions. This kwarg behaves identically to the field in the style dict.

<span id="release-notes-0-10-0-bug-fixes" />

<span id="id546" />

#### Bug Fixes

*   Instructions layering which underlies all types of circuit drawing has changed to address right/left justification. This sometimes results in output which is topologically equivalent to the rendering in prior versions but visually different than previously rendered. Fixes [issue #2802](https://github.com/Qiskit/qiskit-terra/issues/2802)
*   Add `memory_slots` to `QobjExperimentHeader` of pulse Qobj. This fixes a bug in the data format of `meas_level=2` results of pulse experiments. Measured quantum states are returned as a bit string with zero padding based on the number set for `memory_slots`.
*   Fixed the visualization of the rzz gate in the latex circuit drawer to match the cu1 gate to reflect the symmetry in the rzz gate. The fix is based on the cds command of the qcircuit latex package. Fixes [issue #1957](https://github.com/Qiskit/qiskit-terra/issues/1957)

<span id="release-notes-0-10-0-other-notes" />

<span id="id547" />

#### Other Notes

*   `matplotlib.figure.Figure` objects returned by visualization functions are no longer always closed by default. Instead the returned figure objects are only closed if the configured matplotlib backend is an inline jupyter backend(either set with `%matplotlib inline` or `%matplotlib notebook`). Output figure objects are still closed with these backends to avoid duplicate outputs in jupyter notebooks (which is why the `Figure.close()` were originally added).

<span id="id548" />

### Aer 0.3

No Change

<span id="id549" />

### Ignis 0.2

No Change

<span id="id550" />

### Aqua 0.6

No Change

<span id="ibm-q-provider-0-3" />

### IBM Q Provider 0.3

No Change

<span id="qiskit-0-12-0" />

## Qiskit 0.12.0

<span id="terra-0-9" />

<span id="release-notes-0-9-0" />

### Terra 0.9

<span id="release-notes-0-9-0-prelude" />

<span id="id551" />

#### Prelude

The 0.9 release includes many new features and many bug fixes. The biggest changes for this release are new debugging capabilities for PassManagers. This includes a function to visualize a PassManager, the ability to add a callback function to a PassManager, and logging of passes run in the PassManager. Additionally, this release standardizes the way that you can set an initial layout for your circuit. So now you can leverage `initial_layout` the kwarg parameter on `qiskit.compiler.transpile()` and `qiskit.execute()` and the qubits in the circuit will get laid out on the desire qubits on the device. Visualization of circuits will now also show this clearly when visualizing a circuit that has been transpiled with a layout.

<span id="release-notes-0-9-0-new-features" />

<span id="id552" />

#### New Features

*   A `DAGCircuit` object (i.e. the graph representation of a QuantumCircuit where operation dependencies are explicit) can now be visualized with the `.draw()` method. This is in line with Qiskit’s philosophy of easy visualization. Other objects which support a `.draw()` method are `QuantumCircuit`, `PassManager`, and `Schedule`.

*   Added a new visualization function `qiskit.visualization.plot_error_map()` to plot the error map for a given backend. It takes in a backend object from the qiskit-ibmq-provider and will plot the current error map for that device.

*   Both `qiskit.QuantumCircuit.draw()` and `qiskit.visualization.circuit_drawer()` now support annotating the qubits in the visualization with layout information. If the `QuantumCircuit` object being drawn includes layout metadata (which is normally only set on the circuit output from `transpile()` calls) then by default that layout will be shown on the diagram. This is done for all circuit drawer backends. For example:

    ```python
    from qiskit import ClassicalRegister, QuantumCircuit, QuantumRegister
    from qiskit.compiler import transpile

    qr = QuantumRegister(2, 'userqr')
    cr = ClassicalRegister(2, 'c0')
    qc = QuantumCircuit(qr, cr)
    qc.h(qr[0])
    qc.cx(qr[0], qr[1])
    qc.y(qr[0])
    qc.x(qr[1])
    qc.measure(qr, cr)

    # Melbourne coupling map
    coupling_map = [[1, 0], [1, 2], [2, 3], [4, 3], [4, 10], [5, 4],
                    [5, 6], [5, 9], [6, 8], [7, 8], [9, 8], [9, 10],
                    [11, 3], [11, 10], [11, 12], [12, 2], [13, 1],
                    [13, 12]]
    qc_result = transpile(qc, basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],
                          coupling_map=coupling_map, optimization_level=0)
    qc.draw(output='text')
    ```

    will yield a diagram like:

    ```python
                      ┌──────────┐┌──────────┐┌───┐┌──────────┐┌──────────────────┐┌─┐
       (userqr0) q0|0>┤ U2(0,pi) ├┤ U2(0,pi) ├┤ X ├┤ U2(0,pi) ├┤ U3(pi,pi/2,pi/2) ├┤M├───
                      ├──────────┤└──────────┘└─┬─┘├──────────┤└─┬─────────────┬──┘└╥┘┌─┐
       (userqr1) q1|0>┤ U2(0,pi) ├──────────────■──┤ U2(0,pi) ├──┤ U3(pi,0,pi) ├────╫─┤M├
                      └──────────┘                 └──────────┘  └─────────────┘    ║ └╥┘
      (ancilla0) q2|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
      (ancilla1) q3|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
      (ancilla2) q4|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
      (ancilla3) q5|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
      (ancilla4) q6|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
      (ancilla5) q7|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
      (ancilla6) q8|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
      (ancilla7) q9|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
     (ancilla8) q10|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
     (ancilla9) q11|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
    (ancilla10) q12|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
    (ancilla11) q13|0>──────────────────────────────────────────────────────────────╫──╫─
                                                                                    ║  ║
              c0_0: 0 ══════════════════════════════════════════════════════════════╩══╬═
                                                                                       ║
              c0_1: 0 ═════════════════════════════════════════════════════════════════╩═
    ```

    If you do not want the layout to be shown on transpiled circuits (or any other circuits with a layout set) there is a new boolean kwarg for both functions, `with_layout` (which defaults `True`), which when set `False` will disable the layout annotation in the output circuits.

*   A new analysis pass `CountOpsLongest` was added to retrieve the number of operations on the longest path of the DAGCircuit. When used it will add a `count_ops_longest_path` key to the property set dictionary. You can add it to your a passmanager with something like:

    ```python
    from qiskit.transpiler.passes import CountOpsLongestPath
    from qiskit.transpiler.passes import CxCancellation
    from qiskit.transpiler import PassManager

    pm = PassManager()
    pm.append(CountOpsLongestPath())
    ```

    and then access the longest path via the property set value with something like:

    ```python
    pm.append(
        CxCancellation(),
        condition=lambda property_set: property_set[
            'count_ops_longest_path'] < 5)
    ```

    which will set a condition on that pass based on the longest path.

*   Two new functions, `sech()` and `sech_deriv()` were added to the pulse library module `qiskit.pulse.pulse_lib` for creating an unnormalized hyperbolic secant `SamplePulse` object and an unnormalized hyperbolic secant derviative `SamplePulse` object respectively.

*   A new kwarg option `vertical_compression` was added to the `QuantumCircuit.draw()` method and the `qiskit.visualization.circuit_drawer()` function. This option only works with the `text` backend. This option can be set to either `high`, `medium` (the default), or `low` to adjust how much vertical space is used by the output visualization.

*   A new kwarg boolean option `idle_wires` was added to the `QuantumCircuit.draw()` method and the `qiskit.visualization.circuit_drawer()` function. It works for all drawer backends. When `idle_wires` is set False in a drawer call the drawer will not draw any bits that do not have any circuit elements in the output quantum circuit visualization.

*   A new PassManager visualizer function `qiskit.visualization.pass_mamanger_drawer()` was added. This function takes in a PassManager object and will generate a flow control diagram of all the passes run in the PassManager.

*   When creating a PassManager you can now specify a callback function that if specified will be run after each pass is executed. This function gets passed a set of kwargs on each call with the state of the pass manager after each pass execution. Currently these kwargs are:

    *   `pass_` (`Pass`): the pass being run
    *   `dag` (`DAGCircuit`): the dag output of the pass
    *   `time` (`float`): the time to execute the pass
    *   `property_set` (`PropertySet`): the property set
    *   `count` (`int`): the index for the pass execution

    However, it’s worth noting that while these arguments are set for the 0.9 release they expose the internals of the pass manager and are subject to change in future release.

    For example you can use this to create a callback function that will visualize the circuit output after each pass is executed:

    ```python
    from qiskit.transpiler import PassManager

    def my_callback(**kwargs):
        print(kwargs['dag'])

    pm = PassManager(callback=my_callback)
    ```

    Additionally you can specify the callback function when using `qiskit.compiler.transpile()`:

    ```python
    from qiskit.compiler import transpile

    def my_callback(**kwargs):
        print(kwargs['pass'])

    transpile(circ, callback=my_callback)
    ```

*   A new method `filter()` was added to the `qiskit.pulse.Schedule` class. This enables filtering the instructions in a schedule. For example, filtering by instruction type:

    ```python
    from qiskit.pulse import Schedule
    from qiskit.pulse.commands import Acquire
    from qiskit.pulse.commands import AcquireInstruction
    from qiskit.pulse.commands import FrameChange

    sched = Schedule(name='MyExperiment')
    sched.insert(0, FrameChange(phase=-1.57)(device))
    sched.insert(60, Acquire(5))
    acquire_sched = sched.filter(instruction_types=[AcquireInstruction])
    ```

*   Additional decomposition methods for several types of gates. These methods will use different decomposition techniques to break down a gate into a sequence of CNOTs and single qubit gates. The following methods are added:

    | Method                       | Description                                                                                                                                                          |
    | ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `QuantumCircuit.iso()`       | Add an arbitrary isometry from m to n qubits to a circuit. This allows for attaching arbitrary unitaries on n qubits (m=n) or to prepare any state of n qubits (m=0) |
    | `QuantumCircuit.diag_gate()` | Add a diagonal gate to the circuit                                                                                                                                   |
    | `QuantumCircuit.squ()`       | Decompose an arbitrary 2x2 unitary into three rotation gates and add to a circuit                                                                                    |
    | `QuantumCircuit.ucg()`       | Attach an uniformly controlled gate (also called a multiplexed gate) to a circuit                                                                                    |
    | `QuantumCircuit.ucx()`       | Attach a uniformly controlled (also called multiplexed) Rx rotation gate to a circuit                                                                                |
    | `QuantumCircuit.ucy()`       | Attach a uniformly controlled (also called multiplexed) Ry rotation gate to a circuit                                                                                |
    | `QuantumCircuit.ucz()`       | Attach a uniformly controlled (also called multiplexed) Rz rotation gate to a circuit                                                                                |

*   Addition of Gray-Synth and Patel–Markov–Hayes algorithms for synthesis of CNOT-Phase and CNOT-only linear circuits. These functions allow the synthesis of circuits that consist of only CNOT gates given a linear function or a circuit that consists of only CNOT and phase gates given a matrix description.

*   A new function `random_circuit` was added to the `qiskit.circuit.random` module. This function will generate a random circuit of a specified size by randomly selecting different gates and adding them to the circuit. For example, you can use this to generate a 5-qubit circuit with a depth of 10 using:

    ```python
    from qiskit.circuit.random import random_circuit

    circ = random_circuit(5, 10)
    ```

*   A new kwarg `output_names` was added to the `qiskit.compiler.transpile()` function. This kwarg takes in a string or a list of strings and uses those as the value of the circuit name for the output circuits that get returned by the `transpile()` call. For example:

    ```python
    from qiskit.compiler import transpile
    my_circs = [circ_a, circ_b]
    tcirc_a, tcirc_b = transpile(my_circs,
                                 output_names=['Circuit A', 'Circuit B'])
    ```

    the `name` attribute on tcirc\_a and tcirc\_b will be `'Circuit A'` and `'Circuit B'` respectively.

*   A new method `equiv()` was added to the `qiskit.quantum_info.Operator` and `qiskit.quantum_info.Statevector` classes. These methods are used to check whether a second `Operator` object or `Statevector` is equivalent up to global phase.

*   The user config file has several new options:

    *   The `circuit_drawer` field now accepts an auto value. When set as the value for the `circuit_drawer` field the default drawer backend will be mpl if it is available, otherwise the text backend will be used.
    *   A new field `circuit_mpl_style` can be used to set the default style used by the matplotlib circuit drawer. Valid values for this field are `bw` and `default` to set the default to a black and white or the default color style respectively.
    *   A new field `transpile_optimization_level` can be used to set the default transpiler optimization level to use for calls to `qiskit.compiler.transpile()`. The value can be set to either 0, 1, 2, or 3.

*   Introduced a new pulse command `Delay` which may be inserted into a pulse `Schedule`. This command accepts a `duration` and may be added to any `Channel`. Other commands may not be scheduled on a channel during a delay.

    The delay can be added just like any other pulse command. For example:

    ```python
    from qiskit import pulse

    drive_channel = pulse.DriveChannel(0)
    delay = pulse.Delay(20)

    sched = pulse.Schedule()
    sched += delay(drive_channel)
    ```

<span id="release-notes-0-9-0-upgrade-notes" />

<span id="id553" />

#### Upgrade Notes

*   The previously deprecated `qiskit._util` module has been removed. `qiskit.util` should be used instead.

*   The `QuantumCircuit.count_ops()` method now returns an `OrderedDict` object instead of a `dict`. This should be compatible for most use cases since `OrderedDict` is a `dict` subclass. However type checks and other class checks might need to be updated.

*   The `DAGCircuit.width()` method now returns the total number quantum bits and classical bits. Before it would only return the number of quantum bits. If you require just the number of quantum bits you can use `DAGCircuit.num_qubits()` instead.

*   The function `DAGCircuit.num_cbits()` has been removed. Instead you can use `DAGCircuit.num_clbits()`.

*   Individual quantum bits and classical bits are no longer represented as `(register, index)` tuples. They are now instances of Qubit and Clbit classes. If you’re dealing with individual bits make sure that you update any usage or type checks to look for these new classes instead of tuples.

*   The preset passmanager classes `qiskit.transpiler.preset_passmanagers.default_pass_manager` and `qiskit.transpiler.preset_passmanagers.default_pass_manager_simulator` (which were the previous default pass managers for `qiskit.compiler.transpile()` calls) have been removed. If you were manually using this pass managers switch to the new default, `qiskit.transpile.preset_passmanagers.level1_pass_manager`.

*   The `LegacySwap` pass has been removed. If you were using it in a custom pass manager, it’s usage can be replaced by the `StochasticSwap` pass, which is a faster more stable version. All the preset passmanagers have been updated to use `StochasticSwap` pass instead of the `LegacySwap`.

*   The following deprecated `qiskit.dagcircuit.DAGCircuit` methods have been removed:

    *   `DAGCircuit.get_qubits()` - Use `DAGCircuit.qubits()` instead

    *   `DAGCircuit.get_bits()` - Use `DAGCircuit.clbits()` instead

    *   `DAGCircuit.qasm()` - Use a combination of `qiskit.converters.dag_to_circuit()` and `QuantumCircuit.qasm()`. For example:

        ```python
        from qiskit.dagcircuit import DAGCircuit
        from qiskit.converters import dag_to_circuit
        my_dag = DAGCircuit()
        qasm = dag_to_circuit(my_dag).qasm()
        ```

    *   `DAGCircuit.get_op_nodes()` - Use `DAGCircuit.op_nodes()` instead. Note that the return type is a list of `DAGNode` objects for `op_nodes()` instead of the list of tuples previously returned by `get_op_nodes()`.

    *   `DAGCircuit.get_gate_nodes()` - Use `DAGCircuit.gate_nodes()` instead. Note that the return type is a list of `DAGNode` objects for `gate_nodes()` instead of the list of tuples previously returned by `get_gate_nodes()`.

    *   `DAGCircuit.get_named_nodes()` - Use `DAGCircuit.named_nodes()` instead. Note that the return type is a list of `DAGNode` objects for `named_nodes()` instead of the list of node\_ids previously returned by `get_named_nodes()`.

    *   `DAGCircuit.get_2q_nodes()` - Use `DAGCircuit.twoQ_gates()` instead. Note that the return type is a list of `DAGNode` objects for `twoQ_gates()` instead of the list of data\_dicts previously returned by `get_2q_nodes()`.

    *   `DAGCircuit.get_3q_or_more_nodes()` - Use `DAGCircuit.threeQ_or_more_gates()` instead. Note that the return type is a list of `DAGNode` objects for `threeQ_or_more_gates()` instead of the list of tuples previously returned by `get_3q_or_more_nodes()`.

*   The following `qiskit.dagcircuit.DAGCircuit` methods had deprecated support for accepting a `node_id` as a parameter. This has been removed and now only `DAGNode` objects are accepted as input:

    *   `successors()`
    *   `predecessors()`
    *   `ancestors()`
    *   `descendants()`
    *   `bfs_successors()`
    *   `quantum_successors()`
    *   `remove_op_node()`
    *   `remove_ancestors_of()`
    *   `remove_descendants_of()`
    *   `remove_nonancestors_of()`
    *   `remove_nondescendants_of()`
    *   `substitute_node_with_dag()`

*   The `qiskit.dagcircuit.DAGCircuit` method `rename_register()` has been removed. This was unused by all the qiskit code. If you were relying on it externally you’ll have to re-implement is an external function.

*   The `qiskit.dagcircuit.DAGCircuit` property `multi_graph` has been removed. Direct access to the underlying `networkx` `multi_graph` object isn’t supported anymore. The API provided by the `DAGCircuit` class should be used instead.

*   The deprecated exception class `qiskit.qiskiterror.QiskitError` has been removed. Instead you should use `qiskit.exceptions.QiskitError`.

*   The boolean kwargs, `ignore_requires` and `ignore_preserves` from the `qiskit.transpiler.PassManager` constructor have been removed. These are no longer valid options.

*   The module `qiskit.tools.logging` has been removed. This module was not used by anything and added nothing over the interfaces that Python’s standard library `logging` module provides. If you want to set a custom formatter for logging use the standard library `logging` module instead.

*   The `CompositeGate` class has been removed. Instead you should directly create a instruction object from a circuit and append that to your circuit. For example, you can run something like:

    ```python
    custom_gate_circ = qiskit.QuantumCircuit(2)
    custom_gate_circ.x(1)
    custom_gate_circ.h(0)
    custom_gate_circ.cx(0, 1)
    custom_gate = custom_gate_circ.to_instruction()
    ```

*   The previously deprecated kwargs, `seed` and `config` for `qiskit.compiler.assemble()` have been removed use `seed_simulator` and `run_config` respectively instead.

*   The previously deprecated converters `qiskit.converters.qobj_to_circuits()` and `qiskit.converters.circuits_to_qobj()` have been removed. Use `qiskit.assembler.disassemble()` and `qiskit.compiler.assemble()` respectively instead.

*   The previously deprecated kwarg `seed_mapper` for `qiskit.compiler.transpile()` has been removed. Instead you should use `seed_transpiler`

*   The previously deprecated kwargs `seed`, `seed_mapper`, `config`, and `circuits` for the `qiskit.execute()` function have been removed. Use `seed_simulator`, `seed_transpiler`, `run_config`, and `experiments` arguments respectively instead.

*   The previously deprecated `qiskit.tools.qcvv` module has been removed use qiskit-ignis instead.

*   The previously deprecated functions `qiskit.transpiler.transpile()` and `qiskit.transpiler.transpile_dag()` have been removed. Instead you should use `qiskit.compiler.transpile`. If you were using `transpile_dag()` this can be replaced by running:

    ```python
    circ = qiskit.converters.dag_to_circuit(dag)
    out_circ = qiskit.compiler.transpile(circ)
    qiskit.converters.circuit_to_dag(out_circ)
    ```

*   The previously deprecated function `qiskit.compile()` has been removed instead you should use `qiskit.compiler.transpile()` and `qiskit.compiler.assemble()`.

*   The jupyter cell magic `%%qiskit_progress_bar` from `qiskit.tools.jupyter` has been changed to a line magic. This was done to better reflect how the magic is used and how it works. If you were using the `%%qiskit_progress_bar` cell magic in an existing notebook, you will have to update this to be a line magic by changing it to be `%qiskit_progress_bar` instead. Everything else should behave identically.

*   The deprecated function `qiskit.tools.qi.qi.random_unitary_matrix()` has been removed. You should use the `qiskit.quantum_info.random.random_unitary()` function instead.

*   The deprecated function `qiskit.tools.qi.qi.random_density_matrix()` has been removed. You should use the `qiskit.quantum_info.random.random_density_matrix()` function instead.

*   The deprecated function `qiskit.tools.qi.qi.purity()` has been removed. You should the `qiskit.quantum_info.purity()` function instead.

*   The deprecated `QuantumCircuit._attach()` method has been removed. You should use `QuantumCircuit.append()` instead.

*   The `qiskit.qasm.Qasm` method `get_filename()` has been removed. You can use the `return_filename()` method instead.

*   The deprecated `qiskit.mapper` module has been removed. The list of functions and classes with their alternatives are:

    *   `qiskit.mapper.CouplingMap`: `qiskit.transpiler.CouplingMap` should be used instead.
    *   `qiskit.mapper.Layout`: `qiskit.transpiler.Layout` should be used instead
    *   `qiskit.mapper.compiling.euler_angles_1q()`: `qiskit.quantum_info.synthesis.euler_angles_1q()` should be used instead
    *   `qiskit.mapper.compiling.two_qubit_kak()`: `qiskit.quantum_info.synthesis.two_qubit_cnot_decompose()` should be used instead.

    The deprecated exception classes `qiskit.mapper.exceptions.CouplingError` and `qiskit.mapper.exceptions.LayoutError` don’t have an alternative since they serve no purpose without a `qiskit.mapper` module.

*   The `qiskit.pulse.samplers` module has been moved to `qiskit.pulse.pulse_lib.samplers`. You will need to update imports of `qiskit.pulse.samplers` to `qiskit.pulse.pulse_lib.samplers`.

*   [seaborn](https://seaborn.pydata.org/) is now a dependency for the function `qiskit.visualization.plot_state_qsphere()`. It is needed to generate proper angular color maps for the visualization. The `qiskit-terra[visualization]` extras install target has been updated to install `seaborn>=0.9.0` If you are using visualizations and specifically the `plot_state_qsphere()` function you can use that to install `seaborn` or just manually run `pip install seaborn>=0.9.0`

*   The previously deprecated functions `qiksit.visualization.plot_state` and `qiskit.visualization.iplot_state` have been removed. Instead you should use the specific function for each plot type. You can refer to the following tables to map the deprecated functions to their equivalent new ones:

    | Qiskit Terra 0.6                    | Qiskit Terra 0.7+             |
    | ----------------------------------- | ----------------------------- |
    | plot\_state(rho)                    | plot\_state\_city(rho)        |
    | plot\_state(rho, method=’city’)     | plot\_state\_city(rho)        |
    | plot\_state(rho, method=’paulivec’) | plot\_state\_paulivec(rho)    |
    | plot\_state(rho, method=’qsphere’)  | plot\_state\_qsphere(rho)     |
    | plot\_state(rho, method=’bloch’)    | plot\_bloch\_multivector(rho) |
    | plot\_state(rho, method=’hinton’)   | plot\_state\_hinton(rho)      |

*   The `pylatexenc` and `pillow` dependencies for the `latex` and `latex_source` circuit drawer backends are no longer listed as requirements. If you are going to use the latex circuit drawers ensure you have both packages installed or use the setuptools extras to install it along with qiskit-terra:

    ```python
    pip install qiskit-terra[visualization]
    ```

*   The root of the `qiskit` namespace will now emit a warning on import if either `qiskit.IBMQ` or `qiskit.Aer` could not be setup. This will occur whenever anything in the `qiskit` namespace is imported. These warnings were added to make it clear for users up front if they’re running qiskit and the qiskit-aer and qiskit-ibmq-provider packages could not be found. It’s not always clear if the packages are missing or python packaging/pip installed an element incorrectly until you go to use them and get an empty `ImportError`. These warnings should make it clear up front if there these commonly used aliases are missing.

    However, for users that choose not to use either qiskit-aer or qiskit-ibmq-provider this might cause additional noise. For these users these warnings are easily suppressable using Python’s standard library `warnings`. Users can suppress the warnings by putting these two lines before any imports from qiskit:

    ```python
    import warnings
    warnings.filterwarnings('ignore', category=RuntimeWarning,
                            module='qiskit')
    ```

    This will suppress the warnings emitted by not having qiskit-aer or qiskit-ibmq-provider installed, but still preserve any other warnings emitted by qiskit or any other package.

<span id="release-notes-0-9-0-deprecation-notes" />

<span id="id554" />

#### Deprecation Notes

*   The `U` and `CX` gates have been deprecated. If you’re using these gates in your code you should update them to use `u3` and `cx` instead. For example, if you’re using the circuit gate functions `circuit.u_base()` and `circuit.cx_base()` you should update these to be `circuit.u3()` and `circuit.cx()` respectively.

*   The `u0` gate has been deprecated in favor of using multiple `iden` gates and it will be removed in the future. If you’re using the `u0` gate in your circuit you should update your calls to use `iden`. For example, f you were using `circuit.u0(2)` in your circuit before that should be updated to be:

    ```python
    circuit.iden()
    circuit.iden()
    ```

    instead.

*   The `qiskit.pulse.DeviceSpecification` class is deprecated now. Instead you should use `qiskit.pulse.PulseChannelSpec`.

*   Accessing a `qiskit.circuit.Qubit`, `qiskit.circuit.Clbit`, or `qiskit.circuit.Bit` class by index is deprecated (for compatibility with the `(register, index)` tuples that these classes replaced). Instead you should use the `register` and `index` attributes.

*   Passing in a bit to the `qiskit.QuantumCircuit` method `append` as a tuple `(register, index)` is deprecated. Instead bit objects should be used directly.

*   Accessing the elements of a `qiskit.transpiler.Layout` object with a tuple `(register, index)` is deprecated. Instead a bit object should be used directly.

*   The `qiskit.transpiler.Layout` constructor method `qiskit.transpiler.Layout.from_tuplelist()` is deprecated. Instead the constructor `qiskit.transpiler.Layout.from_qubit_list()` should be used.

*   The module `qiskit.pulse.ops` has been deprecated. All the functions it provided:

    *   `union`
    *   `flatten`
    *   `shift`
    *   `insert`
    *   `append`

    have equivalent methods available directly on the `qiskit.pulse.Schedule` and `qiskit.pulse.Instruction` classes. Those methods should be used instead.

*   The `qiskit.qasm.Qasm` method `get_tokens()` is deprecated. Instead you should use the `generate_tokens()` method.

*   The `qiskit.qasm.qasmparser.QasmParser` method `get_tokens()` is deprecated. Instead you should use the `read_tokens()` method.

*   The `as_dict()` method for the Qobj class has been deprecated and will be removed in the future. You should replace calls to it with `to_dict()` instead.

<span id="release-notes-0-9-0-bug-fixes" />

<span id="id555" />

#### Bug Fixes

*   The definition of the `CU3Gate` has been changed to be equivalent to the canonical definition of a controlled `U3Gate`.

*   The handling of layout in the pass manager has been standardized. This fixes several reported issues with handling layout. The `initial_layout` kwarg parameter on `qiskit.compiler.transpile()` and `qiskit.execute()` will now lay out your qubits from the circuit onto the desired qubits on the device when transpiling circuits.

*   Support for n-qubit unitaries was added to the BasicAer simulator and `unitary` (arbitrary unitary gates) was added to the set of basis gates for the simulators

*   The `qiskit.visualization.plost_state_qsphere()` has been updated to fix several issues with it. Now output Q Sphere visualization will be correctly generated and the following aspects have been updated:

    *   All complementary basis states are antipodal

    *   Phase is indicated by color of line and marker on sphere’s surface

    *   ## Probability is indicated by translucency of line and volume of marker on

        sphere’s surface

<span id="release-notes-0-9-0-other-notes" />

<span id="id556" />

#### Other Notes

*   The default PassManager for `qiskit.compiler.transpile()` and `qiskit.execute()` has been changed to optimization level 1 pass manager defined at `qiskit.transpile.preset_passmanagers.level1_pass_manager`.

*   All the circuit drawer backends now will express gate parameters in a circuit as common fractions of pi in the output visualization. If the value of a parameter can be expressed as a fraction of pi that will be used instead of the numeric equivalent.

*   When using `qiskit.assembler.assemble_schedules()` if you do not provide the number of memory\_slots to use the number will be inferred based on the number of acquisitions in the input schedules.

*   The deprecation warning on the `qiskit.dagcircuit.DAGCircuit` property `node_counter` has been removed. The behavior change being warned about was put into effect when the warning was added, so warning that it had changed served no purpose.

*   Calls to `PassManager.run()` now will emit python logging messages at the INFO level for each pass execution. These messages will include the Pass name and the total execution time of the pass. Python’s standard logging was used because it allows Qiskit-Terra’s logging to integrate in a standard way with other applications and libraries. All logging for the transpiler occurs under the `qiskit.transpiler` namespace, as used by `logging.getLogger('qiskit.transpiler`). For example, to turn on DEBUG level logging for the transpiler you can run:

    ```python
    import logging

    logging.basicConfig()
    logging.getLogger('qiskit.transpiler').setLevel(logging.DEBUG)
    ```

    which will set the log level for the transpiler to DEBUG and configure those messages to be printed to stderr.

<span id="id557" />

### Aer 0.3

*   There’s a new high-performance Density Matrix Simulator that can be used in conjunction with our noise models, to better simulate real world scenarios.
*   We have added a Matrix Product State (MPS) simulator. MPS allows for efficient simulation of several classes of quantum circuits, even under presence of strong correlations and highly entangled states. For cases amenable to MPS, circuits with several hundred qubits and more can be exactly simulated, e.g., for the purpose of obtaining expectation values of observables.
*   Snapshots can be performed in all of our simulators.
*   Now we can measure sampling circuits with read-out errors too, not only ideal circuits.
*   We have increased some circuit optimizations with noise presence.
*   A better 2-qubit error approximations have been included.
*   Included some tools for making certain noisy simulations easier to craft and faster to simulate.
*   Increased performance with simulations that require less floating point numerical precision.

<span id="id558" />

### Ignis 0.2

<span id="id559" />

#### New Features

*   [Logging Module](https://github.com/Qiskit/qiskit-iqx-tutorials/blob/stable/0.12.x/qiskit/advanced/ignis/9_ignis_logging.ipynb)
*   [Purity RB](https://github.com/Qiskit/qiskit-iqx-tutorials/blob/stable/0.12.x/qiskit/advanced/ignis/5c_purity_rb.ipynb)
*   [Interleaved RB](https://github.com/Qiskit/qiskit-iqx-tutorials/blob/stable/0.12.x/qiskit/advanced/ignis/5b_interleaved_rb.ipynb)
*   [Repetition Code for Verification](https://github.com/Qiskit/qiskit-iqx-tutorials/blob/stable/0.12.x/qiskit/advanced/ignis/8_repetition_code.ipynb)
*   Seed values can now be arbitrarily added to RB (not just in order)
*   Support for adding multiple results to measurement mitigation
*   RB Fitters now support providing guess values

<span id="id560" />

#### Bug Fixes

*   Fixed a bug in RB fit error
*   Fixed a bug in the characterization fitter when selecting a qubit index to fit

<span id="id561" />

#### Other Notes

*   Measurement mitigation now operates in parallel when applied to multiple results
*   Guess values for RB fitters are improved

<span id="id562" />

### Aqua 0.6

<span id="id563" />

#### Added

*   Relative-Phase Toffoli gates `rccx` (with 2 controls) and `rcccx` (with 3 controls).

*   Variational form `RYCRX`

*   A new `'basic-no-ancilla'` mode to `mct`.

*   Multi-controlled rotation gates `mcrx`, `mcry`, and `mcrz` as a general `u3` gate is not supported by graycode implementation

*   Chemistry: ROHF open-shell support

    *   Supported for all drivers: Gaussian16, PyQuante, PySCF and PSI4
    *   HartreeFock initial state, UCCSD variational form and two qubit reduction for parity mapping now support different alpha and beta particle numbers for open shell support

*   Chemistry: UHF open-shell support

    *   Supported for all drivers: Gaussian16, PyQuante, PySCF and PSI4
    *   QMolecule extended to include integrals, coefficients etc for separate beta

*   Chemistry: QMolecule extended with integrals in atomic orbital basis to facilitate common access to these for experimentation

    *   Supported for all drivers: Gaussian16, PyQuante, PySCF and PSI4

*   Chemistry: Additional PyQuante and PySCF driver configuration

    *   Convergence tolerance and max convergence iteration controls.
    *   For PySCF initial guess choice

*   Chemistry: Processing output added to debug log from PyQuante and PySCF computations (Gaussian16 and PSI4 outputs were already added to debug log)

*   Chemistry: Merged qiskit-chemistry into qiskit-aqua

*   Add `MatrixOperator`, `WeightedPauliOperator` and `TPBGroupedPauliOperator` class.

*   Add `evolution_instruction` function to get registerless instruction of time evolution.

*   Add `op_converter` module to unify the place in charge of converting different types of operators.

*   Add `Z2Symmetries` class to encapsulate the Z2 symmetries info and has helper methods for tapering an Operator.

*   Amplitude Estimation: added maximum likelihood postprocessing and confidence interval computation.

*   Maximum Likelihood Amplitude Estimation (MLAE): Implemented new algorithm for amplitude estimation based on maximum likelihood estimation, which reduces number of required qubits and circuit depth.

*   Added (piecewise) linearly and polynomially controlled Pauli-rotation circuits.

*   Add `q_equation_of_motion` to study excited state of a molecule, and add two algorithms to prepare the reference state.

<span id="id564" />

#### Changed

*   Improve `mct`’s `'basic'` mode by using relative-phase Toffoli gates to build intermediate results.
*   Adapt to Qiskit Terra’s newly introduced `Qubit` class.
*   Prevent `QPE/IQPE` from modifying input `Operator` objects.
*   The PyEDA dependency was removed; corresponding oracles’ underlying logic operations are now handled by SymPy.
*   Refactor the `Operator` class, each representation has its own class `MatrixOperator`, `WeightedPauliOperator` and `TPBGroupedPauliOperator`.
*   The `power` in `evolution_instruction` was applied on the theta on the CRZ gate directly, the new version repeats the circuits to implement power.
*   CircuitCache is OFF by default, and it can be set via environment variable now `QISKIT_AQUA_CIRCUIT_CACHE`.

<span id="id565" />

#### Bug Fixes

*   A bug where `TruthTableOracle` would build incorrect circuits for truth tables with only a single `1` value.
*   A bug caused by `PyEDA`’s indeterminism.
*   A bug with `QPE/IQPE`’s translation and stretch computation.
*   Chemistry: Bravyi-Kitaev mapping fixed when num qubits was not a power of 2
*   Setup `initial_layout` in `QuantumInstance` via a list.

<span id="id566" />

#### Removed

*   General multi-controlled rotation gate `mcu3` is removed and replaced by multi-controlled rotation gates `mcrx`, `mcry`, and `mcrz`

<span id="id567" />

#### Deprecated

*   The `Operator` class is deprecated, in favor of using `MatrixOperator`, `WeightedPauliOperator` and `TPBGroupedPauliOperator`.

<span id="id568" />

### IBM Q Provider 0.3

No change

<span id="qiskit-0-11-1" />

## Qiskit 0.11.1

We have bumped up Qiskit micro version to 0.11.1 because IBM Q Provider has bumped its micro version as well.

<span id="terra-0-8" />

### Terra 0.8

No Change

<span id="aer-0-2" />

### Aer 0.2

No change

<span id="ignis-0-1" />

### Ignis 0.1

No Change

<span id="aqua-0-5" />

### Aqua 0.5

`qiskit-aqua` has been updated to `0.5.3` to fix code related to changes in how gates inverses are done.

<span id="id569" />

### IBM Q Provider 0.3

The `IBMQProvider` has been updated to version `0.3.1` to fix backward compatibility issues and work with the default 10 job limit in single calls to the IBM Q API v2.

<span id="qiskit-0-11" />

## Qiskit 0.11

We have bumped up Qiskit minor version to 0.11 because IBM Q Provider has bumped up its minor version too. On Aer, we have jumped from 0.2.1 to 0.2.3 because there was an issue detected right after releasing 0.2.2 and before Qiskit 0.11 went online.

<span id="id570" />

### Terra 0.8

No Change

<span id="id571" />

### Aer 0.2

<span id="id572" />

#### New features

*   Added support for multi-controlled phase gates
*   Added optimized anti-diagonal single-qubit gates

#### Improvements

*   Introduced a technique called Fusion that increments performance of circuit execution Tuned threading strategy to gain performance in most common scenarios.
*   Some of the already implemented error models have been polished.

<span id="id573" />

### Ignis 0.1

No Change

<span id="id574" />

### Aqua 0.5

No Change

<span id="id575" />

### IBM Q Provider 0.3

The `IBMQProvider` has been updated in order to default to use the new [IBM Q Experience v2](https://quantum-computing.ibm.com). Accessing the legacy IBM Q Experience v1 and QConsole will still be supported during the 0.3.x line until its final deprecation one month from the release. It is encouraged to update to the new IBM Q Experience to take advantage of the new functionality and features.

#### Updating to the new IBM Q Experience v2

If you have credentials for the legacy IBM Q Experience stored on disk, you can make use of the interactive helper:

```python
from qiskit import IBMQ

IBMQ.update_account()
```

For more complex cases or fine tuning your configuration, the following methods are available:

*   the `IBMQ.delete_accounts()` can be used for resetting your configuration file.
*   the `IBMQ.save_account('MY_TOKEN')` method can be used for saving your credentials, following the instructions in the [IBM Q Experience v2](https://quantum-computing.ibm.com) account page.

#### Updating your programs

When using the new IBM Q Experience v2 through the provider, access to backends is done via individual `provider` instances (as opposed to accessing them directly through the `qiskit.IBMQ` object as in previous versions), which allows for more granular control over the project you are using.

You can get a reference to the `providers` that you have access to using the `IBMQ.providers()` and `IBMQ.get_provider()` methods:

```python
from qiskit import IBMQ

provider = IBMQ.load_account()
my_providers = IBMQ.providers()
provider_2 = IBMQ.get_provider(hub='A', group='B', project='C')
```

For convenience, `IBMQ.load_account()` and `IBMQ.enable_account()` will return a provider for the open access project, which is the default in the new IBM Q Experience v2.

For example, the following program in previous versions:

```python
from qiskit import IBMQ

IBMQ.load_accounts()
backend = IBMQ.get_backend('ibmqx4')
backend_2 = IBMQ.get_backend('ibmq_qasm_simulator', hub='HUB2')
```

Would be equivalent to the following program in the current version:

```python
from qiskit import IBMQ

provider = IBMQ.load_account()
backend = provider.get_backend('ibmqx4')
provider_2 = IBMQ.get_provider(hub='HUB2')
backend_2 = provider_2.get_backend('ibmq_qasm_simulator')
```

You can find more information and details in the [IBM Q Provider documentation](https://github.com/Qiskit/qiskit-ibmq-provider).

<span id="qiskit-0-10" />

## Qiskit 0.10

<span id="id576" />

### Terra 0.8

No Change

<span id="id577" />

### Aer 0.2

No Change

<span id="id578" />

### Ignis 0.1

No Change

<span id="id579" />

### Aqua 0.5

No Change

<span id="ibm-q-provider-0-2" />

### IBM Q Provider 0.2

<span id="id580" />

#### New Features

*   The `IBMQProvider` supports connecting to the new version of the IBM Q API. Please note support for this version is still experimental [qiskit-ibmq-provider #78](https://github.com/Qiskit/qiskit-ibmq-provider/pull/78).
*   Added support for Circuits through the new API [qiskit-ibmq-provider #79](https://github.com/Qiskit/qiskit-ibmq-provider/pull/79).

<span id="id581" />

#### Bug Fixes

*   Fixed incorrect parsing of some API hub URLs [qiskit-ibmq-provider #77](https://github.com/Qiskit/qiskit-ibmq-provider/pull/77).
*   Fixed noise model handling for remote simulators [qiskit-ibmq-provider #84](https://github.com/Qiskit/qiskit-ibmq-provider/pull/84).

<span id="qiskit-0-9" />

## Qiskit 0.9

<span id="id582" />

### Terra 0.8

#### Highlights

*   Introduction of the Pulse module under `qiskit.pulse`, which includes tools for building pulse commands, scheduling them on pulse channels, visualization, and running them on IBM Q devices.
*   Improved QuantumCircuit and Instruction classes, allowing for the composition of arbitrary sub-circuits into larger circuits, and also for creating parameterized circuits.
*   A powerful Quantum Info module under `qiskit.quantum_info`, providing tools to work with operators and channels and to use them inside circuits.
*   New transpiler optimization passes and access to predefined transpiling routines.

<span id="id583" />

#### New Features

*   The core `StochasticSwap` routine is implemented in [Cython](https://cython.org/).
*   Added `QuantumChannel` classes for manipulating quantum channels and CPTP maps.
*   Support for parameterized circuits.
*   The `PassManager` interface has been improved and new functions added for easier interaction and usage with custom pass managers.
*   Preset `PassManager`s are now included which offer a predetermined pipeline of transpiler passes.
*   User configuration files to let local environments override default values for some functions.
*   New transpiler passes: `EnlargeWithAncilla`, `Unroll2Q`, `NoiseAdaptiveLayout`, `OptimizeSwapBeforeMeasure`, `RemoveDiagonalGatesBeforeMeasure`, `CommutativeCancellation`, `Collect2qBlocks`, and `ConsolidateBlocks`.

#### Compatibility Considerations

As part of the 0.8 release the following things have been deprecated and will either be removed or changed in a backwards incompatible manner in a future release. While not strictly necessary these are things to adjust for before the 0.9 (unless otherwise noted) release to avoid a breaking change in the future.

*   The methods prefixed by `_get` in the `DAGCircuit` object are being renamed without that prefix.
*   Changed elements in `couplinglist` of `CouplingMap` from tuples to lists.
*   Unroller bases must now be explicit, and violation raises an informative `QiskitError`.
*   The `qiskit.tools.qcvv` package is deprecated and will be removed in the in the future. You should migrate to using the Qiskit Ignis which replaces this module.
*   The `qiskit.compile()` function is now deprecated in favor of explicitly using the `qiskit.compiler.transpile()` function to transform a circuit, followed by `qiskit.compiler.assemble()` to make a Qobj out of it. Instead of `compile(...)`, use `assemble(transpile(...), ...)`.
*   `qiskit.converters.qobj_to_circuits()` has been deprecated and will be removed in a future release. Instead `qiskit.assembler.disassemble()` should be used to extract `QuantumCircuit` objects from a compiled Qobj.
*   The `qiskit.mapper` namespace has been deprecated. The `Layout` and `CouplingMap` classes can be accessed via `qiskit.transpiler`.
*   A few functions in `qiskit.tools.qi.qi` have been deprecated and moved to `qiskit.quantum_info`.

Please note that some backwards incompatible changes have been made during this release. The following notes contain information on how to adapt to these changes.

##### IBM Q Provider

The IBM Q provider was previously included in Terra, but it has been split out into a separate package `qiskit-ibmq-provider`. This will need to be installed, either via pypi with `pip install qiskit-ibmq-provider` or from source in order to access `qiskit.IBMQ` or `qiskit.providers.ibmq`. If you install qiskit with `pip install qiskit`, that will automatically install all subpackages of the Qiskit project.

##### Cython Components

Starting in the 0.8 release the core stochastic swap routine is now implemented in [Cython](https://cython.org/). This was done to significantly improve the performance of the swapper, however if you build Terra from source or run on a non-x86 or other platform without prebuilt wheels and install from source distribution you’ll need to make sure that you have Cython installed prior to installing/building Qiskit Terra. This can easily be done with pip/pypi: `pip install Cython`.

##### Compiler Workflow

The `qiskit.compile()` function has been deprecated and replaced by first calling `qiskit.compiler.transpile()` to run optimization and mapping on a circuit, and then `qiskit.compiler.assemble()` to build a Qobj from that optimized circuit to send to a backend. While this is only a deprecation it will emit a warning if you use the old `qiskit.compile()` call.

**transpile(), assemble(), execute() parameters**

These functions are heavily overloaded and accept a wide range of inputs. They can handle circuit and pulse inputs. All kwargs except for `backend` for these functions now also accept lists of the previously accepted types. The `initial_layout` kwarg can now be supplied as a both a list and dictionary, e.g. to map a Bell experiment on qubits 13 and 14, you can supply: `initial_layout=[13, 14]` or `initial_layout={qr[0]: 13, qr[1]: 14}`

##### Qobj

The Qobj class has been split into two separate subclasses depending on the use case, either `PulseQobj` or `QasmQobj` for pulse and circuit jobs respectively. If you’re interacting with Qobj directly you may need to adjust your usage accordingly.

The `qiskit.qobj.qobj_to_dict()` is removed. Instead use the `to_dict()` method of a Qobj object.

##### Visualization

The largest change to the visualization module is it has moved from `qiskit.tools.visualization` to `qiskit.visualization`. This was done to indicate that the visualization module is more than just a tool. However, since this interface was declared stable in the 0.7 release the public interface off of `qiskit.tools.visualization` will continue to work. That may change in a future release, but it will be deprecated prior to removal if that happens.

The previously deprecated functions, `plot_circuit()`, `latex_circuit_drawer()`, `generate_latex_source()`, and `matplotlib_circuit_drawer()` from `qiskit.tools.visualization` have been removed. Instead of these functions, calling `qiskit.visualization.circuit_drawer()` with the appropriate arguments should be used.

The previously deprecated `plot_barriers` and `reverse_bits` keys in the `style` kwarg dictionary are deprecated, instead the `qiskit.visualization.circuit_drawer()` kwargs `plot_barriers` and `reverse_bits` should be used.

The Wigner plotting functions `plot_wigner_function`, `plot_wigner_curve`, `plot_wigner_plaquette`, and `plot_wigner_data` previously in the `qiskit.tools.visualization._state_visualization` module have been removed. They were never exposed through the public stable interface and were not well documented. The code to use this feature can still be accessed through the qiskit-tutorials repository.

##### Mapper

The public api from `qiskit.mapper` has been moved into `qiskit.transpiler`. While it has only been deprecated in this release, it will be removed in the 0.9 release so updating your usage of `Layout` and `CouplingMap` to import from `qiskit.transpiler` instead of `qiskit.mapper` before that takes place will avoid any surprises in the future.

<span id="id584" />

### Aer 0.2

<span id="id585" />

#### New Features

*   Added multiplexer gate [qiskit-aer #192](https://github.com/Qiskit/qiskit-aer/pull/192)
*   Added `remap_noise_model` function to `noise.utils` [qiskit-aer #181](https://github.com/Qiskit/qiskit-aer/pull/181)
*   Added `__eq__` method to `NoiseModel`, `QuantumError`, `ReadoutError` [qiskit-aer #181](https://github.com/Qiskit/qiskit-aer/pull/181)
*   Added support for labelled gates in noise models [qiskit-aer #175](https://github.com/Qiskit/qiskit-aer/pull/175)
*   Added optimized `mcx`, `mcy`, `mcz`, `mcu1`, `mcu2`, `mcu3`, gates to `QubitVector` [qiskit-aer #124](https://github.com/Qiskit/qiskit-aer/pull/124)
*   Added optimized controlled-swap gate to `QubitVector` [qiskit-aer #142](https://github.com/Qiskit/qiskit-aer/pull/142)
*   Added gate-fusion optimization for `QasmController`, which is enabled by setting `fusion_enable=true` [qiskit-aer #136](https://github.com/Qiskit/qiskit-aer/pull/136)
*   Added better management of failed simulations [qiskit-aer #167](https://github.com/Qiskit/qiskit-aer/pull/167)
*   Added qubits truncate optimization for unused qubits [qiskit-aer #164](https://github.com/Qiskit/qiskit-aer/pull/164)
*   Added ability to disable depolarizing error on device noise model [qiskit-aer #131](https://github.com/Qiskit/qiskit-aer/pull/131)
*   Added initialize simulator instruction to `statevector_state` [qiskit-aer #117](https://github.com/Qiskit/qiskit-aer/pull/117), [qiskit-aer #137](https://github.com/Qiskit/qiskit-aer/pull/137)
*   Added coupling maps to simulators [qiskit-aer #93](https://github.com/Qiskit/qiskit-aer/pull/93)
*   Added circuit optimization framework [qiskit-aer #83](https://github.com/Qiskit/qiskit-aer/pull/83)
*   Added benchmarking [qiskit-aer #71](https://github.com/Qiskit/qiskit-aer/pull/71), [qiskit-aer #177](https://github.com/Qiskit/qiskit-aer/pull/177)
*   Added wheels support for Debian-like distributions [qiskit-aer #69](https://github.com/Qiskit/qiskit-aer/pull/69)
*   Added autoconfiguration of threads for qasm simulator [qiskit-aer #61](https://github.com/Qiskit/qiskit-aer/pull/61)
*   Added Simulation method based on Stabilizer Rank Decompositions [qiskit-aer #51](https://github.com/Qiskit/qiskit-aer/pull/51)
*   Added `basis_gates` kwarg to `NoiseModel` init [qiskit-aer #175](https://github.com/Qiskit/qiskit-aer/pull/175).
*   Added an optional parameter to `NoiseModel.as_dict()` for returning dictionaries that can be serialized using the standard json library directly [qiskit-aer #165](https://github.com/Qiskit/qiskit-aer/pull/165)
*   Refactor thread management [qiskit-aer #50](https://github.com/Qiskit/qiskit-aer/pull/50)
*   Improve noise transformations [qiskit-aer #162](https://github.com/Qiskit/qiskit-aer/pull/162)
*   Improve error reporting [qiskit-aer #160](https://github.com/Qiskit/qiskit-aer/pull/160)
*   Improve efficiency of parallelization with `max_memory_mb` a new parameter of `backend_opts` [qiskit-aer #61](https://github.com/Qiskit/qiskit-aer/pull/61)
*   Improve u1 performance in `statevector` [qiskit-aer #123](https://github.com/Qiskit/qiskit-aer/pull/123)

<span id="id586" />

#### Bug Fixes

*   Fixed OpenMP clashing problems on macOS for the Terra add-on [qiskit-aer #46](https://github.com/Qiskit/qiskit-aer/pull/46)

<span id="id587" />

#### Compatibility Considerations

*   Deprecated `"initial_statevector"` backend option for `QasmSimulator` and `StatevectorSimulator` [qiskit-aer #185](https://github.com/Qiskit/qiskit-aer/pull/185)
*   Renamed `"chop_threshold"` backend option to `"zero_threshold"` and changed default value to 1e-10 [qiskit-aer #185](https://github.com/Qiskit/qiskit-aer/pull/185)

<span id="id588" />

### Ignis 0.1

<span id="id589" />

#### New Features

*   Quantum volume
*   Measurement mitigation using tensored calibrations
*   Simultaneous RB has the option to align Clifford gates across subsets
*   Measurement correction can produce a new calibration for a subset of qubits

<span id="id590" />

#### Compatibility Considerations

*   RB writes to the minimal set of classical registers (it used to be Q\[i]->C\[i]). This change enables measurement correction with RB. Unless users had external analysis code, this will not change outcomes. RB circuits from 0.1 are not compatible with 0.1.1 fitters.

<span id="id591" />

### Aqua 0.5

<span id="id592" />

#### New Features

*   Implementation of the HHL algorithm supporting `LinearSystemInput`
*   Pluggable component `Eigenvalues` with variant `EigQPE`
*   Pluggable component `Reciprocal` with variants `LookupRotation` and `LongDivision`
*   Multiple-Controlled U1 and U3 operations `mcu1` and `mcu3`
*   Pluggable component `QFT` derived from component `IQFT`
*   Summarized the transpiled circuits at the DEBUG logging level
*   `QuantumInstance` accepts `basis_gates` and `coupling_map` again.
*   Support to use `cx` gate for the entanglement in `RY` and `RYRZ` variational form (`cz` is the default choice)
*   Support to use arbitrary mixer Hamiltonian in QAOA, allowing use of QAOA in constrained optimization problems \[arXiv:1709.03489]
*   Added variational algorithm base class `VQAlgorithm`, implemented by `VQE` and `QSVMVariational`
*   Added `ising/docplex.py` for automatically generating Ising Hamiltonian from optimization models of DOcplex
*   Added `'basic-dirty-ancilla`’ mode for `mct`
*   Added `mcmt` for Multi-Controlled, Multi-Target gate
*   Exposed capabilities to generate circuits from logical AND, OR, DNF (disjunctive normal forms), and CNF (conjunctive normal forms) formulae
*   Added the capability to generate circuits from ESOP (exclusive sum of products) formulae with optional optimization based on Quine-McCluskey and ExactCover
*   Added `LogicalExpressionOracle` for generating oracle circuits from arbitrary Boolean logic expressions (including DIMACS support) with optional optimization capability
*   Added `TruthTableOracle` for generating oracle circuits from truth-tables with optional optimization capability
*   Added `CustomCircuitOracle` for generating oracle from user specified circuits
*   Added implementation of the Deutsch-Jozsa algorithm
*   Added implementation of the Bernstein-Vazirani algorithm
*   Added implementation of the Simon’s algorithm
*   Added implementation of the Shor’s algorithm
*   Added optional capability for Grover’s algorithm to take a custom initial state (as opposed to the default uniform superposition)
*   Added capability to create a `Custom` initial state using existing circuit
*   Added the ADAM (and AMSGRAD) optimization algorithm
*   Multivariate distributions added, so uncertainty models now have univariate and multivariate distribution components
*   Added option to include or skip the swaps operations for qft and iqft circuit constructions
*   Added classical linear system solver `ExactLSsolver`
*   Added parameters `auto_hermitian` and `auto_resize` to `HHL` algorithm to support non-Hermitian and non $2^n$ sized matrices by default
*   Added another feature map, `RawFeatureVector`, that directly maps feature vectors to qubits’ states for classification
*   `SVM_Classical` can now load models trained by `QSVM`

<span id="id593" />

#### Bug Fixes

*   Fixed `ising/docplex.py` to correctly multiply constant values in constraints
*   Fixed package setup to correctly identify namespace packages using `setuptools.find_namespace_packages`

<span id="id594" />

#### Compatibility Considerations

*   `QuantumInstance` does not take `memory` anymore.
*   Moved command line and GUI to separate repo (`qiskit_aqua_uis`)
*   Removed the `SAT`-specific oracle (now supported by `LogicalExpressionOracle`)
*   Changed `advanced` mode implementation of `mct`: using simple `h` gates instead of `ch`, and fixing the old recursion step in `_multicx`
*   Components `random_distributions` renamed to `uncertainty_models`
*   Reorganized the constructions of various common gates (`ch`, `cry`, `mcry`, `mct`, `mcu1`, `mcu3`, `mcmt`, `logic_and`, and `logic_or`) and circuits (`PhaseEstimationCircuit`, `BooleanLogicCircuits`, `FourierTransformCircuits`, and `StateVectorCircuits`) under the `circuits` directory
*   Renamed the algorithm `QSVMVariational` to `VQC`, which stands for Variational Quantum Classifier
*   Renamed the algorithm `QSVMKernel` to `QSVM`
*   Renamed the class `SVMInput` to `ClassificationInput`
*   Renamed problem type `'svm_classification'` to `'classification'`
*   Changed the type of `entangler_map` used in `FeatureMap` and `VariationalForm` to list of lists

<span id="ibm-q-provider-0-1" />

### IBM Q Provider 0.1

<span id="id595" />

#### New Features

*   This is the first release as a standalone package. If you are installing Terra standalone you’ll also need to install the `qiskit-ibmq-provider` package with `pip install qiskit-ibmq-provider` if you want to use the IBM Q backends.
*   Support for non-Qobj format jobs has been removed from the provider. You’ll have to convert submissions in an older format to Qobj before you can submit.

<span id="qiskit-0-8" />

## Qiskit 0.8

In Qiskit 0.8 we introduced the Qiskit Ignis element. It also includes the Qiskit Terra element 0.7.1 release which contains a bug fix for the BasicAer Python simulator.

<span id="terra-0-7" />

### Terra 0.7

No Change

<span id="aer-0-1" />

### Aer 0.1

No Change

<span id="id596" />

### Ignis 0.1

This is the first release of Qiskit Ignis.

<span id="qiskit-0-7" />

## Qiskit 0.7

In Qiskit 0.7 we introduced Qiskit Aer and combined it with Qiskit Terra.

<span id="id597" />

### Terra 0.7

<span id="id598" />

#### New Features

This release includes several new features and many bug fixes. With this release the interfaces for circuit diagram, histogram, bloch vectors, and state visualizations are declared stable. Additionally, this release includes a defined and standardized bit order/endianness throughout all aspects of Qiskit. These are all declared as stable interfaces in this release which won’t have breaking changes made moving forward, unless there is appropriate and lengthy deprecation periods warning of any coming changes.

There is also the introduction of the following new features:

*   A new ASCII art circuit drawing output mode
*   A new circuit drawing interface off of `QuantumCircuit` objects that enables calls of `circuit.draw()` or `print(circuit)` to render a drawing of circuits
*   A visualizer for drawing the DAG representation of a circuit
*   A new quantum state plot type for hinton diagrams in the local matplotlib based state plots
*   2 new constructor methods off the `QuantumCircuit` class `from_qasm_str()` and `from_qasm_file()` which let you easily create a circuit object from OpenQASM
*   A new function `plot_bloch_multivector()` to plot Bloch vectors from a tensored state vector or density matrix
*   Per-shot measurement results are available in simulators and select devices. These can be accessed by setting the `memory` kwarg to `True` when calling `compile()` or `execute()` and then accessed using the `get_memory()` method on the `Result` object.
*   A `qiskit.quantum_info` module with revamped Pauli objects and methods for working with quantum states
*   New transpile passes for circuit analysis and transformation: `CommutationAnalysis`, `CommutationTransformation`, `CXCancellation`, `Decompose`, `Unroll`, `Optimize1QGates`, `CheckMap`, `CXDirection`, `BarrierBeforeFinalMeasurements`
*   New alternative swap mapper passes in the transpiler: `BasicSwap`, `LookaheadSwap`, `StochasticSwap`
*   More advanced transpiler infrastructure with support for analysis passes, transformation passes, a global `property_set` for the pass manager, and repeat-until control of passes

<span id="id599" />

#### Compatibility Considerations

As part of the 0.7 release the following things have been deprecated and will either be removed or changed in a backwards incompatible manner in a future release. While not strictly necessary these are things to adjust for before the next release to avoid a breaking change.

*   `plot_circuit()`, `latex_circuit_drawer()`, `generate_latex_source()`, and `matplotlib_circuit_drawer()` from qiskit.tools.visualization are deprecated. Instead the `circuit_drawer()` function from the same module should be used, there are kwarg options to mirror the functionality of all the deprecated functions.
*   The current default output of `circuit_drawer()` (using latex and falling back on python) is deprecated and will be changed to just use the `text` output by default in future releases.
*   The `qiskit.wrapper.load_qasm_string()` and `qiskit.wrapper.load_qasm_file()` functions are deprecated and the `QuantumCircuit.from_qasm_str()` and `QuantumCircuit.from_qasm_file()` constructor methods should be used instead.
*   The `plot_barriers` and `reverse_bits` keys in the `style` kwarg dictionary are deprecated, instead the `qiskit.tools.visualization.circuit_drawer()` kwargs `plot_barriers` and `reverse_bits` should be used instead.
*   The functions `plot_state()` and `iplot_state()` have been depreciated. Instead the functions `plot_state_*()` and `iplot_state_*()` should be called for the visualization method required.
*   The `skip_transpiler` argument has been deprecated from `compile()` and `execute()`. Instead you can use the `PassManager` directly, just set the `pass_manager` to a blank `PassManager` object with `PassManager()`
*   The `transpile_dag()` function `format` kwarg for emitting different output formats is deprecated, instead you should convert the default output `DAGCircuit` object to the desired format.
*   The unrollers have been deprecated, moving forward only DAG to DAG unrolling will be supported.

Please note that some backwards-incompatible changes have been made during this release. The following notes contain information on how to adapt to these changes.

##### Changes to Result objects

As part of the rewrite of the Results object to be more consistent and a stable interface moving forward a few changes have been made to how you access the data stored in the result object. First the `get_data()` method has been renamed to just `data()`. Accompanying that change is a change in the data format returned by the function. It is now returning the raw data from the backends instead of doing any post-processing. For example, in previous versions you could call:

```python
result = execute(circuit, backend).result()
unitary = result.get_data()['unitary']
print(unitary)
```

and that would return the unitary matrix like:

```python
[[1+0j, 0+0.5j], [0-0.5j][-1+0j]]
```

But now if you call (with the renamed method):

```python
result.data()['unitary']
```

it will return something like:

```python
[[[1, 0], [0, -0.5]], [[0, -0.5], [-1, 0]]]
```

To get the post processed results in the same format as before the 0.7 release you must use the `get_counts()`, `get_statevector()`, and `get_unitary()` methods on the result object instead of `get_data()['counts']`, `get_data()['statevector']`, and `get_data()['unitary']` respectively.

Additionally, support for `len()` and indexing on a `Result` object has been removed. Instead you should deal with the output from the post processed methods on the Result objects.

Also, the `get_snapshot()` and `get_snapshots()` methods from the `Result` class have been removed. Instead you can access the snapshots using `Result.data()['snapshots']`.

##### Changes to Visualization

The largest change made to visualization in the 0.7 release is the removal of Matplotlib and other visualization dependencies from the project requirements. This was done to simplify the requirements and configuration required for installing Qiskit. If you plan to use any visualizations (including all the jupyter magics) except for the `text`, `latex`, and `latex_source` output for the circuit drawer you’ll you must manually ensure that the visualization dependencies are installed. You can leverage the optional requirements to the Qiskit Terra package to do this:

```python
pip install qiskit-terra[visualization]
```

Aside from this there have been changes made to several of the interfaces as part of the stabilization which may have an impact on existing code. The first is the `basis` kwarg in the `circuit_drawer()` function is no longer accepted. If you were relying on the `circuit_drawer()` to adjust the basis gates used in drawing a circuit diagram you will have to do this priort to calling `circuit_drawer()`. For example:

```python
from qiskit.tools import visualization
visualization.circuit_drawer(circuit, basis_gates='x,U,CX')
```

will have to be adjusted to be:

```python
from qiskit import BasicAer
from qiskit import transpiler
from qiskit.tools import visualization
backend = BasicAer.backend('qasm_simulator')
draw_circ = transpiler.transpile(circuit, backend, basis_gates='x,U,CX')
visualization.circuit_drawer(draw_circ)
```

Moving forward the `circuit_drawer()` function will be the sole interface for circuit drawing in the visualization module. Prior to the 0.7 release there were several other functions which either used different output backends or changed the output for drawing circuits. However, all those other functions have been deprecated and that functionality has been integrated as options on `circuit_drawer()`.

For the other visualization functions, `plot_histogram()` and `plot_state()` there are also a few changes to check when upgrading. First is the output from these functions has changed, in prior releases these would interactively show the output visualization. However that has changed to instead return a `matplotlib.Figure` object. This provides much more flexibility and options to interact with the visualization prior to saving or showing it. This will require adjustment to how these functions are consumed. For example, prior to this release when calling:

```python
plot_histogram(counts)
plot_state(rho)
```

would open up new windows (depending on matplotlib backend) to display the visualization. However starting in the 0.7 you’ll have to call `show()` on the output to mirror this behavior. For example:

```python
plot_histogram(counts).show()
plot_state(rho).show()
```

or:

```python
hist_fig = plot_histogram(counts)
state_fig = plot_state(rho)
hist_fig.show()
state_fig.show()
```

Note that this is only for when running outside of Jupyter. No adjustment is required inside a Jupyter environment because Jupyter notebooks natively understand how to render `matplotlib.Figure` objects.

However, returning the Figure object provides additional flexibility for dealing with the output. For example instead of just showing the figure you can now directly save it to a file by leveraging the `savefig()` method. For example:

```python
hist_fig = plot_histogram(counts)
state_fig = plot_state(rho)
hist_fig.savefig('histogram.png')
state_fig.savefig('state_plot.png')
```

The other key aspect which has changed with these functions is when running under jupyter. In the 0.6 release `plot_state()` and `plot_histogram()` when running under jupyter the default behavior was to use the interactive Javascript plots if the externally hosted Javascript library for rendering the visualization was reachable over the network. If not it would just use the matplotlib version. However in the 0.7 release this no longer the case, and separate functions for the interactive plots, `iplot_state()` and `iplot_histogram()` are to be used instead. `plot_state()` and `plot_histogram()` always use the matplotlib versions.

Additionally, starting in this release the `plot_state()` function is deprecated in favor of calling individual methods for each method of plotting a quantum state. While the `plot_state()` function will continue to work until the 0.9 release, it will emit a warning each time it is used. The

| Qiskit Terra 0.6                    | Qiskit Terra 0.7+             |
| ----------------------------------- | ----------------------------- |
| plot\_state(rho)                    | plot\_state\_city(rho)        |
| plot\_state(rho, method=’city’)     | plot\_state\_city(rho)        |
| plot\_state(rho, method=’paulivec’) | plot\_state\_paulivec(rho)    |
| plot\_state(rho, method=’qsphere’)  | plot\_state\_qsphere(rho)     |
| plot\_state(rho, method=’bloch’)    | plot\_bloch\_multivector(rho) |
| plot\_state(rho, method=’hinton’)   | plot\_state\_hinton(rho)      |

The same is true for the interactive JS equivalent, `iplot_state()`. The function names are all the same, just with a prepended i for each function. For example, `iplot_state(rho, method='paulivec')` is `iplot_state_paulivec(rho)`.

##### Changes to Backends

With the improvements made in the 0.7 release there are a few things related to backends to keep in mind when upgrading. The biggest change is the restructuring of the provider instances in the root `` qiskit` `` namespace. The `Aer` provider is not installed by default and requires the installation of the `qiskit-aer` package. This package contains the new high performance fully featured simulator. If you installed via `pip install qiskit` you’ll already have this installed. The python simulators are now available under `qiskit.BasicAer` and the old C++ simulators are available with `qiskit.LegacySimulators`. This also means that the implicit fallback to python based simulators when the C++ simulators are not found doesn’t exist anymore. If you ask for a local C++ based simulator backend, and it can’t be found an exception will be raised instead of just using the python simulator instead.

Additionally the previously deprecation top level functions `register()` and `available_backends()` have been removed. Also, the deprecated `backend.parameters()` and `backend.calibration()` methods have been removed in favor of `backend.properties()`. You can refer to the 0.6 release notes section [Working with backends](#backends) for more details on these changes.

The `backend.jobs()` and `backend.retrieve_jobs()` calls no longer return results from those jobs. Instead you must call the `result()` method on the returned jobs objects.

##### Changes to the compiler, transpiler, and unrollers

As part of an effort to stabilize the compiler interfaces there have been several changes to be aware of when leveraging the compiler functions. First it is important to note that the `qiskit.transpiler.transpile()` function now takes a QuantumCircuit object (or a list of them) and returns a QuantumCircuit object (or a list of them). The DAG processing is done internally now.

You can also easily switch between circuits, DAGs, and Qobj now using the functions in `qiskit.converters`.

<span id="id600" />

### Aer 0.1

<span id="id601" />

#### New Features

Aer provides three simulator backends:

*   `QasmSimulator`: simulate experiments and return measurement outcomes
*   `StatevectorSimulator`: return the final statevector for a quantum circuit acting on the all zero state
*   `UnitarySimulator`: return the unitary matrix for a quantum circuit

`noise` module: contains advanced noise modeling features for the `QasmSimulator`

*   `NoiseModel`, `QuantumError`, `ReadoutError` classes for simulating a Qiskit quantum circuit in the presence of errors
*   `errors` submodule including functions for generating `QuantumError` objects for the following types of quantum errors: Kraus, mixed unitary, coherent unitary, Pauli, depolarizing, thermal relaxation, amplitude damping, phase damping, combined phase and amplitude damping
*   `device` submodule for automatically generating a noise model based on the `BackendProperties` of a device

`utils` module:

*   `qobj_utils` provides functions for directly modifying a Qobj to insert special simulator instructions not yet supported through the Qiskit Terra API.

<span id="aqua-0-4" />

### Aqua 0.4

<span id="id602" />

#### New Features

*   Programmatic APIs for algorithms and components – each component can now be instantiated and initialized via a single (non-empty) constructor call

*   `QuantumInstance` API for algorithm/backend decoupling – `QuantumInstance` encapsulates a backend and its settings

*   Updated documentation and Jupyter Notebooks illustrating the new programmatic APIs

*   Transparent parallelization for gradient-based optimizers

*   Multiple-Controlled-NOT (cnx) operation

*   Pluggable algorithmic component `RandomDistribution`

*   Concrete implementations of `RandomDistribution`: `BernoulliDistribution`, `LogNormalDistribution`, `MultivariateDistribution`, `MultivariateNormalDistribution`, `MultivariateUniformDistribution`, `NormalDistribution`, `UniformDistribution`, and `UnivariateDistribution`

*   Concrete implementations of `UncertaintyProblem`: `FixedIncomeExpectedValue`, `EuropeanCallExpectedValue`, and `EuropeanCallDelta`

*   Amplitude Estimation algorithm

*   Qiskit Optimization: New Ising models for optimization problems exact cover, set packing, vertex cover, clique, and graph partition

*   Qiskit AI:

    *   New feature maps extending the `FeatureMap` pluggable interface: `PauliExpansion` and `PauliZExpansion`
    *   Training model serialization/deserialization mechanism

*   Qiskit Finance:

    *   Amplitude estimation for Bernoulli random variable: illustration of amplitude estimation on a single qubit problem
    *   Loading of multiple univariate and multivariate random distributions
    *   European call option: expected value and delta (using univariate distributions)
    *   Fixed income asset pricing: expected value (using multivariate distributions)

*   The Pauli string in `Operator` class is aligned with Terra 0.7. Now the order of a n-qubit pauli string is `q_{n-1}...q{0}` Thus, the (de)serialier (`save_to_dict` and `load_from_dict`) in the `Operator` class are also changed to adopt the changes of `Pauli` class.

<span id="id603" />

#### Compatibility Considerations

*   `HartreeFock` component of pluggable type `InitialState` moved to Qiskit Chemistry
*   `UCCSD` component of pluggable type `VariationalForm` moved to Qiskit Chemistry

<span id="qiskit-0-6" />

## Qiskit 0.6

<span id="terra-0-6" />

### Terra 0.6

<span id="id604" />

#### Highlights

This release includes a redesign of internal components centered around a new, formal communication format (Qobj), along with long awaited features to improve the user experience as a whole. The highlights, compared to the 0.5 release, are:

*   Improvements for inter-operability (based on the Qobj specification) and extensibility (facilities for extending Qiskit with new backends in a seamless way)
*   New options for handling credentials and authentication for the IBM Q backends, aimed at simplifying the process and supporting automatic loading of user credentials
*   A revamp of the visualization utilities: stylish interactive visualizations are now available for Jupyter users, along with refinements for the circuit drawer (including a matplotlib-based version)
*   Performance improvements centered around circuit transpilation: the basis for a more flexible and modular architecture have been set, including parallelization of the circuit compilation and numerous optimizations

<span id="id605" />

#### Compatibility Considerations

Please note that some backwards-incompatible changes have been introduced during this release – the following notes contain information on how to adapt to the new changes.

<span id="removal-of-quantumprogram" />

##### Removal of `QuantumProgram`

As hinted during the 0.5 release, the deprecation of the `QuantumProgram` class has now been completed and is no longer available, in favor of working with the individual components (`BaseJob`, `QuantumCircuit`, `ClassicalRegister`, `QuantumRegister`, [`qiskit`](index#module-qiskit "qiskit")) directly.

Please check the [0.5 release notes](#quantum-program-0-5) and the examples for details about the transition:

```python
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import Aer, execute

q = QuantumRegister(2)
c = ClassicalRegister(2)
qc = QuantumCircuit(q, c)

qc.h(q[0])
qc.cx(q[0], q[1])
qc.measure(q, c)

backend = get_backend('qasm_simulator')

job_sim = execute(qc, backend)
sim_result = job_sim.result()

print("simulation: ", sim_result)
print(sim_result.get_counts(qc))
```

<span id="ibm-q-authentication-and-qconfig-py" />

##### IBM Q Authentication and `Qconfig.py`

The managing of credentials for authenticating when using the IBM Q backends has been expanded, and there are new options that can be used for convenience:

1.  save your credentials in disk once, and automatically load them in future sessions. This provides a one-off mechanism:

    ```python
    from qiskit import IBMQ
    IBMQ.save_account('MY_API_TOKEN', 'MY_API_URL')
    ```

    afterwards, your credentials can be automatically loaded from disk by invoking `load_accounts()`:

    ```python
    from qiskit import IBMQ
    IBMQ.load_accounts()
    ```

    or you can load only specific accounts if you only want to use those in a session:

    ```python
    IBMQ.load_accounts(project='MY_PROJECT')
    ```

2.  use environment variables. If `QE_TOKEN` and `QE_URL` is set, the `IBMQ.load_accounts()` call will automatically load the credentials from them.

Additionally, the previous method of having a `Qconfig.py` file in the program folder and passing the credentials explicitly is still supported.

<span id="backends" />

##### Working with backends

A new mechanism has been introduced in Terra 0.6 as the recommended way for obtaining a backend, allowing for more powerful and unified filtering and integrated with the new credentials system. The previous top-level methods `register()`, `available_backends()` and `get_backend()` are still supported, but will deprecated in upcoming versions in favor of using the qiskit.IBMQ and qiskit.Aer objects directly, which allow for more complex filtering.

For example, to list and use a local backend:

```python
from qiskit import Aer

all_local_backends = Aer.backends(local=True)  # returns a list of instances
qasm_simulator = Aer.backends('qasm_simulator')
```

And for listing and using remote backends:

```python
from qiskit import IBMQ

IBMQ.enable_account('MY_API_TOKEN')
5_qubit_devices = IBMQ.backends(simulator=True, n_qubits=5)
ibmqx4 = IBMQ.get_backend('ibmqx4')
```

Please note as well that the names of the local simulators have been simplified. The previous names can still be used, but it is encouraged to use the new, shorter names:

| Qiskit Terra 0.5                | Qiskit Terra 0.6         |
| ------------------------------- | ------------------------ |
| ‘local\_qasm\_simulator’        | ‘qasm\_simulator’        |
| ‘local\_statevector\_simulator’ | ‘statevector\_simulator’ |
| ‘local\_unitary\_simulator\_py’ | ‘unitary\_simulator’     |

##### Backend and Job API changes

*   Jobs submitted to IBM Q backends have improved capabilities. It is possible to cancel them and replenish credits (`job.cancel()`), and to retrieve previous jobs executed on a specific backend either by job id (`backend.retrieve_job(job_id)`) or in batch of latest jobs (`backend.jobs(limit)`)

*   Properties for checking each individual job status (`queued`, `running`, `validating`, `done` and `cancelled`) no longer exist. If you want to check the job status, use the identity comparison against `job.status`:

    ```python
    from qiskit.backends import JobStatus

    job = execute(circuit, backend)
    if job.status() is JobStatus.RUNNING:
        handle_job(job)
    ```

Please consult the new documentation of the `IBMQJob` class to get further insight in how to use the simplified API.

*   A number of members of `BaseBackend` and `BaseJob` are no longer properties, but methods, and as a result they need to be invoked as functions.

    | Qiskit Terra 0.5      | Qiskit Terra 0.6                              |
    | --------------------- | --------------------------------------------- |
    | backend.name          | backend.name()                                |
    | backend.status        | backend.status()                              |
    | backend.configuration | backend.configuration()                       |
    | backend.calibration   | backend.properties()                          |
    | backend.parameters    | backend.jobs() backend.retrieve\_job(job\_id) |
    | job.status            | job.status()                                  |
    | job.cancelled         | job.queue\_position()                         |
    | job.running           | job.cancel()                                  |
    | job.queued            |                                               |
    | job.done              |                                               |

##### Better Jupyter tools

The new release contains improvements to the user experience while using Jupyter notebooks.

First, new interactive visualizations of counts histograms and quantum states are provided: `plot_histogram()` and `plot_state()`. These methods will default to the new interactive kind when the environment is Jupyter and internet connection exists.

Secondly, the new release provides Jupyter cell magics for keeping track of the progress of your code. Use `%%qiskit_job_status` to keep track of the status of submitted jobs to IBM Q backends. Use `%%qiskit_progress_bar` to keep track of the progress of compilation/execution.

<span id="qiskit-0-5" />

## Qiskit 0.5

<span id="terra-0-5" />

### Terra 0.5

<span id="id606" />

#### Highlights

This release brings a number of improvements to Qiskit, both for the user experience and under the hood. Please refer to the full changelog for a detailed description of the changes - the highlights are:

*   new `statevector` `simulators` and feature and performance improvements to the existing ones (in particular to the C++ simulator), along with a reorganization of how to work with backends focused on extensibility and flexibility (using aliases and backend providers)
*   reorganization of the asynchronous features, providing a friendlier interface for running jobs asynchronously via `Job` instances
*   numerous improvements and fixes throughout the Terra as a whole, both for convenience of the users (such as allowing anonymous registers) and for enhanced functionality (such as improved plotting of circuits)

<span id="id607" />

#### Compatibility Considerations

Please note that several backwards-incompatible changes have been introduced during this release as a result of the ongoing development. While some of these features will continue to be supported during a period of time before being fully deprecated, it is recommended to update your programs in order to prepare for the new versions and take advantage of the new functionality.

<span id="quantumprogram-changes" />

<span id="quantum-program-0-5" />

##### `QuantumProgram` changes

Several methods of the `QuantumProgram` class are on their way to being deprecated:

*   methods for interacting **with the backends and the API**:

    The recommended way for opening a connection to the IBM Q API and for using the backends is through the top-level functions directly instead of the `QuantumProgram` methods. In particular, the `qiskit.register()` method provides the equivalent of the previous `qiskit.QuantumProgram.set_api()` call. In a similar vein, there is a new `qiskit.available_backends()`, `qiskit.get_backend()` and related functions for querying the available backends directly. For example, the following snippet for version 0.4:

    ```python
    from qiskit import QuantumProgram

    quantum_program = QuantumProgram()
    quantum_program.set_api(token, url)
    backends = quantum_program.available_backends()
    print(quantum_program.get_backend_status('ibmqx4')
    ```

    would be equivalent to the following snippet for version 0.5:

    ```python
    from qiskit import register, available_backends, get_backend

    register(token, url)
    backends = available_backends()
    backend = get_backend('ibmqx4')
    print(backend.status)
    ```

*   methods for **compiling and executing programs**:

    The top-level functions now also provide equivalents for the `qiskit.QuantumProgram.compile()` and `qiskit.QuantumProgram.execute()` methods. For example, the following snippet from version 0.4:

    ```python
    quantum_program.execute(circuit, args, ...)
    ```

    would be equivalent to the following snippet for version 0.5:

    ```python
    from qiskit import execute

    execute(circuit, args, ...)
    ```

In general, from version 0.5 onwards we encourage to try to make use of the individual objects and classes directly instead of relying on `QuantumProgram`. For example, a `QuantumCircuit` can be instantiated and constructed by appending `QuantumRegister`, `ClassicalRegister`, and gates directly. Please check the update example in the Quickstart section, or the `using_qiskit_core_level_0.py` and `using_qiskit_core_level_1.py` examples on the main repository.

##### Backend name changes

In order to provide a more extensible framework for backends, there have been some design changes accordingly:

*   **local simulator names**

    The names of the local simulators have been homogenized in order to follow the same pattern: `PROVIDERNAME_TYPE_simulator_LANGUAGEORPROJECT` - for example, the C++ simulator previously named `local_qiskit_simulator` is now `local_qasm_simulator_cpp`. An overview of the current simulators:

    *   `QASM` simulator is supposed to be like an experiment. You apply a circuit on some qubits, and observe measurement results - and you repeat for many shots to get a histogram of counts via `result.get_counts()`.
    *   `Statevector` simulator is to get the full statevector ($2^n$ amplitudes) after evolving the zero state through the circuit, and can be obtained via `result.get_statevector()`.
    *   `Unitary` simulator is to get the unitary matrix equivalent of the circuit, returned via `result.get_unitary()`.
    *   In addition, you can get intermediate states from a simulator by applying a `snapshot(slot)` instruction at various spots in the circuit. This will save the current state of the simulator in a given slot, which can later be retrieved via `result.get_snapshot(slot)`.

*   **backend aliases**:

    The SDK now provides an “alias” system that allows for automatically using the most performant simulator of a specific type, if it is available in your system. For example, with the following snippet:

    ```python
    from qiskit import get_backend

    backend = get_backend('local_statevector_simulator')
    ```

    the backend will be the C++ statevector simulator if available, falling back to the Python statevector simulator if not present.

##### More flexible names and parameters

Several functions of the SDK have been made more flexible and user-friendly:

*   **automatic circuit and register names**

    `qiskit.ClassicalRegister`, `qiskit.QuantumRegister` and `qiskit.QuantumCircuit` can now be instantiated without explicitly giving them a name - a new autonaming feature will automatically assign them an identifier:

    ```python
    q = QuantumRegister(2)
    ```

    Please note as well that the order of the parameters have been swapped `QuantumRegister(size, name)`.

*   **methods accepting names or instances**

    In combination with the autonaming changes, several methods such as `qiskit.Result.get_data()` now accept both names and instances for convenience. For example, when retrieving the results for a job that has a single circuit such as:

    ```python
    qc = QuantumCircuit(..., name='my_circuit')
    job = execute(qc, ...)
    result = job.result()
    ```

    The following calls are equivalent:

    ```python
    data = result.get_data('my_circuit')
    data = result.get_data(qc)
    data = result.get_data()
    ```

