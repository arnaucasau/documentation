---
title: Qiskit 0.25 release notes
description: New features and bug fixes
---

# Qiskit 0.25 release notes

## 0.25.0rc1

<span id="relnotes-0-25-0rc1-new-features" />

### New Features

*   Added two new options to `BlockCollector`.

    The first new options `split_layers` allows to split the collected block into sub-blocks over disjoint qubit subsets, i.e. into depth-1 sub-blocks.

    The second new option `collect_from_back` allows to greedily collect blocks starting from the outputs of the circuit. This is important in combination with ALAP-scheduling passes where we may prefer to put gates in the later rather than earlier blocks.

*   Added new options `split_layers` and `collect_from_back` to `CollectLinearFunctions` and `CollectCliffords` transpiler passes.

    When `split_layers` is True, the collected blocks are split into into sub-blocks over disjoint qubit subsets, i.e. into depth-1 sub-blocks. Consider the following example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler.passes import CollectLinearFunctions

    circuit = QuantumCircuit(5)
    circuit.cx(0, 2)
    circuit.cx(1, 4)
    circuit.cx(2, 0)
    circuit.cx(0, 3)
    circuit.swap(3, 2)
    circuit.swap(4, 1)

    # Collect all linear gates, without splitting into layers
    qct = CollectLinearFunctions(split_blocks=False, min_block_size=1, split_layers=False)(circuit)
    assert qct.count_ops()["linear_function"] == 1

    # Collect all linear gates, with splitting into layers
    qct = CollectLinearFunctions(split_blocks=False, min_block_size=1, split_layers=True)(circuit)
    assert qct.count_ops()["linear_function"] == 4
    ```

    The original circuit is linear. When collecting linear gates without splitting into layers, we should end up with a single linear function. However, when collecting linear gates and splitting into layers, we should end up with 4 linear functions.

    When `collect_from_back` is True, the blocks are greedily collected from the outputs towards the inputs of the circuit. Consider the following example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler.passes import CollectLinearFunctions

    circuit = QuantumCircuit(3)
    circuit.cx(1, 2)
    circuit.cx(1, 0)
    circuit.h(2)
    circuit.swap(1, 2)

    # This combines the CX(1, 2) and CX(1, 0) gates into a single linear function
    qct = CollectLinearFunctions(collect_from_back=False)(circuit)

    # This combines the CX(1, 0) and SWAP(1, 2) gates into a single linear function
    qct = CollectLinearFunctions(collect_from_back=True)(circuit)
    ```

    The original circuit contains a Hadamard gate, so that the CX(1, 0) gate can be combined either with CX(1, 2) or with SWAP(1, 2), but not with both. When `collect_from_back` is False, the linear blocks are greedily collected from the start of the circuit, and thus CX(1, 0) is combined with CX(1, 2). When `collect_from_back` is True, the linear blocks are greedily collected from the end of the circuit, and thus CX(1, 0) is combined with SWAP(1, 2).

*   Added [`DAGCircuit.classical_predecessors()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.classical_predecessors "qiskit.dagcircuit.DAGCircuit.classical_predecessors") and [`DAGCircuit.classical_successors()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.classical_successors "qiskit.dagcircuit.DAGCircuit.classical_successors"), an alternative to select the classical wires without having to go to the inner graph object directly of a node in the DAG. The following example illustrates the new functionality:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit.converters import circuit_to_dag
    from qiskit.circuit.library import RZGate

    q = QuantumRegister(3, 'q')
    c = ClassicalRegister(3, 'c')
    circ = QuantumCircuit(q, c)
    circ.h(q[0])
    circ.cx(q[0], q[1])
    circ.measure(q[0], c[0])
    circ.rz(0.5, q[1]).c_if(c, 2)
    circ.measure(q[1], c[0])
    dag = circuit_to_dag(circ)

    rz_node = dag.op_nodes(RZGate)[0]
    # Contains the "measure" on clbit 0, and the "wire start" nodes for clbits 1 and 2.
    classical_predecessors = list(dag.classical_predecessors(rz_node))
    # Contains the "measure" on clbit 0, and the "wire end" nodes for clbits 1 and 2.
    classical_successors = list(dag.classical_successors(rz_node))
    ```

*   Enabled performing the [`qiskit.transpiler.passes.CommutativeCancellation`](/api/qiskit/qiskit.transpiler.passes.CommutativeCancellation#qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation") pass inside the blocks of [`qiskit.circuit.ControlFlowOp`](/api/qiskit/qiskit.circuit.ControlFlowOp#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp"). This pass reorders some commuting gates and reduces resulting pairs of self-inverse gates. Previously, the blocks in control flow operations were skipped by this pass. The new feature operates recursively, that is, it will act on control flow operations inside blocks.

*   Enabled performing the [`ConsolidateBlocks`](/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") pass inside the blocks of [`ControlFlowOp`](/api/qiskit/qiskit.circuit.ControlFlowOp#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp"). This pass collects several sequences of gates and replaces each sequence with the equivalent numeric unitary gate. This new feature enables applying this pass recursively to the blocks in control flow operations. Note that the meaning of “block” in [`ConsolidateBlocks`](/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") is unrelated to that in [`ControlFlowOp`](/api/qiskit/qiskit.circuit.ControlFlowOp#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp").

*   Added [`DAGCircuit.quantum_causal_cone()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.quantum_causal_cone "qiskit.dagcircuit.DAGCircuit.quantum_causal_cone") to obtain the causal cone of a qubit in a [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit"). The following example shows its correct usage:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit.circuit.library import CXGate, CZGate
    from qiskit.dagcircuit import DAGCircuit

    # Build a DAGCircuit
    dag = DAGCircuit()
    qreg = QuantumRegister(5)
    creg = ClassicalRegister(5)
    dag.add_qreg(qreg)
    dag.add_creg(creg)
    dag.apply_operation_back(CXGate(), qreg[[1, 2]], [])
    dag.apply_operation_back(CXGate(), qreg[[0, 3]], [])
    dag.apply_operation_back(CZGate(), qreg[[1, 4]], [])
    dag.apply_operation_back(CZGate(), qreg[[2, 4]], [])
    dag.apply_operation_back(CXGate(), qreg[[3, 4]], [])

    # Get the causal cone of qubit at index 0
    result = dag.quantum_causal_cone(qreg[0])
    ```

*   Added a new function , `negativity()` that adds support for calculating entanglement measures negativity of an quantum state. An illustrative example for using the above function is given below:

*   A new method, `find_bit()`, has been added to the `DagCircuit` class. This is a method to get mapping of Qubit and Clbit to positional index. The method takes a Bit as input, checks whether it’s a Qubit or a Clbit, and then returns the corresponding BitLocations from the respective index dictionary (\_qubit\_indices or \_clbit\_indices). The BitLocations is a namedtuple which includes the positional index of the bit in the circuit and a list of registers containing the bit. If the bit cannot be found or is of an unknown type, it raises a DAGCircuitError.

*   The transpiler’s built-in [`EquivalenceLibrary`](/api/qiskit/qiskit.circuit.EquivalenceLibrary#qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") has been taught the circular Pauli relations $X = iYZ$, $Y = iZX$ and $Z = iXY$. This should make transpiling to constrained, and potentially incomplete, basis sets more reliable. See [#10293](https://github.com/Qiskit/qiskit-terra/issues/10293) for more detail.

*   Add `schmidt_decomposition` function to the `quantum_info` module. This function works with the `Statevector` and `DensityMatrix` classes for bipartite pure states.

*   Control-flow operations are now supported through the transpiler at all optimization levels, including levels 2 and 3 (e.g. calling [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`generate_preset_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") with keyword argument `optimization_level=3`).

*   Added a new synthesis algorithm `qiskit.synthesis.linear_phase.synth_cx_cz_depth_line_my()` of a CX circuit followed by a CZ circuit for linear nearest neighbor (LNN) connectivity in 2-qubit depth of at most 5n using CX and phase gates (S, Sdg or Z). The synthesis algorithm is based on the paper of Maslov and Yang ([https://arxiv.org/abs/2210.16195](https://arxiv.org/abs/2210.16195)). The algorithm accepts a binary invertible matrix `mat_x` representing the CX-circuit, a binary symmetric matrix `mat_z` representing the CZ-circuit, and returns a quantum circuit with 2-qubit depth of at most 5n computing the composition of the CX and CZ circuits. The following example illustrates the new functionality:

    ```python
    import numpy as np
    from qiskit.synthesis.linear_phase import synth_cx_cz_depth_line_my
    mat_x = np.array([[0, 1], [1, 1]])
    mat_z = np.array([[0, 1], [1, 0]])
    qc = synth_cx_cz_depth_line_my(mat_x, mat_z)
    ```

    This algorithm is now used by default in the Clifford synthesis algorithm `qiskit.synthesis.clifford.synth_clifford_depth_lnn()` that optimizes 2-qubit depth for LNN connectivity, improving the 2-qubit depth from 9n+4 to 7n+2. The clifford synthesis algorithm can be used as follows:

    ```python
    from qiskit.quantum_info import random_clifford
    from qiskit.synthesis import synth_clifford_depth_lnn

    cliff = random_clifford(3)
    qc = synth_clifford_depth_lnn(cliff)
    ```

    The above synthesis can be further improved as described in the paper by Maslov and Yang, using local optimization between 2-qubit layers. This improvement is left for follow-up work.

*   [`DAGCircuit.substitute_node()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.substitute_node "qiskit.dagcircuit.DAGCircuit.substitute_node") gained a `propagate_condition` keyword argument that is analogous to the same argument in [`substitute_node_with_dag()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag "qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag"). Setting this to `False` opts out of the legacy behaviour of copying a condition on the `node` onto the new `op` that is replacing it.

    This option is ignored for general control-flow operations, which will never propagate their condition, nor accept a condition from another node.

*   Introduced a new method, [`separable_circuits()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.separable_circuits "qiskit.dagcircuit.DAGCircuit.separable_circuits"), which returns a list of [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") objects, one for each set of connected qubits which have no gates connecting them to another set.

    Each [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") instance returned by this method will contain the same number of clbits as `self`. This method will not return [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") instances consisting solely of clbits.

*   The `SymbolicPulse` library was extended. The new pulses in the library are:

    > *   [`GaussianDeriv()`](/api/qiskit/qiskit.pulse.library.GaussianDeriv#qiskit.pulse.library.GaussianDeriv "qiskit.pulse.library.GaussianDeriv")
    > *   [`Sech()`](/api/qiskit/qiskit.pulse.library.Sech_fun.rst#qiskit.pulse.library.Sech "qiskit.pulse.library.Sech")
    > *   [`SechDeriv()`](/api/qiskit/qiskit.pulse.library.SechDeriv#qiskit.pulse.library.SechDeriv "qiskit.pulse.library.SechDeriv")
    > *   [`Square()`](/api/qiskit/qiskit.pulse.library.Square_fun.rst#qiskit.pulse.library.Square "qiskit.pulse.library.Square")

    The new functions return a `ScalableSymbolicPulse`, and match the functionality of the corresponding functions in the discrete pulse library, with the exception of Square() for which a phase of $2\\pi$ shifts by a full cycle (contrary to the discrete square() where such a shift was induced by a $\\pi$ phase).

*   In `MatplotlibDrawer`, operations built from [`ControlFlowOp`](/api/qiskit/qiskit.circuit.ControlFlowOp#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp"), including `if`, `else`, `while`, `for`, and `switch/case`, whether directly instantiated or built using methods in [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"), will now fully display the circuits defined in the ControlFlowOps wrapped with boxes to delineate the circuits.

*   Added [`concurrent_measurements`](/api/qiskit/qiskit.transpiler.Target#qiskit.transpiler.Target.concurrent_measurements "qiskit.transpiler.Target.concurrent_measurements") which represents a hardware constraint of qubits measured concurrently. This constraint is provided in the nested list form, in which each element represents qubit group to be measured together. In an example below,

    ```python
    [[0, 1], [2, 3, 4]]
    ```

    qubits 0 and 1, and 2, 3 and 4 are measured together on the device. This constraint doesn’t block measuring an individual qubit, however, Qiskit scheduler must consider the alignment of measure operations for those qubits.

*   The performance of [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") and [`bind_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") has significantly increased for large circuits with structures typical of applications uses. This includes most circuits based on the [`NLocal`](/api/qiskit/qiskit.circuit.library.NLocal#qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") structure, such as [`EfficientSU2`](/api/qiskit/qiskit.circuit.library.EfficientSU2#qiskit.circuit.library.EfficientSU2 "qiskit.circuit.library.EfficientSU2"). See [#10282](https://github.com/Qiskit/qiskit-terra/issues/10282) for more detail.

*   The method [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") has gained two new keywords arguments: `flat_input` and `strict`. These are advanced options that can be used to speed up the method when passing the parameter bindings as a dictionary; `flat_input=True` is a guarantee that the dictionary keys contain only [`Parameter`](/api/qiskit/qiskit.circuit.Parameter#qiskit.circuit.Parameter "qiskit.circuit.Parameter") instances (not [`ParameterVector`](/api/qiskit/qiskit.circuit.ParameterVector#qiskit.circuit.ParameterVector "qiskit.circuit.ParameterVector")s), and `strict=False` allows the dictionary to contain parameters that are not present in the circuit. Using these two options can reduce the overhead of input normalisation in this function.

*   The method `filter()` is activated in the [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock#qiskit.pulse.ScheduleBlock "qiskit.pulse.schedule.ScheduleBlock") class. This method enables users to retain only `Instruction` objects which pass through all the provided filters. As builtin filter conditions, pulse [`Channel`](/api/qiskit/pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel") subclass instance and [`Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") subclass type can be specified. User-defined callbacks taking [`Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") instance can be added to the filters, too.

*   The method `exclude()` is activated in the [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock#qiskit.pulse.ScheduleBlock "qiskit.pulse.schedule.ScheduleBlock") class. This method enables users to retain only `Instruction` objects which do not pass at least one of all the provided filters. As builtin filter conditions, pulse [`Channel`](/api/qiskit/pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel") subclass instance and [`Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") subclass type can be specified. User-defined callbacks taking [`Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") instance can be added to the filters, too. This method is the complement of `filter()`, so the following condition is always satisfied: `block.filter(*filters) + block.exclude(*filters) == block` in terms of instructions included, where `block` is a [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock#qiskit.pulse.ScheduleBlock "qiskit.pulse.schedule.ScheduleBlock") instance.

*   The transpiler pass `SetLayout` now is able to be constructed with a list of integers that represent the physical qubits on which the quantum circuit will be mapped on. That is, the first qubit in the circuit will be allocated in the physical qubit in the position zero of the list, and so on.

*   Added a new keyword argument `flatten` to the constructor for the following classes:

    > *   [`EfficientSU2`](/api/qiskit/qiskit.circuit.library.EfficientSU2#qiskit.circuit.library.EfficientSU2 "qiskit.circuit.library.EfficientSU2")
    > *   [`ExcitationPreserving`](/api/qiskit/qiskit.circuit.library.ExcitationPreserving#qiskit.circuit.library.ExcitationPreserving "qiskit.circuit.library.ExcitationPreserving")
    > *   [`NLocal`](/api/qiskit/qiskit.circuit.library.NLocal#qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal")
    > *   [`RealAmplitudes`](/api/qiskit/qiskit.circuit.library.RealAmplitudes#qiskit.circuit.library.RealAmplitudes "qiskit.circuit.library.RealAmplitudes")
    > *   [`TwoLocal`](/api/qiskit/qiskit.circuit.library.TwoLocal#qiskit.circuit.library.TwoLocal "qiskit.circuit.library.TwoLocal")
    > *   [`EvolvedOperatorAnsatz`](/api/qiskit/qiskit.circuit.library.EvolvedOperatorAnsatz#qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz")
    > *   [`QAOAAnsatz`](/api/qiskit/qiskit.circuit.library.QAOAAnsatz#qiskit.circuit.library.QAOAAnsatz "qiskit.circuit.library.QAOAAnsatz")

    If this argument is set to `True` the [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") subclass generated will not wrap the implementation into [`Gate`](/api/qiskit/qiskit.circuit.Gate#qiskit.circuit.Gate "qiskit.circuit.Gate") or [`Instruction`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") objects. While this isn’t optimal for visualization it typically results in much better runtime performance, especially with [`QuantumCircuit.bind_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") and [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") which can see a substatial runtime improvement with a flattened output compared to the nested wrapped default output.

*   Add new `gaussian_square_echo()` pulse shape. This pulse is composed by three `GaussianSquare` pulses. The first two are echo pulses with duration half of the total duration and implement rotary tones. The third pulse is a cancellation tone that lasts the full duration of the pulse and implements correcting single qubit rotations.

*   A new lazy import tester, [`HAS_PYGMENTS`](/api/qiskit/utils#qiskit.utils.optionals.HAS_PYGMENTS "qiskit.utils.optionals.HAS_PYGMENTS"), is available for testing for the presence of [the Pygments syntax highlighting library](https://pygments.org/).

*   Allowing to construct a [`LinearFunction`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") object from more general quantum circuits, that may contain:

    > *   Barriers (of type `Barrier`) and delays ([`Delay`](/api/qiskit/qiskit.circuit.Delay#qiskit.circuit.Delay "qiskit.circuit.Delay")), which are simply ignored
    > *   Permutations (of type [`PermutationGate`](/api/qiskit/qiskit.circuit.library.PermutationGate#qiskit.circuit.library.PermutationGate "qiskit.circuit.library.PermutationGate"))
    > *   Other linear functions
    > *   Cliffords (of type [`Clifford`](/api/qiskit/qiskit.quantum_info.Clifford#qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford")), when the Clifford represents a linear function (and a `CircuitError` exception is raised if not)
    > *   Nested quantum circuits of this form

*   Added `LinearFunction.__eq__()` method. Two objects of type [`LinearFunction`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") are considered equal when their representations as binary invertible matrices are equal.

*   Added [`LinearFunction.extend_with_identity()`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction.extend_with_identity "qiskit.circuit.library.LinearFunction.extend_with_identity") method, which allows to extend a linear function over `k` qubits to a linear function over `n >= k` qubits, specifying the new positions of the original qubits and padding with identities on the remaining qubits.

*   Added two methods for pretty-printing [`LinearFunction`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") objects: [`LinearFunction.mat_str()`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction.mat_str "qiskit.circuit.library.LinearFunction.mat_str"), which returns the string representation of the linear function viewed as a matrix with 0/1 entries, and [`LinearFunction.function_str()`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction.function_str "qiskit.circuit.library.LinearFunction.function_str"), which returns the string representation of the linear function viewed as a linear transformation.

*   The instructions [`StatePreparation`](/api/qiskit/qiskit.circuit.library.StatePreparation#qiskit.circuit.library.StatePreparation "qiskit.circuit.library.StatePreparation") and `Initialize`, and their associated circuit methods [`QuantumCircuit.prepare_state()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.prepare_state "qiskit.circuit.QuantumCircuit.prepare_state") and [`initialize()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.initialize "qiskit.circuit.QuantumCircuit.initialize"), gained a keyword argument `normalize`, which can be set to `True` to automatically normalize an array target. By default this is `False`, which retains the current behaviour of raising an exception when given non-normalized input.

*   Added utility function `qiskit.transpiler.passes.utils._block_to_matrix()` that can generate a matrix based on a block of operations between two qubits. This function can be used in transpiler passes that work on some decomposed circuits such as [`ConsolidateBlocks`](/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks").

*   The transpiler’s built-in [`EquivalenceLibrary`](/api/qiskit/qiskit.circuit.EquivalenceLibrary#qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") has been taught more Pauli-rotation equivalences between the one-qubit $R_X$, $R_Y$ and $R_Z$ gates, and between the two-qubit $R_{XX}$, $R_{YY}$ and $R_{ZZ}$ gates. This should make simple basis translations more reliable, especially circuits that use $Y$ rotations. See [#7332](https://github.com/Qiskit/qiskit-terra/issues/7332).

*   The OpenQASM 3 exporters ([`qasm3.dump()`](/api/qiskit/qasm3#qiskit.qasm3.dump "qiskit.qasm3.dump"), [`dumps()`](/api/qiskit/qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps") and [`Exporter`](/api/qiskit/qasm3#qiskit.qasm3.Exporter "qiskit.qasm3.Exporter")) have a new `allow_aliasing` argument, which will eventually replace the `alias_classical_registers` argument. This controls whether aliasing is permitted for either classical bits or qubits, rather than the option only being available for classical bits.

*   QPY supports the `Discriminator` and `Kernel` objects. This feature enables users to serialize and deserialize the [`Acquire`](/api/qiskit/qiskit.pulse.instructions.Acquire#qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire") instructions with these objects using QPY.

*   Some restrictions when using `wire_order` in the circuit drawers had been relaxed. Now, `wire_order` can list just qubits and, in that case, it can be used with `cregbundle=True`, since it will not affect the classical bits.

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister

    qr = QuantumRegister(4, "q")
    cr = ClassicalRegister(4, "c")
    cr2 = ClassicalRegister(2, "ca")
    circuit = QuantumCircuit(qr, cr, cr2)
    circuit.h(0)
    circuit.h(3)
    circuit.x(1)
    circuit.x(3).c_if(cr, 10)
    circuit.draw('text', wire_order=[2, 3, 0, 1], cregbundle=True)
    ```

    ```python
     q_2: ────────────
          ┌───┐ ┌───┐
     q_3: ┤ H ├─┤ X ├─
          ├───┤ └─╥─┘
     q_0: ┤ H ├───╫───
          ├───┤   ║
     q_1: ┤ X ├───╫───
          └───┘┌──╨──┐
     c: 4/═════╡ 0xa ╞
               └─────┘
    ca: 2/════════════
    ```

*   Control-flow operations are now supported by the Sabre family of transpiler passes, namely layout pass [`SabreLayout`](/api/qiskit/qiskit.transpiler.passes.SabreLayout#qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and routing pass [`SabreSwap`](/api/qiskit/qiskit.transpiler.passes.SabreSwap#qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap"). Function [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") keyword arguments `layout_method` and `routing_method` now accept the option “sabre” for circuits with control flow, which was previously unsupported.

*   Adds support for multiplication of [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") objects with [`Parameter`](/api/qiskit/qiskit.circuit.Parameter#qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects by using the \* operator, for example:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.quantum_info import SparsePauliOp

    param = Parameter("a")
    op = SparsePauliOp("X")
    param * op
    ```

*   Added the option to pass a callback to the [`UMDA`](/api/qiskit/qiskit.algorithms.optimizers.UMDA#qiskit.algorithms.optimizers.UMDA "qiskit.algorithms.optimizers.UMDA") optimizer, which allows to keep track of the number of function evaluations, the current parameters, and the best achieved function value.

<span id="relnotes-0-25-0rc1-transpiler-features" />

<span id="id7" />

### Transpiler Features

*   A new [`qiskit.passmanager`](/api/qiskit/passmanager#module-qiskit.passmanager "qiskit.passmanager") module has been added to the Qiskit library. This module implements a generic pass manager and flow controllers, and provides infrastructure to manage execution of pass manager tasks. The module provides base classes for passes ([`GenericPass`](/api/qiskit/qiskit.passmanager.GenericPass#qiskit.passmanager.GenericPass "qiskit.passmanager.GenericPass")) and flow controllers ([`BaseController`](/api/qiskit/qiskit.passmanager.BaseController#qiskit.passmanager.BaseController "qiskit.passmanager.BaseController")), as well as a new interface class, `passmanager.Task`, to manage the execution of the pass manager (see the `Task.execute()` method). These new classes follow the composite pattern, as flow controllers are collections of passes, and a controller can be recursively nested into the task pipeline. It must also be noted the base classes are not not aware of the input and output object types, and they must be subclassed for a particular program type to optimize. This unified design reduces the complexity of the conventional pass manager, and no longer requires the use of classes such as the `RunningPassManager` to handle the execution logic dispatch and task structure renormalization. The [`qiskit.transpiler`](/api/qiskit/transpiler#module-qiskit.transpiler "qiskit.transpiler") module has been reorganized to rebuild the existing pass managers based off of the generic pass manager. See upgrade notes for more details.

<span id="relnotes-0-25-0rc1-known-issues" />

### Known Issues

*   Added support for taking absolute values of [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")s. For example, the following is now possible:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter

    x = Parameter("x")
    circuit = QuantumCircuit(1)
    circuit.rx(abs(x), 0)

    bound = circuit.bind_parameters({x: -1})
    ```

<span id="relnotes-0-25-0rc1-upgrade-notes" />

### Upgrade Notes

*   Changed [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") to bind assigned integer and float values directly into the parameters of [`Instruction`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") instances in the circuit rather than binding the values wrapped within a [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"). This change should have little user impact as `float(QuantumCircuit.data[i].operation.params[j])` still produces a `float` (and is the only way to access the value of a [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")). Also, [`Instruction()`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") parameters could already be `float` as well as a [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"), so code dealing with instruction parameters should already handle both cases. The most likely chance for user impact is in code that uses `isinstance` to check for [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") and behaves differently depending on the result. Additionally, qpy serializes the numeric value in a bound [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") at a different precision than a `float` (see also the related bug fix note about [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters")).

*   [`Clifford.from_circuit()`](/api/qiskit/qiskit.quantum_info.Clifford#qiskit.quantum_info.Clifford.from_circuit "qiskit.quantum_info.Clifford.from_circuit") will no longer attempt to resolve instructions whose [`definition`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction.definition "qiskit.circuit.Instruction.definition") fields are mutually recursive with some other object. Such recursive definitions are already a violation of the strictly hierarchical ordering that the [`definition`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction.definition "qiskit.circuit.Instruction.definition") field requires, and code should not rely on this being possible at all. If you want to define equivalences that are permitted to have (mutual) cycles, use an [`EquivalenceLibrary`](/api/qiskit/qiskit.circuit.EquivalenceLibrary#qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary").

*   Qiskit Terra 0.25 has dropped support for Python 3.7 following deprecation warnings started in Qiskit Terra 0.23. This is consistent with Python 3.7’s end-of-life on the 27th of June, 2023. To continue using Qiskit, you must upgrade to a more recent version of Python.

*   The OpenQASM 2 constructor methods on [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") ([`from_qasm_str()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") and [`from_qasm_file()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file")) have been switched to use the Rust-based parser added in Qiskit Terra 0.24. This should result in significantly faster parsing times (10 times or more is not uncommon) and massively reduced intermediate memory usage.

    The [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods are kept with the same interface for continuity; the preferred way to access the OpenQASM 2 importer is to use [`qasm2.load()`](/api/qiskit/qasm2#qiskit.qasm2.load "qiskit.qasm2.load") and [`qasm2.loads()`](/api/qiskit/qasm2#qiskit.qasm2.loads "qiskit.qasm2.loads"), which offer an expanded interface to control the parsing and construction.

*   The maximum number of trials evaluated when searching for the best layout using [`VF2Layout`](/api/qiskit/qiskit.transpiler.passes.VF2Layout#qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](/api/qiskit/qiskit.transpiler.passes.VF2PostLayout#qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") is now limited in [`qiskit.transpiler.preset_passmanagers.level_1_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`qiskit.transpiler.preset_passmanagers.level_2_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`qiskit.transpiler.preset_passmanagers.level_3_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") to `2,500`, `25,000`, and `250,000`, respectively. Previously, all possible layouts were evaluated. This change was made to prevent transpilation from hanging during layout scoring for circuits with many connected components on larger devices, which scales combinatorially since each connected component must be evaluated in all possible positions on the device. To perform a full search as before, manually run [`VF2PostLayout`](/api/qiskit/qiskit.transpiler.passes.VF2PostLayout#qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") over the transpiled circuit in strict mode, specifying `0` for `max_trials`.

*   The OpenQASM 3 exporters ([`qasm3.dump()`](/api/qiskit/qasm3#qiskit.qasm3.dump "qiskit.qasm3.dump"), [`dumps()`](/api/qiskit/qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps") and [`Exporter`](/api/qiskit/qasm3#qiskit.qasm3.Exporter "qiskit.qasm3.Exporter")) will now use fewer “register alias” definitions in its output. The circuit described will not change, but it will now preferentially export in terms of direct `bit`, `qubit` and `qubit[n]` types rather than producing a `_loose_bits` register and aliasing more registers off this. This is done to minimise the number of advanced OpenQASM 3 features in use, and to avoid introducing unnecessary array structure into programmes that do not require it.

*   The QPY format version emitted by `dump` has increased to 8. This new format version adds support for serializing the [`QuantumCircuit.layout`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.layout "qiskit.circuit.QuantumCircuit.layout") attribute.

*   The deprecated `circuit_cregs` argument to the constructor for the [`InstructionSet`](/api/qiskit/qiskit.circuit.InstructionSet#qiskit.circuit.InstructionSet "qiskit.circuit.InstructionSet") class has been removed. It was deprecated in the 0.19.0 release. If you were using this argument and manually constructing an [`InstructionSet`](/api/qiskit/qiskit.circuit.InstructionSet#qiskit.circuit.InstructionSet "qiskit.circuit.InstructionSet") object (which should be quite uncommon as it’s mostly used internally) you should pass a callable to the `resource_requester` keyword argument instead. For example:

    ```python
    from qiskit.circuit import Clbit, ClassicalRegister, InstructionSet
    from qiskit.circuit.exceptions import CircuitError

    def my_requester(bits, registers):
        bits_set = set(bits)
        bits_flat = tuple(bits)
        registers_set = set(registers)

        def requester(specifier):
            if isinstance(specifer, Clbit) and specifier in bits_set:
                return specifier
            if isinstance(specifer, ClassicalRegster) and specifier in register_set:
                return specifier
            if isinstance(specifier, int) and 0 <= specifier < len(bits_flat):
                return bits_flat[specifier]
            raise CircuitError(f"Unknown resource: {specifier}")

        return requester

    my_bits = [Clbit() for _ in [None]*5]
    my_registers = [ClassicalRegister(n) for n in range(3)]

    InstructionSet(resource_requester=my_requester(my_bits, my_registers))
    ```

*   In the internal `qiskit.visualization.circuit.matplotlib.MatplotlibDrawer` object, the arguments `layout`, `global_phase`, `qregs` and `cregs` have been removed. They were originally deprecated in Qiskit Terra 0.20. These objects are simply inferred from the given `circuit` now.

    This is an internal worker class of the visualization routines. It is unlikely you will need to change any of your code.

*   Support for passing in lists of argument values to the [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function is removed. This functionality was deprecated as part of the 0.23.0 release and is now being removed. You are still able to pass in a list of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects for the first positional argument, what has been removed is the broadcasting lists of the other arguments to each circuit in that input list. Removing this functionality was necessary to greatly reduce the overhead for parallel execution for transpiling multiple circuits at once. If you’re using this functionality currently you can call [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") multiple times instead. For example if you were previously doing something like:

    ```python
    from qiskit.transpiler import CouplingMap
    from qiskit import QuantumCircuit
    from qiskit import transpile

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    cmaps = [CouplingMap.from_heavy_hex(d) for d in range(3, 15, 2)]
    results = transpile([qc] * 6, coupling_map=cmaps)
    ```

    instead you should now run something like:

    ```python
    from qiskit.transpiler import CouplingMap
    from qiskit import QuantumCircuit
    from qiskit import transpile

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    cmaps = [CouplingMap.from_heavy_hex(d) for d in range(3, 15, 2)]
    results = [transpile(qc, coupling_map=cm) for cm in cmap]
    ```

    You can also leverage [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") or `multiprocessing` from the Python standard library if you want to run this in parallel.

*   The `qiskit.util` import location has been removed, as it had been deprecated since Qiskit Terra 0.17. Users should use the new import location, `qiskit.utils`.

*   The Sabre family of transpiler passes (namely [`SabreLayout`](/api/qiskit/qiskit.transpiler.passes.SabreLayout#qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and [`SabreSwap`](/api/qiskit/qiskit.transpiler.passes.SabreSwap#qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap")) are now used by default for all circuits when invoking the transpiler at optimization level 1 (e.g. calling [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`generate_preset_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") with keyword argument `optimization_level=1`). Previously, circuits with control flow operations used [`DenseLayout`](/api/qiskit/qiskit.transpiler.passes.DenseLayout#qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") and [`StochasticSwap`](/api/qiskit/qiskit.transpiler.passes.StochasticSwap#qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") with this profile.

*   The `map()` has been modified to use the new `rustworkx` version of `graph_token_swapper()` for performance reasons. Qiskit Terra 0.25 now requires versison 0.13.0 of `rustworkx`.

*   By default Qiskit builds its compiled extensions using the [Python Stable ABI](https://docs.python.org/3/c-api/stable.html) with support back to the oldest version of Python supported by Qiskit (currently 3.8). This means that moving forward there will be a single precompiled wheels that are shipped on release that works with all of Qiskit’s supported Python versions. There isn’t any expected runtime performance difference using the limited API so it is enabled by default for all builds now. Previously, the compiled extensions were built using the version specific API and would only work with a single Python version. This change was made to reduce the number of package files we need to build and publish in each release. When building Qiskit from source there should be no changes necessary to the build process except that the default tags in the output filenames will be different to reflect the use of the limited API.

<span id="relnotes-0-25-0rc1-transpiler-upgrade-notes" />

<span id="id8" />

### Transpiler Upgrade Notes

*   As a consequence of the pass manager refactoring efforts, existing flow controllers: [`FlowControllerLinear`](/api/qiskit/qiskit.passmanager.FlowControllerLinear#qiskit.passmanager.FlowControllerLinear "qiskit.passmanager.FlowControllerLinear"), [`ConditionalController`](/api/qiskit/qiskit.passmanager.ConditionalController#qiskit.passmanager.ConditionalController "qiskit.passmanager.ConditionalController"), and [`DoWhileController`](/api/qiskit/qiskit.passmanager.DoWhileController#qiskit.passmanager.DoWhileController "qiskit.passmanager.DoWhileController") are now subclasses of the [`BaseController`](/api/qiskit/qiskit.passmanager.BaseController#qiskit.passmanager.BaseController "qiskit.passmanager.BaseController"). Note that these controllers have dropped the implementation of the [`__iter__()`](https://docs.python.org/3/reference/datamodel.html#object.__iter__ "(in Python v3.12)") method. They are now only iterable in the context of a flow-controller execution, which threads the compilation state through after each inner task is executed.

*   The functionalitly of the `RunningPassManager` class has been superseded by the new pass manager framework ([`BasePassManager`](/api/qiskit/qiskit.passmanager.BasePassManager#qiskit.passmanager.BasePassManager "qiskit.passmanager.BasePassManager") and [`BaseController`](/api/qiskit/qiskit.passmanager.BaseController#qiskit.passmanager.BaseController "qiskit.passmanager.BaseController")). The running pass manager is now a stateless flow controller (essentially, an alias of [`FlowControllerLinear`](/api/qiskit/qiskit.passmanager.FlowControllerLinear#qiskit.passmanager.FlowControllerLinear "qiskit.passmanager.FlowControllerLinear")), as the pass manager is responsible for the construction of task pipeline, while the controller is responsible for the execution of associated tasks. Subclassing the `RunningPassManager` is no longer recommended, and this class will be completely replaced with the flow controller in future releases.

*   A new class, [`WorkflowStatus`](/api/qiskit/qiskit.passmanager.WorkflowStatus#qiskit.passmanager.WorkflowStatus "qiskit.passmanager.WorkflowStatus"), has been introduced to track the status of the pass manager workflow. This portable object is created when the pass manager is run, and handed over to the underlying tasks. Such status was previously managed by the `RunningPassManager` with instance variables.

*   The transpiler-specific [`transpiler.PassManager`](/api/qiskit/qiskit.transpiler.PassManager#qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") (used in [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile")) is now a subclass of [`passmanager.BasePassManager`](/api/qiskit/qiskit.passmanager.BasePassManager#qiskit.passmanager.BasePassManager "qiskit.passmanager.BasePassManager"). However, this class hierarchy change doesn’t introduce any breaking change to the public-facing API.

*   Exceptions raised during pass-manager execution now inherit from the newly introduced [`PassManagerError`](/api/qiskit/passmanager#qiskit.passmanager.PassManagerError "qiskit.passmanager.PassManagerError"). A generic failure of the pass-manager machinery will raise [`PassManagerError`](/api/qiskit/passmanager#qiskit.passmanager.PassManagerError "qiskit.passmanager.PassManagerError") for general pass managers, but the transpiler-specific `transpile.PassManager` will currently wrap this in its specific [`TranspilerError`](/api/qiskit/transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.TranspilerError") for backwards compatibility. This wrapping will be removed in the future.

*   The use of `FencedObject` in the pass manager framework has been removed. This wrapper class cannot protect mutable object attributes from modification, and this should not be an issue for properly implemented code. Analysis passes should not modify an input IR, controllers should not update the property set, and so forth. It’s the pass manager developer’s responsibility to ensure that the pass is not modifying object attributes,

<span id="relnotes-0-25-0rc1-misc-upgrade-notes" />

<span id="id9" />

### Misc. Upgrade Notes

*   The magic `%qiskit_version_table` from `qiskit.tools.jupyter` and the deprecated `qiskit.__qiskit_version__` do not include qiskit-terra anymore. Now that Qiskit Terra is called Qiskit, these entries are not needed anymore and you can just refer to the `qiskit` entry.

<span id="relnotes-0-25-0rc1-deprecation-notes" />

### Deprecation Notes

*   The [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") module has been deprecated and will be removed in a future release. It has been superseded by a new standalone library `qiskit-algorithms` which can be found on PyPi or on Github here:

    [https://github.com/qiskit-community/qiskit-algorithms](https://github.com/qiskit-community/qiskit-algorithms)

    The [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") will continue to work as before and bug fixes will be made to module until its future removal, but active development of new features has moved to the new package. If you’re relying on [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") you should update your requirements to also include `qiskit-algorithms` and update the imports from `qiskit.algorithms` to `qiskit_algorithms`. Please note that this new package does not include already deprecated algorithms code, including `opflow` and `QuantumInstance`-based algorithms. If you have not yet migrated from `QuantumInstance`-based to primitives-based algorithms, you should follow the migration guidelines in [https://qisk.it/algo\_migration](https://qisk.it/algo_migration). The decision to migrate the [`algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") module to a separate package was made to clarify the purpose Qiskit and make a distinction between the tools and libraries built on top of it.

*   The Jupyter magic `%circuit_library_info` and the objects in `qiskit.tools.jupyter.library` it calls in turn:

    *   `circuit_data_table`
    *   `properties_widget`
    *   `qasm_widget`
    *   `circuit_digram_widget`
    *   `circuit_library_widget`

    are deprecated and will be removed in Terra 0.27. These objects were only intended for use in the documentation build. They are no longer used there, so are no longer supported or maintained.

*   Initializing a `ScalableSymbolicPulse` with complex amp value is now deprecated. This change also affects the following library pulses:

    > *   [`Gaussian`](/api/qiskit/qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian")
    > *   [`GaussianSquare`](/api/qiskit/qiskit.pulse.library.GaussianSquare#qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare")
    > *   [`Drag`](/api/qiskit/qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag")
    > *   [`Constant`](/api/qiskit/qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant")

    Initializing them with complex amp is now deprecated as well.

    Instead, one should use two floats for the amp and angle parameters, where amp represents the magnitude of the complex amplitude, and angle represents the angle of the complex amplitude. i.e. the complex amplitude is given by amp \* exp(1j \* angle).

*   The function `get_vf2_call_limit` available via the module `qiskit.transpiler.preset_passmanagers.common` has been deprecated. This will likely affect very few users since this function was neither explicitly exported nor documented. Its functionality has been replaced and extended by a function in the same module.

*   The method [`qasm()`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction.qasm "qiskit.circuit.Instruction.qasm") and all overriding methods of subclasses of :meth:\`\~qiskit.circuit.Instruction are deprecated. There is no replacement for generating an OpenQASM 2 string for an isolated instruction.

*   Extensions of the `qiskit` and `qiskit.providers` namespaces by external packages are now deprecated and the hook points enabling this will be removed in a future release. In the past, the Qiskit project was composed of elements that extended a shared namespace and these hook points enabled doing that. However, it was not intended for these interfaces to ever be used by other packages. Now that the overall Qiskit package is no longer using that packaging model, leaving the possibility for these extensions carry more risk than benefits and is therefore being deprecated for future removal. If you’re maintaining a package that extends the Qiskit namespace (i.e. your users import from `qiskit.x` or `qiskit.providers.y`) you should transition to using a standalone Python namespace for your package. No warning will be raised as part of this because there is no method to inject a warning at the packaging level that would be required to warn external packages of this change.

*   The [`Call`](/api/qiskit/qiskit.pulse.instructions.Call#qiskit.pulse.instructions.Call "qiskit.pulse.instructions.Call") has been deprecated and will be removed in a future release. Instead, use the [pulse builder](https://qiskit.org/documentation/tutorials/circuits_advanced/06_building_pulse_schedules.html) function [`call()`](/api/qiskit/pulse#qiskit.pulse.builder.call "qiskit.pulse.builder.call") within an active building context.

<span id="relnotes-0-25-0rc1-transpiler-deprecations" />

<span id="id10" />

### Transpiler Deprecations

*   The flow controller factory method [`FlowController.controller_factory()`](/api/qiskit/qiskit.passmanager.FlowController#qiskit.passmanager.FlowController.controller_factory "qiskit.passmanager.FlowController.controller_factory") is deprecated along with [`FlowController.add_flow_controller()`](/api/qiskit/qiskit.passmanager.FlowController#qiskit.passmanager.FlowController.add_flow_controller "qiskit.passmanager.FlowController.add_flow_controller") and [`FlowController.remove_flow_controller()`](/api/qiskit/qiskit.passmanager.FlowController#qiskit.passmanager.FlowController.remove_flow_controller "qiskit.passmanager.FlowController.remove_flow_controller"). In the future, task construction with keyword arguments in the [`BasePassManager.append()`](/api/qiskit/qiskit.passmanager.BasePassManager#qiskit.passmanager.BasePassManager.append "qiskit.passmanager.BasePassManager.append") method will also be deprecated. Controllers must be explicitly instantiated and appended to the pass manager. For example, the previously used conventional syntax

    ```python
    pm.append([task1, task2], condition=lambda x: x["value1"] > 10)
    ```

    must be replaced with

    ```python
    controller = ConditionalController([task1, task2], condition=lambda x: x["value1"] > 10)
    pm.append(controller)
    ```

    The latter allows more precise control on the order of controllers especially when multiple keyword arguments are specified together, and allows for the construction of general flow controllers that may have more than one pipeline or do not take a single simple conditional function in their constructors.

*   The [`FlowControllerLinear.append()`](/api/qiskit/qiskit.passmanager.FlowControllerLinear#qiskit.passmanager.FlowControllerLinear.append "qiskit.passmanager.FlowControllerLinear.append"), [`DoWhileController.append()`](/api/qiskit/qiskit.passmanager.DoWhileController#qiskit.passmanager.DoWhileController.append "qiskit.passmanager.DoWhileController.append"), and [`ConditionalController.append()`](/api/qiskit/qiskit.passmanager.ConditionalController#qiskit.passmanager.ConditionalController.append "qiskit.passmanager.ConditionalController.append") methods are all deprecated immediately. The construction of the pass manager task pipeline is now the role of [`BasePassManager`](/api/qiskit/qiskit.passmanager.BasePassManager#qiskit.passmanager.BasePassManager "qiskit.passmanager.BasePassManager"), and individual flow controllers do not need to this method. For a flow controller, all the passes should be specificed in one go directly to the constructor.

*   The general attribute and variable name `passes` is replaced with `tasks` all over the [`qiskit.passmanager`](/api/qiskit/passmanager#module-qiskit.passmanager "qiskit.passmanager") module. Note that a task must indicate a union of pass and controller, and the singular form pass conflicts with the Python keyword. In this sense, the use of tasks is much preferable.

<span id="relnotes-0-25-0rc1-bug-fixes" />

<span id="id11" />

### Bug Fixes

*   Updated [`plot_gate_map()`](/api/qiskit/qiskit.visualization.plot_gate_map#qiskit.visualization.plot_gate_map "qiskit.visualization.plot_gate_map"), [`plot_error_map()`](/api/qiskit/qiskit.visualization.plot_error_map#qiskit.visualization.plot_error_map "qiskit.visualization.plot_error_map"), and [`plot_circuit_layout()`](/api/qiskit/qiskit.visualization.plot_circuit_layout#qiskit.visualization.plot_circuit_layout "qiskit.visualization.plot_circuit_layout") to support 433 qubit heavy-hex coupling maps. This allows coupling map visualizations for IBM’s `ibm_seattle`.

*   Fixed the deserialization of [`DiagonalGate`](/api/qiskit/qiskit.circuit.library.DiagonalGate#qiskit.circuit.library.DiagonalGate "qiskit.circuit.library.DiagonalGate") instances through QPY. See [#10364](https://github.com/Qiskit/qiskit-terra/issues/10364).

*   Fixed an issue with [`FullAncillaAllocation`](/api/qiskit/qiskit.transpiler.passes.FullAncillaAllocation#qiskit.transpiler.passes.FullAncillaAllocation "qiskit.transpiler.passes.FullAncillaAllocation") so it can now function with [`Target`](/api/qiskit/qiskit.transpiler.Target#qiskit.transpiler.Target "qiskit.transpiler.Target") objects that do not have a coupling map (typically because there are no 2 qubit gates in the [`Target`](/api/qiskit/qiskit.transpiler.Target#qiskit.transpiler.Target "qiskit.transpiler.Target")). In this case [`FullAncillaAllocation`](/api/qiskit/qiskit.transpiler.passes.FullAncillaAllocation#qiskit.transpiler.passes.FullAncillaAllocation "qiskit.transpiler.passes.FullAncillaAllocation") will add ancilla qubits so that the number of qubits in the [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") matches the number [`Target.num_qubits`](/api/qiskit/qiskit.transpiler.Target#qiskit.transpiler.Target.num_qubits "qiskit.transpiler.Target.num_qubits").

*   Changed the binding of numeric values with [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") to avoid a mismatch between the values of circuit instruction parameters and corresponding parameter keys in the circuit’s calibration dictionary. Fixed [#9764](https://github.com/Qiskit/qiskit-terra/issues/9764) and [#10166](https://github.com/Qiskit/qiskit-terra/issues/10166). See also the related upgrade note regarding [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters").

*   [`DAGCircuit.substitute_node()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.substitute_node "qiskit.dagcircuit.DAGCircuit.substitute_node") will no longer silently overwrite an existing condition on the given replacement `op`. If `propagate_condition` is set to `True` (the default), a [`DAGCircuitError`](/api/qiskit/dagcircuit#qiskit.dagcircuit.DAGCircuitError "qiskit.dagcircuit.DAGCircuitError") will be raised instead.

*   A parametrised circuit that contains a custom gate whose definition has a parametrised global phase can now successfully bind the parameter in the inner global phase. See [#10283](https://github.com/Qiskit/qiskit-terra/issues/10283) for more detail.

*   Construction of a [`Statevector`](/api/qiskit/qiskit.quantum_info.Statevector#qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") from a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") containing zero-qubit operations will no longer raise an error. These operations impart a global phase on the resulting statevector.

*   When `qs_decomposition()`, which does quantum Shannon decomposition, was called on trivial numeric unitaries that do not benefit from this decomposition, an unexpected error was raised. With this fix, such unitaries are detected and the equivalent circuit is returned without performing Shannon decomposition.

*   Fixes a typo where BasicSwap called `fake_run()` the attribute instead of `_fake_run()` the function. Refer to #10149 \<hhttps\://github.com/Qiskit/qiskit-terra/issues/10147> for more details.

*   Fixed an issue with copying circuits with new-style [`Clbit`](/api/qiskit/qiskit.circuit.Clbit#qiskit.circuit.Clbit "qiskit.circuit.Clbit")s and [`Qubit`](/api/qiskit/qiskit.circuit.Qubit#qiskit.circuit.Qubit "qiskit.circuit.Qubit")s (bits without registers) where references to these bits from the containing circuit could be broken, causing issues with serialization and circuit visualization.

*   The [`CheckMap`](/api/qiskit/qiskit.transpiler.passes.CheckMap#qiskit.transpiler.passes.CheckMap "qiskit.transpiler.passes.CheckMap") transpiler pass will no longer spuriously error when dealing with nested conditional structures created by the control-flow builder interface. See [#10394](https://github.com/Qiskit/qiskit-terra/issues/10394).

*   Fixed a bug in `BlockCollapser` where classical bits were ignored when collapsing a block of nodes.

*   Fixed a bug in [`replace_block_with_op()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.replace_block_with_op "qiskit.dagcircuit.DAGCircuit.replace_block_with_op") and [`replace_block_with_op()`](/api/qiskit/qiskit.dagcircuit.DAGDependency#qiskit.dagcircuit.DAGDependency.replace_block_with_op "qiskit.dagcircuit.DAGDependency.replace_block_with_op") that led to ignoring classical bits.

*   Fixed a bug in [`QuantumCircuit.compose()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.compose "qiskit.circuit.QuantumCircuit.compose") where the `SwitchCaseOp.target` attribute in the subcircuit would not get mapped to a register in the base circuit correctly.

*   The control-flow builder interface will now correctly include [`ClassicalRegister`](/api/qiskit/qiskit.circuit.ClassicalRegister#qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") resources from nested switch statements in their containing circuit scopes. See [#10398](https://github.com/Qiskit/qiskit-terra/issues/10398).

*   Fixed an issue in the `QuantumCircuit.decompose()` method where passing a circuit name to the function that matched a composite gate name would not decompose the gate if it had a label assigned to it as well. Fixed [#9136](https://github.com/Qiskit/qiskit-terra/issues/9136)

*   Fixed an issue in tranpiler passes for padding delays, which did not respect target’s constraints and inserted delays even for qubits not supporting [`Delay`](/api/qiskit/qiskit.circuit.Delay#qiskit.circuit.Delay "qiskit.circuit.Delay") instruction. [`PadDelay`](/api/qiskit/qiskit.transpiler.passes.PadDelay#qiskit.transpiler.passes.PadDelay "qiskit.transpiler.passes.PadDelay") and [`PadDynamicalDecoupling`](/api/qiskit/qiskit.transpiler.passes.PadDynamicalDecoupling#qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling") are fixed so that they do not pad any idle time of qubits such that the target does not support `Delay` instructions for the qubits. Also legacy scheduling passes `ASAPSchedule` and `ALAPSchedule`, which pad delays internally, are fixed in the same way. In addition, `transpile()` is fixed to call `PadDelay` with a `target` object so that it works correctly when called with `scheduling_method` option. Fixed [#9993](https://github.com/Qiskit/qiskit-terra/issues/9993)

*   Fixed an failure of the pulse builder when the context is initialized with [`BackendV2`](/api/qiskit/qiskit.providers.BackendV2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2").

*   Fix a bug in [`RZXCalibrationBuilder`](/api/qiskit/qiskit.transpiler.passes.RZXCalibrationBuilder#qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") where calling calibration with wrong parameters would crash instead of raising exception.

*   Fixed an issue with the [`BooleanExpression.from_dimacs_file()`](/api/qiskit/qiskit.circuit.classicalfunction.BooleanExpression#qiskit.circuit.classicalfunction.BooleanExpression.from_dimacs_file "qiskit.circuit.classicalfunction.BooleanExpression.from_dimacs_file") constructor method where the exception type raised when tweedledum wasn’t installed was not the expected `MissingOptionalLibrary`. Fixed [#10079](https://github.com/Qiskit/qiskit-terra/issues/10079)

*   Using `initial_layout` in calls to [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") will no longer error if the circuit contains qubits not in any registers, or qubits that exist in more than one register. See [#10125](https://github.com/Qiskit/qiskit-terra/issues/10125).

*   Fixed the gate decomposition of multi-controlled Z rotation gates added via [`QuantumCircuit.mcrz()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.mcrz "qiskit.circuit.QuantumCircuit.mcrz"). Previously, this method implemented a multi-controlled phase gate, which has a relative phase difference to the Z rotation. To obtain the previous .QuantumCircuit.mcrz behaviour, use .QuantumCircuit.mcp.

*   Fixed the output of pulse `measure()` and `measure_all()` when functions are called with the [`BackendV2`](/api/qiskit/qiskit.providers.BackendV2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend.

*   Fixed the dimensions of the output density matrix from [`DensityMatrix.partial_transpose()`](/api/qiskit/qiskit.quantum_info.DensityMatrix#qiskit.quantum_info.DensityMatrix.partial_transpose "qiskit.quantum_info.DensityMatrix.partial_transpose") so they match the dimensions of the corresponding input density matrix.

*   Fixed plot legend error when your dataset has a zero value at first position. When one of your counts or distributions had a zero value at first position, the relative legend didn’t show up. See #10158 \<[https://github.com/Qiskit/qiskit-terra/issues/10158](https://github.com/Qiskit/qiskit-terra/issues/10158)> for more details.

*   Fixed an issue with the [`PassManagerConfig.from_backend()`](/api/qiskit/qiskit.transpiler.PassManagerConfig#qiskit.transpiler.PassManagerConfig.from_backend "qiskit.transpiler.PassManagerConfig.from_backend") constructor when building a [`PassManagerConfig`](/api/qiskit/qiskit.transpiler.PassManagerConfig#qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig") object from a [`BackendV1`](/api/qiskit/qiskit.providers.BackendV1#qiskit.providers.BackendV1 "qiskit.providers.BackendV1") instance that didn’t have a coupling map attribute defined. Previously, the constructor would incorrectly create a [`CouplingMap`](/api/qiskit/qiskit.transpiler.CouplingMap#qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") object with 0 qubits instead of using `None`. Fixed [#10171](https://github.com/Qiskit/qiskit-terra/issues/10171)

*   Importing [`qiskit.primitives`](/api/qiskit/primitives#module-qiskit.primitives "qiskit.primitives") will no longer cause deprecation warnings stemming from the deprecated [`qiskit.opflow`](/api/qiskit/opflow#module-qiskit.opflow "qiskit.opflow") module. These warnings would have been hidden to users by the default Python filters, but triggered the eager import of [`opflow`](/api/qiskit/opflow#module-qiskit.opflow "qiskit.opflow"), which meant that a subsequent import by a user would not trigger the warnings.

*   Fixed the OpenQASM 2 output of [`QuantumCircuit.qasm()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.qasm "qiskit.circuit.QuantumCircuit.qasm") when a custom gate object contained a gate with the same name. Ideally this shouldn’t happen for most gates, but complex algorithmic operations like the [`GroverOperator`](/api/qiskit/qiskit.circuit.library.GroverOperator#qiskit.circuit.library.GroverOperator "qiskit.circuit.library.GroverOperator") class could produce such structures accidentally. See [#10162](https://github.com/Qiskit/qiskit-terra/issues/10162).

*   Fixed a regression in the LaTeX drawer of [`QuantumCircuit.draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.draw "qiskit.circuit.QuantumCircuit.draw") when temporary files are placed on a separate filesystem to the working directory. See [#10211](https://github.com/Qiskit/qiskit-terra/issues/10211).

*   Fixes a bug introduced in Qiskit 0.24.0 where numeric rotation angles were no longer substituted for symbolic ones before preparing for two-qubit synthesis. This caused an exception to be raised because the synthesis routines require numberic matrices.

*   Fixed an issue with [`UnitarySynthesis`](/api/qiskit/qiskit.transpiler.passes.UnitarySynthesis#qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") when using the `target` parameter where circuits with control flow were not properly mapped to the target.

*   Fix a bug in which running [`Optimize1qGatesDecomposition`](/api/qiskit/qiskit.transpiler.passes.Optimize1qGatesDecomposition#qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") in parallel would raise an error due to OneQubitGateErrorMap not being picklable.

*   Fixed an failure of [`Target.update_from_instruction_schedule_map()`](/api/qiskit/qiskit.transpiler.Target#qiskit.transpiler.Target.update_from_instruction_schedule_map "qiskit.transpiler.Target.update_from_instruction_schedule_map") when the argument `inst_map` has schedule with unassigned duration.

*   Fix a bug in the [`VF2Layout`](/api/qiskit/qiskit.transpiler.passes.VF2Layout#qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](/api/qiskit/qiskit.transpiler.passes.VF2PostLayout#qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") passes where the passes wer failing to account for the 1 qubit error component when evaluating a potential layout.

*   Fixed bug in [`VQD`](/api/qiskit/qiskit.algorithms.eigensolvers.VQD#qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD") where `result.optimal_values` was a copy of `result.optimal_points`. It now returns the corresponding values.

*   When the parameter `conditional=True` is set in `qiskit.circuit.random.random_circuit`, the conditional operations will be preceded by a full mid-circuit measurment. Fixes [#9016](https://github.com/Qiskit/qiskit-terra/issues/9016)

*   Improve the type annotations on the [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") method to reflect the change in return type depending on the `inplace` argument.

*   The OpenQASM 2 circuit-constructor methods ([`QuantumCircuit.from_qasm_str()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") and [`from_qasm_file()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file")) will no longer error when encountering a `gate` definition that contains `U` or `CX` instructions. See [#5536](https://github.com/Qiskit/qiskit-terra/issues/5536).

*   Reduced overhead of the [`ConsolidateBlocks`](/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") pass by performing matrix operations on all two-qubit blocks using `qiskit.transpiler.passes.utils._block_to_matrix()` instead of creating an instance of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and passing it to an [`Operator`](/api/qiskit/qiskit.quantum_info.Operator#qiskit.quantum_info.Operator "qiskit.quantum_info.Operator"). The speedup will only be applicable when consolidating two-qubit blocks. Anything higher than that will still be handled by the [`Operator`](/api/qiskit/qiskit.quantum_info.Operator#qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") class. Check [#8779](https://github.com/Qiskit/qiskit-terra/issues/8779) for details.

*   Improved the error messages returned when an attempt to convert a fully bound [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") into a concrete `float` or `int` failed, for example because the expression was naturally a complex number.

*   Fixed `float` conversions for [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") values which had, at some point in their construction history, an imaginary component that had subsequently been cancelled. When using Sympy as a backend, these conversions would usually already have worked. When using Symengine as the backend, these conversions would often fail with type errors, despite the result having been symbolically evaluated to be real, and [`ParameterExpression.is_real()`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression.is_real "qiskit.circuit.ParameterExpression.is_real") being true.

*   Fixed a potential performance scaling issue with layout scoring in preset pass managers, which could occur when transpiling circuits with many connected components on large devices.

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](/api/qiskit/qasm3#module-qiskit.qasm3 "qiskit.qasm3")) will no longer output invalid OpenQASM 3 for non-unitary [`Instruction`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") instances, but will instead raise a [`QASM3ExporterError`](/api/qiskit/qasm3#qiskit.qasm3.QASM3ExporterError "qiskit.qasm3.QASM3ExporterError") explaining that this are not yet supported. This feature will is slated for a later release of Qiskit, when there are more classical-processing facilities throughout the library.

*   Fixed the [`qpy`](/api/qiskit/qpy#module-qiskit.qpy "qiskit.qpy") serialization of [`QuantumCircuit.layout`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.layout "qiskit.circuit.QuantumCircuit.layout") attribue. Previously, the [`layout`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.layout "qiskit.circuit.QuantumCircuit.layout") attribute would have been dropped when serializing a circuit to QPY. Fixed [#10112](https://github.com/Qiskit/qiskit-terra/issues/10112)

*   Fixes issue #10185 \<[https://github.com/Qiskit/qiskit-terra/issues/10185](https://github.com/Qiskit/qiskit-terra/issues/10185)>.

*   The function `state_to_latex()` produced not valid LaTeX with unintended coefficient rounding, resulting in errors when calling `state_drawer()` is called. Fixed [#9297](https://github.com/Qiskit/qiskit-terra/issues/9297).


