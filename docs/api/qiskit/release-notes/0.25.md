---
title: Qiskit 0.25 release notes
description: New features and bug fixes
---

# Qiskit 0.25 release notes

## 0.25.0rc1

<span id="relnotes-0-25-0rc1-new-features" />

### New Features

*   Added two new options to `BlockCollector`.

    The first new options `split_layers` allows to split the collected block into sub-blocks over disjoint qubit subsets, i.e. into depth-1 sub-blocks.

    The second new option `collect_from_back` allows to greedily collect blocks starting from the outputs of the circuit. This is important in combination with ALAP-scheduling passes where we may prefer to put gates in the later rather than earlier blocks.

*   Added new options `split_layers` and `collect_from_back` to `CollectLinearFunctions` and `CollectCliffords` transpiler passes.

    When `split_layers` is True, the collected blocks are split into into sub-blocks over disjoint qubit subsets, i.e. into depth-1 sub-blocks. Consider the following example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler.passes import CollectLinearFunctions

    circuit = QuantumCircuit(5)
    circuit.cx(0, 2)
    circuit.cx(1, 4)
    circuit.cx(2, 0)
    circuit.cx(0, 3)
    circuit.swap(3, 2)
    circuit.swap(4, 1)

    # Collect all linear gates, without splitting into layers
    qct = CollectLinearFunctions(split_blocks=False, min_block_size=1, split_layers=False)(circuit)
    assert qct.count_ops()["linear_function"] == 1

    # Collect all linear gates, with splitting into layers
    qct = CollectLinearFunctions(split_blocks=False, min_block_size=1, split_layers=True)(circuit)
    assert qct.count_ops()["linear_function"] == 4
    ```

    The original circuit is linear. When collecting linear gates without splitting into layers, we should end up with a single linear function. However, when collecting linear gates and splitting into layers, we should end up with 4 linear functions.

    When `collect_from_back` is True, the blocks are greedily collected from the outputs towards the inputs of the circuit. Consider the following example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler.passes import CollectLinearFunctions

    circuit = QuantumCircuit(3)
    circuit.cx(1, 2)
    circuit.cx(1, 0)
    circuit.h(2)
    circuit.swap(1, 2)

    # This combines the CX(1, 2) and CX(1, 0) gates into a single linear function
    qct = CollectLinearFunctions(collect_from_back=False)(circuit)

    # This combines the CX(1, 0) and SWAP(1, 2) gates into a single linear function
    qct = CollectLinearFunctions(collect_from_back=True)(circuit)
    ```

    The original circuit contains a Hadamard gate, so that the CX(1, 0) gate can be combined either with CX(1, 2) or with SWAP(1, 2), but not with both. When `collect_from_back` is False, the linear blocks are greedily collected from the start of the circuit, and thus CX(1, 0) is combined with CX(1, 2). When `collect_from_back` is True, the linear blocks are greedily collected from the end of the circuit, and thus CX(1, 0) is combined with SWAP(1, 2).

*   Added [`DAGCircuit.classical_predecessors()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.classical_predecessors "qiskit.dagcircuit.DAGCircuit.classical_predecessors") and [`DAGCircuit.classical_successors()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.classical_successors "qiskit.dagcircuit.DAGCircuit.classical_successors"), an alternative to select the classical wires without having to go to the inner graph object directly of a node in the DAG. The following example illustrates the new functionality:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit.converters import circuit_to_dag
    from qiskit.circuit.library import RZGate

    q = QuantumRegister(3, 'q')
    c = ClassicalRegister(3, 'c')
    circ = QuantumCircuit(q, c)
    circ.h(q[0])
    circ.cx(q[0], q[1])
    circ.measure(q[0], c[0])
    circ.rz(0.5, q[1]).c_if(c, 2)
    circ.measure(q[1], c[0])
    dag = circuit_to_dag(circ)

    rz_node = dag.op_nodes(RZGate)[0]
    # Contains the "measure" on clbit 0, and the "wire start" nodes for clbits 1 and 2.
    classical_predecessors = list(dag.classical_predecessors(rz_node))
    # Contains the "measure" on clbit 0, and the "wire end" nodes for clbits 1 and 2.
    classical_successors = list(dag.classical_successors(rz_node))
    ```

*   Enabled performing the [`qiskit.transpiler.passes.CommutativeCancellation`](/api/qiskit/qiskit.transpiler.passes.CommutativeCancellation#qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation") pass inside the blocks of [`qiskit.circuit.ControlFlowOp`](/api/qiskit/qiskit.circuit.ControlFlowOp#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp"). This pass reorders some commuting gates and reduces resulting pairs of self-inverse gates. Previously, the blocks in control flow operations were skipped by this pass. The new feature operates recursively, that is, it will act on control flow operations inside blocks.

*   Enabled performing the [`ConsolidateBlocks`](/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") pass inside the blocks of [`ControlFlowOp`](/api/qiskit/qiskit.circuit.ControlFlowOp#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp"). This pass collects several sequences of gates and replaces each sequence with the equivalent numeric unitary gate. This new feature enables applying this pass recursively to the blocks in control flow operations. Note that the meaning of “block” in [`ConsolidateBlocks`](/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") is unrelated to that in [`ControlFlowOp`](/api/qiskit/qiskit.circuit.ControlFlowOp#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp").

*   Added [`DAGCircuit.quantum_causal_cone()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.quantum_causal_cone "qiskit.dagcircuit.DAGCircuit.quantum_causal_cone") to obtain the causal cone of a qubit in a [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit"). The following example shows its correct usage:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit.circuit.library import CXGate, CZGate
    from qiskit.dagcircuit import DAGCircuit

    # Build a DAGCircuit
    dag = DAGCircuit()
    qreg = QuantumRegister(5)
    creg = ClassicalRegister(5)
    dag.add_qreg(qreg)
    dag.add_creg(creg)
    dag.apply_operation_back(CXGate(), qreg[[1, 2]], [])
    dag.apply_operation_back(CXGate(), qreg[[0, 3]], [])
    dag.apply_operation_back(CZGate(), qreg[[1, 4]], [])
    dag.apply_operation_back(CZGate(), qreg[[2, 4]], [])
    dag.apply_operation_back(CXGate(), qreg[[3, 4]], [])

    # Get the causal cone of qubit at index 0
    result = dag.quantum_causal_cone(qreg[0])
    ```

*   Added a new function , `negativity()` that adds support for calculating entanglement measures negativity of an quantum state. An illustrative example for using the above function is given below:

*   A new method, `find_bit()`, has been added to the `DagCircuit` class. This is a method to get mapping of Qubit and Clbit to positional index. The method takes a Bit as input, checks whether it’s a Qubit or a Clbit, and then returns the corresponding BitLocations from the respective index dictionary (\_qubit\_indices or \_clbit\_indices). The BitLocations is a namedtuple which includes the positional index of the bit in the circuit and a list of registers containing the bit. If the bit cannot be found or is of an unknown type, it raises a DAGCircuitError.

*   The transpiler’s built-in [`EquivalenceLibrary`](/api/qiskit/qiskit.circuit.EquivalenceLibrary#qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") has been taught the circular Pauli relations $X = iYZ$, $Y = iZX$ and $Z = iXY$. This should make transpiling to constrained, and potentially incomplete, basis sets more reliable. See [#10293](https://github.com/Qiskit/qiskit-terra/issues/10293) for more detail.

*   Add `schmidt_decomposition` function to the `quantum_info` module. This function works with the `Statevector` and `DensityMatrix` classes for bipartite pure states.

*   Control-flow operations are now supported through the transpiler at all optimization levels, including levels 2 and 3 (e.g. calling [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`generate_preset_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") with keyword argument `optimization_level=3`).

*   Added a new synthesis algorithm `qiskit.synthesis.linear_phase.synth_cx_cz_depth_line_my()` of a CX circuit followed by a CZ circuit for linear nearest neighbor (LNN) connectivity in 2-qubit depth of at most 5n using CX and phase gates (S, Sdg or Z). The synthesis algorithm is based on the paper of Maslov and Yang ([https://arxiv.org/abs/2210.16195](https://arxiv.org/abs/2210.16195)). The algorithm accepts a binary invertible matrix `mat_x` representing the CX-circuit, a binary symmetric matrix `mat_z` representing the CZ-circuit, and returns a quantum circuit with 2-qubit depth of at most 5n computing the composition of the CX and CZ circuits. The following example illustrates the new functionality:

    ```python
    import numpy as np
    from qiskit.synthesis.linear_phase import synth_cx_cz_depth_line_my
    mat_x = np.array([[0, 1], [1, 1]])
    mat_z = np.array([[0, 1], [1, 0]])
    qc = synth_cx_cz_depth_line_my(mat_x, mat_z)
    ```

    This algorithm is now used by default in the Clifford synthesis algorithm `qiskit.synthesis.clifford.synth_clifford_depth_lnn()` that optimizes 2-qubit depth for LNN connectivity, improving the 2-qubit depth from 9n+4 to 7n+2. The clifford synthesis algorithm can be used as follows:

    ```python
    from qiskit.quantum_info import random_clifford
    from qiskit.synthesis import synth_clifford_depth_lnn

    cliff = random_clifford(3)
    qc = synth_clifford_depth_lnn(cliff)
    ```

    The above synthesis can be further improved as described in the paper by Maslov and Yang, using local optimization between 2-qubit layers. This improvement is left for follow-up work.

*   [`DAGCircuit.substitute_node()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.substitute_node "qiskit.dagcircuit.DAGCircuit.substitute_node") gained a `propagate_condition` keyword argument that is analogous to the same argument in [`substitute_node_with_dag()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag "qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag"). Setting this to `False` opts out of the legacy behaviour of copying a condition on the `node` onto the new `op` that is replacing it.

    This option is ignored for general control-flow operations, which will never propagate their condition, nor accept a condition from another node.

*   Introduced a new method, [`separable_circuits()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.separable_circuits "qiskit.dagcircuit.DAGCircuit.separable_circuits"), which returns a list of [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") objects, one for each set of connected qubits which have no gates connecting them to another set.

    Each [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") instance returned by this method will contain the same number of clbits as `self`. This method will not return [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") instances consisting solely of clbits.

*   The `SymbolicPulse` library was extended. The new pulses in the library are:

    > *   [`GaussianDeriv()`](/api/qiskit/qiskit.pulse.library.GaussianDeriv#qiskit.pulse.library.GaussianDeriv "qiskit.pulse.library.GaussianDeriv")
    > *   [`Sech()`](/api/qiskit/qiskit.pulse.library.Sech_fun.rst#qiskit.pulse.library.Sech "qiskit.pulse.library.Sech")
    > *   [`SechDeriv()`](/api/qiskit/qiskit.pulse.library.SechDeriv#qiskit.pulse.library.SechDeriv "qiskit.pulse.library.SechDeriv")
    > *   [`Square()`](/api/qiskit/qiskit.pulse.library.Square_fun.rst#qiskit.pulse.library.Square "qiskit.pulse.library.Square")

    The new functions return a `ScalableSymbolicPulse`, and match the functionality of the corresponding functions in the discrete pulse library, with the exception of Square() for which a phase of $2\\pi$ shifts by a full cycle (contrary to the discrete square() where such a shift was induced by a $\\pi$ phase).

*   In `MatplotlibDrawer`, operations built from [`ControlFlowOp`](/api/qiskit/qiskit.circuit.ControlFlowOp#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp"), including `if`, `else`, `while`, `for`, and `switch/case`, whether directly instantiated or built using methods in [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"), will now fully display the circuits defined in the ControlFlowOps wrapped with boxes to delineate the circuits.

*   Added [`concurrent_measurements`](/api/qiskit/qiskit.transpiler.Target#qiskit.transpiler.Target.concurrent_measurements "qiskit.transpiler.Target.concurrent_measurements") which represents a hardware constraint of qubits measured concurrently. This constraint is provided in the nested list form, in which each element represents qubit group to be measured together. In an example below,

    ```python
    [[0, 1], [2, 3, 4]]
    ```

    qubits 0 and 1, and 2, 3 and 4 are measured together on the device. This constraint doesn’t block measuring an individual qubit, however, Qiskit scheduler must consider the alignment of measure operations for those qubits.

*   The performance of [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") and [`bind_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") has significantly increased for large circuits with structures typical of applications uses. This includes most circuits based on the [`NLocal`](/api/qiskit/qiskit.circuit.library.NLocal#qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") structure, such as [`EfficientSU2`](/api/qiskit/qiskit.circuit.library.EfficientSU2#qiskit.circuit.library.EfficientSU2 "qiskit.circuit.library.EfficientSU2"). See [#10282](https://github.com/Qiskit/qiskit-terra/issues/10282) for more detail.

*   The method [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") has gained two new keywords arguments: `flat_input` and `strict`. These are advanced options that can be used to speed up the method when passing the parameter bindings as a dictionary; `flat_input=True` is a guarantee that the dictionary keys contain only [`Parameter`](/api/qiskit/qiskit.circuit.Parameter#qiskit.circuit.Parameter "qiskit.circuit.Parameter") instances (not [`ParameterVector`](/api/qiskit/qiskit.circuit.ParameterVector#qiskit.circuit.ParameterVector "qiskit.circuit.ParameterVector")s), and `strict=False` allows the dictionary to contain parameters that are not present in the circuit. Using these two options can reduce the overhead of input normalisation in this function.

*   The method `filter()` is activated in the [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock#qiskit.pulse.ScheduleBlock "qiskit.pulse.schedule.ScheduleBlock") class. This method enables users to retain only `Instruction` objects which pass through all the provided filters. As builtin filter conditions, pulse [`Channel`](/api/qiskit/pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel") subclass instance and [`Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") subclass type can be specified. User-defined callbacks taking [`Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") instance can be added to the filters, too.

*   The method `exclude()` is activated in the [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock#qiskit.pulse.ScheduleBlock "qiskit.pulse.schedule.ScheduleBlock") class. This method enables users to retain only `Instruction` objects which do not pass at least one of all the provided filters. As builtin filter conditions, pulse [`Channel`](/api/qiskit/pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel") subclass instance and [`Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") subclass type can be specified. User-defined callbacks taking [`Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") instance can be added to the filters, too. This method is the complement of `filter()`, so the following condition is always satisfied: `block.filter(*filters) + block.exclude(*filters) == block` in terms of instructions included, where `block` is a [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock#qiskit.pulse.ScheduleBlock "qiskit.pulse.schedule.ScheduleBlock") instance.

*   The transpiler pass `SetLayout` now is able to be constructed with a list of integers that represent the physical qubits on which the quantum circuit will be mapped on. That is, the first qubit in the circuit will be allocated in the physical qubit in the position zero of the list, and so on.

*   Added a new keyword argument `flatten` to the constructor for the following classes:

    > *   [`EfficientSU2`](/api/qiskit/qiskit.circuit.library.EfficientSU2#qiskit.circuit.library.EfficientSU2 "qiskit.circuit.library.EfficientSU2")
    > *   [`ExcitationPreserving`](/api/qiskit/qiskit.circuit.library.ExcitationPreserving#qiskit.circuit.library.ExcitationPreserving "qiskit.circuit.library.ExcitationPreserving")
    > *   [`NLocal`](/api/qiskit/qiskit.circuit.library.NLocal#qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal")
    > *   [`RealAmplitudes`](/api/qiskit/qiskit.circuit.library.RealAmplitudes#qiskit.circuit.library.RealAmplitudes "qiskit.circuit.library.RealAmplitudes")
    > *   [`TwoLocal`](/api/qiskit/qiskit.circuit.library.TwoLocal#qiskit.circuit.library.TwoLocal "qiskit.circuit.library.TwoLocal")
    > *   [`EvolvedOperatorAnsatz`](/api/qiskit/qiskit.circuit.library.EvolvedOperatorAnsatz#qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz")
    > *   [`QAOAAnsatz`](/api/qiskit/qiskit.circuit.library.QAOAAnsatz#qiskit.circuit.library.QAOAAnsatz "qiskit.circuit.library.QAOAAnsatz")

    If this argument is set to `True` the [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") subclass generated will not wrap the implementation into [`Gate`](/api/qiskit/qiskit.circuit.Gate#qiskit.circuit.Gate "qiskit.circuit.Gate") or [`Instruction`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") objects. While this isn’t optimal for visualization it typically results in much better runtime performance, especially with [`QuantumCircuit.bind_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") and [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") which can see a substatial runtime improvement with a flattened output compared to the nested wrapped default output.

*   Add new `gaussian_square_echo()` pulse shape. This pulse is composed by three `GaussianSquare` pulses. The first two are echo pulses with duration half of the total duration and implement rotary tones. The third pulse is a cancellation tone that lasts the full duration of the pulse and implements correcting single qubit rotations.

*   A new lazy import tester, [`HAS_PYGMENTS`](/api/qiskit/utils#qiskit.utils.optionals.HAS_PYGMENTS "qiskit.utils.optionals.HAS_PYGMENTS"), is available for testing for the presence of [the Pygments syntax highlighting library](https://pygments.org/).

*   Allowing to construct a [`LinearFunction`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") object from more general quantum circuits, that may contain:

    > *   Barriers (of type `Barrier`) and delays ([`Delay`](/api/qiskit/qiskit.circuit.Delay#qiskit.circuit.Delay "qiskit.circuit.Delay")), which are simply ignored
    > *   Permutations (of type [`PermutationGate`](/api/qiskit/qiskit.circuit.library.PermutationGate#qiskit.circuit.library.PermutationGate "qiskit.circuit.library.PermutationGate"))
    > *   Other linear functions
    > *   Cliffords (of type [`Clifford`](/api/qiskit/qiskit.quantum_info.Clifford#qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford")), when the Clifford represents a linear function (and a `CircuitError` exception is raised if not)
    > *   Nested quantum circuits of this form

*   Added `LinearFunction.__eq__()` method. Two objects of type [`LinearFunction`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") are considered equal when their representations as binary invertible matrices are equal.

*   Added [`LinearFunction.extend_with_identity()`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction.extend_with_identity "qiskit.circuit.library.LinearFunction.extend_with_identity") method, which allows to extend a linear function over `k` qubits to a linear function over `n >= k` qubits, specifying the new positions of the original qubits and padding with identities on the remaining qubits.

*   Added two methods for pretty-printing [`LinearFunction`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") objects: [`LinearFunction.mat_str()`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction.mat_str "qiskit.circuit.library.LinearFunction.mat_str"), which returns the string representation of the linear function viewed as a matrix with 0/1 entries, and [`LinearFunction.function_str()`](/api/qiskit/qiskit.circuit.library.LinearFunction#qiskit.circuit.library.LinearFunction.function_str "qiskit.circuit.library.LinearFunction.function_str"), which returns the string representation of the linear function viewed as a linear transformation.

*   The instructions [`StatePreparation`](/api/qiskit/qiskit.circuit.library.StatePreparation#qiskit.circuit.library.StatePreparation "qiskit.circuit.library.StatePreparation") and `Initialize`, and their associated circuit methods [`QuantumCircuit.prepare_state()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.prepare_state "qiskit.circuit.QuantumCircuit.prepare_state") and [`initialize()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.initialize "qiskit.circuit.QuantumCircuit.initialize"), gained a keyword argument `normalize`, which can be set to `True` to automatically normalize an array target. By default this is `False`, which retains the current behaviour of raising an exception when given non-normalized input.

*   Added utility function `qiskit.transpiler.passes.utils._block_to_matrix()` that can generate a matrix based on a block of operations between two qubits. This function can be used in transpiler passes that work on some decomposed circuits such as [`ConsolidateBlocks`](/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks").

*   The transpiler’s built-in [`EquivalenceLibrary`](/api/qiskit/qiskit.circuit.EquivalenceLibrary#qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") has been taught more Pauli-rotation equivalences between the one-qubit $R_X$, $R_Y$ and $R_Z$ gates, and between the two-qubit $R_{XX}$, $R_{YY}$ and $R_{ZZ}$ gates. This should make simple basis translations more reliable, especially circuits that use $Y$ rotations. See [#7332](https://github.com/Qiskit/qiskit-terra/issues/7332).

*   The OpenQASM 3 exporters ([`qasm3.dump()`](/api/qiskit/qasm3#qiskit.qasm3.dump "qiskit.qasm3.dump"), [`dumps()`](/api/qiskit/qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps") and [`Exporter`](/api/qiskit/qasm3#qiskit.qasm3.Exporter "qiskit.qasm3.Exporter")) have a new `allow_aliasing` argument, which will eventually replace the `alias_classical_registers` argument. This controls whether aliasing is permitted for either classical bits or qubits, rather than the option only being available for classical bits.

*   QPY supports the `Discriminator` and `Kernel` objects. This feature enables users to serialize and deserialize the [`Acquire`](/api/qiskit/qiskit.pulse.instructions.Acquire#qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire") instructions with these objects using QPY.

*   Some restrictions when using `wire_order` in the circuit drawers had been relaxed. Now, `wire_order` can list just qubits and, in that case, it can be used with `cregbundle=True`, since it will not affect the classical bits.

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister

    qr = QuantumRegister(4, "q")
    cr = ClassicalRegister(4, "c")
    cr2 = ClassicalRegister(2, "ca")
    circuit = QuantumCircuit(qr, cr, cr2)
    circuit.h(0)
    circuit.h(3)
    circuit.x(1)
    circuit.x(3).c_if(cr, 10)
    circuit.draw('text', wire_order=[2, 3, 0, 1], cregbundle=True)
    ```

    ```python
     q_2: ────────────
          ┌───┐ ┌───┐
     q_3: ┤ H ├─┤ X ├─
          ├───┤ └─╥─┘
     q_0: ┤ H ├───╫───
          ├───┤   ║
     q_1: ┤ X ├───╫───
          └───┘┌──╨──┐
     c: 4/═════╡ 0xa ╞
               └─────┘
    ca: 2/════════════
    ```

*   Control-flow operations are now supported by the Sabre family of transpiler passes, namely layout pass [`SabreLayout`](/api/qiskit/qiskit.transpiler.passes.SabreLayout#qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and routing pass [`SabreSwap`](/api/qiskit/qiskit.transpiler.passes.SabreSwap#qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap"). Function [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") keyword arguments `layout_method` and `routing_method` now accept the option “sabre” for circuits with control flow, which was previously unsupported.

*   Adds support for multiplication of [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") objects with [`Parameter`](/api/qiskit/qiskit.circuit.Parameter#qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects by using the \* operator, for example:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.quantum_info import SparsePauliOp

    param = Parameter("a")
    op = SparsePauliOp("X")
    param * op
    ```

*   Added the option to pass a callback to the [`UMDA`](/api/qiskit/qiskit.algorithms.optimizers.UMDA#qiskit.algorithms.optimizers.UMDA "qiskit.algorithms.optimizers.UMDA") optimizer, which allows to keep track of the number of function evaluations, the current parameters, and the best achieved function value.

<span id="relnotes-0-25-0rc1-transpiler-features" />

<span id="id7" />

### Transpiler Features

*   A new [`qiskit.passmanager`](/api/qiskit/passmanager#module-qiskit.passmanager "qiskit.passmanager") module has been added to the Qiskit library. This module implements a generic pass manager and flow controllers, and provides infrastructure to manage execution of pass manager tasks. The module provides base classes for passes ([`GenericPass`](/api/qiskit/qiskit.passmanager.GenericPass#qiskit.passmanager.GenericPass "qiskit.passmanager.GenericPass")) and flow controllers ([`BaseController`](/api/qiskit/qiskit.passmanager.BaseController#qiskit.passmanager.BaseController "qiskit.passmanager.BaseController")), as well as a new interface class, `passmanager.Task`, to manage the execution of the pass manager (see the `Task.execute()` method). These new classes follow the composite pattern, as flow controllers are collections of passes, and a controller can be recursively nested into the task pipeline. It must also be noted the base classes are not not aware of the input and output object types, and they must be subclassed for a particular program type to optimize. This unified design reduces the complexity of the conventional pass manager, and no longer requires the use of classes such as the `RunningPassManager` to handle the execution logic dispatch and task structure renormalization. The [`qiskit.transpiler`](/api/qiskit/transpiler#module-qiskit.transpiler "qiskit.transpiler") module has been reorganized to rebuild the existing pass managers based off of the generic pass manager. See upgrade notes for more details.

<span id="relnotes-0-25-0rc1-known-issues" />

### Known Issues

*   Added support for taking absolute values of [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")s. For example, the following is now possible:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter

    x = Parameter("x")
    circuit = QuantumCircuit(1)
    circuit.rx(abs(x), 0)

    bound = circuit.bind_parameters({x: -1})
    ```

<span id="relnotes-0-25-0rc1-upgrade-notes" />

### Upgrade Notes

*   Changed [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") to bind assigned integer and float values directly into the parameters of [`Instruction`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") instances in the circuit rather than binding the values wrapped within a [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"). This change should have little user impact as `float(QuantumCircuit.data[i].operation.params[j])` still produces a `float` (and is the only way to access the value of a [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")). Also, [`Instruction()`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") parameters could already be `float` as well as a [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"), so code dealing with instruction parameters should already handle both cases. The most likely chance for user impact is in code that uses `isinstance` to check for [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") and behaves differently depending on the result. Additionally, qpy serializes the numeric value in a bound [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") at a different precision than a `float` (see also the related bug fix note about [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters")).

*   [`Clifford.from_circuit()`](/api/qiskit/qiskit.quantum_info.Clifford#qiskit.quantum_info.Clifford.from_circuit "qiskit.quantum_info.Clifford.from_circuit") will no longer attempt to resolve instructions whose [`definition`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction.definition "qiskit.circuit.Instruction.definition") fields are mutually recursive with some other object. Such recursive definitions are already a violation of the strictly hierarchical ordering that the [`definition`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction.definition "qiskit.circuit.Instruction.definition") field requires, and code should not rely on this being possible at all. If you want to define equivalences that are permitted to have (mutual) cycles, use an [`EquivalenceLibrary`](/api/qiskit/qiskit.circuit.EquivalenceLibrary#qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary").

*   Qiskit Terra 0.25 has dropped support for Python 3.7 following deprecation warnings started in Qiskit Terra 0.23. This is consistent with Python 3.7’s end-of-life on the 27th of June, 2023. To continue using Qiskit, you must upgrade to a more recent version of Python.

*   The OpenQASM 2 constructor methods on [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") ([`from_qasm_str()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") and [`from_qasm_file()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file")) have been switched to use the Rust-based parser added in Qiskit Terra 0.24. This should result in significantly faster parsing times (10 times or more is not uncommon) and massively reduced intermediate memory usage.

    The [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods are kept with the same interface for continuity; the preferred way to access the OpenQASM 2 importer is to use [`qasm2.load()`](/api/qiskit/qasm2#qiskit.qasm2.load "qiskit.qasm2.load") and [`qasm2.loads()`](/api/qiskit/qasm2#qiskit.qasm2.loads "qiskit.qasm2.loads"), which offer an expanded interface to control the parsing and construction.

*   The maximum number of trials evaluated when searching for the best layout using [`VF2Layout`](/api/qiskit/qiskit.transpiler.passes.VF2Layout#qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](/api/qiskit/qiskit.transpiler.passes.VF2PostLayout#qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") is now limited in [`qiskit.transpiler.preset_passmanagers.level_1_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`qiskit.transpiler.preset_passmanagers.level_2_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`qiskit.transpiler.preset_passmanagers.level_3_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") to `2,500`, `25,000`, and `250,000`, respectively. Previously, all possible layouts were evaluated. This change was made to prevent transpilation from hanging during layout scoring for circuits with many connected components on larger devices, which scales combinatorially since each connected component must be evaluated in all possible positions on the device. To perform a full search as before, manually run [`VF2PostLayout`](/api/qiskit/qiskit.transpiler.passes.VF2PostLayout#qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") over the transpiled circuit in strict mode, specifying `0` for `max_trials`.

*   The OpenQASM 3 exporters ([`qasm3.dump()`](/api/qiskit/qasm3#qiskit.qasm3.dump "qiskit.qasm3.dump"), [`dumps()`](/api/qiskit/qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps") and [`Exporter`](/api/qiskit/qasm3#qiskit.qasm3.Exporter "qiskit.qasm3.Exporter")) will now use fewer “register alias” definitions in its output. The circuit described will not change, but it will now preferentially export in terms of direct `bit`, `qubit` and `qubit[n]` types rather than producing a `_loose_bits` register and aliasing more registers off this. This is done to minimise the number of advanced OpenQASM 3 features in use, and to avoid introducing unnecessary array structure into programmes that do not require it.

*   The QPY format version emitted by `dump` has increased to 8. This new format version adds support for serializing the [`QuantumCircuit.layout`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.layout "qiskit.circuit.QuantumCircuit.layout") attribute.

*   The deprecated `circuit_cregs` argument to the constructor for the [`InstructionSet`](/api/qiskit/qiskit.circuit.InstructionSet#qiskit.circuit.InstructionSet "qiskit.circuit.InstructionSet") class has been removed. It was deprecated in the 0.19.0 release. If you were using this argument and manually constructing an [`InstructionSet`](/api/qiskit/qiskit.circuit.InstructionSet#qiskit.circuit.InstructionSet "qiskit.circuit.InstructionSet") object (which should be quite uncommon as it’s mostly used internally) you should pass a callable to the `resource_requester` keyword argument instead. For example:

    ```python
    from qiskit.circuit import Clbit, ClassicalRegister, InstructionSet
    from qiskit.circuit.exceptions import CircuitError

    def my_requester(bits, registers):
        bits_set = set(bits)
        bits_flat = tuple(bits)
        registers_set = set(registers)

        def requester(specifier):
            if isinstance(specifer, Clbit) and specifier in bits_set:
                return specifier
            if isinstance(specifer, ClassicalRegster) and specifier in register_set:
                return specifier
            if isinstance(specifier, int) and 0 <= specifier < len(bits_flat):
                return bits_flat[specifier]
            raise CircuitError(f"Unknown resource: {specifier}")

        return requester

    my_bits = [Clbit() for _ in [None]*5]
    my_registers = [ClassicalRegister(n) for n in range(3)]

    InstructionSet(resource_requester=my_requester(my_bits, my_registers))
    ```

*   In the internal `qiskit.visualization.circuit.matplotlib.MatplotlibDrawer` object, the arguments `layout`, `global_phase`, `qregs` and `cregs` have been removed. They were originally deprecated in Qiskit Terra 0.20. These objects are simply inferred from the given `circuit` now.

    This is an internal worker class of the visualization routines. It is unlikely you will need to change any of your code.

*   Support for passing in lists of argument values to the [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function is removed. This functionality was deprecated as part of the 0.23.0 release and is now being removed. You are still able to pass in a list of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects for the first positional argument, what has been removed is the broadcasting lists of the other arguments to each circuit in that input list. Removing this functionality was necessary to greatly reduce the overhead for parallel execution for transpiling multiple circuits at once. If you’re using this functionality currently you can call [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") multiple times instead. For example if you were previously doing something like:

    ```python
    from qiskit.transpiler import CouplingMap
    from qiskit import QuantumCircuit
    from qiskit import transpile

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    cmaps = [CouplingMap.from_heavy_hex(d) for d in range(3, 15, 2)]
    results = transpile([qc] * 6, coupling_map=cmaps)
    ```

    instead you should now run something like:

    ```python
    from qiskit.transpiler import CouplingMap
    from qiskit import QuantumCircuit
    from qiskit import transpile

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    cmaps = [CouplingMap.from_heavy_hex(d) for d in range(3, 15, 2)]
    results = [transpile(qc, coupling_map=cm) for cm in cmap]
    ```

    You can also leverage [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") or `multiprocessing` from the Python standard library if you want to run this in parallel.

*   The `qiskit.util` import location has been removed, as it had been deprecated since Qiskit Terra 0.17. Users should use the new import location, `qiskit.utils`.

*   The Sabre family of transpiler passes (namely [`SabreLayout`](/api/qiskit/qiskit.transpiler.passes.SabreLayout#qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and [`SabreSwap`](/api/qiskit/qiskit.transpiler.passes.SabreSwap#qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap")) are now used by default for all circuits when invoking the transpiler at optimization level 1 (e.g. calling [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`generate_preset_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") with keyword argument `optimization_level=1`). Previously, circuits with control flow operations used [`DenseLayout`](/api/qiskit/qiskit.transpiler.passes.DenseLayout#qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") and [`StochasticSwap`](/api/qiskit/qiskit.transpiler.passes.StochasticSwap#qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap") with this profile.

*   The `map()` has been modified to use the new `rustworkx` version of `graph_token_swapper()` for performance reasons. Qiskit Terra 0.25 now requires versison 0.13.0 of `rustworkx`.

*   By default Qiskit builds its compiled extensions using the [Python Stable ABI](https://docs.python.org/3/c-api/stable.html) with support back to the oldest version of Python supported by Qiskit (currently 3.8). This means that moving forward there will be a single precompiled wheels that are shipped on release that works with all of Qiskit’s supported Python versions. There isn’t any expected runtime performance difference using the limited API so it is enabled by default for all builds now. Previously, the compiled extensions were built using the version specific API and would only work with a single Python version. This change was made to reduce the number of package files we need to build and publish in each release. When building Qiskit from source there should be no changes necessary to the build process except that the default tags in the output filenames will be different to reflect the use of the limited API.

<span id="relnotes-0-25-0rc1-transpiler-upgrade-notes" />

<span id="id8" />

### Transpiler Upgrade Notes

*   As a consequence of the pass manager refactoring efforts, existing flow controllers: [`FlowControllerLinear`](/api/qiskit/qiskit.passmanager.FlowControllerLinear#qiskit.passmanager.FlowControllerLinear "qiskit.passmanager.FlowControllerLinear"), [`ConditionalController`](/api/qiskit/qiskit.passmanager.ConditionalController#qiskit.passmanager.ConditionalController "qiskit.passmanager.ConditionalController"), and [`DoWhileController`](/api/qiskit/qiskit.passmanager.DoWhileController#qiskit.passmanager.DoWhileController "qiskit.passmanager.DoWhileController") are now subclasses of the [`BaseController`](/api/qiskit/qiskit.passmanager.BaseController#qiskit.passmanager.BaseController "qiskit.passmanager.BaseController"). Note that these controllers have dropped the implementation of the [`__iter__()`](https://docs.python.org/3/reference/datamodel.html#object.__iter__ "(in Python v3.12)") method. They are now only iterable in the context of a flow-controller execution, which threads the compilation state through after each inner task is executed.

*   The functionalitly of the `RunningPassManager` class has been superseded by the new pass manager framework ([`BasePassManager`](/api/qiskit/qiskit.passmanager.BasePassManager#qiskit.passmanager.BasePassManager "qiskit.passmanager.BasePassManager") and [`BaseController`](/api/qiskit/qiskit.passmanager.BaseController#qiskit.passmanager.BaseController "qiskit.passmanager.BaseController")). The running pass manager is now a stateless flow controller (essentially, an alias of [`FlowControllerLinear`](/api/qiskit/qiskit.passmanager.FlowControllerLinear#qiskit.passmanager.FlowControllerLinear "qiskit.passmanager.FlowControllerLinear")), as the pass manager is responsible for the construction of task pipeline, while the controller is responsible for the execution of associated tasks. Subclassing the `RunningPassManager` is no longer recommended, and this class will be completely replaced with the flow controller in future releases.

*   A new class, [`WorkflowStatus`](/api/qiskit/qiskit.passmanager.WorkflowStatus#qiskit.passmanager.WorkflowStatus "qiskit.passmanager.WorkflowStatus"), has been introduced to track the status of the pass manager workflow. This portable object is created when the pass manager is run, and handed over to the underlying tasks. Such status was previously managed by the `RunningPassManager` with instance variables.

*   The transpiler-specific [`transpiler.PassManager`](/api/qiskit/qiskit.transpiler.PassManager#qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") (used in [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile")) is now a subclass of [`passmanager.BasePassManager`](/api/qiskit/qiskit.passmanager.BasePassManager#qiskit.passmanager.BasePassManager "qiskit.passmanager.BasePassManager"). However, this class hierarchy change doesn’t introduce any breaking change to the public-facing API.

*   Exceptions raised during pass-manager execution now inherit from the newly introduced [`PassManagerError`](/api/qiskit/passmanager#qiskit.passmanager.PassManagerError "qiskit.passmanager.PassManagerError"). A generic failure of the pass-manager machinery will raise [`PassManagerError`](/api/qiskit/passmanager#qiskit.passmanager.PassManagerError "qiskit.passmanager.PassManagerError") for general pass managers, but the transpiler-specific `transpile.PassManager` will currently wrap this in its specific [`TranspilerError`](/api/qiskit/transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.TranspilerError") for backwards compatibility. This wrapping will be removed in the future.

*   The use of `FencedObject` in the pass manager framework has been removed. This wrapper class cannot protect mutable object attributes from modification, and this should not be an issue for properly implemented code. Analysis passes should not modify an input IR, controllers should not update the property set, and so forth. It’s the pass manager developer’s responsibility to ensure that the pass is not modifying object attributes,

<span id="relnotes-0-25-0rc1-misc-upgrade-notes" />

<span id="id9" />

### Misc. Upgrade Notes

*   The magic `%qiskit_version_table` from `qiskit.tools.jupyter` and the deprecated `qiskit.__qiskit_version__` do not include qiskit-terra anymore. Now that Qiskit Terra is called Qiskit, these entries are not needed anymore and you can just refer to the `qiskit` entry.

<span id="relnotes-0-25-0rc1-deprecation-notes" />

### Deprecation Notes

*   The [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") module has been deprecated and will be removed in a future release. It has been superseded by a new standalone library `qiskit-algorithms` which can be found on PyPi or on Github here:

    [https://github.com/qiskit-community/qiskit-algorithms](https://github.com/qiskit-community/qiskit-algorithms)

    The [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") will continue to work as before and bug fixes will be made to module until its future removal, but active development of new features has moved to the new package. If you’re relying on [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") you should update your requirements to also include `qiskit-algorithms` and update the imports from `qiskit.algorithms` to `qiskit_algorithms`. Please note that this new package does not include already deprecated algorithms code, including `opflow` and `QuantumInstance`-based algorithms. If you have not yet migrated from `QuantumInstance`-based to primitives-based algorithms, you should follow the migration guidelines in [https://qisk.it/algo\_migration](https://qisk.it/algo_migration). The decision to migrate the [`algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") module to a separate package was made to clarify the purpose Qiskit and make a distinction between the tools and libraries built on top of it.

*   The Jupyter magic `%circuit_library_info` and the objects in `qiskit.tools.jupyter.library` it calls in turn:

    *   `circuit_data_table`
    *   `properties_widget`
    *   `qasm_widget`
    *   `circuit_digram_widget`
    *   `circuit_library_widget`

    are deprecated and will be removed in Terra 0.27. These objects were only intended for use in the documentation build. They are no longer used there, so are no longer supported or maintained.

*   Initializing a `ScalableSymbolicPulse` with complex amp value is now deprecated. This change also affects the following library pulses:

    > *   [`Gaussian`](/api/qiskit/qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian")
    > *   [`GaussianSquare`](/api/qiskit/qiskit.pulse.library.GaussianSquare#qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare")
    > *   [`Drag`](/api/qiskit/qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag")
    > *   [`Constant`](/api/qiskit/qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant")

    Initializing them with complex amp is now deprecated as well.

    Instead, one should use two floats for the amp and angle parameters, where amp represents the magnitude of the complex amplitude, and angle represents the angle of the complex amplitude. i.e. the complex amplitude is given by amp \* exp(1j \* angle).

*   The function `get_vf2_call_limit` available via the module `qiskit.transpiler.preset_passmanagers.common` has been deprecated. This will likely affect very few users since this function was neither explicitly exported nor documented. Its functionality has been replaced and extended by a function in the same module.

*   The method [`qasm()`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction.qasm "qiskit.circuit.Instruction.qasm") and all overriding methods of subclasses of :meth:\`\~qiskit.circuit.Instruction are deprecated. There is no replacement for generating an OpenQASM 2 string for an isolated instruction.

*   Extensions of the `qiskit` and `qiskit.providers` namespaces by external packages are now deprecated and the hook points enabling this will be removed in a future release. In the past, the Qiskit project was composed of elements that extended a shared namespace and these hook points enabled doing that. However, it was not intended for these interfaces to ever be used by other packages. Now that the overall Qiskit package is no longer using that packaging model, leaving the possibility for these extensions carry more risk than benefits and is therefore being deprecated for future removal. If you’re maintaining a package that extends the Qiskit namespace (i.e. your users import from `qiskit.x` or `qiskit.providers.y`) you should transition to using a standalone Python namespace for your package. No warning will be raised as part of this because there is no method to inject a warning at the packaging level that would be required to warn external packages of this change.

*   The [`Call`](/api/qiskit/qiskit.pulse.instructions.Call#qiskit.pulse.instructions.Call "qiskit.pulse.instructions.Call") has been deprecated and will be removed in a future release. Instead, use the [pulse builder](https://qiskit.org/documentation/tutorials/circuits_advanced/06_building_pulse_schedules.html) function [`call()`](/api/qiskit/pulse#qiskit.pulse.builder.call "qiskit.pulse.builder.call") within an active building context.

<span id="relnotes-0-25-0rc1-transpiler-deprecations" />

<span id="id10" />

### Transpiler Deprecations

*   The flow controller factory method [`FlowController.controller_factory()`](/api/qiskit/qiskit.passmanager.FlowController#qiskit.passmanager.FlowController.controller_factory "qiskit.passmanager.FlowController.controller_factory") is deprecated along with [`FlowController.add_flow_controller()`](/api/qiskit/qiskit.passmanager.FlowController#qiskit.passmanager.FlowController.add_flow_controller "qiskit.passmanager.FlowController.add_flow_controller") and [`FlowController.remove_flow_controller()`](/api/qiskit/qiskit.passmanager.FlowController#qiskit.passmanager.FlowController.remove_flow_controller "qiskit.passmanager.FlowController.remove_flow_controller"). In the future, task construction with keyword arguments in the [`BasePassManager.append()`](/api/qiskit/qiskit.passmanager.BasePassManager#qiskit.passmanager.BasePassManager.append "qiskit.passmanager.BasePassManager.append") method will also be deprecated. Controllers must be explicitly instantiated and appended to the pass manager. For example, the previously used conventional syntax

    ```python
    pm.append([task1, task2], condition=lambda x: x["value1"] > 10)
    ```

    must be replaced with

    ```python
    controller = ConditionalController([task1, task2], condition=lambda x: x["value1"] > 10)
    pm.append(controller)
    ```

    The latter allows more precise control on the order of controllers especially when multiple keyword arguments are specified together, and allows for the construction of general flow controllers that may have more than one pipeline or do not take a single simple conditional function in their constructors.

*   The [`FlowControllerLinear.append()`](/api/qiskit/qiskit.passmanager.FlowControllerLinear#qiskit.passmanager.FlowControllerLinear.append "qiskit.passmanager.FlowControllerLinear.append"), [`DoWhileController.append()`](/api/qiskit/qiskit.passmanager.DoWhileController#qiskit.passmanager.DoWhileController.append "qiskit.passmanager.DoWhileController.append"), and [`ConditionalController.append()`](/api/qiskit/qiskit.passmanager.ConditionalController#qiskit.passmanager.ConditionalController.append "qiskit.passmanager.ConditionalController.append") methods are all deprecated immediately. The construction of the pass manager task pipeline is now the role of [`BasePassManager`](/api/qiskit/qiskit.passmanager.BasePassManager#qiskit.passmanager.BasePassManager "qiskit.passmanager.BasePassManager"), and individual flow controllers do not need to this method. For a flow controller, all the passes should be specificed in one go directly to the constructor.

*   The general attribute and variable name `passes` is replaced with `tasks` all over the [`qiskit.passmanager`](/api/qiskit/passmanager#module-qiskit.passmanager "qiskit.passmanager") module. Note that a task must indicate a union of pass and controller, and the singular form pass conflicts with the Python keyword. In this sense, the use of tasks is much preferable.

<span id="relnotes-0-25-0rc1-bug-fixes" />

<span id="id11" />

### Bug Fixes

*   Updated [`plot_gate_map()`](/api/qiskit/qiskit.visualization.plot_gate_map#qiskit.visualization.plot_gate_map "qiskit.visualization.plot_gate_map"), [`plot_error_map()`](/api/qiskit/qiskit.visualization.plot_error_map#qiskit.visualization.plot_error_map "qiskit.visualization.plot_error_map"), and [`plot_circuit_layout()`](/api/qiskit/qiskit.visualization.plot_circuit_layout#qiskit.visualization.plot_circuit_layout "qiskit.visualization.plot_circuit_layout") to support 433 qubit heavy-hex coupling maps. This allows coupling map visualizations for IBM’s `ibm_seattle`.

*   Fixed the deserialization of [`DiagonalGate`](/api/qiskit/qiskit.circuit.library.DiagonalGate#qiskit.circuit.library.DiagonalGate "qiskit.circuit.library.DiagonalGate") instances through QPY. See [#10364](https://github.com/Qiskit/qiskit-terra/issues/10364).

*   Fixed an issue with [`FullAncillaAllocation`](/api/qiskit/qiskit.transpiler.passes.FullAncillaAllocation#qiskit.transpiler.passes.FullAncillaAllocation "qiskit.transpiler.passes.FullAncillaAllocation") so it can now function with [`Target`](/api/qiskit/qiskit.transpiler.Target#qiskit.transpiler.Target "qiskit.transpiler.Target") objects that do not have a coupling map (typically because there are no 2 qubit gates in the [`Target`](/api/qiskit/qiskit.transpiler.Target#qiskit.transpiler.Target "qiskit.transpiler.Target")). In this case [`FullAncillaAllocation`](/api/qiskit/qiskit.transpiler.passes.FullAncillaAllocation#qiskit.transpiler.passes.FullAncillaAllocation "qiskit.transpiler.passes.FullAncillaAllocation") will add ancilla qubits so that the number of qubits in the [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") matches the number [`Target.num_qubits`](/api/qiskit/qiskit.transpiler.Target#qiskit.transpiler.Target.num_qubits "qiskit.transpiler.Target.num_qubits").

*   Changed the binding of numeric values with [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") to avoid a mismatch between the values of circuit instruction parameters and corresponding parameter keys in the circuit’s calibration dictionary. Fixed [#9764](https://github.com/Qiskit/qiskit-terra/issues/9764) and [#10166](https://github.com/Qiskit/qiskit-terra/issues/10166). See also the related upgrade note regarding [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters").

*   [`DAGCircuit.substitute_node()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.substitute_node "qiskit.dagcircuit.DAGCircuit.substitute_node") will no longer silently overwrite an existing condition on the given replacement `op`. If `propagate_condition` is set to `True` (the default), a [`DAGCircuitError`](/api/qiskit/dagcircuit#qiskit.dagcircuit.DAGCircuitError "qiskit.dagcircuit.DAGCircuitError") will be raised instead.

*   A parametrised circuit that contains a custom gate whose definition has a parametrised global phase can now successfully bind the parameter in the inner global phase. See [#10283](https://github.com/Qiskit/qiskit-terra/issues/10283) for more detail.

*   Construction of a [`Statevector`](/api/qiskit/qiskit.quantum_info.Statevector#qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") from a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") containing zero-qubit operations will no longer raise an error. These operations impart a global phase on the resulting statevector.

*   When `qs_decomposition()`, which does quantum Shannon decomposition, was called on trivial numeric unitaries that do not benefit from this decomposition, an unexpected error was raised. With this fix, such unitaries are detected and the equivalent circuit is returned without performing Shannon decomposition.

*   Fixes a typo where BasicSwap called `fake_run()` the attribute instead of `_fake_run()` the function. Refer to #10149 \<hhttps\://github.com/Qiskit/qiskit-terra/issues/10147> for more details.

*   Fixed an issue with copying circuits with new-style [`Clbit`](/api/qiskit/qiskit.circuit.Clbit#qiskit.circuit.Clbit "qiskit.circuit.Clbit")s and [`Qubit`](/api/qiskit/qiskit.circuit.Qubit#qiskit.circuit.Qubit "qiskit.circuit.Qubit")s (bits without registers) where references to these bits from the containing circuit could be broken, causing issues with serialization and circuit visualization.

*   The [`CheckMap`](/api/qiskit/qiskit.transpiler.passes.CheckMap#qiskit.transpiler.passes.CheckMap "qiskit.transpiler.passes.CheckMap") transpiler pass will no longer spuriously error when dealing with nested conditional structures created by the control-flow builder interface. See [#10394](https://github.com/Qiskit/qiskit-terra/issues/10394).

*   Fixed a bug in `BlockCollapser` where classical bits were ignored when collapsing a block of nodes.

*   Fixed a bug in [`replace_block_with_op()`](/api/qiskit/qiskit.dagcircuit.DAGCircuit#qiskit.dagcircuit.DAGCircuit.replace_block_with_op "qiskit.dagcircuit.DAGCircuit.replace_block_with_op") and [`replace_block_with_op()`](/api/qiskit/qiskit.dagcircuit.DAGDependency#qiskit.dagcircuit.DAGDependency.replace_block_with_op "qiskit.dagcircuit.DAGDependency.replace_block_with_op") that led to ignoring classical bits.

*   Fixed a bug in [`QuantumCircuit.compose()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.compose "qiskit.circuit.QuantumCircuit.compose") where the `SwitchCaseOp.target` attribute in the subcircuit would not get mapped to a register in the base circuit correctly.

*   The control-flow builder interface will now correctly include [`ClassicalRegister`](/api/qiskit/qiskit.circuit.ClassicalRegister#qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") resources from nested switch statements in their containing circuit scopes. See [#10398](https://github.com/Qiskit/qiskit-terra/issues/10398).

*   Fixed an issue in the `QuantumCircuit.decompose()` method where passing a circuit name to the function that matched a composite gate name would not decompose the gate if it had a label assigned to it as well. Fixed [#9136](https://github.com/Qiskit/qiskit-terra/issues/9136)

*   Fixed an issue in tranpiler passes for padding delays, which did not respect target’s constraints and inserted delays even for qubits not supporting [`Delay`](/api/qiskit/qiskit.circuit.Delay#qiskit.circuit.Delay "qiskit.circuit.Delay") instruction. [`PadDelay`](/api/qiskit/qiskit.transpiler.passes.PadDelay#qiskit.transpiler.passes.PadDelay "qiskit.transpiler.passes.PadDelay") and [`PadDynamicalDecoupling`](/api/qiskit/qiskit.transpiler.passes.PadDynamicalDecoupling#qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling") are fixed so that they do not pad any idle time of qubits such that the target does not support `Delay` instructions for the qubits. Also legacy scheduling passes `ASAPSchedule` and `ALAPSchedule`, which pad delays internally, are fixed in the same way. In addition, `transpile()` is fixed to call `PadDelay` with a `target` object so that it works correctly when called with `scheduling_method` option. Fixed [#9993](https://github.com/Qiskit/qiskit-terra/issues/9993)

*   Fixed an failure of the pulse builder when the context is initialized with [`BackendV2`](/api/qiskit/qiskit.providers.BackendV2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2").

*   Fix a bug in [`RZXCalibrationBuilder`](/api/qiskit/qiskit.transpiler.passes.RZXCalibrationBuilder#qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") where calling calibration with wrong parameters would crash instead of raising exception.

*   Fixed an issue with the [`BooleanExpression.from_dimacs_file()`](/api/qiskit/qiskit.circuit.classicalfunction.BooleanExpression#qiskit.circuit.classicalfunction.BooleanExpression.from_dimacs_file "qiskit.circuit.classicalfunction.BooleanExpression.from_dimacs_file") constructor method where the exception type raised when tweedledum wasn’t installed was not the expected `MissingOptionalLibrary`. Fixed [#10079](https://github.com/Qiskit/qiskit-terra/issues/10079)

*   Using `initial_layout` in calls to [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") will no longer error if the circuit contains qubits not in any registers, or qubits that exist in more than one register. See [#10125](https://github.com/Qiskit/qiskit-terra/issues/10125).

*   Fixed the gate decomposition of multi-controlled Z rotation gates added via [`QuantumCircuit.mcrz()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.mcrz "qiskit.circuit.QuantumCircuit.mcrz"). Previously, this method implemented a multi-controlled phase gate, which has a relative phase difference to the Z rotation. To obtain the previous .QuantumCircuit.mcrz behaviour, use .QuantumCircuit.mcp.

*   Fixed the output of pulse `measure()` and `measure_all()` when functions are called with the [`BackendV2`](/api/qiskit/qiskit.providers.BackendV2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend.

*   Fixed the dimensions of the output density matrix from [`DensityMatrix.partial_transpose()`](/api/qiskit/qiskit.quantum_info.DensityMatrix#qiskit.quantum_info.DensityMatrix.partial_transpose "qiskit.quantum_info.DensityMatrix.partial_transpose") so they match the dimensions of the corresponding input density matrix.

*   Fixed plot legend error when your dataset has a zero value at first position. When one of your counts or distributions had a zero value at first position, the relative legend didn’t show up. See #10158 \<[https://github.com/Qiskit/qiskit-terra/issues/10158](https://github.com/Qiskit/qiskit-terra/issues/10158)> for more details.

*   Fixed an issue with the [`PassManagerConfig.from_backend()`](/api/qiskit/qiskit.transpiler.PassManagerConfig#qiskit.transpiler.PassManagerConfig.from_backend "qiskit.transpiler.PassManagerConfig.from_backend") constructor when building a [`PassManagerConfig`](/api/qiskit/qiskit.transpiler.PassManagerConfig#qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig") object from a [`BackendV1`](/api/qiskit/qiskit.providers.BackendV1#qiskit.providers.BackendV1 "qiskit.providers.BackendV1") instance that didn’t have a coupling map attribute defined. Previously, the constructor would incorrectly create a [`CouplingMap`](/api/qiskit/qiskit.transpiler.CouplingMap#qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") object with 0 qubits instead of using `None`. Fixed [#10171](https://github.com/Qiskit/qiskit-terra/issues/10171)

*   Importing [`qiskit.primitives`](/api/qiskit/primitives#module-qiskit.primitives "qiskit.primitives") will no longer cause deprecation warnings stemming from the deprecated [`qiskit.opflow`](/api/qiskit/opflow#module-qiskit.opflow "qiskit.opflow") module. These warnings would have been hidden to users by the default Python filters, but triggered the eager import of [`opflow`](/api/qiskit/opflow#module-qiskit.opflow "qiskit.opflow"), which meant that a subsequent import by a user would not trigger the warnings.

*   Fixed the OpenQASM 2 output of [`QuantumCircuit.qasm()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.qasm "qiskit.circuit.QuantumCircuit.qasm") when a custom gate object contained a gate with the same name. Ideally this shouldn’t happen for most gates, but complex algorithmic operations like the [`GroverOperator`](/api/qiskit/qiskit.circuit.library.GroverOperator#qiskit.circuit.library.GroverOperator "qiskit.circuit.library.GroverOperator") class could produce such structures accidentally. See [#10162](https://github.com/Qiskit/qiskit-terra/issues/10162).

*   Fixed a regression in the LaTeX drawer of [`QuantumCircuit.draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.draw "qiskit.circuit.QuantumCircuit.draw") when temporary files are placed on a separate filesystem to the working directory. See [#10211](https://github.com/Qiskit/qiskit-terra/issues/10211).

*   Fixes a bug introduced in Qiskit 0.24.0 where numeric rotation angles were no longer substituted for symbolic ones before preparing for two-qubit synthesis. This caused an exception to be raised because the synthesis routines require numberic matrices.

*   Fixed an issue with [`UnitarySynthesis`](/api/qiskit/qiskit.transpiler.passes.UnitarySynthesis#qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") when using the `target` parameter where circuits with control flow were not properly mapped to the target.

*   Fix a bug in which running [`Optimize1qGatesDecomposition`](/api/qiskit/qiskit.transpiler.passes.Optimize1qGatesDecomposition#qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") in parallel would raise an error due to OneQubitGateErrorMap not being picklable.

*   Fixed an failure of [`Target.update_from_instruction_schedule_map()`](/api/qiskit/qiskit.transpiler.Target#qiskit.transpiler.Target.update_from_instruction_schedule_map "qiskit.transpiler.Target.update_from_instruction_schedule_map") when the argument `inst_map` has schedule with unassigned duration.

*   Fix a bug in the [`VF2Layout`](/api/qiskit/qiskit.transpiler.passes.VF2Layout#qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](/api/qiskit/qiskit.transpiler.passes.VF2PostLayout#qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") passes where the passes wer failing to account for the 1 qubit error component when evaluating a potential layout.

*   Fixed bug in [`VQD`](/api/qiskit/qiskit.algorithms.eigensolvers.VQD#qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD") where `result.optimal_values` was a copy of `result.optimal_points`. It now returns the corresponding values.

*   When the parameter `conditional=True` is set in `qiskit.circuit.random.random_circuit`, the conditional operations will be preceded by a full mid-circuit measurment. Fixes [#9016](https://github.com/Qiskit/qiskit-terra/issues/9016)

*   Improve the type annotations on the [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") method to reflect the change in return type depending on the `inplace` argument.

*   The OpenQASM 2 circuit-constructor methods ([`QuantumCircuit.from_qasm_str()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") and [`from_qasm_file()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file")) will no longer error when encountering a `gate` definition that contains `U` or `CX` instructions. See [#5536](https://github.com/Qiskit/qiskit-terra/issues/5536).

*   Reduced overhead of the [`ConsolidateBlocks`](/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") pass by performing matrix operations on all two-qubit blocks using `qiskit.transpiler.passes.utils._block_to_matrix()` instead of creating an instance of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and passing it to an [`Operator`](/api/qiskit/qiskit.quantum_info.Operator#qiskit.quantum_info.Operator "qiskit.quantum_info.Operator"). The speedup will only be applicable when consolidating two-qubit blocks. Anything higher than that will still be handled by the [`Operator`](/api/qiskit/qiskit.quantum_info.Operator#qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") class. Check [#8779](https://github.com/Qiskit/qiskit-terra/issues/8779) for details.

*   Improved the error messages returned when an attempt to convert a fully bound [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") into a concrete `float` or `int` failed, for example because the expression was naturally a complex number.

*   Fixed `float` conversions for [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") values which had, at some point in their construction history, an imaginary component that had subsequently been cancelled. When using Sympy as a backend, these conversions would usually already have worked. When using Symengine as the backend, these conversions would often fail with type errors, despite the result having been symbolically evaluated to be real, and [`ParameterExpression.is_real()`](/api/qiskit/qiskit.circuit.ParameterExpression#qiskit.circuit.ParameterExpression.is_real "qiskit.circuit.ParameterExpression.is_real") being true.

*   Fixed a potential performance scaling issue with layout scoring in preset pass managers, which could occur when transpiling circuits with many connected components on large devices.

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](/api/qiskit/qasm3#module-qiskit.qasm3 "qiskit.qasm3")) will no longer output invalid OpenQASM 3 for non-unitary [`Instruction`](/api/qiskit/qiskit.circuit.Instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") instances, but will instead raise a [`QASM3ExporterError`](/api/qiskit/qasm3#qiskit.qasm3.QASM3ExporterError "qiskit.qasm3.QASM3ExporterError") explaining that this are not yet supported. This feature will is slated for a later release of Qiskit, when there are more classical-processing facilities throughout the library.

*   Fixed the [`qpy`](/api/qiskit/qpy#module-qiskit.qpy "qiskit.qpy") serialization of [`QuantumCircuit.layout`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.layout "qiskit.circuit.QuantumCircuit.layout") attribue. Previously, the [`layout`](/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.layout "qiskit.circuit.QuantumCircuit.layout") attribute would have been dropped when serializing a circuit to QPY. Fixed [#10112](https://github.com/Qiskit/qiskit-terra/issues/10112)

*   Fixes issue #10185 \<[https://github.com/Qiskit/qiskit-terra/issues/10185](https://github.com/Qiskit/qiskit-terra/issues/10185)>.

*   The function `state_to_latex()` produced not valid LaTeX with unintended coefficient rounding, resulting in errors when calling `state_drawer()` is called. Fixed [#9297](https://github.com/Qiskit/qiskit-terra/issues/9297).


## 0.25.0

This release officially deprecates the Qiskit Aqua project. Accordingly, in a future release the `qiskit-aqua` package will be removed from the Qiskit metapackage, which means in that future release `pip install qiskit` will no longer include `qiskit-aqua`. The application modules that are provided by qiskit-aqua have been split into several new packages: `qiskit-optimization`, `qiskit-nature`, `qiskit-machine-learning`, and `qiskit-finance`. These packages can be installed by themselves (via the standard pip install command, e.g. `pip install qiskit-nature`) or with the rest of the Qiskit metapackage as optional extras (e.g. `pip install 'qiskit[finance,optimization]'` or `pip install 'qiskit[all]'` The core algorithms and the operator flow now exist as part of qiskit-terra at [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") and [`qiskit.opflow`](/api/qiskit/opflow#module-qiskit.opflow "qiskit.opflow"). Depending on your existing usage of Aqua you should either use the application packages or the new modules in Qiskit Terra. For more details on how to migrate from Qiskit Aqua, you can refer to the [migration guide](https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide).

<span id="terra-0-17-0" />

<span id="release-notes-0-17-0" />

### Terra 0.17.0

<span id="release-notes-0-17-0-prelude" />

<span id="id299" />

#### Prelude

The Qiskit Terra 0.17.0 includes many new features and bug fixes. The major new feature for this release is the introduction of the [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") and [`qiskit.opflow`](/api/qiskit/opflow#module-qiskit.opflow "qiskit.opflow") modules which were migrated and adapted from the `qiskit.aqua` project.

<span id="release-notes-0-17-0-new-features" />

<span id="id300" />

#### New Features

*   The `qiskit.pulse.call()` function can now take a [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") object along with a parameterized subroutine. This enables assigning different values to the [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects for each subroutine call.

    For example,

    ```python
    from qiskit.circuit import Parameter
    from qiskit import pulse

    amp = Parameter('amp')

    with pulse.build() as subroutine:
        pulse.play(pulse.Gaussian(160, amp, 40), DriveChannel(0))

    with pulse.build() as main_prog:
        pulse.call(subroutine, amp=0.1)
        pulse.call(subroutine, amp=0.3)
    ```

*   The [`qiskit.providers.models.QasmBackendConfiguration`](/api/qiskit/qiskit.providers.models.QasmBackendConfiguration "qiskit.providers.models.QasmBackendConfiguration") has a new field `processor_type` which can optionally be used to provide information about a backend’s processor in the form: `{"family": <str>, "revision": <str>, segment: <str>}`. For example: `{"family": "Canary", "revision": "1.0", segment: "A"}`.

*   The [`qiskit.pulse.Schedule`](/api/qiskit/qiskit.pulse.Schedule "qiskit.pulse.Schedule"), `qiskit.pulse.Instruction`, and `qiskit.pulse.Channel` classes now have a `parameter` property which will return any [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects used in the object and a [`is_parameterized()`](/api/qiskit/qiskit.pulse.Schedule#is_parameterized "qiskit.pulse.Schedule.is_parameterized") method which will return `True` if any parameters are used in the object.

    For example:

    ```python
    from qiskit.circuit import Parameter
    from qiskit import pulse

    shift = Parameter('alpha')

    schedule = pulse.Schedule()
    schedule += pulse.SetFrequency(shift, pulse.DriveChannel(0))

    assert schedule.is_parameterized() == True
    print(schedule.parameters)
    ```

*   Added a [`PiecewiseChebyshev`](/api/qiskit/qiskit.circuit.library.PiecewiseChebyshev "qiskit.circuit.library.PiecewiseChebyshev") to the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") for implementing a piecewise Chebyshev approximation of an input function. For a given function $f(x)$ and degree $d$, this class class implements a piecewise polynomial Chebyshev approximation on $n$ qubits to $f(x)$ on the given intervals. All the polynomials in the approximation are of degree $d$.

    For example:

    ```python
    import numpy as np
    from qiskit import QuantumCircuit
    from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev
    f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2
    pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)
    pw_approximation._build()
    qc = QuantumCircuit(pw_approximation.num_qubits)
    qc.h(list(range(num_state_qubits)))
    qc.append(pw_approximation.to_instruction(), qc.qubits)
    qc.draw(output='mpl')
    ```

*   The [`BackendProperties`](/api/qiskit/qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") class now has a [`readout_length()`](/api/qiskit/qiskit.providers.models.BackendProperties#readout_length "qiskit.providers.models.BackendProperties.readout_length") method, which returns the readout length \[sec] of the given qubit.

*   A new class, [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"), has been added to the [`qiskit.pulse`](/api/qiskit/pulse#module-qiskit.pulse "qiskit.pulse") module. This class provides a new representation of a pulse program. This representation is best suited for the pulse builder syntax and is based on relative instruction ordering.

    This representation takes `alignment_context` instead of specifying starting time `t0` for each instruction. The start time of instruction is implicitly allocated with the specified transformation and relative position of instructions.

    The [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") allows for lazy instruction scheduling, meaning we can assign arbitrary parameters to the duration of instructions.

    For example:

    ```python
    from qiskit.pulse import ScheduleBlock, DriveChannel, Gaussian
    from qiskit.pulse.instructions import Play, Call
    from qiskit.pulse.transforms import AlignRight
    from qiskit.circuit import Parameter

    dur = Parameter('rabi_duration')

    block = ScheduleBlock(alignment_context=AlignRight())
    block += Play(Gaussian(dur, 0.1, dur/4), DriveChannel(0))
    block += Call(measure_sched)  # subroutine defined elsewhere
    ```

    this code defines an experiment scanning a Gaussian pulse’s duration followed by a measurement `measure_sched`, i.e. a Rabi experiment. You can reuse the `block` object for every scanned duration by assigning a target duration value.

*   Added a new function [`array_to_latex()`](/api/qiskit/qiskit.visualization.array_to_latex "qiskit.visualization.array_to_latex") to the [`qiskit.visualization`](/api/qiskit/visualization#module-qiskit.visualization "qiskit.visualization") module that can be used to represent and visualize vectors and matrices with LaTeX.

    ```python
    from qiskit.visualization import array_to_latex
    from numpy import sqrt, exp, pi
    mat = [[0, exp(pi*.75j)],
           [1/sqrt(8), 0.875]]
    array_to_latex(mat)
    ```

*   The [`Statevector`](/api/qiskit/qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`DensityMatrix`](/api/qiskit/qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes now have [`draw()`](/api/qiskit/qiskit.quantum_info.Statevector#draw "qiskit.quantum_info.Statevector.draw") methods which allow objects to be drawn as either text matrices, IPython Latex objects, Latex source, Q-spheres, Bloch spheres and Hinton plots. By default the output type is the equivalent output from `__repr__` but this default can be changed in a user config file by setting the `state_drawer` option. For example:

    ```python
    from qiskit.quantum_info import DensityMatrix
    dm = DensityMatrix.from_label('r0')
    dm.draw('latex')
    ```

    ```python
    from qiskit.quantum_info import Statevector
    sv = Statevector.from_label('+r')
    sv.draw('qsphere')
    ```

    Additionally, the [`draw()`](/api/qiskit/qiskit.quantum_info.DensityMatrix#draw "qiskit.quantum_info.DensityMatrix.draw") method is now used for the ipython display of these classes, so if you change the default output type in a user config file then when a [`Statevector`](/api/qiskit/qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") or a [`DensityMatrix`](/api/qiskit/qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") object are displayed in a jupyter notebook that output type will be used for the object.

*   Pulse `qiskit.pulse.Instruction` objects and parametric pulse objects (eg [`Gaussian`](/api/qiskit/qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian") now support using [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") and [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects for the `duration` parameter. For example:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.pulse import Gaussian

    dur = Parameter('x_pulse_duration')
    double_dur = dur * 2
    rx_pulse = Gaussian(dur, 0.1, dur/4)
    double_rx_pulse = Gaussian(double_dir, 0.1, dur/4)
    ```

    Note that while we can create an instruction with a parameterized `duration` adding an instruction with unbound parameter `duration` to a schedule is supported only by the newly introduced representation [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"). See the known issues release notes section for more details.

*   The [`run()`](/api/qiskit/qiskit.providers.basicaer.QasmSimulatorPy#run "qiskit.providers.basicaer.QasmSimulatorPy.run") method for the [`QasmSimulatorPy`](/api/qiskit/qiskit.providers.basicaer.QasmSimulatorPy "qiskit.providers.basicaer.QasmSimulatorPy"), [`StatevectorSimulatorPy`](/api/qiskit/qiskit.providers.basicaer.StatevectorSimulatorPy "qiskit.providers.basicaer.StatevectorSimulatorPy"), and [`UnitarySimulatorPy`](/api/qiskit/qiskit.providers.basicaer.UnitarySimulatorPy "qiskit.providers.basicaer.UnitarySimulatorPy") backends now takes a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") (or a list of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects) as its input. The previous [`QasmQobj`](/api/qiskit/qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") object is still supported for now, but will be deprecated in a future release.

    For an example of how to use this see:

    ```python
    from qiskit import transpile, QuantumCircuit

    from qiskit.providers.basicaer import BasicAer

    backend = BasicAer.get_backend('qasm_simulator')

    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()

    tqc = transpile(circuit, backend)
    result = backend.run(tqc, shots=4096).result()
    ```

*   The [`CommutativeCancellation`](/api/qiskit/qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation") transpiler pass has a new optional kwarg on the constructor `basis_gates`, which takes the a list of the names of basis gates for the target backend. When specified the pass will only use gates in the `basis_gates` kwarg. Previously, the pass would automatically replace consecutive gates which commute with [`ZGate`](/api/qiskit/qiskit.circuit.library.ZGate "qiskit.circuit.library.ZGate") with the [`U1Gate`](/api/qiskit/qiskit.circuit.library.U1Gate "qiskit.circuit.library.U1Gate") unconditionally. The `basis_gates` kwarg enables you to specify which z-rotation gates are present in the target basis to avoid this.

*   The constructors of the [`Bit`](/api/qiskit/qiskit.circuit.Bit "qiskit.circuit.Bit") class and subclasses, [`Qubit`](/api/qiskit/qiskit.circuit.Qubit "qiskit.circuit.Qubit"), [`Clbit`](/api/qiskit/qiskit.circuit.Clbit "qiskit.circuit.Clbit"), and [`AncillaQubit`](/api/qiskit/qiskit.circuit.AncillaQubit "qiskit.circuit.AncillaQubit"), have been updated such that their two parameters, `register` and `index` are now optional. This enables the creation of bit objects that are independent of a register.

*   A new class, [`BooleanExpression`](/api/qiskit/qiskit.circuit.classicalfunction.BooleanExpression "qiskit.circuit.classicalfunction.BooleanExpression"), has been added to the [`qiskit.circuit.classicalfunction`](/api/qiskit/classicalfunction#module-qiskit.circuit.classicalfunction "qiskit.circuit.classicalfunction") module. This class allows for creating an oracle from a Python boolean expression. For example:

    ```python
    from qiskit.circuit import BooleanExpression, QuantumCircuit

    expression = BooleanExpression('~x & (y | z)')
    circuit = QuantumCircuit(4)
    circuit.append(expression, [0, 1, 2, 3])
    circuit.draw('mpl')
    ```

    ```python
    circuit.decompose().draw('mpl')
    ```

    The [`BooleanExpression`](/api/qiskit/qiskit.circuit.classicalfunction.BooleanExpression "qiskit.circuit.classicalfunction.BooleanExpression") also includes a method, [`from_dimacs_file()`](/api/qiskit/qiskit.circuit.classicalfunction.BooleanExpression#from_dimacs_file "qiskit.circuit.classicalfunction.BooleanExpression.from_dimacs_file"), which allows loading formulas described in the [DIMACS-CNF](https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html) format. For example:

    ```python
    from qiskit.circuit import BooleanExpression, QuantumCircuit

    boolean_exp = BooleanExpression.from_dimacs_file("simple_v3_c2.cnf")
    circuit = QuantumCircuit(boolean_exp.num_qubits)
    circuit.append(boolean_exp, range(boolean_exp.num_qubits))
    circuit.draw('text')
    ```

    ```python
         ┌───────────────────┐
    q_0: ┤0                  ├
         │                   │
    q_1: ┤1                  ├
         │  SIMPLE_V3_C2.CNF │
    q_2: ┤2                  ├
         │                   │
    q_3: ┤3                  ├
         └───────────────────┘
    ```

    ```python
    circuit.decompose().draw('text')
    ```

    ```python
    q_0: ──o────o────────────
           │    │
    q_1: ──■────o────■───────
           │    │    │
    q_2: ──■────┼────o────■──
         ┌─┴─┐┌─┴─┐┌─┴─┐┌─┴─┐
    q_3: ┤ X ├┤ X ├┤ X ├┤ X ├
         └───┘└───┘└───┘└───┘
    ```

*   Added a new class, [`PhaseOracle`](/api/qiskit/qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle"), has been added to the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module. This class enables the construction of phase oracle circuits from Python boolean expressions.

    ```python
    from qiskit.circuit.library.phase_oracle import PhaseOracle

    oracle = PhaseOracle('x1 & x2 & (not x3)')
    oracle.draw('mpl')
    ```

    These phase oracles can be used as part of a larger algorithm, for example with [`qiskit.algorithms.AmplificationProblem`](/api/qiskit/qiskit.algorithms.AmplificationProblem "qiskit.algorithms.AmplificationProblem"):

    ```python
    from qiskit.algorithms import AmplificationProblem, Grover
    from qiskit import BasicAer

    backend = BasicAer.get_backend('qasm_simulator')

    problem = AmplificationProblem(oracle, is_good_state=oracle.evaluate_bitstring)
    grover = Grover(quantum_instance=backend)
    result = grover.amplify(problem)
    result.top_measurement
    ```

    The [`PhaseOracle`](/api/qiskit/qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") class also includes a [`from_dimacs_file()`](/api/qiskit/qiskit.circuit.library.PhaseOracle#from_dimacs_file "qiskit.circuit.library.PhaseOracle.from_dimacs_file") method which enables constructing a phase oracle from a file describing a formula in the [DIMACS-CNF](https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html) format.

    ```python
    from qiskit.circuit.library.phase_oracle import PhaseOracle

    oracle = PhaseOracle.from_dimacs_file("simple_v3_c2.cnf")
    oracle.draw('text')
    ```

    ```python
    state_0: ─o───────o──────────────
              │ ┌───┐ │ ┌───┐
    state_1: ─■─┤ X ├─■─┤ X ├─■──────
              │ └───┘   └───┘ │ ┌───┐
    state_2: ─■───────────────o─┤ Z ├
                                └───┘
    ```

*   All transpiler passes (ie any instances of `BasePass`) are now directly callable. Calling a pass provides a convenient interface for running the pass on a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object.

    For example, running a single transformation pass, such as [`BasisTranslator`](/api/qiskit/qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator"), can be done with:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.transpiler.passes import BasisTranslator
    from qiskit.circuit.equivalence_library import SessionEquivalenceLibrary as sel

    circuit = QuantumCircuit(1)
    circuit.h(0)

    pass_instance = BasisTranslator(sel, ['rx', 'rz', 'cx'])
    result = pass_instance(circuit)
    result.draw(output='mpl')
    ```

    When running an analysis pass, a property set (as `dict` or as `PropertySet`) needs to be added as a parameter and it might be modified “in-place”. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.transpiler.passes import Depth

    circuit = QuantumCircuit(1)
    circuit.h(0)

    property_set = {}
    pass_instance = Depth()
    pass_instance(circuit, property_set)
    print(property_set)
    ```

*   The [`QasmQobjConfig`](/api/qiskit/qiskit.qobj.QasmQobjConfig "qiskit.qobj.QasmQobjConfig") class now has an optional kwarg for `meas_level` and `meas_return`. These fields can be used to enable generating [`QasmQobj`](/api/qiskit/qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") job payloads that support `meas_level=1` (kerneled data) for circuit jobs (previously this was only exposed for [`PulseQobj`](/api/qiskit/qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") objects). The [`assemble()`](/api/qiskit/compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") function has been updated to set this field for [`QasmQobj`](/api/qiskit/qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") objects it generates.

*   A new [`tensor()`](/api/qiskit/qiskit.circuit.QuantumCircuit#tensor "qiskit.circuit.QuantumCircuit.tensor") method has been added to the [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This method enables tensoring another circuit with an existing circuit. This method works analogously to [`qiskit.quantum_info.Operator.tensor()`](/api/qiskit/qiskit.quantum_info.Operator#tensor "qiskit.quantum_info.Operator.tensor") and is consistent with the little-endian convention of Qiskit.

    For example:

    ```python
    from qiskit import QuantumCircuit
    top = QuantumCircuit(1)
    top.x(0);
    bottom = QuantumCircuit(2)
    bottom.cry(0.2, 0, 1);
    bottom.tensor(top).draw(output='mpl')
    ```

*   The [`qiskit.circuit.QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class now supports arbitrary free form metadata with the [`metadata`](/api/qiskit/qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") attribute. A user (or program built on top of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")) can attach metadata to a circuit for use in tracking the circuit. For example:

    ```python
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(2, user_metadata_field_1='my_metadata',
                        user_metadata_field_2='my_other_value')
    ```

    or:

    ```python
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(2)
    qc.metadata = {'user_metadata_field_1': 'my_metadata',
                   'user_metadata_field_2': 'my_other_value'}
    ```

    This metadata will **not** be used for influencing the execution of the circuit but is just used for tracking the circuit for the lifetime of the object. The `metadata` attribute will persist between any circuit transforms including [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`assemble()`](/api/qiskit/compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"). The expectation is for providers to associate the metadata in the result it returns, so that users can filter results based on circuit metadata the same way they can currently do with `QuantumCircuit.name`.

*   Add a new operator class [`CNOTDihedral`](/api/qiskit/qiskit.quantum_info.CNOTDihedral "qiskit.quantum_info.CNOTDihedral") has been added to the [`qiskit.quantum_info`](/api/qiskit/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module. This class is used to represent the CNOT-Dihedral group, which is generated by the quantum gates [`CXGate`](/api/qiskit/qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate"), [`TGate`](/api/qiskit/qiskit.circuit.library.TGate "qiskit.circuit.library.TGate"), and [`XGate`](/api/qiskit/qiskit.circuit.library.XGate "qiskit.circuit.library.XGate").

*   Adds a `&` (`__and__`) binary operator to `BaseOperator` subclasses (eg [`qiskit.quantum_info.Operator`](/api/qiskit/qiskit.quantum_info.Operator "qiskit.quantum_info.Operator")) in the [`qiskit.quantum_info`](/api/qiskit/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module. This is shorthand to call the classes [`compose()`](/api/qiskit/qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose") method (ie `A & B == A.compose(B)`).

    For example:

    ```python
    import qiskit.quantum_info as qi

    qi.Pauli('X') & qi.Pauli('Y')
    ```

*   Adds a `&` (`__and__`) binary operator to [`qiskit.quantum_info.Statevector`](/api/qiskit/qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](/api/qiskit/qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes. This is shorthand to call the classes [`evolve()`](/api/qiskit/qiskit.quantum_info.Statevector#evolve "qiskit.quantum_info.Statevector.evolve") method (ie `psi & U == psi.evolve(U)`).

    For example:

    ```python
    import qiskit.quantum_info as qi

    qi.Statevector.from_label('0') & qi.Pauli('X')
    ```

*   A new a new 2-qubit gate, [`ECRGate`](/api/qiskit/qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate"), the echo cross-resonance (ECR), has been added to the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module along with a corresponding method, [`ecr()`](/api/qiskit/qiskit.circuit.QuantumCircuit#ecr "qiskit.circuit.QuantumCircuit.ecr") for the [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. The ECR gate is two $CR(\frac{π}{4})$ pulses with an [`XGate`](/api/qiskit/qiskit.circuit.library.XGate "qiskit.circuit.library.XGate") between them for the echo. This gate is locally equivalent to a [`CXGate`](/api/qiskit/qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") (can convert to a CNOT with local pre- or post-rotation). It is the native gate on current IBM hardware and compiling to it allows the pre-/post-rotations to be merged into the rest of the circuit.

*   A new kwarg `approximation_degree` has been added to the [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function for enabling approximate compilation. Valid values range from 0 to 1, and higher means less approximation. This is a heuristic dial to experiment with circuit approximations. The concrete interpretation of this number is left to each pass, which may use it to perform some approximate version of the pass. Specific examples include the [`UnitarySynthesis`](/api/qiskit/qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") pass or the or translators to discrete gate sets. If a pass does not support this option, it implies exact transformation.

*   Two new transpiler passess, [`GateDirection`](/api/qiskit/qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection") and [`qiskit.transpiler.passes.CheckGateDirection`](/api/qiskit/qiskit.transpiler.passes.CheckGateDirection "qiskit.transpiler.passes.CheckGateDirection"), were added to the [`qiskit.transpiler.passes`](/api/qiskit/transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module. These new passes are inteded to be more general replacements for `CXDirection` and `CheckCXDirection` (which are both now deprecated, see the deprecation notes for more details) that perform the same function but work with other gates beside just [`CXGate`](/api/qiskit/qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate").

*   When running on Windows, parallel execution with the [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") function can now be enabled (it is still disabled by default). To do this you can either set `parallel = True` in a user config file, or set the `QISKIT_PARALLEL` environment variable to `TRUE` (this will also effect [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`assemble()`](/api/qiskit/compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") which both use [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") internally). It is important to note that when enabling parallelism on Windows there are limitations around how Python launches processes for Windows, see the Known Issues section below for more details on the limitations with parallel execution on Windows.

*   A new function, [`hellinger_distance()`](/api/qiskit/quantum_info#qiskit.quantum_info.hellinger_distance "qiskit.quantum_info.hellinger_distance"), for computing the Hellinger distance between two counts distributions has been added to the [`qiskit.quantum_info`](/api/qiskit/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module.

*   The [`decompose_clifford()`](/api/qiskit/quantum_info#qiskit.quantum_info.decompose_clifford "qiskit.quantum_info.decompose_clifford") function in the [`qiskit.quantum_info`](/api/qiskit/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module (which gets used internally by the [`qiskit.quantum_info.Clifford.to_circuit()`](/api/qiskit/qiskit.quantum_info.Clifford#to_circuit "qiskit.quantum_info.Clifford.to_circuit") method) has a new kwarg `method` which enables selecting the synthesis method used by either setting it to `'AG'` or `'greedy'`. By default for more than three qubits it is set to `'greedy'` which uses a non-optimal greedy compilation routine for Clifford elements synthesis, by Bravyi et. al., which typically yields better CX cost compared to the previously used Aaronson-Gottesman method (for more than two qubits). You can use the `method` kwarg to revert to the previous default Aaronson-Gottesman method by setting `method='AG'`.

*   The `Initialize` class in the [`qiskit.extensions`](/api/qiskit/extensions#module-qiskit.extensions "qiskit.extensions") module can now be constructed using an integer. The ‘1’ bits of the integer will insert a `Reset` and an [`XGate`](/api/qiskit/qiskit.circuit.library.XGate "qiskit.circuit.library.XGate") into the circuit for the corresponding qubit. This will be done using the standard little-endian convention is qiskit, ie the rightmost bit of the integer will set qubit 0. For example, setting the parameter in `Initialize` equal to `5` will set qubits 0 and 2 to value 1.

    ```python
    from qiskit.extensions import Initialize

    initialize = Initialize(13)
    initialize.definition.draw('mpl')
    ```

*   The `Initialize` class in the [`qiskit.extensions`](/api/qiskit/extensions#module-qiskit.extensions "qiskit.extensions") module now supports constructing directly from a Pauli label (analogous to the [`qiskit.quantum_info.Statevector.from_label()`](/api/qiskit/qiskit.quantum_info.Statevector#from_label "qiskit.quantum_info.Statevector.from_label") method). The Pauli label refer to basis states of the Pauli eigenstates Z, X, Y. These labels use Qiskit’s standard little-endian notation, for example a label of `'01'` would initialize qubit 0 to $|1\rangle$ and qubit 1 to $|0\rangle$.

    ```python
    from qiskit.extensions import Initialize

    initialize = Initialize("10+-lr")
    initialize.definition.draw('mpl')
    ```

*   The kwarg, `template_list`, for the constructor of the [`qiskit.transpiler.passes.TemplateOptimization`](/api/qiskit/qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") transpiler pass now supports taking in a list of both [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and [`DAGDependency`](/api/qiskit/qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") objects. Previously, only [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") were accepted (which were internally converted to [`DAGDependency`](/api/qiskit/qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") objects) in the input list.

*   A new transpiler pass, [`qiskit.transpiler.passes.RZXCalibrationBuilder`](/api/qiskit/qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder"), capable of generating calibrations and adding them to a quantum circuit has been introduced. This pass takes calibrated [`CXGate`](/api/qiskit/qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") objects and creates the calibrations for [`qiskit.circuit.library.RZXGate`](/api/qiskit/qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate") objects with an arbitrary rotation angle. The schedules are created by stretching and compressing the `GaussianSquare` pulses of the echoed-cross resonance gates.

*   New template circuits for using [`qiskit.circuit.library.RZXGate`](/api/qiskit/qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate") are added to the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module (eg [`rzx_yz`](/api/qiskit/circuit_library#qiskit.circuit.library.rzx_yz "qiskit.circuit.library.rzx_yz")). This enables pairing the [`TemplateOptimization`](/api/qiskit/qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") pass with the [`qiskit.transpiler.passes.RZXCalibrationBuilder`](/api/qiskit/qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") pass to automatically find and replace gate sequences, such as `CNOT - P(theta) - CNOT`, with more efficent circuits based on [`qiskit.circuit.library.RZXGate`](/api/qiskit/qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate") with a calibration.

*   The matplotlib output type for the [`circuit_drawer()`](/api/qiskit/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and the [`draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method for the [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class now supports configuration files for setting the visualization style. In previous releases, there was basic functionality that allowed users to pass in a `style` kwarg that took in a `dict` to customize the colors and other display features of the `mpl` drawer. This has now been expanded so that these dictionaries can be loaded from JSON files directly without needing to pass a dictionary. This enables users to create new style files and use that style for visualizations by passing the style filename as a string to the `style` kwarg.

    To leverage this feature you must set the `circuit_mpl_style_path` option in a user config file. This option should be set to the path you want qiskit to search for style JSON files. If specifying multiple path entries they should be separated by `:`. For example, setting `circuit_mpl_style_path = ~/.qiskit:~/user_styles` in a user config file will look for JSON files in both `~/.qiskit` and `~/user_styles`.

*   A new kwarg, `format_marginal` has been added to the function `marginal_counts()` which when set to `True` formats the counts output according to the `cregs` in the circuit and missing indices are represented with a `_`. For example:

    ```python
    from qiskit import QuantumCircuit, execute, BasicAer, result
    from qiskit.result.utils import marginal_counts
    qc = QuantumCircuit(5, 5)
    qc.x(0)
    qc.measure(0, 0)

    result = execute(qc, BasicAer.get_backend('qasm_simulator')).result()
    print(marginal_counts(result.get_counts(), [0, 2, 4], format_marginal=True))
    ```

*   Improved the performance of [`qiskit.quantum_info.Statevector.expectation_value()`](/api/qiskit/qiskit.quantum_info.Statevector#expectation_value "qiskit.quantum_info.Statevector.expectation_value") and [`qiskit.quantum_info.DensityMatrix.expectation_value()`](/api/qiskit/qiskit.quantum_info.DensityMatrix#expectation_value "qiskit.quantum_info.DensityMatrix.expectation_value") when the argument operator is a [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") or [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") operator.

*   The user config file has 2 new configuration options, `num_processes` and `parallel`, which are used to control the default behavior of [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map"). The `parallel` option is a boolean that is used to dictate whether [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") will run in multiple processes or not. If it set to `False` calls to [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") will be executed serially, while setting it to `True` will enable parallel execution. The `num_processes` option takes an integer which sets how many CPUs to use when executing in parallel. By default it will use the number of CPU cores on a system.

*   There are 2 new environment variables, `QISKIT_PARALLEL` and `QISKIT_NUM_PROCS`, that can be used to control the default behavior of [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map"). The `QISKIT_PARALLEL` option can be set to the `TRUE` (any capitalization) to set the default to run in multiple processes when [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") is called. If it is set to any other value [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") will be executed serially. `QISKIT_NUM_PROCS` takes an integer (for example `QISKIT_NUM_PROCS=5`) which will be used as the default number of processes to run with. Both of these will take precedence over the equivalent option set in the user config file.

*   A new method, [`gradient()`](/api/qiskit/qiskit.circuit.ParameterExpression#gradient "qiskit.circuit.ParameterExpression.gradient"), has been added to the [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") class. This method is used to evaluate the gradient of a [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") object.

*   The `__eq__` method (ie what is called when the `==` operator is used) for the [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") now allows for the comparison with a numeric value. Previously, it was only possible to compare two instances of [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") with `==`. For example:

    ```python
    from qiskit.circuit import Parameter

    x = Parameter("x")
    y = x + 2
    y = y.assign(x, -1)

    assert y == 1
    ```

*   The [`PauliFeatureMap`](/api/qiskit/qiskit.circuit.library.PauliFeatureMap "qiskit.circuit.library.PauliFeatureMap") class in the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module now supports adjusting the rotational factor, $\alpha$, by either setting using the kwarg `alpha` on the constructor or setting the [`alpha`](/api/qiskit/qiskit.circuit.library.PauliFeatureMap#alpha "qiskit.circuit.library.PauliFeatureMap.alpha") attribute after creation. Previously this value was fixed at `2.0`. Adjusting this attribute allows for better control of decision boundaries and provides additional flexibility handling the input features without needing to explicitly scale them in the data set.

*   A new [`Gate`](/api/qiskit/qiskit.circuit.Gate "qiskit.circuit.Gate") class, [`PauliGate`](/api/qiskit/qiskit.circuit.library.PauliGate "qiskit.circuit.library.PauliGate"), has been added the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module and corresponding method, [`pauli()`](/api/qiskit/qiskit.circuit.QuantumCircuit#pauli "qiskit.circuit.QuantumCircuit.pauli"), was added to the [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This new gate class enables applying several individual pauli gates to different qubits at the simultaneously. This is primarily useful for simulators which can use this new gate to more efficiently implement multiple simultaneous Pauli gates.

*   Improve the [`qiskit.quantum_info.Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") operator. This class now represents and element from the full N-qubit Pauli group including complex coefficients. It now supports the Operator API methods including [`compose()`](/api/qiskit/qiskit.quantum_info.Pauli#compose "qiskit.quantum_info.Pauli.compose"), [`dot()`](/api/qiskit/qiskit.quantum_info.Pauli#dot "qiskit.quantum_info.Pauli.dot"), [`tensor()`](/api/qiskit/qiskit.quantum_info.Pauli#tensor "qiskit.quantum_info.Pauli.tensor") etc, where compose and dot are defined with respect to the full Pauli group.

    This class also allows conversion to and from the string representation of Pauli’s for convenience.

    For example

    ```python
    from qiskit.quantum_info import Pauli

    P1 = Pauli('XYZ')
    P2 = Pauli('YZX')
    P1.dot(P2)
    ```

    Pauli’s can also be directly appended to [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects

    ```python
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import Pauli

    circ = QuantumCircuit(3)
    circ.append(Pauli('XYZ'), [0, 1, 2])
    circ.draw(output='mpl')
    ```

    Additional methods allow computing when two Pauli’s commute (using the [`commutes()`](/api/qiskit/qiskit.quantum_info.Pauli#commutes "qiskit.quantum_info.Pauli.commutes") method) or anticommute (using the [`anticommutes()`](/api/qiskit/qiskit.quantum_info.Pauli#anticommutes "qiskit.quantum_info.Pauli.anticommutes") method), and computing the Pauli resulting from Clifford conjugation $P^\prime = C.P.C^\dagger$ using the [`evolve()`](/api/qiskit/qiskit.quantum_info.Pauli#evolve "qiskit.quantum_info.Pauli.evolve") method.

    See the API documentation of the [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") class for additional information.

*   A new function, [`random_pauli()`](/api/qiskit/quantum_info#qiskit.quantum_info.random_pauli "qiskit.quantum_info.random_pauli"), for generating a random element of the N-qubit Pauli group has been added to the [`qiskit.quantum_info`](/api/qiskit/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module.

*   A new class, [`PiecewisePolynomialPauliRotations`](/api/qiskit/qiskit.circuit.library.PiecewisePolynomialPauliRotations "qiskit.circuit.library.PiecewisePolynomialPauliRotations"), has been added to the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module. This circuit library element is used for mapping a piecewise polynomial function, $f(x)$, which is defined through breakpoints and coefficients, on qubit amplitudes. The breakpoints $(x_0, ..., x_J)$ are a subset of $[0, 2^n-1]$, where $n$ is the number of state qubits. The corresponding coefficients $[a_{j,1},...,a_{j,d}]$, where $d$ is the highest degree among all polynomials. Then $f(x)$ is defined as:

    $$
    \begin{split}f(x) = \begin{cases}
        0, x < x_0 \\
        \sum_{i=0}^{i=d}a_{j,i} x^i, x_j \leq x < x_{j+1}
        \end{cases}\end{split}
    $$

    where we implicitly assume $x_{J+1} = 2^n$. And the mapping applied to the amplitudes is given by

    $$
    F|x\rangle |0\rangle = \cos(p_j(x))|x\rangle |0\rangle + \sin(p_j(x))|x\rangle |1\rangle
    $$

    This mapping is based on controlled Pauli Y-rotations and constructed using the [`PolynomialPauliRotations`](/api/qiskit/qiskit.circuit.library.PolynomialPauliRotations "qiskit.circuit.library.PolynomialPauliRotations").

*   A new module [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") has been introduced. This module contains functionality equivalent to what has previously been provided by the `qiskit.aqua.algorithms` module (which is now deprecated) and provides the building blocks for constructing quantum algorithms. For details on migrating from `qiskit-aqua` to this new module, please refer to the [migration guide](https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide).

*   A new module [`qiskit.opflow`](/api/qiskit/opflow#module-qiskit.opflow "qiskit.opflow") has been introduced. This module contains functionality equivalent to what has previously been provided by the `qiskit.aqua.operators` module (which is now deprecated) and provides the operators and state functions which are used to build quantum algorithms. For details on migrating from `qiskit-aqua` to this new module, please refer to the [migration guide](https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide).

*   This is the first release that includes precompiled binary wheels for the for Linux aarch64 systems. If you are running a manylinux2014 compatible aarch64 Linux system there are now precompiled wheels available on PyPI, you are no longer required to build from source to install qiskit-terra.

*   The [`qiskit.quantum_info.process_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity") function is now able to be used with a non-unitary target channel. In this case the returned value is equivalent to the [`qiskit.quantum_info.state_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.state_fidelity "qiskit.quantum_info.state_fidelity") of the normalized [`qiskit.quantum_info.Choi`](/api/qiskit/qiskit.quantum_info.Choi "qiskit.quantum_info.Choi") matrices for the channels.

    Note that the [`qiskit.quantum_info.average_gate_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.average_gate_fidelity "qiskit.quantum_info.average_gate_fidelity") and [`qiskit.quantum_info.gate_error()`](/api/qiskit/quantum_info#qiskit.quantum_info.gate_error "qiskit.quantum_info.gate_error") functions still require the target channel to be unitary and will raise an exception if it is not.

*   Added a new pulse builder function, `qiskit.pulse.macro()`. This enables normal Python functions to be decorated as macros. This enables pulse builder functions to be used within the decorated function. The builder macro can then be called from within a pulse building context, enabling code reuse.

    For Example:

    ```python
    from qiskit import pulse

    @pulse.macro
    def measure(qubit: int):
        pulse.play(pulse.GaussianSquare(16384, 256, 15872),
                   pulse.MeasureChannel(qubit))
        mem_slot = pulse.MemorySlot(0)
        pulse.acquire(16384, pulse.AcquireChannel(0), mem_slot)
        return mem_slot

    with pulse.build(backend=backend) as sched:
        mem_slot = measure(0)
        print(f"Qubit measured into {mem_slot}")

    sched.draw()
    ```

*   A new class, [`PauliTwoDesign`](/api/qiskit/qiskit.circuit.library.PauliTwoDesign "qiskit.circuit.library.PauliTwoDesign"), was added to the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") which implements a particular form of a 2-design circuit from [https://arxiv.org/pdf/1803.11173.pdf](https://arxiv.org/pdf/1803.11173.pdf) For instance, this circuit can look like:

    ```python
    from qiskit.circuit.library import PauliTwoDesign
    circuit = PauliTwoDesign(4, reps=2, seed=5, insert_barriers=True)
    circuit.decompose().draw(output='mpl')
    ```

*   A new pulse drawer `qiskit.visualization.pulse_v2.draw()` (which is aliased as `qiskit.visualization.pulse_drawer_v2`) is now available. This new pulse drawer supports multiple new features not present in the original pulse drawer ([`pulse_drawer()`](/api/qiskit/qiskit.visualization.pulse_drawer "qiskit.visualization.pulse_drawer")).

    *   Truncation of long pulse instructions.
    *   Visualization of parametric pulses.
    *   New stylesheets `IQXStandard`, `IQXSimple`, `IQXDebugging`.
    *   Visualization of system info (channel frequency, etc…) by specifying [`qiskit.providers.Backend`](/api/qiskit/qiskit.providers.Backend "qiskit.providers.Backend") objects for visualization.
    *   Specifying `axis` objects for plotting to allow further extension of generated plots, i.e., for publication manipulations.

    New stylesheets can take callback functions that dynamically modify the apperance of the output image, for example, reassembling a collection of channels, showing details of instructions, updating appearance of pulse envelopes, etc… You can create custom callback functions and feed them into a stylesheet instance to modify the figure appearance without modifying the drawer code. See pulse drawer module docstrings for details.

    Note that file saving is now delegated to Matplotlib. To save image files, you need to call `savefig` method with returned `Figure` object.

*   Adds a [`reverse_qargs()`](/api/qiskit/qiskit.quantum_info.Statevector#reverse_qargs "qiskit.quantum_info.Statevector.reverse_qargs") method to the [`qiskit.quantum_info.Statevector`](/api/qiskit/qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](/api/qiskit/qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes. This method reverses the order of subsystems in the states and is equivalent to the [`qiskit.circuit.QuantumCircuit.reverse_bits()`](/api/qiskit/qiskit.circuit.QuantumCircuit#reverse_bits "qiskit.circuit.QuantumCircuit.reverse_bits") method for N-qubit states. For example:

    > ```python
    > from qiskit.circuit.library import QFT
    > from qiskit.quantum_info import Statevector
    >
    > circ = QFT(3)
    >
    > state1 = Statevector.from_instruction(circ)
    > state2 = Statevector.from_instruction(circ.reverse_bits())
    >
    > state1.reverse_qargs() == state2
    > ```

*   Adds a [`reverse_qargs()`](/api/qiskit/qiskit.quantum_info.Operator#reverse_qargs "qiskit.quantum_info.Operator.reverse_qargs") method to the [`qiskit.quantum_info.Operator`](/api/qiskit/qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") class. This method reverses the order of subsystems in the operator and is equivalent to the [`qiskit.circuit.QuantumCircuit.reverse_bits()`](/api/qiskit/qiskit.circuit.QuantumCircuit#reverse_bits "qiskit.circuit.QuantumCircuit.reverse_bits") method for N-qubit operators. For example:

    > ```python
    > from qiskit.circuit.library import QFT
    > from qiskit.quantum_info import Operator
    >
    > circ = QFT(3)
    >
    > op1 = Operator(circ)
    > op2 = Operator(circ.reverse_bits())
    >
    > op1.reverse_qargs() == op2
    > ```

*   The `latex` output method for the [`qiskit.visualization.circuit_drawer()`](/api/qiskit/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method now will use a user defined label on gates in the output visualization. For example:

    ```python
    import math

    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.rx(math.pi/2, 0, label='My Special Rotation')

    qc.draw(output='latex')
    ```

*   The `routing_method` kwarg for the [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function now accepts a new option, `'none'`. When `routing_method='none'` no routing pass will be run as part of the transpilation. If the circuit does not fit coupling map a [`TranspilerError`](/api/qiskit/transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.exceptions.TranspilerError") exception will be raised.

*   A new gate class, [`RVGate`](/api/qiskit/qiskit.circuit.library.RVGate "qiskit.circuit.library.RVGate"), was added to the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module along with the corresponding [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`rv()`](/api/qiskit/qiskit.circuit.QuantumCircuit#rv "qiskit.circuit.QuantumCircuit.rv"). The [`RVGate`](/api/qiskit/qiskit.circuit.library.RVGate "qiskit.circuit.library.RVGate") is a general rotation gate, similar to the [`UGate`](/api/qiskit/qiskit.circuit.library.UGate "qiskit.circuit.library.UGate"), but instead of specifying Euler angles the three components of a rotation vector are specified where the direction of the vector specifies the rotation axis and the magnitude specifies the rotation angle about the axis in radians. For example:

    ```python
    import math

    import np

    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(1)
    theta = math.pi / 5
    phi = math.pi / 3
    # RGate axis:
    axis = np.array([math.cos(phi), math.sin(phi)])
    rotation_vector = theta * axis
    qc.rv(*rotation_vector, 0)
    ```

*   Unbound [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects used in a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object will now be sorted by name. This will take effect for the parameters returned by the [`parameters`](/api/qiskit/qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") attribute. Additionally, the [`qiskit.circuit.QuantumCircuit.bind_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") and [`qiskit.circuit.QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") methods can now take in a list of a values which will bind/assign them to the parameters in name-sorted order. Previously these methods would only take a dictionary of parameters and values. For example:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter

    circuit = QuantumCircuit(1)
    circuit.rx(Parameter('x'), 0)
    circuit.ry(Parameter('y'), 0)

    print(circuit.parameters)

    bound = circuit.bind_parameters([1, 2])
    bound.draw(output='mpl')
    ```

*   The constructors for the [`qiskit.quantum_info.Statevector`](/api/qiskit/qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](/api/qiskit/qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes can now take a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object in to build a [`Statevector`](/api/qiskit/qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`DensityMatrix`](/api/qiskit/qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") object from that circuit, assuming that the qubits are initialized in $|0\rangle$. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import Statevector

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)

    statevector = Statevector(qc)
    statevector.draw(output='latex')
    ```

*   New fake backend classes are available under `qiskit.test.mock`. These included mocked versions of `ibmq_casablanca`, `ibmq_sydney`, `ibmq_mumbai`, `ibmq_lima`, `ibmq_belem`, `ibmq_quito`. As with the other fake backends, these include snapshots of calibration data (i.e. `backend.defaults()`) and error data (i.e. `backend.properties()`) taken from the real system, and can be used for local testing, compilation and simulation.

<span id="release-notes-0-17-0-known-issues" />

<span id="id303" />

#### Known Issues

*   Attempting to add an `qiskit.pulse.Instruction` object with a parameterized `duration` (ie the value of `duration` is an unbound [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") or [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") object) to a [`qiskit.pulse.Schedule`](/api/qiskit/qiskit.pulse.Schedule "qiskit.pulse.Schedule") is not supported. Attempting to do so will result in `UnassignedDurationError` [`PulseError`](/api/qiskit/pulse#qiskit.pulse.PulseError "qiskit.pulse.PulseError") being raised. This is a limitation of how the `Instruction` overlap constraints are evaluated currently. This is supported by [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"), in which the overlap constraints are evaluated just before the execution.

*   On Windows systems when parallel execution is enabled for [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") parallelism may not work when called from a script running outside of a `if __name__ == '__main__':` block. This is due to how Python launches parallel processes on Windows. If a `RuntimeError` or `AttributeError` are raised by scripts that call [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") (including using functions that use `parallel_map()` internally like [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile")) with Windows and parallelism enabled you can try embedding the script calls inside `if __name__ == '__main__':` to workaround the issue. For example:

    ```python
    from qiskit import QuantumCircuit, QiskitError
    from qiskit import execute, Aer

    qc1 = QuantumCircuit(2, 2)
    qc1.h(0)
    qc1.cx(0, 1)
    qc1.measure([0,1], [0,1])
    # making another circuit: superpositions
    qc2 = QuantumCircuit(2, 2)
    qc2.h([0,1])
    qc2.measure([0,1], [0,1])
    execute([qc1, qc2], Aer.get_backend('qasm_simulator'))
    ```

    should be changed to:

    ```python
    from qiskit import QuantumCircuit, QiskitError
    from qiskit import execute, Aer

    def main():
        qc1 = QuantumCircuit(2, 2)
        qc1.h(0)
        qc1.cx(0, 1)
        qc1.measure([0,1], [0,1])
        # making another circuit: superpositions
        qc2 = QuantumCircuit(2, 2)
        qc2.h([0,1])
        qc2.measure([0,1], [0,1])
        execute([qc1, qc2], Aer.get_backend('qasm_simulator'))

    if __name__ == '__main__':
        main()
    ```

    if any errors are encountered with parallelism on Windows.

<span id="release-notes-0-17-0-upgrade-notes" />

<span id="id304" />

#### Upgrade Notes

*   The preset pass managers [`level_1_pass_manager`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`level_2_pass_manager`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`level_3_pass_manager`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") (which are used for `optimization_level` 1, 2, and 3 in the [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`execute()`](/api/qiskit/execute#qiskit.execute_function.execute "qiskit.execute_function.execute") functions) now unconditionally use the [`Optimize1qGatesDecomposition`](/api/qiskit/qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") pass for 1 qubit gate optimization. Previously, these pass managers would use the [`Optimize1qGates`](/api/qiskit/qiskit.transpiler.passes.Optimize1qGates "qiskit.transpiler.passes.Optimize1qGates") pass if the basis gates contained `u1`, `u2`, or `u3`. If you want to still use the old [`Optimize1qGates`](/api/qiskit/qiskit.transpiler.passes.Optimize1qGates "qiskit.transpiler.passes.Optimize1qGates") you will need to construct a custom [`PassManager`](/api/qiskit/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") with the pass.

*   Following transpilation of a parameterized [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"), the [`global_phase`](/api/qiskit/qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") attribute of output circuit may no longer be returned in a simplified form, if the global phase is a [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression").

    For example:

    ```python
    qc = QuantumCircuit(1)
    theta = Parameter('theta')

    qc.rz(theta, 0)
    qc.rz(-theta, 0)

    print(transpile(qc, basis_gates=['p']).global_phase)
    ```

    previously returned `0`, but will now return `-0.5*theta + 0.5*theta`. This change was necessary was to avoid a large runtime performance penalty as simplifying symbolic expressions can be quite slow, especially if there are many [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects in a circuit.

*   The [`BasicAerJob`](/api/qiskit/qiskit.providers.basicaer.BasicAerJob "qiskit.providers.basicaer.BasicAerJob") job objects returned from BasicAer backends are now synchronous instances of [`JobV1`](/api/qiskit/qiskit.providers.JobV1 "qiskit.providers.JobV1"). This means that calls to the [`run()`](/api/qiskit/qiskit.providers.basicaer.QasmSimulatorPy#run "qiskit.providers.basicaer.QasmSimulatorPy.run") will block until the simulation finishes executing. If you want to restore the previous async behavior you’ll need to wrap the [`run()`](/api/qiskit/qiskit.providers.basicaer.QasmSimulatorPy#run "qiskit.providers.basicaer.QasmSimulatorPy.run") with something that will run in a seperate thread or process like `futures.ThreadPoolExecutor` or `futures.ProcessPoolExecutor`.

*   The `allow_sample_measuring` option for the BasicAer simulator [`QasmSimulatorPy`](/api/qiskit/qiskit.providers.basicaer.QasmSimulatorPy "qiskit.providers.basicaer.QasmSimulatorPy") has changed from a default of `False` to `True`. This was done to better reflect the actual default behavior of the simulator, which would use sample measuring if the input circuit supported it (even if it was not enabled). If you are running a circuit that doesn’t support sample measurement (ie it has `Reset` operations or if there are operations after a measurement on a qubit) you should make sure to explicitly set this option to `False` when you call [`run()`](/api/qiskit/qiskit.providers.basicaer.QasmSimulatorPy#run "qiskit.providers.basicaer.QasmSimulatorPy.run").

*   The [`CommutativeCancellation`](/api/qiskit/qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation") transpiler pass is now aware of the target basis gates, which means it will only use gates in the specified basis. Previously, the pass would unconditionally replace consecutive gates which commute with [`ZGate`](/api/qiskit/qiskit.circuit.library.ZGate "qiskit.circuit.library.ZGate") with the [`U1Gate`](/api/qiskit/qiskit.circuit.library.U1Gate "qiskit.circuit.library.U1Gate"). However, now that the pass is basis aware and has a kwarg, `basis_gates`, for specifying the target basis there is a potential change in behavior if the kwarg is not set. When the `basis_gates` kwarg is not used and there are no variable z-rotation gates in the circuit then no commutative cancellation will occur.

*   [`Register`](/api/qiskit/qiskit.circuit.Register "qiskit.circuit.Register") (which is the parent class for [`QuantumRegister`](/api/qiskit/qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`ClassicalRegister`](/api/qiskit/qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") and [`Bit`](/api/qiskit/qiskit.circuit.Bit "qiskit.circuit.Bit") (which is the parent class for [`Qubit`](/api/qiskit/qiskit.circuit.Qubit "qiskit.circuit.Qubit") and [`Clbit`](/api/qiskit/qiskit.circuit.Clbit "qiskit.circuit.Clbit")) objects are now immutable. In previous releases it was possible to adjust the value of a [`size`](/api/qiskit/qiskit.circuit.QuantumRegister#size "qiskit.circuit.QuantumRegister.size") or [`name`](/api/qiskit/qiskit.circuit.QuantumRegister#name "qiskit.circuit.QuantumRegister.name") attributes of a [`Register`](/api/qiskit/qiskit.circuit.Register "qiskit.circuit.Register") object and the [`index`](/api/qiskit/qiskit.circuit.Qubit#index "qiskit.circuit.Qubit.index") or [`register`](/api/qiskit/qiskit.circuit.Qubit#register "qiskit.circuit.Qubit.register") attributes of a [`Bit`](/api/qiskit/qiskit.circuit.Bit "qiskit.circuit.Bit") object after it was initially created. However this would lead to unsound behavior that would corrupt container structure that rely on a hash (such as a dict) since these attributes are treated as immutable properties of a register or bit (see [#4705](https://github.com/Qiskit/qiskit-terra/issues/4705) for more details). To avoid this unsound behavior this attributes of a [`Register`](/api/qiskit/qiskit.circuit.Register "qiskit.circuit.Register") and [`Bit`](/api/qiskit/qiskit.circuit.Bit "qiskit.circuit.Bit") are no longer settable after initial creation. If you were previously adjusting the objects at runtime you will now need to create a new `Register` or `Bit` object with the new values.

*   The `DAGCircuit.__eq__` method (which is used by the `==` operator), which is used to check structural equality of [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instances, will now include the [`global_phase`](/api/qiskit/qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") and [`calibrations`](/api/qiskit/qiskit.circuit.QuantumCircuit#calibrations "qiskit.circuit.QuantumCircuit.calibrations") attributes in the fields checked for equality. This means that circuits which would have evaluated as equal in prior releases may not anymore if the `global_phase` or `calibrations` differ between the circuits. For example, in previous releases this would return `True`:

    ```python
    import math

    from qiskit import QuantumCircuit

    qc1 = QuantumCircuit(1)
    qc1.x(0)

    qc2 = QuantumCircuit(1, global_phase=math.pi)
    qc2.x(0)

    print(qc2 == qc1)
    ```

    However, now because the `global_phase` attribute of the circuits differ this will now return `False`.

*   The previously deprecated `qubits()` and `clbits()` methods on the [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class, which were deprecated in the 0.15.0 Terra release, have been removed. Instead you should use the `qubits` and `clbits` attributes of the [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class. For example, if you were running:

    ```python
    from qiskit.dagcircuit import DAGCircuit

    dag = DAGCircuit()
    qubits = dag.qubits()
    ```

    That would be replaced by:

    ```python
    from qiskit.dagcircuit import DAGCircuit

    dag = DAGCircuit()
    qubits = dag.qubits
    ```

*   The [`PulseDefaults`](/api/qiskit/qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") returned by the fake pulse backends `qiskit.test.mock.FakeOpenPulse2Q` and `qiskit.test.mock.FakeOpenPulse3Q` have been updated to have more realistic pulse sequence definitions. If you are using these fake backend classes you may need to update your usage because of these changes.

*   The default synthesis method used by [`decompose_clifford()`](/api/qiskit/quantum_info#qiskit.quantum_info.decompose_clifford "qiskit.quantum_info.decompose_clifford") function in the [`quantum_info`](/api/qiskit/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module (which gets used internally by the [`qiskit.quantum_info.Clifford.to_circuit()`](/api/qiskit/qiskit.quantum_info.Clifford#to_circuit "qiskit.quantum_info.Clifford.to_circuit") method) for more than 3 qubits now uses a non-optimal greedy compilation routine for Clifford elements synthesis, by Bravyi et. al., which typically yields better CX cost compared to the old default. If you need to revert to the previous Aaronson-Gottesman method this can be done by setting `method='AG'`.

*   The previously deprecated module `qiskit.visualization.interactive`, which was deprecated in the 0.15.0 release, has now been removed. Instead you should use the matplotlib based visualizations:

    | Removed Interactive function | Equivalent matplotlib function                                                                                                               |
    | ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
    | `iplot_bloch_multivector`    | [`qiskit.visualization.plot_bloch_multivector()`](/api/qiskit/qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector") |
    | `iplot_state_city`           | [`qiskit.visualization.plot_state_city()`](/api/qiskit/qiskit.visualization.plot_state_city "qiskit.visualization.plot_state_city")                      |
    | `iplot_state_qsphere`        | [`qiskit.visualization.plot_state_qsphere()`](/api/qiskit/qiskit.visualization.plot_state_qsphere "qiskit.visualization.plot_state_qsphere")             |
    | `iplot_state_hinton`         | [`qiskit.visualization.plot_state_hinton()`](/api/qiskit/qiskit.visualization.plot_state_hinton "qiskit.visualization.plot_state_hinton")                |
    | `iplot_histogram`            | [`qiskit.visualization.plot_histogram()`](/api/qiskit/qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram")                         |
    | `iplot_state_paulivec`       | [`qiskit.visualization.plot_state_paulivec()`](/api/qiskit/qiskit.visualization.plot_state_paulivec "qiskit.visualization.plot_state_paulivec")          |

*   The `qiskit.Aer` and `qiskit.IBMQ` top level attributes are now lazy loaded. This means that the objects will now always exist and warnings will no longer be raised on import if `qiskit-aer` or `qiskit-ibmq-provider` are not installed (or can’t be found by Python). If you were checking for the presence of `qiskit-aer` or `qiskit-ibmq-provider` using these module attributes and explicitly comparing to `None` or looking for the absence of the attribute this no longer will work because they are always defined as an object now. In other words running something like:

    ```python
    try:
        from qiskit import Aer
    except ImportError:
        print("Aer not available")

    or::

    try:
        from qiskit import IBMQ
    except ImportError:
        print("IBMQ not available")
    ```

    will no longer work. Instead to determine if those providers are present you can either explicitly use `qiskit.providers.aer.Aer` and `qiskit.providers.ibmq.IBMQ`:

    ```python
    try:
        from qiskit.providers.aer import Aer
    except ImportError:
        print("Aer not available")

    try:
        from qiskit.providers.ibmq import IBMQ
    except ImportError:
        print("IBMQ not available")
    ```

    or check `bool(qiskit.Aer)` and `bool(qiskit.IBMQ)` instead, for example:

    ```python
    import qiskit

    if not qiskit.Aer:
        print("Aer not available")
    if not qiskit.IBMQ:
        print("IBMQ not available")
    ```

    This change was necessary to avoid potential import cycle issues between the qiskit packages and also to improve the import time when Aer or IBMQ are not being used.

*   The user config file option `suppress_packaging_warnings` option in the user config file and the `QISKIT_SUPPRESS_PACKAGING_WARNINGS` environment variable no longer has any effect and will be silently ignored. The warnings this option controlled have been removed and will no longer be emitted at import time from the `qiskit` module.

*   The previously deprecated `condition` kwarg for [`qiskit.dagcircuit.DAGNode`](/api/qiskit/qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") constructor has been removed. It was deprecated in the 0.15.0 release. Instead you should now be setting the classical condition on the [`Instruction`](/api/qiskit/qiskit.circuit.Instruction "qiskit.circuit.Instruction") object passed into the [`DAGNode`](/api/qiskit/qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") constructor when creating a new `op` node.

*   When creating a new [`Register`](/api/qiskit/qiskit.circuit.Register "qiskit.circuit.Register") (which is the parent class for [`QuantumRegister`](/api/qiskit/qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`ClassicalRegister`](/api/qiskit/qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister")) or [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object with a number of bits (eg `QuantumCircuit(2)`), it is now required that number of bits are specified as an integer or another type which is castable to unambiguous integers(e.g. `2.0`). Non-integer values will now raise an error as the intent in those cases was unclear (you can’t have fractional bits). For more information on why this was changed refer to: [#4855](https://github.com/Qiskit/qiskit-terra/issues/4855)

*   [networkx](https://networkx.org/) is no longer a requirement for qiskit-terra. All the networkx usage inside qiskit-terra has been removed with the exception of 3 methods:

    *   `qiskit.dagcircuit.DAGCircuit.to_networkx`
    *   `qiskit.dagcircuit.DAGCircuit.from_networkx`
    *   `qiskit.dagcircuit.DAGDependency.to_networkx`

    If you are using any of these methods you will need to manually install networkx in your environment to continue using them.

*   By default on macOS with Python >=3.8 [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") will no longer run in multiple processes. This is a change from previous releases where the default behavior was that [`parallel_map()`](/api/qiskit/tools#qiskit.tools.parallel_map "qiskit.tools.parallel_map") would launch multiple processes. This change was made because with newer versions of macOS with Python 3.8 and 3.9 multiprocessing is either unreliable or adds significant overhead because of the change in Python 3.8 to launch new processes with `spawn` instead of `fork`. To re-enable parallel execution on macOS with Python >= 3.8 you can use the user config file `parallel` option or set the environment variable `QISKIT_PARALLEL` to `True`.

*   The previously deprecated kwarg `callback` on the constructor for the [`PassManager`](/api/qiskit/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") class has been removed. This kwarg has been deprecated since the 0.13.0 release (April, 9th 2020). Instead you can pass the `callback` kwarg to the [`qiskit.transpiler.PassManager.run()`](/api/qiskit/qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") method directly. For example, if you were using:

    ```python
    from qiskit.circuit.random import random_circuit
    from qiskit.transpiler import PassManager

    qc = random_circuit(2, 2)

    def callback(**kwargs)
      print(kwargs['pass_'])

    pm = PassManager(callback=callback)
    pm.run(qc)
    ```

    this can be replaced with:

    ```python
    from qiskit.circuit.random import random_circuit
    from qiskit.transpiler import PassManager

    qc = random_circuit(2, 2)

    def callback(**kwargs)
      print(kwargs['pass_'])

    pm = PassManager()
    pm.run(qc, callback=callback)
    ```

*   It is now no longer possible to instantiate a base channel without a prefix, such as `qiskit.pulse.Channel` or `qiskit.pulse.PulseChannel`. These classes are designed to classify types of different user facing channel classes, such as `qiskit.pulse.DriveChannel`, but do not have a definition as a target resource. If you were previously directly instantiating either `qiskit.pulse.Channel` or `qiskit.pulse.PulseChannel`, this is no longer allowed. Please use the appropriate subclass.

*   When the `require_cp` and/or `require_tp` kwargs of [`qiskit.quantum_info.process_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity"), [`qiskit.quantum_info.average_gate_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.average_gate_fidelity "qiskit.quantum_info.average_gate_fidelity"), [`qiskit.quantum_info.gate_error()`](/api/qiskit/quantum_info#qiskit.quantum_info.gate_error "qiskit.quantum_info.gate_error") are `True`, they will now only log a warning rather than the previous behavior of raising a [`QiskitError`](/api/qiskit/exceptions#qiskit.exceptions.QiskitError "qiskit.exceptions.QiskitError") exception if the input channel is non-CP or non-TP respectively.

*   The [`QFT`](/api/qiskit/qiskit.circuit.library.QFT "qiskit.circuit.library.QFT") class in the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") module now computes the Fourier transform using a little-endian representation of tensors, i.e. the state $|1\rangle$ maps to $|0\rangle - |1\rangle + |2\rangle - ..$ assuming the computational basis correspond to little-endian bit ordering of the integers. $|0\rangle = |000\rangle, |1\rangle = |001\rangle$, etc. This was done to make it more consistent with the rest of Qiskit, which uses a little-endian convention for bit order. If you were depending on the previous bit order you can use the `reverse_bits()` method to revert to the previous behavior. For example:

    ```python
    from qiskit.circuit.library import QFT

    qft = QFT(5).reverse_bits()
    ```

*   The `qiskit.__qiskit_version__` module attribute was previously a `dict` will now return a custom read-only `Mapping` object that checks the version of qiskit elements at runtime instead of at import time. This was done to speed up the import path of qiskit and eliminate a possible import cycle by only importing the element packages at runtime if the version is needed from the package. This should be fully compatible with the `dict` previously return and for most normal use cases there will be no difference. However, if some applications were relying on either mutating the contents or explicitly type checking it may require updates to adapt to this change.

*   The `qiskit.execute` module has been renamed to [`qiskit.execute_function`](/api/qiskit/execute#module-qiskit.execute_function "qiskit.execute_function"). This was necessary to avoid a potentical name conflict between the [`execute()`](/api/qiskit/execute#qiskit.execute_function.execute "qiskit.execute_function.execute") function which is re-exported as `qiskit.execute`. `qiskit.execute` the function in some situations could conflict with `qiskit.execute` the module which would lead to a cryptic error because Python was treating `qiskit.execute` as the module when the intent was to the function or vice versa. The module rename was necessary to avoid this conflict. If you’re importing `qiskit.execute` to get the module (typical usage was `from qiskit.execute import execute`) you will need to update this to use `qiskit.execute_function` instead. `qiskit.execute` will now always resolve to the function.

*   The `qiskit.compiler.transpile`, `qiskit.compiler.assemble`, `qiskit.compiler.schedule`, and `qiskit.compiler.sequence` modules have been renamed to `qiskit.compiler.transpiler`, `qiskit.compiler.assembler`, `qiskit.compiler.scheduler`, and `qiskit.compiler.sequence` respectively. This was necessary to avoid a potentical name conflict between the modules and the re-exported function paths [`qiskit.compiler.transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), [`qiskit.compiler.assemble()`](/api/qiskit/compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"), [`qiskit.compiler.schedule()`](/api/qiskit/compiler#qiskit.compiler.schedule "qiskit.compiler.schedule"), and [`qiskit.compiler.sequence()`](/api/qiskit/compiler#qiskit.compiler.sequence "qiskit.compiler.sequence"). In some situations this name conflict between the module path and re-exported function path would lead to a cryptic error because Python was treating an import as the module when the intent was to use the function or vice versa. The module rename was necessary to avoid this conflict. If you were using the imports to get the modules before (typical usage would be like\`\`from qiskit.compiler.transpile import transpile\`\`) you will need to update this to use the new module paths. [`qiskit.compiler.transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), [`qiskit.compiler.assemble()`](/api/qiskit/compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"), [`qiskit.compiler.schedule()`](/api/qiskit/compiler#qiskit.compiler.schedule "qiskit.compiler.schedule"), and [`qiskit.compiler.sequence()`](/api/qiskit/compiler#qiskit.compiler.sequence "qiskit.compiler.sequence") will now always resolve to the functions.

*   The [`qiskit.quantum_info.Quaternion`](/api/qiskit/qiskit.quantum_info.Quaternion "qiskit.quantum_info.Quaternion") class was moved from the `qiskit.quantum_info.operator` submodule to the `qiskit.quantum_info.synthesis` submodule to better reflect it’s purpose. No change is required if you were importing it from the root [`qiskit.quantum_info`](/api/qiskit/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module, but if you were importing from `qiskit.quantum_info.operator` you will need to update your import path.

*   Removed the `QuantumCircuit.mcmt` method, which has been deprecated since the Qiskit Terra 0.14.0 release in April 2020. Instead of using the method, please use the [`MCMT`](/api/qiskit/qiskit.circuit.library.MCMT "qiskit.circuit.library.MCMT") class instead to construct a multi-control multi-target gate and use the [`qiskit.circuit.QuantumCircuit.append()`](/api/qiskit/qiskit.circuit.QuantumCircuit#append "qiskit.circuit.QuantumCircuit.append") or [`qiskit.circuit.QuantumCircuit.compose()`](/api/qiskit/qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") to add it to a circuit.

    For example, you can replace:

    ```python
    circuit.mcmt(ZGate(), [0, 1, 2], [3, 4])
    ```

    with:

    ```python
    from qiskit.circuit.library import MCMT
    mcmt = MCMT(ZGate(), 3, 2)
    circuit.compose(mcmt, range(5))
    ```

*   Removed the `QuantumCircuit.diag_gate` method which has been deprecated since the Qiskit Terra 0.14.0 release in April 2020. Instead, use the [`diagonal()`](/api/qiskit/qiskit.circuit.QuantumCircuit#diagonal "qiskit.circuit.QuantumCircuit.diagonal") method of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").

*   Removed the `QuantumCircuit.ucy` method which has been deprecated since the Qiskit Terra 0.14.0 release in April 2020. Instead, use the [`ucry()`](/api/qiskit/qiskit.circuit.QuantumCircuit#ucry "qiskit.circuit.QuantumCircuit.ucry") method of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").

*   The previously deprecated `mirror()` method for [`qiskit.circuit.QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") has been removed. It was deprecated in the 0.15.0 release. The [`qiskit.circuit.QuantumCircuit.reverse_ops()`](/api/qiskit/qiskit.circuit.QuantumCircuit#reverse_ops "qiskit.circuit.QuantumCircuit.reverse_ops") method should be used instead since mirroring could be confused with swapping the output qubits of the circuit. The `reverse_ops()` method only reverses the order of gates that are applied instead of mirroring.

*   The previously deprecated support passing a float (for the `scale` kwarg as the first positional argument to the [`qiskit.circuit.QuantumCircuit.draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") has been removed. It was deprecated in the 0.12.0 release. The first positional argument to the [`qiskit.circuit.QuantumCircuit.draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method is now the `output` kwarg which does not accept a float. Instead you should be using `scale` as a named kwarg instead of using it positionally.

    For example, if you were previously calling `draw` with:

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(2)
    qc.draw(0.75, output='mpl')
    ```

    this would now need to be:

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(2)
    qc.draw(output='mpl', scale=0.75)
    ```

    or:

    ```python
    qc.draw('mpl', scale=0.75)
    ```

*   Features of Qiskit Pulse ([`qiskit.pulse`](/api/qiskit/pulse#module-qiskit.pulse "qiskit.pulse")) which were deprecated in the 0.15.0 release (August, 2020) have been removed. The full set of changes are:

    | Module                 | Old                      | New                                                                                                                 |
    | ---------------------- | ------------------------ | ------------------------------------------------------------------------------------------------------------------- |
    | `qiskit.pulse.library` | `SamplePulse`            | [`Waveform`](/api/qiskit/qiskit.pulse.library.Waveform "qiskit.pulse.library.Waveform")                                         |
    | `qiskit.pulse.library` | `ConstantPulse`          | [`Constant`](/api/qiskit/qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant") |
    | (module rename)        | `pulse.pulse_lib` Module | [`qiskit.pulse.library`](/api/qiskit/pulse#module-qiskit.pulse.library "qiskit.pulse.library")                                  |

    | Class                                                                                                | Old method                           | New method                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
    | ---------------------------------------------------------------------------------------------------- | ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | [`ParametricPulse`](/api/qiskit/qiskit.pulse.library.ParametricPulse "qiskit.pulse.library.ParametricPulse")     | `get_sample_pulse`                   | [`get_waveform`](/api/qiskit/qiskit.pulse.library.ParametricPulse#get_waveform "qiskit.pulse.library.ParametricPulse.get_waveform")                                                                                                                                                                                                                                                                                                                                                   |
    | [`Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction") | `command`                            | N/A. Commands and Instructions have been unified. Use `operands()` to get information about the instruction data.                                                                                                                                                                                                                                                                                                                                                         |
    | [`Acquire`](/api/qiskit/qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire")                   | `acquires`, `mem_slots`, `reg_slots` | [`acquire()`](/api/qiskit/qiskit.pulse.instructions.Acquire#acquire "qiskit.pulse.instructions.Acquire.acquire"), [`mem_slot()`](/api/qiskit/qiskit.pulse.instructions.Acquire#mem_slot "qiskit.pulse.instructions.Acquire.mem_slot"), [`reg_slot()`](/api/qiskit/qiskit.pulse.instructions.Acquire#reg_slot "qiskit.pulse.instructions.Acquire.reg_slot"). (The [`Acquire`](/api/qiskit/qiskit.pulse.instructions.Acquire "qiskit.pulse.instructions.Acquire") instruction no longer broadcasts across multiple qubits.) |

*   The dictionary previously held on [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") edges has been removed. Instead, edges now hold the [`Bit`](/api/qiskit/qiskit.circuit.Bit "qiskit.circuit.Bit") instance which had previously been included in the dictionary as its `'wire'` field. Note that the NetworkX graph returned by `to_networkx()` will still have a dictionary for its edge attributes, but the `'name'` field will no longer be populated.

*   The [`parameters`](/api/qiskit/qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") attribute of the [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class no longer is returning a `set`. Instead it returns a `ParameterView` object which implements all the methods that `set` offers (albeit deprecated). This was done to support a model that preserves name-sorted parameters. It should be fully compatible with any previous usage of the `set` returned by the [`parameters`](/api/qiskit/qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") attribute, except for where explicit type checking of a set was done.

*   When running [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") on a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with [`delay()`](/api/qiskit/qiskit.circuit.QuantumCircuit#delay "qiskit.circuit.QuantumCircuit.delay") instructions, the units will be converted to dt if the value of dt (sample time) is known to [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), either explicitly via the `dt` kwarg or via the [`BackendConfiguration`](/api/qiskit/qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") for a `Backend` object passed in via the `backend` kwarg.

*   The interpretation of `meas_map` (which is an attribute of a [`PulseBackendConfiguration`](/api/qiskit/qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") object or as the corresponding `meas_map` kwarg on the [`schedule()`](/api/qiskit/compiler#qiskit.compiler.schedule "qiskit.compiler.schedule"), [`assemble()`](/api/qiskit/compiler#qiskit.compiler.assemble "qiskit.compiler.assemble"), [`sequence()`](/api/qiskit/compiler#qiskit.compiler.sequence "qiskit.compiler.sequence"), or [`execute()`](/api/qiskit/execute#qiskit.execute_function.execute "qiskit.execute_function.execute") functions) has been updated to better match the true constraints of the hardware. The format of this data is a list of lists, where the items in the inner list are integers specifying qubit labels. For instance:

    ```python
    [[A, B, C], [D, E, F, G]]
    ```

    Previously, the `meas_map` constraint was interpreted such that if one qubit was acquired (e.g. A), then all other qubits sharing a subgroup with that qubit (B and C) would have to be acquired at the same time and for the same duration. This constraint has been relaxed. One acquisition does not require more acquisitions. (If A is acquired, B and C do **not** need to be acquired.) Instead, qubits in the same measurement group cannot be acquired in a partially overlapping way – think of the `meas_map` as specifying a shared acquisition resource (If we acquire A from `t=1000` to `t=2000`, we cannot acquire B starting from `1000<t<2000`). For example:

    ```python
    # Good
    meas_map = [[0, 1]]
    # Acquire a subset of [0, 1]
    sched = pulse.Schedule()
    sched = sched.append(pulse.Acquire(10, acq_q0))

    # Acquire 0 and 1 together (same start time, same duration)
    sched = pulse.Schedule()
    sched = sched.append(pulse.Acquire(10, acq_q0))
    sched = sched.append(pulse.Acquire(10, acq_q1))

    # Acquire 0 and 1 disjointly
    sched = pulse.Schedule()
    sched = sched.append(pulse.Acquire(10, acq_q0))
    sched = sched.append(pulse.Acquire(10, acq_q1)) << 10

    # Acquisitions overlap, but 0 and 1 aren't in the same measurement
    # grouping
    meas_map = [[0], [1]]
    sched = pulse.Schedule()
    sched = sched.append(pulse.Acquire(10, acq_q0))
    sched = sched.append(pulse.Acquire(10, acq_q1)) << 1

    # Bad: 0 and 1 are in the same grouping, but acquisitions
    # partially overlap
    meas_map = [[0, 1]]
    sched = pulse.Schedule()
    sched = sched.append(pulse.Acquire(10, acq_q0))
    sched = sched.append(pulse.Acquire(10, acq_q1)) << 1
    ```

<span id="release-notes-0-17-0-deprecation-notes" />

<span id="id305" />

#### Deprecation Notes

*   Two new arguments have been added to [`qiskit.dagcircuit.DAGNode.semantic_eq()`](/api/qiskit/qiskit.dagcircuit.DAGNode#semantic_eq "qiskit.dagcircuit.DAGNode.semantic_eq"), `bit_indices1` and `bit_indices2`, which are expected to map the [`Bit`](/api/qiskit/qiskit.circuit.Bit "qiskit.circuit.Bit") instances in each [`DAGNode`](/api/qiskit/qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") to their index in `qubits` or `clbits` list of their respective [`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit"). During the deprecation period, these arguments are optional and when **not** specified the mappings will be automatically constructed based on the `register` and `index` properties of each [`Bit`](/api/qiskit/qiskit.circuit.Bit "qiskit.circuit.Bit") instance. However, in a future release, they will be required arguments and the mapping will need to be supplied by the user.

*   The [`pulse`](/api/qiskit/pulse#module-qiskit.pulse "qiskit.pulse") builder functions:

    *   `qiskit.pulse.call_circuit()`
    *   `qiskit.pulse.call_schedule()`

    are deprecated and will be removed in a future release. These functions are unified into `qiskit.pulse.call()` which should be used instead.

*   The [`qiskit.pulse.Schedule`](/api/qiskit/qiskit.pulse.Schedule "qiskit.pulse.Schedule") method `qiskit.pulse.Schedule.flatten()` method is deprecated and will be removed in a future release. Instead you can use the [`qiskit.pulse.transforms.flatten()`](/api/qiskit/pulse#qiskit.pulse.transforms.flatten "qiskit.pulse.transforms.flatten") function which will perform the same operation.

*   The `assign_parameters()` for the following classes:

    > *   [`qiskit.pulse.channels.Channel`](/api/qiskit/pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel"),
    > *   `qiskit.pulse.library.Pulse`,
    > *   [`qiskit.pulse.instructions.Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction"),

    and all their subclasses is now deprecated and will be removed in a future release. This functionality has been subsumed [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") which is the future direction for constructing parameterized pulse programs.

*   The `parameters` attribute for the following clasess:

    > *   [`Channel`](/api/qiskit/pulse#qiskit.pulse.channels.Channel "qiskit.pulse.channels.Channel")
    > *   [`Instruction`](/api/qiskit/pulse#qiskit.pulse.instructions.Instruction "qiskit.pulse.instructions.Instruction").

    is deprecated and will be removed in a future release. This functionality has been subsumed [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") which is the future direction for constructing parameterized pulse programs.

*   Python 3.6 support has been deprecated and will be removed in a future release. When support is removed you will need to upgrade the Python version you’re using to Python 3.7 or above.

*   Two [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods `combine()` and `extend()` along with their corresponding Python operators `+` and `+=` are deprecated and will be removed in a future release. Instead the [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") method [`compose()`](/api/qiskit/qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") should be used. The [`compose()`](/api/qiskit/qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") method allows more flexibility in composing two circuits that do not have matching registers. It does not, however, automatically add qubits/clbits unlike the deprecated methods. To add a circuit on new qubits/clbits, the [`qiskit.circuit.QuantumCircuit.tensor()`](/api/qiskit/qiskit.circuit.QuantumCircuit#tensor "qiskit.circuit.QuantumCircuit.tensor") method can be used. For example:

    ```python
    from qiskit.circuit import QuantumRegister, QuantumCircuit

    a = QuantumRegister(2, 'a')
    circuit_a = QuantumCircuit(a)
    circuit_a.cx(0, 1)

    b = QuantumRegister(2, 'b')
    circuit_b = QuantumCircuit(b)
    circuit_b.cz(0, 1)

    # same as circuit_a + circuit_b (or combine)
    added_with_different_regs = circuit_b.tensor(circuit_a)

    # same as circuit_a + circuit_a (or combine)
    added_with_same_regs = circuit_a.compose(circuit_a)

    # same as circuit_a += circuit_b (or extend)
    circuit_a = circuit_b.tensor(circuit_a)

    # same as circuit_a += circuit_a (or extend)
    circuit_a.compose(circuit_a, inplace=True)
    ```

*   Support for passing [`Qubit`](/api/qiskit/qiskit.circuit.Qubit "qiskit.circuit.Qubit") instances to the `qubits` kwarg of the [`qiskit.transpiler.InstructionDurations.get()`](/api/qiskit/qiskit.transpiler.InstructionDurations#get "qiskit.transpiler.InstructionDurations.get") method has been deprecated and will be removed in a future release. Instead, you should call the [`get()`](/api/qiskit/qiskit.transpiler.InstructionDurations#get "qiskit.transpiler.InstructionDurations.get") method with the integer indices of the desired qubits.

*   Using `@` (`__matmul__`) for invoking the `compose` method of `BaseOperator` subclasses (eg [`Operator`](/api/qiskit/qiskit.quantum_info.Operator "qiskit.quantum_info.Operator")) is deprecated and will be removed in a future release. The [`qiskit.quantum_info.Operator.compose()`](/api/qiskit/qiskit.quantum_info.Operator#compose "qiskit.quantum_info.Operator.compose") method can be used directly or also invoked using the `&` (`__and__`) operator.

*   Using `*` (`__mul__`) for calling the [`dot()`](/api/qiskit/qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot") method of `BaseOperator` subclasses (eg [`qiskit.quantum_info.Operator`](/api/qiskit/qiskit.quantum_info.Operator "qiskit.quantum_info.Operator")) is deprecated and will be removed in a future release. Instead you can just call the [`dot()`](/api/qiskit/qiskit.quantum_info.Operator#dot "qiskit.quantum_info.Operator.dot") directly.

*   Using `@` (`__matmul__`) for invoking the [`evolve()`](/api/qiskit/qiskit.quantum_info.Statevector#evolve "qiskit.quantum_info.Statevector.evolve") method of the [`qiskit.quantum_info.Statevector`](/api/qiskit/qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`qiskit.quantum_info.DensityMatrix`](/api/qiskit/qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") classes is deprecated and will be removed in a future release.. The `evolve` method can be used directly or also invoked using the `&` (`__and__`) operator.

*   The `qiskit.pulse.schedule.ParameterizedSchedule` class has been deprecated and will be removed in a future release. Instead you can directly parameterize pulse [`Schedule`](/api/qiskit/qiskit.pulse.Schedule "qiskit.pulse.Schedule") objects with a [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") object, for example:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.pulse import Schedule
    from qiskit.pulse import ShiftPhase, DriveChannel

    theta = Parameter('theta')
    target_schedule = Schedule()
    target_schedule.insert(0, ShiftPhase(theta, DriveChannel(0)), inplace=True)
    ```

*   The `qiskit.pulse.ScheduleComponent` class in the [`qiskit.pulse`](/api/qiskit/pulse#module-qiskit.pulse "qiskit.pulse") module has been deprecated and will be removed in a future release. Its usage should be replaced either using a [`qiskit.pulse.Schedule`](/api/qiskit/qiskit.pulse.Schedule "qiskit.pulse.Schedule") or `qiskit.pulse.Instruction` directly. Additionally, the primary purpose of the `ScheduleComponent` class was as a common base class for both [`Schedule`](/api/qiskit/qiskit.pulse.Schedule "qiskit.pulse.Schedule") and `Instruction` for any place that was explicitly type checking or documenting accepting a `ScheduleComponent` input should be updated to accept `Instruction` or [`Schedule`](/api/qiskit/qiskit.pulse.Schedule "qiskit.pulse.Schedule").

*   The JSON Schema files and usage for the IBMQ API payloads are deprecated and will be removed in a future release. This includes everything under the `qiskit.schemas` module and the `qiskit.validation` module. This also includes the `validate` kwargs for [`qiskit.qobj.QasmQobj.to_dict()`](/api/qiskit/qiskit.qobj.QasmQobj#to_dict "qiskit.qobj.QasmQobj.to_dict") and [`qiskit.qobj.QasmQobj.to_dict()`](/api/qiskit/qiskit.qobj.QasmQobj#to_dict "qiskit.qobj.QasmQobj.to_dict") along with the module level fastjsonschema validators in [`qiskit.qobj`](/api/qiskit/qobj#module-qiskit.qobj "qiskit.qobj") (which do not raise a deprecation warning). The schema files have been moved to the [Qiskit/ibmq-schemas](https://github.com/Qiskit/ibmq-schemas) repository and those should be treated as the canonical versions of the API schemas. Moving forward only those schemas will recieve updates and will be used as the source of truth for the schemas. If you were relying on the schemas bundled in qiskit-terra you should update to use that repository instead.

*   The `qiskit.util` module has been deprecated and will be removed in a future release. It has been replaced by [`qiskit.utils`](/api/qiskit/utils#module-qiskit.utils "qiskit.utils") which provides the same functionality and will be expanded in the future. Note that no `DeprecationWarning` will be emitted regarding this deprecation since it was not feasible on Python 3.6.

*   The `CXDirection` transpiler pass in the [`qiskit.transpiler.passes`](/api/qiskit/transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module has been deprecated and will be removed in a future release. Instead the `GateDirection` should be used. It behaves identically to the `CXDirection` except that it now also supports transforming a circuit with [`ECRGate`](/api/qiskit/qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate") gates in addition to [`CXGate`](/api/qiskit/qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") gates.

*   The `CheckCXDirection` transpiler pass in the [`qiskit.transpiler.passes`](/api/qiskit/transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") module has been deprecated and will be removed in a future release. Instead the `CheckGateDirection` pass should be used. It behaves identically to the `CheckCXDirection` except that it now also supports checking the direction of all 2-qubit gates, not just [`CXGate`](/api/qiskit/qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") gates.

*   The [`WeightedAdder`](/api/qiskit/qiskit.circuit.library.WeightedAdder "qiskit.circuit.library.WeightedAdder") method `num_ancilla_qubits()` is deprecated and will be removed in a future release. It has been replaced with the [`qiskit.circuit.library.WeightedAdder.num_ancillas`](/api/qiskit/qiskit.circuit.library.WeightedAdder#num_ancillas "qiskit.circuit.library.WeightedAdder.num_ancillas") attribute which is consistent with other circuit libraries’ APIs.

*   The following legacy methods of the [`qiskit.quantum_info.Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") class have been deprecated. See the method documentation for replacement use in the updated Pauli class.

    *   `from_label()`
    *   `sgn_prod()`
    *   `to_spmatrix()`
    *   `kron()`
    *   `update_z()`
    *   `update_x()`
    *   `insert_paulis()`
    *   `append_paulis()`
    *   `delete_qubits()`
    *   `pauli_single()`
    *   `random()`

*   Using a `list` or `numpy.ndarray` as the `channel` or `target` argument for the [`qiskit.quantum_info.process_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity"), [`qiskit.quantum_info.average_gate_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.average_gate_fidelity "qiskit.quantum_info.average_gate_fidelity"), [`qiskit.quantum_info.gate_error()`](/api/qiskit/quantum_info#qiskit.quantum_info.gate_error "qiskit.quantum_info.gate_error"), and [`qiskit.quantum_info.diamond_norm()`](/api/qiskit/quantum_info#qiskit.quantum_info.diamond_norm "qiskit.quantum_info.diamond_norm") functions has been deprecated and will not be supported in a future release. The inputs should instead be a [`Gate`](/api/qiskit/qiskit.circuit.Gate "qiskit.circuit.Gate") or a `BaseOperator` subclass object (eg. [`Operator`](/api/qiskit/qiskit.quantum_info.Operator "qiskit.quantum_info.Operator"), [`Choi`](/api/qiskit/qiskit.quantum_info.Choi "qiskit.quantum_info.Choi"), etc.)

*   Accessing references from [`Qubit`](/api/qiskit/qiskit.circuit.Qubit "qiskit.circuit.Qubit") and [`Clbit`](/api/qiskit/qiskit.circuit.Clbit "qiskit.circuit.Clbit") instances to their containing registers via the [`register`](/api/qiskit/qiskit.circuit.Qubit#register "qiskit.circuit.Qubit.register") or [`index`](/api/qiskit/qiskit.circuit.Qubit#index "qiskit.circuit.Qubit.index") properties has been deprecated and will be removed in a future release. Instead, [`Register`](/api/qiskit/qiskit.circuit.Register "qiskit.circuit.Register") objects can be queried to find the [`Bit`](/api/qiskit/qiskit.circuit.Bit "qiskit.circuit.Bit") objects they contain.

*   The current functionality of the [`qiskit.visualization.pulse_drawer()`](/api/qiskit/qiskit.visualization.pulse_drawer "qiskit.visualization.pulse_drawer") function is deprecated and will be replaced by `qiskit.visualization.pulse_drawer_v2()` (which is not backwards compatible) in a future release.

*   The use of methods inherited from the `set` type on the output of the [`parameters`](/api/qiskit/qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") attribute (which used to be a `set`) of the [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class are deprecated and will be removed in a future release. This includes the methods from the `add()`, `difference()`, `difference_update()`, `discard()`, `intersection()`, `intersection_update()`, `issubset()`, `issuperset()`, `symmetric_difference()`, `symmetric_difference_update()`, `union()`, `update()`, `__isub__()` (which is the `-=` operator), and `__ixor__()` (which is the `^=` operator).

*   The name of the first (and only) positional argument for the [`qiskit.circuit.QuantumCircuit.bind_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") method has changed from `value_dict` to `values`. The passing an argument in with the name `values_dict` is deprecated and will be removed in future release. For example, if you were previously calling [`bind_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") with a call like: `bind_parameters(values_dict={})` this is deprecated and should be replaced by `bind_parameters(values={})` or even better just pass the argument positionally `bind_parameters({})`.

*   The name of the first (and only) positional argument for the [`qiskit.circuit.QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") method has changed from `param_dict` to `parameters`. Passing an argument in with the name `param_dict` is deprecated and will be removed in future release. For example, if you were previously calling [`assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") with a call like: `assign_parameters(param_dict={})` this is deprecated and should be replaced by `assign_parameters(values={})` or even better just pass the argument positionally `assign_parameters({})`.

<span id="release-notes-0-17-0-bug-fixes" />

<span id="id306" />

#### Bug Fixes

*   Fixed an issue where the [`execute()`](/api/qiskit/execute#qiskit.execute_function.execute "qiskit.execute_function.execute") function would raise [`QiskitError`](/api/qiskit/exceptions#qiskit.exceptions.QiskitError "qiskit.exceptions.QiskitError") exception when a [`ParameterVector`](/api/qiskit/qiskit.circuit.ParameterVector "qiskit.circuit.ParameterVector") object was passed in for the `parameter_bind` kwarg. parameter. For example, it is now possible to call something like:

    ```python
    execute(circuit, backend, parameter_binds=[{pv1: [...], pv2: [...]}])
    ```

    where `pv1` and `pv2` are [`ParameterVector`](/api/qiskit/qiskit.circuit.ParameterVector "qiskit.circuit.ParameterVector") objects. Fixed [#5467](https://github.com/Qiskit/qiskit-terra/issues/5467)

*   Fixed an issue with the labels of parametric pulses in the [`PulseQobjInstruction`](/api/qiskit/qiskit.qobj.PulseQobjInstruction "qiskit.qobj.PulseQobjInstruction") class were not being properly set as they are with sampled pulses. This also means that pulse names that are imported from the [`PulseDefaults`](/api/qiskit/qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") returned by a [`Backend`](/api/qiskit/qiskit.providers.Backend "qiskit.providers.Backend"), such as `x90`, `x90m`, etc, will properly be set. Fixed [#5363](https://github.com/Qiskit/qiskit-terra/issues/5363)

*   Fixed an issue where unbound parameters only occurring in the [`global_phase`](/api/qiskit/qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") attribute of a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object would not show in the [`parameters`](/api/qiskit/qiskit.circuit.QuantumCircuit#parameters "qiskit.circuit.QuantumCircuit.parameters") attribute and could not be bound. Fixed [#5806](https://github.com/Qiskit/qiskit-terra/issues/5806)

*   The [`calibrations`](/api/qiskit/qiskit.circuit.QuantumCircuit#calibrations "qiskit.circuit.QuantumCircuit.calibrations") attribute of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects are now preserved when the `+=` (ie the `extend()` method) and the `+` (ie the `combine()` method) are used. Fixed [#5930](https://github.com/Qiskit/qiskit-terra/pull/5930) and [#5908](https://github.com/Qiskit/qiskit-terra/issues/5908)

*   The [`name`](/api/qiskit/qiskit.circuit.Register#name "qiskit.circuit.Register.name") setter method of class [`Register`](/api/qiskit/qiskit.circuit.Register "qiskit.circuit.Register") (which is the parent class of [`QuantumRegister`](/api/qiskit/qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`ClassicalRegister`](/api/qiskit/qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister")) previously did not check if the assigned string was a valid register name as per the [OpenQASM specification](https://arxiv.org/pdf/1707.03429v2.pdf). This check was previously only performed when the name was specified in the constructor, this has now been fixed so that setting the `name` attribute directly with an invalid value will now also raise an exception. Fixed [#5461](https://github.com/Qiskit/qiskit-terra/issues/5461)

*   Fixed an issue with the [`qiskit.visualization.circuit_drawer()`](/api/qiskit/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`qiskit.circuit.QuantumCircuit.draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method when visualizing a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with a [`Gate`](/api/qiskit/qiskit.circuit.Gate "qiskit.circuit.Gate") that has a classical condition after a `Measure` that used the same [`ClassicalRegister`](/api/qiskit/qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister"), it was possible for the conditional [`Gate`](/api/qiskit/qiskit.circuit.Gate "qiskit.circuit.Gate") to be displayed to the left of the `Measure`. Fixed [#5387](https://github.com/Qiskit/qiskit-terra/issues/5387)

*   In the transpiler pass [`qiskit.transpiler.passes.CSPLayout`](/api/qiskit/qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") a bias towards lower numbered qubits could be observed. This undesireable bias has been fixed by shuffling the candidates to randomize the results. Furthermore, the usage of the [`CSPLayout`](/api/qiskit/qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") pass in the [`preset_passmanagers`](/api/qiskit/transpiler_preset#module-qiskit.transpiler.preset_passmanagers "qiskit.transpiler.preset_passmanagers") (for level 2 and 3) has been adjusted to use a configured seed if the `seed_transpiler` kwarg is set when [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") is called. Fixed [#5990](https://github.com/Qiskit/qiskit-terra/issues/5990)

*   Fixes a bug where the `channels` field for a [`PulseBackendConfiguration`](/api/qiskit/qiskit.providers.models.PulseBackendConfiguration "qiskit.providers.models.PulseBackendConfiguration") object was not being included in the output of the [`qiskit.providers.models.PulseBackendConfiguration.to_dict`](/api/qiskit/qiskit.providers.models.PulseBackendConfiguration#to_dict "qiskit.providers.models.PulseBackendConfiguration.to_dict") method. Fixed [#5579](https://github.com/Qiskit/qiskit-terra/issues/5579)

*   Fixed the `'circular'` entanglement in the [`qiskit.circuit.library.NLocal`](/api/qiskit/qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") circuit class for the edge case where the circuit has the same size as the entanglement block (e.g. a two-qubit circuit and CZ entanglement gates). In this case there should only be one entanglement gate, but there was accidentially added a second one in the inverse direction as the first. Fixed [Qiskit/qiskit-aqua#1452](https://github.com/Qiskit/qiskit-aqua/issues/1452)

*   Fixed the handling of breakpoints in the [`PiecewisePolynomialPauliRotations`](/api/qiskit/qiskit.circuit.library.PiecewisePolynomialPauliRotations "qiskit.circuit.library.PiecewisePolynomialPauliRotations") class in the [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library"). Now for `n` intervals, `n+1` breakpoints are allowed. This enables specifying another end interval other than $2^\text{num qubits}$. This is important because from the end of the last interval to $2^\text{num qubits}$ the function is the identity.

*   Fixed an issue in the [`qiskit.circuit.library.Permutation`](/api/qiskit/qiskit.circuit.library.Permutation "qiskit.circuit.library.Permutation") circuit class where some permutations would not be properly generated. This issue could also effect [`qiskit.circuit.library.QuantumVolume`](/api/qiskit/qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") if it were called with classical\_permutation=False\`. Fixed [#5812](https://github.com/Qiskit/qiskit-terra/issues/5812)

*   Fixed an issue where generating QASM output with the [`qasm()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") method for a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object that has a [`ControlledGate`](/api/qiskit/qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") with an open control the output would be as if all controls were closed independent of the specified control state. This would result in a different circuit being created from [`from_qasm_str()`](/api/qiskit/qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") if parsing the generated QASM.

    This was fixed by updating the QASM output from [`qasm()`](/api/qiskit/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") by defining a composite gate which uses `XGate` to implement the open controls. The composite gate is named like `<original_gate_name>_o<ctrl_state>` where `o` stands for open control and `ctrl_state` is the integer value of the control state. Fixed [#5443](https://github.com/Qiskit/qiskit-terra/issues/5443)

*   Fixed an issue where binding [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects in a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with the `parameter_binds` in the [`execute`](/api/qiskit/execute#qiskit.execute_function.execute "qiskit.execute_function.execute") function would cause all the bound [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects would have the same `name`, which meant the result names were also not unique. This fix causes the [`bind_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#bind_parameters "qiskit.circuit.QuantumCircuit.bind_parameters") and [`assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") to assign a unique circuit name when `inplace=False` as:

    ```python
    <base name>-<class instance no.>[-<pid name>]
    ```

    where `<base name>` is the name supplied by the “name” kwarg, otherwise it defaults to “circuit”. The class instance number gets incremented every time an instance of the class is generated. `<pid name>` is appended if called outside the main process. Fixed [#5185](https://github.com/Qiskit/qiskit-terra/issues/5185)

*   Fixed an issue with the `scheduler()` function where it would raise an exception if an input circuit contained an unbound [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object. Fixed [#5304](https://github.com/Qiskit/qiskit-terra/issues/5304)

*   Fixed an issue in the [`qiskit.transpiler.passes.TemplateOptimization`](/api/qiskit/qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") transpiler passes where template circuits that contained unbound [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects would crash under some scenarios if the parameters could not be bound during the template matching. Now, if the [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects can not be bound templates with unbound [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") are discarded and ignored by the [`TemplateOptimization`](/api/qiskit/qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") pass. Fixed [#5533](https://github.com/Qiskit/qiskit-terra/issues/5533)

*   Fixed an issue with the [`qiskit.visualization.timeline_drawer()`](/api/qiskit/qiskit.visualization.timeline_drawer "qiskit.visualization.timeline_drawer") function where classical bits were inproperly handled. Fixed [#5361](https://github.com/Qiskit/qiskit-terra/issues/5361)

*   Fixed an issue in the [`qiskit.visualization.circuit_drawer()`](/api/qiskit/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`qiskit.circuit.QuantumCircuit.draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method where [`Delay`](/api/qiskit/qiskit.circuit.Delay "qiskit.circuit.Delay") instructions in a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object were not being correctly treated as idle time. So when the `idle_wires` kwarg was set to `False` the wires with the [`Delay`](/api/qiskit/qiskit.circuit.Delay "qiskit.circuit.Delay") objects would still be shown. This has been fixed so that the idle wires are removed from the visualization if there are only [`Delay`](/api/qiskit/qiskit.circuit.Delay "qiskit.circuit.Delay") objects on a wire.

*   Previously, when the option `layout_method` kwarg was provided to the [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function and the `optimization_level` kwarg was set to >= 2 so that the pass [`qiskit.transpiler.passes.CSPLayout`](/api/qiskit/qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") would run, if [`CSPLayout`](/api/qiskit/qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") found a solution then the method in `layout_method` was not executed. This has been fixed so that if specified, the `layout_method` is always honored. Fixed [#5409](https://github.com/Qiskit/qiskit-terra/issues/5409)

*   When the argument `coupling_map=None` (either set explicitly, set implicitly as the default value, or via the `backend` kwarg), the transpiling process was not “embedding” the circuit. That is, even when an `initial_layout` was specified, the virtual qubits were not assigned to physical qubits. This has been fixed so that now, the [`qiskit.compiler.transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function honors the `initial_layout` argument by embedding the circuit:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister
    from qiskit.compiler import transpile

    qr = QuantumRegister(2, name='qr')
    circ = QuantumCircuit(qr)
    circ.h(qr[0])
    circ.cx(qr[0], qr[1])

    transpile(circ, initial_layout=[1, 0]).draw(output='mpl')
    ```

    If the `initial_layout` refers to more qubits than in the circuit, the transpiling process will extended the circuit with ancillas.

    ```python
    from qiskit import QuantumCircuit, QuantumRegister
    from qiskit.compiler import transpile

    qr = QuantumRegister(2, name='qr')
    circ = QuantumCircuit(qr)
    circ.h(qr[0])
    circ.cx(qr[0], qr[1])

    transpile(circ, initial_layout=[4, 2], coupling_map=None).draw()
    ```

    Fixed [#5345](https://github.com/Qiskit/qiskit-terra/issues/5345)

*   A new kwarg, `user_cost_dict` has been added to the constructor for the [`qiskit.transpiler.passes.TemplateOptimization`](/api/qiskit/qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") transpiler pass. This enables users to provide a custom cost dictionary for the gates to the underlying template matching algorithm. For example:

    ```python
    from qiskit.transpiler.passes import TemplateOptimization

    cost_dict = {'id': 0, 'x': 1, 'y': 1, 'z': 1, 'h': 1, 't': 1}
    pass = TemplateOptimization(user_cost_dict=cost_dict)
    ```

*   An issue when passing the [`Counts`](/api/qiskit/qiskit.result.Counts "qiskit.result.Counts") object returned by [`get_counts()`](/api/qiskit/qiskit.result.Result#get_counts "qiskit.result.Result.get_counts") to [`marginal_counts()`](/api/qiskit/result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") would produce an improperly formatted [`Counts`](/api/qiskit/qiskit.result.Counts "qiskit.result.Counts") object with certain inputs has been fixed. Fixes [#5424](https://github.com/Qiskit/qiskit-terra/issues/5424)

*   Improved the allocation of helper qubits in [`PolynomialPauliRotations`](/api/qiskit/qiskit.circuit.library.PolynomialPauliRotations "qiskit.circuit.library.PolynomialPauliRotations") and [`PiecewiseLinearPauliRotations`](/api/qiskit/qiskit.circuit.library.PiecewiseLinearPauliRotations "qiskit.circuit.library.PiecewiseLinearPauliRotations") which makes the implementation of these circuit more efficient. Fixed [#5320](https://github.com/Qiskit/qiskit-terra/issues/5320) and [#5322](https://github.com/Qiskit/qiskit-terra/issues/5322)

*   Fix the usage of the allocated helper qubits in the [`MCXGate`](/api/qiskit/qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate") in the [`WeightedAdder`](/api/qiskit/qiskit.circuit.library.WeightedAdder "qiskit.circuit.library.WeightedAdder") class. These were previously allocated but not used prior to this fix. Fixed [#5321](https://github.com/Qiskit/qiskit-terra/issues/5321)

*   In a number of cases, the `latex` output method for the [`qiskit.visualization.circuit_drawer()`](/api/qiskit/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method did not display the gate name correctly, and in other cases, did not include gate parameters where they should be. Now the gate names will be displayed the same way as they are displayed with the `mpl` output method, and parameters will display for all the gates that have them. In addition, some of the gates did not display in the correct form, and these have been fixed. Fixes [#5605](https://github.com/Qiskit/qiskit-terra/issues/5605), [#4938](https://github.com/Qiskit/qiskit-terra/issues/4938), and [#3765](https://github.com/Qiskit/qiskit-terra/issues/3765)

*   Fixed an issue where, if the `qiskit.circuit.Instruction.to_instruction()` method was used on a subcircuit which contained classical registers and that [`Instruction`](/api/qiskit/qiskit.circuit.Instruction "qiskit.circuit.Instruction") object was then added to a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object, then the output from the [`qiskit.visualization.circuit_drawer()`](/api/qiskit/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and the [`qiskit.circuit.QuantumCircuit.draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method would in some instances display the subcircuit to the left of a measure when it should have been displayed to the right. Fixed [#5947](https://github.com/Qiskit/qiskit-terra/issues/5947)

*   Fixed an issue with [`Delay`](/api/qiskit/qiskit.circuit.Delay "qiskit.circuit.Delay") objects in a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") where [`qiskit.compiler.transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") would not be convert the units of the [`Delay`](/api/qiskit/qiskit.circuit.Delay "qiskit.circuit.Delay") to the units of the [`Backend`](/api/qiskit/qiskit.providers.Backend "qiskit.providers.Backend"), if the `backend` kwarg is set on `transpile()`. This could result in the wrong behavior because of a unit mismatch, for example running:

    ```python
    from qiskit import transpile, execute
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(1)
    qc.delay(100, [0], unit='us')

    qc = transpile(qc, backend)
    job = execute(qc, backend)
    ```

    would previously have resulted in the backend delay for 100 timesteps (each of duration dt) rather than expected (100e-6 / dt) timesteps. This has been corrected so the [`qiskit.compiler.transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function properly converts the units.

<span id="release-notes-0-17-0-other-notes" />

<span id="id307" />

#### Other Notes

*   The snapshots of all the fake/mock backends in `qiskit.test.mock` have been updated to reflect recent device changes. This includes a change in the [`basis_gates`](/api/qiskit/qiskit.providers.models.QasmBackendConfiguration#basis_gates "qiskit.providers.models.QasmBackendConfiguration.basis_gates") attribute for the [`BackendConfiguration`](/api/qiskit/qiskit.providers.models.BackendConfiguration "qiskit.providers.models.BackendConfiguration") to `['cx', 'rz', 'sx', 'x', 'id']`, the addition of a `readout_length` property to the qubit properties in the [`BackendProperties`](/api/qiskit/qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties"), and updating the [`PulseDefaults`](/api/qiskit/qiskit.providers.models.PulseDefaults "qiskit.providers.models.PulseDefaults") so that all the mock backends support parametric pulse based [`InstructionScheduleMap`](/api/qiskit/qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") instances.

<span id="aer-0-8-0" />

<span id="aer-release-notes-0-8-0" />

### Aer 0.8.0

<span id="aer-release-notes-0-8-0-prelude" />

<span id="id308" />

#### Prelude

The 0.8 release includes several new features and bug fixes. The highlights for this release are: the introduction of a unified `AerSimulator` backend for running circuit simulations using any of the supported simulation methods; a simulator instruction library (`qiskit.providers.aer.library`) which includes custom instructions for saving various kinds of simulator data; MPI support for running large simulations on a distributed computing environment.

<span id="aer-release-notes-0-8-0-new-features" />

<span id="id309" />

#### New Features

*   Python 3.9 support has been added in this release. You can now run Qiskit Aer using Python 3.9 without building from source.

*   Add the CMake flag `DISABLE_CONAN` (default=\`\`OFF\`\`)s. When installing from source, setting this to `ON` allows bypassing the Conan package manager to find libraries that are already installed on your system. This is also available as an environment variable `DISABLE_CONAN`, which takes precedence over the CMake flag. This is not the official procedure to build AER. Thus, the user is responsible of providing all needed libraries and corresponding files to make them findable to CMake.

*   This release includes support for building qiskit-aer with MPI support to run large simulations on a distributed computing environment. See the [contributing guide](https://github.com/Qiskit/qiskit-aer/blob/master/CONTRIBUTING.md#building-with-mpi-support) for instructions on building and running in an MPI environment.

*   It is now possible to build qiskit-aer with CUDA enabled in Windows. See the [contributing guide](https://github.com/Qiskit/qiskit-aer/blob/master/CONTRIBUTING.md#building-with-gpu-support) for instructions on building from source with GPU support.

*   When building the qiskit-aer Python extension from source several build dependencies need to be pre-installed to enable C++ compilation. As a user convenience when building the extension any of these build dependencies which were missing would be automatically installed using `pip` prior to the normal `setuptools` installation steps, however it was previously was not possible to avoid this automatic installation. To solve this issue a new environment variable `DISABLE_DEPENDENCY_INSTALL` has been added. If it is set to `1` or `ON` when building the python extension from source this will disable the automatic installation of these missing build dependencies.

*   Adds support for optimized N-qubit Pauli gate ( [`qiskit.circuit.library.PauliGate`](/api/qiskit/qiskit.circuit.library.PauliGate "qiskit.circuit.library.PauliGate")) to the `StatevectorSimulator`, `UnitarySimulator`, and the statevector and density matrix methods of the `QasmSimulator` and `AerSimulator`.

*   The `run()` method for the `AerSimulator`, `QasmSimulator`, `StatevectorSimulator`, and `UnitarySimulator` backends now takes a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") (or a list of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects) as it’s input. The previous [`QasmQobj`](/api/qiskit/qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") object is still supported for now, but will be deprecated in a future release.

    For an example of how to use this see:

    ```python
    from qiskit import transpile, QuantumCircuit

    from qiskit.providers.aer import Aer

    backend = Aer.get_backend('aer_simulator')

    circuit = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    tqc = transpile(circuit, backend)
    result = backend.run(tqc, shots=4096).result()
    ```

*   The `run()` method for the `PulseSimulator` backend now takes a [`Schedule`](/api/qiskit/qiskit.pulse.Schedule "qiskit.pulse.Schedule") (or a list of [`Schedule`](/api/qiskit/qiskit.pulse.Schedule "qiskit.pulse.Schedule") objects) as it’s input. The previous [`PulseQobj`](/api/qiskit/qiskit.qobj.PulseQobj "qiskit.qobj.PulseQobj") object is still supported for now, but will be deprecated in a future release.

*   Adds the new `AerSimulator` simulator backend supporting the following simulation methods

    > *   `automatic`
    > *   `statevector`
    > *   `stabilizer`
    > *   `density_matrix`
    > *   `matrix_product_state`
    > *   `unitary`
    > *   `superop`

    The default automatic method will automatically choose a simulation method separately for each run circuit based on the circuit instructions and noise model (if any). Initializing a simulator with a specific method can be done using the method option.

    GPU simulation for the statevector, density matrix and unitary methods can be enabled by setting the `device='GPU'` backend option.

    Note that the `unitary` and `superop` methods do not support measurement as they simulate the unitary matrix or superoperator matrix of the run circuit so one of the new `save_unitary()`, `save_superop()`, or `save_state()` instructions must be used to save the simulator state to the returned results. Similarly state of the other simulations methods can be saved using the appropriate instructions. See the `qiskit.providers.aer.library` API documents for more details.

    Note that the `AerSimulator` simulator superceds the `QasmSimulator`, `StatevectorSimulator`, and `UnitarySimulator` backends which will be deprecated in a future release.

*   Updates the `AerProvider` class to include multiple `AerSimulator` backends preconfigured for all available simulation methods and simulation devices. The new backends can be accessed through the provider interface using the names

    > *   `"aer_simulator"`
    > *   `"aer_simulator_statevector"`
    > *   `"aer_simulator_stabilizer"`
    > *   `"aer_simulator_density_matrix"`
    > *   `"aer_simulator_matrix_product_state"`
    > *   `"aer_simulator_extended_stabilizer"`
    > *   `"aer_simulator_unitary"`
    > *   `"aer_simulator_superop"`

    Additional if Aer was installed with GPU support on a compatible system the following GPU backends will also be available

    > *   `"aer_simulator_statevector_gpu"`
    > *   `"aer_simulator_density_matrix_gpu"`
    > *   `"aer_simulator_unitary_gpu"`

    For example:

    ```python
    from qiskit import Aer

    # Get the GPU statevector simulator backend
    backend = Aer.get_backend('aer_simulator_statevector_gpu')
    ```

*   Added a new `norm estimation` method for performing measurements when using the `"extended_stabilizer"` simulation method. This norm estimation method can be used by passing the following options to the `AerSimulator` and `QasmSimulator` backends

    ```python
    simulator = QasmSimulator(
        method='extended_stabilizer',
        extended_stabilizer_sampling_method='norm_estimation')
    ```

    The norm estimation method is slower than the alternative `metropolis` or `resampled_metropolis` options, but gives better performance on circuits with sparse output distributions. See the documentation of the `QasmSimulator` for more information.

*   Adds instructions for saving the state of the simulator in various formats. These instructions are

    *   `qiskit.providers.aer.library.SaveDensityMatrix`
    *   `qiskit.providers.aer.library.SaveMatrixProductState`
    *   `qiskit.providers.aer.library.SaveStabilizer`
    *   `qiskit.providers.aer.library.SaveState`
    *   `qiskit.providers.aer.library.SaveStatevector`
    *   `qiskit.providers.aer.library.SaveStatevectorDict`
    *   `qiskit.providers.aer.library.SaveUnitary`

    These instructions can be appended to a quantum circuit by using the `save_density_matrix`, `save_matrix_product_state`, `save_stabilizer`, `save_state`, `save_statevector`, `save_statevector_dict`, `save_unitary` circuit methods which are added to `QuantumCircuit` when importing Aer.

    See the `qiskit.providers.aer.library` API documentation for details on method compatibility for each instruction.

    Note that the snapshot instructions `SnapshotStatevector`, `SnapshotDensityMatrix`, `SnapshotStabilizer` are still supported but will be deprecated in a future release.

*   Adds `qiskit.providers.aer.library.SaveExpectationValue` and `qiskit.providers.aer.library.SaveExpectationValueVariance` quantum circuit instructions for saving the expectation value $\langle H\rangle = Tr[H\rho]$, or expectation value and variance $Var(H) = \langle H^2\rangle - \langle H\rangle^2$, of a Hermitian operator $H$ for the simulator state $\rho$. These instruction can be appended to a quantum circuit by using the `save_expectation_value` and `save_expectation_value_variance` circuit methods which is added to `QuantumCircuit` when importing Aer.

    Note that the snapshot instruction `SnapshotExpectationValue`, is still supported but will be deprecated in a future release.

*   Adds `qiskit.providers.aer.library.SaveProbabilities` and `qiskit.providers.aer.library.SaveProbabilitiesDict` quantum circuit instruction for saving all measurement outcome probabilities for Z-basis measurements of the simualtor state. These instruction can be appended to a quantum circuit by using the `save_probabilities` and `save_probabilities_dict` circuit methods which is added to `QuantumCircuit` when importing Aer.

    Note that the snapshot instruction `SnapshotProbabilities`, is still supported but will be deprecated in a future release.

*   Adds `qiskit.providers.aer.library.SaveAmplitudes` and `qiskit.providers.aer.library.SaveAmplitudesSquared` circuit instructions for saving select complex statevector amplitudes, or select probabilities (amplitudes squared) for supported simulation methods. These instructions can be appended to a quantum circuit by using the `save_amplitudes` and `save_amplitudes_squared` circuit methods which is added to `QuantumCircuit` when importing Aer.

*   Adds instructions for setting the state of the simulators. These instructions must be defined on the full number of qubits in the circuit. They can be applied at any point in a circuit and will override the simulator state with the one specified. Added instructions are

    *   `qiskit.providers.aer.library.SetDensityMatrix`
    *   `qiskit.providers.aer.library.SetStabilizer`
    *   `qiskit.providers.aer.library.SetStatevector`
    *   `qiskit.providers.aer.library.SetUnitary`

    These instruction can be appended to a quantum circuit by using the `set_density_matrix`, `set_stabilizer`, `set_statevector`, `set_unitary` circuit methods which are added to `QuantumCircuit` when importing Aer.

    See the `qiskit.providers.aer.library` API documentation for details on method compatibility for each instruction.

*   Added support for diagonal gates to the `"matrix_product_state"` simulation method.

*   Added support for the `initialize` instruction to the `"matrix_product_state"` simulation method.

<span id="aer-release-notes-0-8-0-known-issues" />

<span id="id310" />

#### Known Issues

*   There is a known issue where the simulation of certain circuits with a Kraus noise model using the `"matrix_product_state"` simulation method can cause the simulator to crash. Refer to [#306](https://github.com/Qiskit/qiskit-aer/issues/1184) for more information.

<span id="aer-release-notes-0-8-0-upgrade-notes" />

<span id="id311" />

#### Upgrade Notes

*   The minimum version of [Conan](https://conan.io/) has been increased to 1.31.2. This was necessary to fix a compatibility issue with newer versions of the [urllib3](https://pypi.org/project/urllib3/) (which is a dependency of Conan). It also adds native support for AppleClang 12 which is useful for users with new Apple computers.

*   `pybind11` minimum version required is 2.6 instead of 2.4. This is needed in order to support CUDA enabled compilation in Windows.

*   Cython has been removed as a build dependency.

*   Removed x90 gate decomposition from noise models that was deprecated in qiskit-aer 0.7. This decomposition is now done by using regular noise model basis gates and the qiskit transpiler.

*   The following options for the `"extended_stabilizer"` simulation method have changed.

    > *   `extended_stabilizer_measure_sampling`: This option has been replaced by the options `extended_stabilizer_sampling_method`, which controls how we simulate qubit measurement.
    > *   `extended_stabilizer_mixing_time`: This option has been renamed as `extended_stabilizer_metropolis_mixing_time` to clarify it only applies to the `metropolis` and `resampled_metropolis` sampling methods.
    > *   `extended_stabilizer_norm_estimation_samples`: This option has been renamed to `extended_stabilizer_norm_estimation_default_samples`.

    One additional option, `extended_stabilizer_norm_estimation_repetitions` has been added, whih controls part of the behaviour of the norm estimation sampling method.

<span id="aer-release-notes-0-8-0-deprecation-notes" />

<span id="id312" />

#### Deprecation Notes

*   Python 3.6 support has been deprecated and will be removed in a future release. When support is removed you will need to upgrade the Python version you’re using to Python 3.7 or above.

<span id="aer-release-notes-0-8-0-bug-fixes" />

<span id="id313" />

#### Bug Fixes

*   Fixes bug with `AerProvider` where options set on the returned backends using `set_options()` were stored in the provider and would persist for subsequent calls to `get_backend()` for the same named backend. Now every call to and `backends()` returns a new instance of the simulator backend that can be configured.
*   Fixes bug in the error message returned when a circuit contains unsupported simulator instructions. Previously some supported instructions were also being listed in the error message along with the unsupported instructions.
*   Fixes issue with setting `QasmSimulator` basis gates when using `"method"` and `"noise_model"` options together, and when using them with a simulator constructed using `from_backend()`. Now the listed basis gates will be the intersection of gates supported by the backend configuration, simulation method, and noise model basis gates. If the intersection of the noise model basis gates and simulator basis gates is empty a warning will be logged.
*   Fix bug where the `` "sx"` `` gate [`SXGate`](/api/qiskit/qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate") was not listed as a supported gate in the C++ code, in `StateOpSet` of `matrix_product_state.hp`.
*   Fix bug where `"csx"`, `"cu2"`, `"cu3"` were incorrectly listed as supported basis gates for the `"density_matrix"` method of the `QasmSimulator`.
*   Fix bug where parameters were passed incorrectly between functions in `matrix_product_state_internal.cpp`, causing wrong simulation, as well as reaching invalid states, which in turn caused an infinite loop.
*   Fixes a bug that resulted in `c_if` not working when the width of the conditional register was greater than 64. See [#1077](https://github.com/Qiskit/qiskit-aer/issues/1077).
*   Fixes a bug [#1153](https://github.com/Qiskit/qiskit-aer/issues/1153)) where noise on conditional gates was always being applied regardless of whether the conditional gate was actually applied based on the classical register value. Now noise on a conditional gate will only be applied in the case where the conditional gate is applied.
*   Fixes a bug with nested OpenMP flag was being set to true when it shouldn’t be.
*   Fixes a bug when applying truncation in the matrix product state method of the QasmSimulator.
*   Fixed issue [#1126](https://github.com/Qiskit/qiskit-aer/issues/1126): bug in reporting measurement of a single qubit. The bug occured when copying the measured value to the output data structure.
*   In MPS, apply\_kraus was operating directly on the input bits in the parameter qubits, instead of on the internal qubits. In the MPS algorithm, the qubits are constantly moving around so all operations should be applied to the internal qubits.
*   When invoking MPS::sample\_measure, we need to first sort the qubits to the default ordering because this is the assumption in qasm\_controller.This is done by invoking the method move\_all\_qubits\_to\_sorted\_ordering. It was correct in sample\_measure\_using\_apply\_measure, but missing in sample\_measure\_using\_probabilities.
*   Fixes bug with the `from_backend()` method of the `QasmSimulator` that would set the `local` attribute of the configuration to the backend value rather than always being set to `True`.
*   Fixes bug in `from_backend()` and `from_backend()` where `basis_gates` was set incorrectly for IBMQ devices with basis gate set `['id', 'rz', 'sx', 'x', 'cx']`. Now the noise model will always have the same basis gates as the backend basis gates regardless of whether those instructions have errors in the noise model or not.
*   Fixes an issue where the Extended “extended\_stabilizer” simulation method would give incorrect results on quantum circuits with sparse output distributions. Refer to [#306](https://github.com/Qiskit/qiskit-aer/issues/306) for more information and examples.

<span id="id314" />

### Ignis 0.6.0

<span id="ignis-release-notes-0-6-0-new-features" />

<span id="id315" />

#### New Features

*   The `qiskit.ignis.mitigation.expval_meas_mitigator_circuits()` function has been improved so that the number of circuits generated by the function used for calibration by the CTMP method are reduced from $O(n)$ to $O(\log{n})$ (where $n$ is the number of qubits).

<span id="ignis-release-notes-0-6-0-upgrade-notes" />

<span id="id316" />

#### Upgrade Notes

*   The `qiskit.ignis.verification.randomized_benchmarking_seq()` function is now using the upgraded CNOTDihedral class, `qiskit.ignis.verification.CNOTDihedral`, which enables performing CNOT-Dihedral Randomized Benchmarking on more than two qubits.
*   The python package `retworkx` is now a requirement for installing qiskit-ignis. It replaces the previous usage of `networkx` (which is no longer a requirement) to get better performance.
*   The `scikit-learn` dependency is no longer required and is now an optional requirement. If you’re using the IQ measurement discriminators (`IQDiscriminationFitter`, `LinearIQDiscriminationFitter`, `QuadraticIQDiscriminationFitter`, or `SklearnIQDiscriminator`) you will now need to manually install scikit-learn, either by running `pip install scikit-learn` or when you’re also installing qiskit-ignis with `pip install qiskit-ignis[iq]`.

<span id="ignis-release-notes-0-6-0-bug-fixes" />

<span id="id317" />

#### Bug Fixes

*   Fixed an issue in the expectation value method `expectation_value()`, for the error mitigation classes `TensoredExpvalMeasMitigator` and `CTMPExpvalMeasMitigator` if the `qubits` kwarg was not specified it would incorrectly use the total number of qubits of the mitigator, rather than the number of classical bits in the count dictionary leading to greatly reduced performance. Fixed [#561](https://github.com/Qiskit/qiskit-ignis/issues/561)
*   Fix the `"auto"` method of the `TomographyFitter`, `StateTomographyFitter`, and `ProcessTomographyFitter` to only use `"cvx"` if CVXPY is installed *and* a third-party SDP solver other than SCS is available. This is because the SCS solver has lower accuracy than other solver methods and often returns a density matrix or Choi-matrix that is not completely-positive and fails validation when used with the [`qiskit.quantum_info.state_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.state_fidelity "qiskit.quantum_info.state_fidelity") or [`qiskit.quantum_info.process_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity") functions.

<span id="aqua-0-9-0" />

### Aqua 0.9.0

This release officially deprecates the Qiskit Aqua project, in the future (no sooner than 3 months from this release) the Aqua project will have it’s final release and be archived. All the functionality that qiskit-aqua provides has been migrated to either new packages or to other qiskit packages. The application modules that are provided by qiskit-aqua have been split into several new packages: `qiskit-optimization`, `qiskit-nature`, `qiskit-machine-learning`, and `qiskit-finance`. These packages can be installed by themselves (via the standard pip install command, ie `pip install qiskit-nature`) or with the rest of the Qiskit metapackage as optional extras (ie, `pip install 'qiskit[finance,optimization]'` or `pip install 'qiskit[all]'`. The core building blocks for algorithms and the operator flow now exist as part of qiskit-terra at [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") and [`qiskit.opflow`](/api/qiskit/opflow#module-qiskit.opflow "qiskit.opflow"). Depending on your existing usage of Aqua you should either use the application packages or the new modules in Qiskit Terra.

For more details on how to migrate from using Qiskit Aqua, you can refer to the [migration guide](https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide).

<span id="id319" />

### IBM Q Provider 0.12.2

No change

<span id="qiskit-0-24-1" />
## 0.25.1

<span id="release-notes-0-17-1" />

<span id="id292" />

### Terra 0.17.1

<span id="release-notes-0-17-1-prelude" />

<span id="id293" />

#### Prelude

This is a bugfix release that fixes several issues from the 0.17.0 release. Most importantly this release fixes the incorrectly constructed sdist package for the 0.17.0 release which was not actually buildable and was blocking installation on platforms without precompiled binaries available.

<span id="release-notes-0-17-1-bug-fixes" />

<span id="id294" />

#### Bug Fixes

*   Fixed an issue where the [`global_phase`](/api/qiskit/qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") attribute would not be preserved in the output [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object when the [`qiskit.circuit.QuantumCircuit.reverse_bits()`](/api/qiskit/qiskit.circuit.QuantumCircuit#reverse_bits "qiskit.circuit.QuantumCircuit.reverse_bits") method was called. For example:

    ```python
    import math
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(3, 2, global_phase=math.pi)
    qc.h(0)
    qc.s(1)
    qc.cx(0, 1)
    qc.measure(0, 1)
    qc.x(0)
    qc.y(1)

    reversed = qc.reverse_bits()
    print(reversed.global_phase)
    ```

    will now correctly print $\pi$.

*   Fixed an issue where the transpiler pass [`Unroller`](/api/qiskit/qiskit.transpiler.passes.Unroller "qiskit.transpiler.passes.Unroller") didn’t preserve global phase in case of nested instructions with one rule in their definition. Fixed [#6134](https://github.com/Qiskit/qiskit-terra/issues/6134)

*   Fixed an issue where the `parameter` attribute of a [`ControlledGate`](/api/qiskit/qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") object built from a `UnitaryGate` was not being set to the unitary matrix of the `UnitaryGate` object. Previously, `control()` was building a [`ControlledGate`](/api/qiskit/qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") with the `parameter` attribute set to the controlled version of `UnitaryGate` matrix. This would lead to a modification of the `parameter` of the base `UnitaryGate` object and subsequent calls to [`inverse()`](/api/qiskit/qiskit.circuit.ControlledGate#inverse "qiskit.circuit.ControlledGate.inverse") was creating the inverse of a double-controlled `UnitaryGate`. Fixed [#5750](https://github.com/Qiskit/qiskit-terra/issues/5750)

*   Fixed an issue with the preset pass managers [`level_0_pass_manager`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_0_pass_manager "qiskit.transpiler.preset_passmanagers.level_0_pass_manager") and [`level_1_pass_manager`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager") (which corresponds to `optimization_level` 0 and 1 for [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile")) where in some cases they would produce circuits not in the requested basis.

*   Fix a bug where using [`SPSA`](/api/qiskit/qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA") with automatic calibration of the learning rate and perturbation (i.e. `learning_rate` and `perturbation` are `None` in the initializer), stores the calibration for all future optimizations. Instead, the calibration should be done for each new objective function.

<span id="aer-release-notes-0-8-1" />

<span id="id295" />

### Aer 0.8.1

<span id="aer-release-notes-0-8-1-bug-fixes" />

<span id="id296" />

#### Bug Fixes

*   Fixed an issue with use of the `matrix_product_state` method of the `AerSimulator` and `QasmSimulator` simulators when running a noisy simulation with Kraus errors. Previously, the matrix product state simulation method would not propogate changes to neighboring qubits after applying the Kraus matrix. This has been fixed so the output from the simulation is correct. Fixed [#1184](https://github.com/Qiskit/qiskit-aer/issues/1184) and [#1205](https://github.com/Qiskit/qiskit-aer/issues/1205)
*   Fixed an issue where the `qiskit.extensions.Initialize` instruction would disable measurement sampling optimization for the `statevector` and `matrix_product_state` simulation methods of the `AerSimulator` and `QasmSimulator` simulators, even when it was the first circuit instruction or applied to all qubits and hence deterministic. Fixed [#1210](https://github.com/Qiskit/qiskit-aer/issues/1210)
*   Fix an issue with the `SaveStatevector` and `SnapshotStatevector` instructions when used with the `extended_stabilizer` simulation method of the `AerSimulator` and `QasmSimulator` simulators where it would return an unnormalized statevector. Fixed [#1196](https://github.com/Qiskit/qiskit-aer/issues/1210)
*   The `matrix_product_state` simulation method now has support for it’s previously missing set state instruction, `qiskit.providers.aer.library.SetMatrixProductState`, which enables setting the state of a simulation in a circuit.

<span id="id297" />

### Ignis 0.6.0

No change

<span id="id298" />

### Aqua 0.9.1

<span id="ibm-q-provider-0-12-2" />

### IBM Q Provider 0.12.2

No change

<span id="qiskit-0-25-0" />
## 0.25.2

<span id="id287" />

### Terra 0.17.1

No change

<span id="aer-0-8-1" />

### Aer 0.8.1

No change

<span id="id288" />

### Ignis 0.6.0

No change

<span id="id289" />

### Aqua 0.9.1

No change

<span id="id290" />

### IBM Q Provider 0.12.3

<span id="release-notes-ibmq-0-12-3-other-notes" />

<span id="id291" />

#### Other Notes

*   The `qiskit.providers.ibmq.experiment.analysis_result.AnalysisResult` `fit` attribute is now optional.

<span id="qiskit-0-25-1" />
## 0.25.3

<span id="terra-0-17-1" />

### Terra 0.17.1

No change

<span id="release-notes-aer-0-8-2" />

<span id="id281" />

### Aer 0.8.2

<span id="release-notes-aer-0-8-2-known-issues" />

<span id="id282" />

#### Known Issues

*   The `SaveExpectationValue` and `SaveExpectationValueVariance` have been disabled for the extended\_stabilizer method of the `QasmSimulator` and `AerSimulator` due to returning the incorrect value for certain Pauli operator components. Refer to #1227 \<[https://github.com/Qiskit/qiskit-aer/issues/1227](https://github.com/Qiskit/qiskit-aer/issues/1227)> for more information and examples.

<span id="release-notes-aer-0-8-2-bug-fixes" />

<span id="id283" />

#### Bug Fixes

*   Fixes performance issue with how the `basis_gates` configuration attribute was set. Previously there were unintended side-effects to the backend class which could cause repeated simulation runtime to incrementally increase. Refer to #1229 \<[https://github.com/Qiskit/qiskit-aer/issues/1229](https://github.com/Qiskit/qiskit-aer/issues/1229)> for more information and examples.
*   Fixes a bug with the `"multiplexer"` simulator instruction where the order of target and control qubits was reversed to the order in the Qiskit instruction.
*   Fixes a bug introduced in 0.8.0 where GPU simulations would allocate unneeded host memory in addition to the GPU memory.
*   Fixes a bug in the `stabilizer` simulator method of the `QasmSimulator` and `AerSimulator` where the expectation value for the `save_expectation_value` and `snapshot_expectation_value` could have the wrong sign for certain `Y` Pauli’s.

<span id="id284" />

### Ignis 0.6.0

No change

<span id="id285" />

### Aqua 0.9.1

No change

<span id="id286" />

### IBM Q Provider 0.12.3

No change

<span id="qiskit-0-25-2" />
## 0.25.4

<span id="terra-0-17-2" />

<span id="release-notes-0-17-2" />

### Terra 0.17.2

<span id="release-notes-0-17-2-prelude" />

<span id="id276" />

#### Prelude

This is a bugfix release that fixes several issues from the 0.17.1 release. Most importantly this release fixes compatibility for the [`QuantumInstance`](/api/qiskit/qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class when running on backends that are based on the [`BackendV1`](/api/qiskit/qiskit.providers.BackendV1 "qiskit.providers.BackendV1") abstract class. This fixes all the algorithms and applications built on [`qiskit.algorithms`](/api/qiskit/algorithms#module-qiskit.algorithms "qiskit.algorithms") or [`qiskit.opflow`](/api/qiskit/opflow#module-qiskit.opflow "qiskit.opflow") when running on newer backends.

<span id="release-notes-0-17-2-bug-fixes" />

<span id="id277" />

#### Bug Fixes

*   Fixed an issue with the [`BasisTranslator`](/api/qiskit/qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") transpiler pass which in some cases would translate gates already in the target basis. This would potentially result in both longer execution time and less optimal results. Fixed [#6085](https://github.com/Qiskit/qiskit-terra/issues/6085)
*   Fixed an issue in the `SPSA` when the optimizer was initialized with a callback function via the `callback` kwarg would potentially cause an error to be raised.
*   Fixed an issue in the [`qiskit.quantum_info.Statevector.expectation_value()`](/api/qiskit/qiskit.quantum_info.Statevector#expectation_value "qiskit.quantum_info.Statevector.expectation_value") and ```qiskit.quantum_info.DensityMatrix.expectation_value`methods where the ``qargs`()``` kwarg was ignored if the operator was a [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") or [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") operator object. Fixed [#6303](https://github.com/Qiskit/qiskit-terra/issues/6303)
*   Fixed an issue in the [`qiskit.quantum_info.Pauli.evolve()`](/api/qiskit/qiskit.quantum_info.Pauli#evolve "qiskit.quantum_info.Pauli.evolve") method which could have resulted in the incorrect Pauli being returned when evolving by a [`CZGate`](/api/qiskit/qiskit.circuit.library.CZGate "qiskit.circuit.library.CZGate"), [`CYGate`](/api/qiskit/qiskit.circuit.library.CYGate "qiskit.circuit.library.CYGate"), or a [`SwapGate`](/api/qiskit/qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") gate.
*   Fixed an issue in the `qiskit.opflow.SparseVectorStateFn.to_dict_fn()` method, which previously had at most one entry for the all zero state due to an index error.
*   Fixed an issue in the `qiskit.opflow.SparseVectorStateFn.equals()` method so that is properly returning `True` or `False` instead of a sparse vector comparison of the single elements.
*   Fixes an issue in the [`Statevector`](/api/qiskit/qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and [`DensityMatrix`](/api/qiskit/qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") probability methods [`qiskit.quantum_info.Statevector.probabilities()`](/api/qiskit/qiskit.quantum_info.Statevector#probabilities "qiskit.quantum_info.Statevector.probabilities"), [`qiskit.quantum_info.Statevector.probabilities_dict()`](/api/qiskit/qiskit.quantum_info.Statevector#probabilities_dict "qiskit.quantum_info.Statevector.probabilities_dict"), [`qiskit.quantum_info.DensityMatrix.probabilities()`](/api/qiskit/qiskit.quantum_info.DensityMatrix#probabilities "qiskit.quantum_info.DensityMatrix.probabilities"), [`qiskit.quantum_info.DensityMatrix.probabilities_dict()`](/api/qiskit/qiskit.quantum_info.DensityMatrix#probabilities_dict "qiskit.quantum_info.DensityMatrix.probabilities_dict") where the returned probabilities could have incorrect ordering for certain values of the `qargs` kwarg. Fixed [#6320](https://github.com/Qiskit/qiskit-terra/issues/6320)
*   Fixed an issue where the `TaperedPauliSumOp` class did not support the multiplication with [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") object and also did not have a necessary `assign_parameters()` method for working with [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects. Fixed [#6127](https://github.com/Qiskit/qiskit-terra/issues/6127)
*   Fixed compatibility for the [`QuantumInstance`](/api/qiskit/qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class when running on backends that are based on the [`BackendV1`](/api/qiskit/qiskit.providers.BackendV1 "qiskit.providers.BackendV1") abstract class. Fixed [#6280](https://github.com/Qiskit/qiskit-terra/issues/6280)

<span id="id278" />

### Aer 0.8.2

No change

<span id="id279" />

### Ignis 0.6.0

No change

<span id="id280" />

### Aqua 0.9.1

No change

<span id="ibm-q-provider-0-12-3" />

### IBM Q Provider 0.12.3

No change

<span id="qiskit-0-25-3" />

