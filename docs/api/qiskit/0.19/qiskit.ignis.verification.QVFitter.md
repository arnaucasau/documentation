---
title: QVFitter
description: API reference for qiskit.ignis.verification.QVFitter
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.ignis.verification.QVFitter
---

# QVFitter

<span id="qiskit.ignis.verification.QVFitter" />

`QVFitter(backend_result=None, statevector_result=None, qubit_lists=None)`

Class for fitters for quantum volume.

**Parameters**

*   **backend\_result** (*list*) – list of results (qiskit.Result).
*   **statevector\_result** (*list*) – the ideal statevectors of each circuit
*   **qubit\_lists** (*list*) – list of qubit lists (what was passed to the circuit generation)

## Attributes

### depths

Return depth list.

### heavy\_output\_counts

Return the number of heavy output counts as measured.

### heavy\_output\_prob\_ideal

Return the heavy output probability ideally.

### heavy\_outputs

Return the ideal heavy outputs dictionary.

### qubit\_lists

Return depth list.

### results

Return all the results.

### ydata

Return the average and std of the output probability.

## Methods

### add\_data

<span id="qiskit.ignis.verification.QVFitter.add_data" />

`QVFitter.add_data(new_backend_result, rerun_fit=True)`

Add a new result. Re calculate fit

**Parameters**

*   **new\_backend\_result** (*list*) – list of qv results
*   **rerun\_fit** (*bool*) – re calculate the means and fit the result

**Raises**

**QiskitError** – If the ideal distribution isn’t loaded yet

#### Additional information:

Assumes that ‘result’ was executed is the output of circuits generated by qv\_circuits,

### add\_statevectors

<span id="qiskit.ignis.verification.QVFitter.add_statevectors" />

`QVFitter.add_statevectors(new_statevector_result)`

Add the ideal results and convert to the heavy outputs.

Assume the result is from ‘statevector\_simulator’

**Parameters**

**new\_statevector\_result** (*list*) – ideal results

**Raises**

**QiskitError** – If the result has already been added for the circuit

### calc\_data

<span id="qiskit.ignis.verification.QVFitter.calc_data" />

`QVFitter.calc_data()`

Make a count dictionary for each unique circuit from all the results.

Calculate the heavy output probability.

#### Additional information:

Assumes that ‘result’ was executed is the output of circuits generated by qv\_circuits,

### calc\_statistics

<span id="qiskit.ignis.verification.QVFitter.calc_statistics" />

`QVFitter.calc_statistics()`

Convert the heavy outputs in the different trials into mean and error for plotting.

Here we assume the error is due to a binomial distribution

### plot\_qv\_data

<span id="qiskit.ignis.verification.QVFitter.plot_qv_data" />

`QVFitter.plot_qv_data(ax=None, show_plt=True)`

Plot the qv data as a function of depth

**Parameters**

*   **ax** (*Axes or None*) – plot axis (if passed in).
*   **show\_plt** (*bool*) – display the plot.

**Raises**

**ImportError** – If matplotlib is not installed.

### quantum\_volume

<span id="qiskit.ignis.verification.QVFitter.quantum_volume" />

`QVFitter.quantum_volume()`

Return the volume for each depth.

**Returns**

List of quantum volumes

**Return type**

list

### qv\_success

<span id="qiskit.ignis.verification.QVFitter.qv_success" />

`QVFitter.qv_success()`

Return whether each depth was successful (>2/3 with confidence greater than 97.5) and the confidence

**Returns**

List of lenth depth with eact element a 3 list with - success True/False - confidence

**Return type**

list

